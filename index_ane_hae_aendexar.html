<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Text-Based Body Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/compromise@latest/builds/compromise.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            padding: 0;
            background: #000000;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        #background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            overflow: hidden;
        }
        
        #background-container canvas {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 1 !important;
        }
        
        #grid-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 50;
            pointer-events: none;
            display: none;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            background: transparent;
        }

        #left-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 250px;
            height: 100vh;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            background: #ffffff;
        }
        
        #left-panel.collapsed {
            background : transparent;
            z-index: 999; /* Below top-bar and fps-bar (1000) so it doesn't block clicks */
            pointer-events: none; /* Don't block clicks on buttons */
        }
        
        #left-panel-header-wrapper {
            background: #ffffff;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            flex-direction: row;
            gap: 5px;
            padding: 4px 10px 5px 10px;
            flex-shrink: 0;
            align-items: flex-start;
            position: relative;
            z-index: 1002; /* Above collapsed left-panel (1001) */
        }
        
        #left-panel.collapsed #left-panel-header-wrapper {
            display: none; /* Hide header wrapper when panel is collapsed to prevent white rectangle */
        }

        #text-box-toggle-btn {
            padding: 0;
            background: #808080;
            border: none;
            color: #ffffff;
            cursor: pointer;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            line-height: 1.2;
            white-space: nowrap;
            flex: 0 1 auto;
            margin: 0;
            box-sizing: border-box;
            position: relative;
            z-index: 1003; /* Above header wrapper (1002) */
            display: flex;
        }
        
        #text-box-toggle-btn:hover {
            background: #707070;
        }
        
        #text-box-toggle-btn-top {
            padding: 0;
            background: #808080;
            border: none;
            color: #ffffff;
            cursor: pointer;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            line-height: 1.2;
            white-space: nowrap;
            margin: 0;
            box-sizing: border-box;
        }
        
        #text-box-toggle-btn-top:hover {
            background: #707070;
        }

        #text-container {
            flex: 1;
            padding: 10px 10px 0 10px;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            transition: flex 0.3s ease, padding 0.3s ease;
            background: #ffffff;
        }
        
        #text-container.collapsed {
            flex: 0 0 0;
            padding: 0;
            overflow: hidden;
            background: transparent;
        }
        
        #text-container.collapsed #textInput,
        #text-container.collapsed #mapped-text-container {
            display: none;
        }

        #generate-button-container {
            padding: 5px 10px 5px 10px;
            background: #ffffff;
            display: flex;
            gap: 5px;
            align-items: flex-start;
            flex-shrink: 0;
            justify-content: space-between;
        }
        
        #left-panel.collapsed #generate-button-container {
            display: none;
        }
        
        #generateBtn, #mapTextBtn {
            padding: 0;
            background: #808080;
            border: none;
            color: #ffffff;
            transition: opacity 0.2s ease;
            cursor: pointer;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            line-height: 1.2;
            white-space: nowrap;
            flex: 0 1 auto;
        }
        
        #mapTextBtn:disabled,
        #nodeListBtn:disabled,
        #toggleNametagsBtn:disabled,
        #resetCameraBtn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        #clearTextBtn {
            padding: 0;
            background: #808080;
            border: none;
            color: #ffffff;
            transition: opacity 0.2s ease;
            cursor: pointer;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            line-height: 1.2;
            white-space: nowrap;
            flex: 0 1 auto;
            margin-left: auto;
        }

        #top-bar {
            position: fixed;
            top: 0;
            left: 250px;
            right: 0;
            height: 18px;
            z-index: 1000;
            display: flex;
            flex-direction: row;
            gap: 5px;
            background: #ffffff;
            align-items: center;
        }

        #fps-bar {
            position: fixed !important;
            top: 18px !important;
            left: 250px;
            right: 0 !important;
            height: auto;
            min-height: 7px;
            z-index: 1000;
            background: #ff6600;
            color: #000000;
            font-size: 7px;
            font-family: Helvetica, Arial, sans-serif;
            display: flex !important;
            align-items: center;
            overflow: hidden;
            white-space: nowrap;
            line-height: 7px;
            padding: 0;
            /* Removed transition to keep fps-bar fixed without animation */
        }
        
        body.left-panel-collapsed #top-bar {
            left: 0;
            padding-left: 10px; /* Add left margin when panel is collapsed */
        }
        
        body.left-panel-collapsed #fps-bar {
            left: 0;
        }
        
        #bottom-bar {
            position: fixed !important;
            bottom: 0 !important;
            left: 250px;
            right: 0 !important;
            height: 21px;
            z-index: 998;
            background: #ffffff;
            display: flex !important;
            flex-direction: column;
        }
        
        #bottom-fps-bar {
            position: relative;
            width: 100%;
            height: 7px;
            min-height: 7px;
            background: #ff6600;
            color: #000000;
            font-size: 7px;
            font-family: Helvetica, Arial, sans-serif;
            display: flex;
            align-items: center;
            overflow: hidden;
            white-space: nowrap;
            line-height: 7px;
            padding: 0;
            flex-shrink: 0;
        }
        
        #bottom-fps-bar span {
            color: #000000;
        }
        
        body.left-panel-collapsed #bottom-bar {
            left: 0;
        }
        
        #realtime-info-panel {
            position: relative;
            width: 100%;
            height: 14px;
            background: #ffffff;
            padding: 0 5px;
            overflow-x: auto;
            overflow-y: hidden;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 9px;
            color: #000000;
            text-align: center;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 5px;
            white-space: nowrap;
            flex: 1;
        }
        
        #realtime-info-panel .info-item {
            margin: 0;
            line-height: 1.2;
            display: inline-block;
            background: transparent;
            padding: 2px 6px;
            text-align: right;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        #realtime-info-panel .info-label {
            font-weight: bold;
            display: inline;
        }
        
        #realtime-info-panel .info-value {
            color: #000000;
        }
        
        #realtime-info-panel .info-label {
            color: #000000;
        }

        #max-value-panel {
            position: fixed;
            bottom: 14px;
            right: 0;
            width: 200px;
            height: 350px;
            z-index: 999;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 5px;
            display: none;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
        }

        #max-value-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            padding: 2px;
            flex-shrink: 0;
            min-height: 15px;
        }
        
        #max-value-panel-hashtag {
            color: #000000;
            font-size: 11px;
            font-family: Helvetica, Arial, sans-serif;
            font-weight: bold;
        }

        #max-value-panel-canvas-container {
            width: 100%;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border: none;
            margin: 0 0 8px 0;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            box-sizing: border-box;
        }

        #max-value-panel-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #max-value-panel-info {
            flex: 1;
            overflow-y: visible;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 9px;
            line-height: 1.3;
            margin: 0;
            padding: 8px;
            background: #000000;
            min-height: 0;
            box-sizing: border-box;
        }
        
        #max-value-panel-info div {
            margin: 2px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        #node-list-container {
            position: fixed;
            top: 25px;
            left: 250px;
            right: 400px;
            bottom: 0;
            z-index: 998;
            overflow-y: auto;
            overflow-x: hidden;
            display: none;
            padding: 10px;
            gap: 10px;
            flex-wrap: wrap;
            align-content: flex-start;
            /* Hide scrollbar */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }
        #node-list-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        #node-list-container.visible {
            display: flex;
        }
        
        #leaderboard-right-panel {
            position: fixed;
            top: 35px;
            right: 10px;
            width: 400px;
            height: 50vh;
            max-height: 600px;
            z-index: 999;
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid rgba(255, 255, 255, 0.5);
            display: none;
            flex-direction: column;
            box-sizing: border-box;
        }
        
        #leaderboard-right-panel.visible {
            display: flex;
        }
        
        #leaderboard-right-panel-grid {
            width: 100%;
            height: 100%;
            background: #000000;
            background-image: 
                linear-gradient(#333333 1px, transparent 1px),
                linear-gradient(90deg, #333333 1px, transparent 1px);
            background-size: 20px 20px;
            position: relative;
            overflow: hidden;
        }
        
        #leaderboard-right-panel-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            background: #000000;
        }
        
        #leaderboard-right-panel-title {
            position: absolute;
            top: 8px;
            left: 8px;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 8px;
            font-weight: 300;
            z-index: 1000;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        #leaderboard-right-panel-stats {
            position: absolute;
            bottom: 8px;
            left: 8px;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 8px;
            font-weight: 300;
            z-index: 1000;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            line-height: 1.4;
        }
        
        #leaderboard-info-panel {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 400px;
            top: calc(35px + 50vh + 10px);
            max-height: calc(100vh - 35px - 50vh - 10px - 10px - 21px);
            z-index: 999;
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 0;
            display: none;
            flex-direction: column;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        #leaderboard-info-panel::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        
        #leaderboard-info-panel.visible {
            display: flex;
        }
        
        #leaderboard-info-panel-title {
            position: sticky;
            top: 0;
            background: rgba(220, 220, 220, 0.76);
            padding: 4px 12px;
            color: #000000;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            font-weight: normal;
            border-bottom: 1px solid rgba(0, 0, 0, 0.2);
            z-index: 10;
            flex-shrink: 0;
        }
        
        #leaderboard-info-panel-content {
            padding: 4px 12px 12px 12px;
            background: rgba(220, 220, 220, 0.76);
            color: #000000;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            line-height: 1.1;
            flex: 1;
            min-height: calc(100% - 30px);
            box-sizing: border-box;
        }
        
        .leaderboard-info-section {
            margin-bottom: 5px;
        }
        
        .leaderboard-info-section-title {
            font-weight: bold;
            font-size: 11px;
            margin-bottom: 3px;
            margin-top: 5px;
            color: #ffffff;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 3px;
        }
        
        .leaderboard-info-item {
            margin-bottom: 2px;
            padding: 0;
            color: #ffffff;
        }
        
        .leaderboard-info-label {
            font-weight: bold;
            color: #ffffff;
        }
        
        .leaderboard-info-value {
            color: #ffffff;
        }
        
        .leaderboard-info-number {
            background: #ffffff;
            color: #000000;
            padding: 0;
            display: inline-block;
            line-height: 1.0;
            vertical-align: baseline;
        }

        .node-list-item {
            width: 200px;
            height: 350px;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 5px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .node-list-item-header {
            text-align: center;
            margin-bottom: 5px;
            padding: 2px;
            flex-shrink: 0;
            min-height: 15px;
        }

        .node-list-item-canvas-container {
            width: 100%;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border: none;
            margin: 0 0 8px 0;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            box-sizing: border-box;
        }

        .node-list-item-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .node-list-item-info {
            flex: 1;
            overflow-y: visible;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 9px;
            line-height: 1.3;
            margin: 0;
            padding: 8px;
            background: #000000;
            min-height: 0;
            box-sizing: border-box;
        }

        .node-list-item-info div {
            margin: 2px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        #right-panel {
            position: fixed;
            bottom: 21px;
            right: 5px;
            width: 200px;
            height: 350px;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 0 5px 5px 5px !important;
            display: none !important;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
            visibility: hidden !important;
            opacity: 0 !important;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        #right-panel.visible {
            display: flex !important;
        }
        
        #right-panel::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        
        /* Styles for cloned right panels */
        .right-panel-clone {
            position: fixed;
            width: 200px;
            height: 350px;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 0 5px 5px 5px !important;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
            display: none;
            visibility: hidden;
            opacity: 0;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        .right-panel-clone.visible {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .right-panel-clone.visible {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .right-panel-clone::-webkit-scrollbar {
            display: none;
        }
        
        #right-panel-header {
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            margin: 0 5px 5px 5px !important;
            margin-top: 0 !important;
            padding: 0 !important;
            padding-top: 0 !important;
            flex-shrink: 0;
            min-height: auto;
        }
        
        #right-panel-close {
            background: #808080 !important;
            color: #ffffff !important;
            border: none !important;
            padding: 0 !important;
            border-radius: 0 !important;
            cursor: pointer;
            font-family: Helvetica, Arial, sans-serif !important;
            font-size: 8px !important;
            display: inline-flex !important;
            align-items: center !important;
            gap: 2px !important;
            white-space: nowrap !important;
            margin: 0 !important;
            text-transform: uppercase !important;
            line-height: 1 !important;
            height: auto !important;
            min-height: 0 !important;
        }
        
        #right-panel-close span {
            margin: 0 !important;
            padding: 0 !important;
            line-height: 1 !important;
            display: inline !important;
        }
        
        #right-panel-close span:first-child {
            font-size: 8px !important;
            margin-right: 2px !important;
        }
        
        #right-panel-close:hover {
            background: #999999;
        }
        
        #right-panel-canvas-container {
            width: calc(100% - 10px);
            height: 140px;
            background: rgba(0, 0, 0, 0.3);
            border: none;
            margin-top: 8px !important;
            margin-left: 5px !important;
            margin-right: 5px !important;
            margin-bottom: 8px !important;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        
        #node-details-content {
            flex: 1;
            overflow-y: visible;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 9px;
            line-height: 1.3;
            margin: 0 !important;
            margin-bottom: 0 !important;
            padding: 8px;
            background: #000000;
            min-height: 0;
            box-sizing: border-box;
            display: block;
        }
        
        #node-details-content div {
            margin: 2px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        #right-panel-canvas {
            width: 100%;
            height: 100%;
        }
        
        #node-details-content {
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 9px;
            line-height: 1.3;
            margin: 0;
            padding: 8px;
            background: #000000;
        }

        .top-bar-item {
            background: #ffffff;
            border: none;
            padding: 0;
            border-radius: 0;
            display: flex;
            align-items: center;
            white-space: nowrap;
            font-size: 11px;
            line-height: 1.2;
        }

        .top-bar-item.black {
            background: #000000;
            color: #ffffff;
        }

        .top-bar-item.grey {
            background: #808080;
            color: #ffffff;
            border: none;
            text-transform: uppercase;
        }

        #backgroundColorBtn {
            border: 2px solid #808080;
        }

        #crossButton {
            border: 2px solid #808080;
        }

        .control-panel h2 {
            font-size: 12px;
            margin-bottom: 6px;
            color: #000000;
            font-family: Helvetica, Arial, sans-serif;
            font-weight: normal;
        }

        #textInput {
            width: 100%;
            flex: 1;
            padding: 10px;
            background: #000000;
            border: 1px solid #000000;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            resize: none;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        #textInput::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        #textInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #mapped-text-container {
            width: 100%;
            flex: 1;
            padding: 10px;
            background: #000000;
            border: 1px solid #000000;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
            -webkit-overflow-scrolling: touch;
            min-height: 0;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        #mapped-text-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        
        #value-logic-modal::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        #mapped-text-container span {
            padding: 0;
            margin: 0;
            display: inline;
        }
        

        .button-group {
            display: flex;
            gap: 0;
            flex-wrap: wrap;
            margin-top: 6px;
        }

        button {
            padding: 4px 8px;
            background: #808080;
            border: none;
            color: #ffffff;
            cursor: pointer;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 10px;
            transition: all 0.2s ease;
            border-radius: 0;
        }

        button:hover {
            background: #999999;
        }

        button:active {
            background: #666666;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #606060;
        }

        #stats {
            font-size: 10px;
            line-height: 1.4;
            color: #000000;
            font-family: Helvetica, Arial, sans-serif;
        }

        .stat-item {
            margin-bottom: 3px;
        }

        .info-text {
            font-size: 9px;
            color: #000000;
            margin-top: 0;
            line-height: 1.3;
            font-family: Helvetica, Arial, sans-serif;
        }
        
        .nametag {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 1px 3px;
            border-radius: 0;
            font-size: 8px;
            font-family: Helvetica, Arial, sans-serif;
            white-space: nowrap;
            border: none;
            transform: translate(-50%, -100%);
            margin-top: -3px;
        }
        
        .node-info-panel {
            position: fixed;
            background: #ffffff;
            border: 1px solid #000000;
            padding: 3px;
            z-index: 2000;
            pointer-events: none;
            min-width: 100px;
            max-width: 110px;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 4px;
            color: #000000;
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        
        .node-info-panel.visible {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .node-info-header {
            display: none;
        }
        
        .node-info-canvas-container {
            width: 100%;
            height: 60px;
            background: #000000;
            border: 1px solid #000000;
            margin: 0 0 2px 0;
            position: relative;
            overflow: hidden;
        }
        
        .node-info-canvas {
            width: 100%;
            height: 100%;
        }
        
        .node-info-content {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1px 1.5px;
            border: 1px solid #000000;
            padding: 1.5px;
            background: #ffffff;
        }
        
        .node-info-item {
            margin: 0;
            line-height: 1.0;
            padding: 1px;
            background: #000000;
            color: #ffffff;
        }
        
        .node-info-label {
            color: #ffffff;
            display: block;
            font-size: 3px;
            margin-bottom: 0;
        }
        
        .node-info-value {
            color: #ffffff;
            font-weight: normal;
            font-size: 3.5px;
        }
        
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0000FF;
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.3s ease;
        }
        
        #start-screen.hidden {
            opacity: 0;
            pointer-events: none;
            display: none;
        }
        
        #start-button {
            background: #808080;
            color: #ffffff;
            border: none;
            padding: 0 2px !important;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s ease;
            text-transform: uppercase;
            line-height: 1;
            margin: 0;
        }
        
        #start-button:hover {
            background: #707070;
        }
        
        #start-button:active {
            background: #606060;
        }
        
        /* Ensure these panels are completely hidden until explicitly shown */
        #node-info-panel:not(.visible),
        #right-panel:not(.visible) {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
        
        /* Ensure modals are hidden by default, but allow JavaScript to show them */
        #value-logic-modal {
            display: none;
        }
        
        #fractal-modal {
            display: none;
        }
        
        #info-modal {
            display: none;
        }
        
        /* When modals are explicitly shown via JavaScript, they will override the default */
        #value-logic-modal[style*="display: block"],
        #value-logic-modal[style*="display: flex"] {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        #fractal-modal[style*="display: block"],
        #fractal-modal[style*="display: flex"] {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        #info-modal[style*="display: block"],
        #info-modal[style*="display: flex"] {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        #value-logic-modal-container,
        #fractal-modal > div,
        #info-modal-container {
            visibility: inherit;
            opacity: inherit;
        }
        
        /* Mobile Responsive Styles */
        @media screen and (max-width: 768px) {
            /* Canvas Container - Full screen behind all UI elements */
            #canvas-container {
                top: 0;
                left: 0;
                width: 100%;
                height: 100vh;
                z-index: 1;
                position: fixed;
            }
            
            /* Top Bar - Move to top, desktop style buttons in two rows */
            #top-bar {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: auto;
                height: auto;
                flex-direction: row;
                flex-wrap: wrap;
                align-items: center;
                gap: 5px;
                padding: 4px;
                overflow-x: auto;
                overflow-y: hidden;
                z-index: 1500;
                background: rgba(255, 255, 255, 0.98);
                border-bottom: 1px solid #e0e0e0;
            }
            
            /* When left panel is collapsed, position top-bar next to the TEXT BOX button */
            
            /* Ensure left-panel-header-wrapper has a fixed width when collapsed so top-bar can position next to it */
            #left-panel.collapsed {
                width: auto;
                min-width: fit-content;
            }
            
            #left-panel.collapsed #left-panel-header-wrapper {
                width: auto;
                min-width: fit-content;
            }
            
            .top-bar-item {
                padding: 0; /* No padding, same as CLEAR button */
                font-size: 11px;
                min-height: auto;
                flex: 0 0 auto;
                white-space: nowrap;
                width: auto; /* Auto width based on content */
                max-width: calc(50% - 2.5px); /* Max two columns */
                box-sizing: border-box;
            }
            
            /* Total value display takes full width */
            #total-value-display {
                width: 100%;
                flex: 1 1 100%;
                order: -1;
                max-width: 100%;
            }
            
            #mobile-menu-toggle {
                display: none !important;
            }
            
            #total-value-display span {
                font-size: 11px !important;
            }
            
            /* FPS bar below top bar - positioned dynamically */
            #fps-bar {
                position: fixed;
                left: 0;
                right: 0;
                height: 7px;
                z-index: 1501;
                background: #ff6600;
            }
            
            /* Bottom bar - Show only fps bar, above left panel */
            #bottom-bar {
                position: fixed;
                left: 0;
                right: 0;
                height: 7px;
                z-index: 1501;
            }
            
            #bottom-fps-bar {
                position: relative;
                width: 100%;
                height: 7px;
                background: #ff6600;
            }
            
            #realtime-info-panel {
                display: none !important;
            }
            
            /* Left Panel - Collapsible text box at bottom */
            #left-panel {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                top: auto;
                width: 100%;
                height: auto;
                max-height: 50vh;
                flex-direction: column;
                z-index: 2000;
                border-top: 1px solid #e0e0e0;
                background: #ffffff;
            }
            
            #left-panel.collapsed {
                max-height: 24px;
            }
            
            #left-panel.collapsed #text-container {
                display: none;
            }
            
            #left-panel.collapsed #generate-button-container {
                display: none;
            }
            
            #left-panel-header-wrapper {
                padding: 1px 3px;
            }
            
            #text-box-toggle-btn {
                font-size: 11px;
                padding: 0;
                min-height: 20px;
                width: 100%;
                line-height: 1.2;
            }
            
            /* Text Input - Collapsible */
            #text-container {
                padding: 4px;
                max-height: 40vh;
                overflow-y: auto;
            }
            
            #textInput {
                font-size: 12px !important;
                padding: 4px !important;
                min-height: 60px !important;
                line-height: 1.4 !important;
            }
            
            /* Mapped text container - Same size as textInput on mobile */
            #mapped-text-container {
                font-size: 12px !important;
                padding: 4px !important;
                min-height: 60px !important;
                width: 100% !important;
                flex: 1 !important;
                box-sizing: border-box !important;
                line-height: 1.4 !important;
            }
            
            #mapped-text-container span {
                font-size: 12px !important;
                padding: 0 !important;
                margin: 0 !important;
                display: inline !important;
                line-height: 1.4 !important;
            }
            
            #mapped-text-container .mapped-word {
                font-size: 12px !important;
                padding: 0 !important;
                margin: 0 !important;
                display: inline !important;
                line-height: 1.4 !important;
            }
            
            /* Generate buttons - Smaller, horizontal layout */
            #generate-button-container {
                flex-direction: row;
                gap: 2px;
                padding: 2px 4px;
                flex-wrap: wrap;
            }
            
            #generateBtn, #mapTextBtn, #clearTextBtn {
                flex: 1 1 auto;
                padding: 2px; /* Equal padding on all sides */
                font-size: 8px;
                min-height: auto;
                min-width: 60px;
                line-height: 1.1;
            }
            
            /* Hide FULLSCREEN and @sylvia buttons on mobile */
            #fullscreenBtn {
                display: none !important;
            }
            
            #testBtn {
                display: none !important;
            }
            
            /* INFO button - Move to right, aligned with TOTAL VALUE */
            #infoBtn {
                margin-left: auto !important;
                margin-right: 0 !important;
                order: 999; /* Push to end */
            }
            
            /* Ensure INFO button aligns with TOTAL VALUE right edge */
            #top-bar {
                justify-content: flex-start;
            }
            
            #infoBtn {
                margin-left: auto !important;
            }
            
            /* Node List Container - Two columns, smaller items - positioned dynamically */
            #node-list-container {
                left: 0;
                right: 0;
                padding: 4px;
                gap: 4px;
                z-index: 2500; /* Above left-panel (2000) */
                /* top and bottom set dynamically by positionMobileElements() */
            }
            
            .node-list-item {
                width: calc(50% - 2px);
                max-width: calc(50% - 2px);
                margin-bottom: 4px;
                padding: 4px;
            }
            
            .node-list-item-header {
                font-size: 10px;
                padding: 2px;
            }
            
            .node-list-item-canvas-container {
                height: 140px; /* Increased from 80px to prevent horizontal stretching */
                margin-bottom: 6px;
                aspect-ratio: 200/140; /* Maintain proper aspect ratio */
            }
            
            .node-list-item-canvas {
                width: 100%;
                height: 100%;
                object-fit: contain; /* Prevent stretching */
            }
            
            .node-list-item-info {
                font-size: 9px;
                padding: 6px;
                line-height: 1.3;
            }
            
            /* Gallery Modal - Two columns layout */
            #gallery-modal-container {
                max-width: 95%;
                width: 95%;
                left: 50% !important;
                transform: translate(-50%, -50%);
                top: 50% !important;
                max-height: 80vh;
                overflow-y: auto;
            }
            
            .gallery-item {
                width: calc(50% - 4px) !important;
                display: inline-block;
                vertical-align: top;
                margin: 2px;
            }
            
            /* Max Value Panel - Hide on mobile */
            #max-value-panel {
                display: none !important;
            }
            
            /* Right Panel - Full width on mobile */
            #right-panel {
                width: 100%;
                max-width: 100%;
                height: auto;
                max-height: 60vh;
                bottom: 80px;
                right: 0;
                left: 0;
            }
            
            .right-panel-clone {
                width: 100%;
                max-width: 100%;
                height: auto;
                max-height: 60vh;
            }
            
            /* Node Info Panel - Adjust size */
            .node-info-panel {
                max-width: 150px;
                font-size: 10px;
            }
            
            /* Modals - Full width on mobile, positioned in 3D visualization space */
            #value-logic-modal-container,
            #convergence-zones-modal-container,
            #info-modal-container {
                max-width: 95%;
                width: 95%;
                left: 50% !important;
                right: auto !important;
                transform: translateX(-50%) !important;
                /* top and max-height set dynamically by JavaScript - no !important here */
                bottom: auto !important;
                overflow-y: auto;
                position: fixed !important;
            }
            
            /* Claim Modal - Smaller and centered */
            #claim-modal-container {
                max-width: 95%;
                width: 95%;
                left: 50% !important;
                transform: translate(-50%, -50%);
                top: 50% !important;
                max-height: 85vh;
                overflow-y: auto;
                padding: 8px;
            }
            
            /* Fractal Modal - Adjust for mobile */
            #fractal-modal-container {
                max-width: 95%;
                width: 95%;
                left: 50% !important;
                transform: translate(-50%, -50%);
                top: 50% !important;
            }
            
            /* Test Dropdown - Full width on mobile */
            #testDropdown {
                width: 100%;
                max-width: 100%;
                right: 0;
                left: 0;
            }
            
            /* Ensure touch-friendly interactions */
            button, .top-bar-item {
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
                touch-action: manipulation;
            }
            
            /* Prevent text input from changing layout when mapped */
            #mapped-text-container {
                font-size: 14px;
                padding: 8px;
                width: 100%;
                flex: 1;
                min-height: 80px;
                box-sizing: border-box;
            }
            
            #mapped-text-container span {
                font-size: 14px;
                padding: 2px 4px;
                display: inline-block;
            }
            
            /* Ensure gallery uses same container as TOP NODES */
            #node-list-container.visible {
                display: flex;
                flex-wrap: wrap;
            }
            
            /* Fix canvas visibility */
            #canvas-container canvas {
                display: block !important;
                width: 100% !important;
                height: 100% !important;
            }
        }
        
        /* Extra small mobile devices */
        @media screen and (max-width: 480px) {
            #textInput {
                font-size: 16px; /* Prevent zoom on iOS */
            }
            
            #top-bar {
                max-height: 60vh;
            }
            
            .top-bar-item {
                font-size: 12px;
                padding: 10px;
            }
            
            #left-panel {
                max-height: 60vh;
            }
            
            #bottom-bar {
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <button id="start-button">CONNECT</button>
    </div>
    
    <!-- Wallet Connection Modal -->
    <div id="wallet-connect-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 40000; pointer-events: auto;">
        <div id="wallet-connect-modal-container" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #ffffff; padding: 9px; border: 2px solid #000000; min-width: 300px; max-width: 400px; display: flex; flex-direction: column;">
            <div style="position: relative; margin-bottom: 12px; min-height: 18px;">
                <button id="wallet-connect-close-btn" style="position: absolute; top: 0; left: 0; background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; display: flex; align-items: center; gap: 2px; white-space: nowrap; border-radius: 0; margin: 0; min-height: 16px; height: 16px; line-height: 1;">
                    <span style="font-size: 12px;">Ã—</span>
                    <span>CLOSE</span>
                </button>
            </div>
            <div style="margin: 0 auto 7px auto; font-family: Helvetica, Arial, sans-serif; font-size: 10px; color: #ffffff; text-align: left; background: #000000; padding: 8px 9px 8px 9px; border: 1px solid #000000; width: 98%;">
                You need to connect your wallet to continue.
            </div>
            <div style="position: relative; min-height: 27px; margin-top: 7px;">
                <button id="wallet-connect-wallet-btn" style="position: absolute; bottom: 0; right: 0; background: #808080; color: #ffffff; border: none; padding: 4px 8px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 10px; border-radius: 0; margin: 0;">CONNECT WALLET</button>
            </div>
        </div>
    </div>
    
    <!-- Loading Modal for API call -->
    <div id="api-loading-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 40001; pointer-events: auto;">
        <div id="api-loading-modal-container" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #ffffff; padding: 10px; border: none; min-width: 350px; width: 350px; display: flex; flex-direction: column; align-items: center; box-sizing: border-box;">
            <div style="font-family: Helvetica, Arial, sans-serif; font-size: 10px; color: #ffffff; text-align: center; background: #000000; padding: 5px 8px; border: 1px solid #000000; width: 100%; box-sizing: border-box;">
                Reading input. Wait a few seconds, this shouldn't take long<span id="loading-dots">...</span>
            </div>
            <div id="loading-progress-container" style="width: 100%; height: 20px; background: #000000; border: 1px solid #000000; margin-top: 5px; box-sizing: border-box;">
                <div id="loading-progress-bar" style="height: 100%; width: 0%; background: #0000ff; transition: width 0.3s ease, background 0.3s ease;"></div>
            </div>
        </div>
    </div>
    
    <!-- Success Modal for Purchase -->
    <div id="purchase-success-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 40002; pointer-events: auto;">
        <div id="purchase-success-modal-container" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #ffffff; padding: 10px; border: none; min-width: 350px; width: 350px; display: flex; flex-direction: column; align-items: center; box-sizing: border-box;">
            <div style="font-family: Helvetica, Arial, sans-serif; font-size: 10px; color: #ffffff; text-align: center; background: #000000; padding: 5px 8px; border: 1px solid #000000; width: 100%; box-sizing: border-box;">
                Your purchase has been completed successfully!
            </div>
        </div>
    </div>
    
    <div id="background-container"></div>
    <div id="grid-container"></div>
    <div id="canvas-container"></div>
    
    <div id="node-info-panel" class="node-info-panel">
        <div class="node-info-canvas-container">
            <canvas id="node-info-canvas" class="node-info-canvas"></canvas>
        </div>
        <div class="node-info-content">
            <div class="node-info-item">
                <span class="node-info-label">W</span>
                <span class="node-info-value" id="info-word">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">V</span>
                <span class="node-info-value" id="info-individual-value">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">P</span>
                <span class="node-info-value" id="info-position">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">%</span>
                <span class="node-info-value" id="info-relative-value">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">C</span>
                <span class="node-info-value" id="info-connections">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">KB</span>
                <span class="node-info-value" id="info-size">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">Perf</span>
                <span class="node-info-value" id="info-performance">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">3D</span>
                <span class="node-info-value" id="info-3d-coords">-</span>
            </div>
        </div>
    </div>
    
    <div id="left-panel">
        <div id="left-panel-header-wrapper">
            <button id="text-box-toggle-btn">TEXT BOX</button>
        </div>
        <div id="text-container">
            <textarea id="textInput" placeholder="Enter your text here... (Max 500 words)" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
            <div id="mapped-text-container" style="display: none;"></div>
        </div>
        <div id="generate-button-container">
            <button id="generateBtn">Export Body</button>
            <button id="mapTextBtn">Map Text</button>
            <button id="clearTextBtn">CLEAR</button>
        </div>
    </div>

    <div id="top-bar">
        <button class="top-bar-item grey" id="text-box-toggle-btn-top" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px; display: none;">OPEN TEXT BOX</button>
        <div class="top-bar-item black" id="total-value-display" style="cursor: pointer;">
            <span style="font-size: 11px; font-weight: bold; font-family: Helvetica, Arial, sans-serif;">Total Value: <span id="valueScore">0.00</span> <span id="valueETH"></span></span>
        </div>
        <button class="top-bar-item grey" id="galleryBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px;">LEADERBOARD</button>
        <button class="top-bar-item grey" id="nodeListBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px;">TOP NODES</button>
        <button class="top-bar-item grey" id="convergenceZoneBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px;">CONVERGENCE ZONES</button>
        <button class="top-bar-item grey" id="toggleNametagsBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px;">SHOW NAMETAGS</button>
        <button class="top-bar-item grey" id="resetCameraBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px;">Reset View</button>
        <button class="top-bar-item grey" id="switchControlModesBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px;">SWITCH CONTROL MODES</button>
        <button class="top-bar-item grey" id="fullscreenBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px;">Fullscreen</button>
        <button class="top-bar-item grey" id="backgroundColorBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px; display: flex; align-items: center; gap: 4px;">
            <span id="bgColorSquare" style="display: inline-block; width: 10px; height: 10px; background: #0000FF; border: 1px solid #000000;"></span>
        </button>
        <button class="top-bar-item grey" id="crossButton" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px; display: flex; align-items: center; justify-content: center; gap: 4px;">
            <span id="crossSquare" style="display: inline-block; width: 10px; height: 10px; background: #000000; border: 1px solid #ffffff; position: relative;">
                <span style="position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: #ffffff; transform: translateY(-50%);"></span>
                <span style="position: absolute; left: 50%; top: 0; width: 1px; height: 100%; background: #ffffff; transform: translateX(-50%);"></span>
            </span>
        </button>
        <button class="top-bar-item grey" id="infoBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px; margin-left: auto; transform: translateX(-3px);">INFO</button>
        <div style="position: relative; transform: translateX(-3px);">
            <button class="top-bar-item grey" id="testBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px;">INDEX</button>
            <div id="testDropdown" style="display: none; position: absolute; top: 100%; right: 0; margin-top: 4px; z-index: 10000; background: #ffffff; padding: 12px; border: 1px solid #333333; min-width: 280px;">
                <div style="font-family: Helvetica, Arial, sans-serif; font-size: 10px; color: #000000; font-weight: bold; margin-bottom: 12px;" id="versionDisplay"></div>
                <div style="font-family: Helvetica, Arial, sans-serif; font-size: 10px; color: #000000; margin-bottom: 6px; margin-top: 6px;" id="userDisplay">USER: <span id="userIdDisplay"></span></div>
                <div style="font-family: Helvetica, Arial, sans-serif; font-size: 10px; color: #000000; margin-bottom: 6px; margin-top: 12px;">OpenAI API Key:</div>
                <input type="password" id="apiKeyInput" placeholder="sk-..." style="width: 100%; padding: 6px; background: #1a1a1a; color: #ffffff; border: 1px solid #333333; font-size: 10px; font-family: monospace; box-sizing: border-box;">
                <button id="saveApiKeyBtn" style="margin-top: 8px; padding: 2px 6px; background: #808080; color: #ffffff; border: none; cursor: pointer; font-size: 8px; font-family: Helvetica, Arial, sans-serif;">Save Key</button>
            </div>
        </div>
    </div>

    <div id="fps-bar">
        <span id="fpsRepeated"></span>
    </div>

    <div id="bottom-bar">
        <div id="bottom-fps-bar">
            <span id="bottom-fpsRepeated"></span>
        </div>
        <div id="realtime-info-panel">
        <div class="info-item">
            <span class="info-label">FPS:</span>
            <span class="info-value" id="realtime-fps">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Camera:</span>
            <span class="info-value">X: <span id="realtime-camera-x">0.00</span> Y: <span id="realtime-camera-y">0.00</span> Z: <span id="realtime-camera-z">0.00</span></span>
        </div>
        <div class="info-item">
            <span class="info-label">Nodes:</span>
            <span class="info-value" id="realtime-nodes">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Connections:</span>
            <span class="info-value" id="realtime-connections">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Total Value:</span>
            <span class="info-value" id="realtime-total-value">0.00 ETH</span>
        </div>
        <div class="info-item">
            <span class="info-label">Avg Value/Node:</span>
            <span class="info-value" id="realtime-avg-value">0.00 ETH</span>
        </div>
        </div>
    </div>

    <div id="node-list-container"></div>
    
    <!-- Leaderboard Right Panel -->
    <div id="leaderboard-right-panel">
        <div id="leaderboard-right-panel-grid">
            <div id="leaderboard-right-panel-title">GENERAL MARKET</div>
            <div id="leaderboard-right-panel-stats"></div>
            <canvas id="leaderboard-right-panel-canvas"></canvas>
        </div>
    </div>
    
    <!-- Leaderboard Info Panel -->
    <div id="leaderboard-info-panel">
        <div id="leaderboard-info-panel-content"></div>
    </div>

    <!-- Value Logic Summary Modal -->
    <div id="value-logic-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0); z-index: 10000; overflow-y: auto; pointer-events: none; scrollbar-width: none; -ms-overflow-style: none;">
        <div id="value-logic-modal-container" style="position: absolute; max-width: 400px; background: rgba(220, 220, 220, 0.76); padding: 4px 12px 12px 12px; border-radius: 0; color: #000000; font-family: Helvetica, Arial, sans-serif; pointer-events: auto;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 3px; margin-top: 0;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <button id="close-value-logic-modal" style="background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; display: flex; align-items: center; gap: 2px; white-space: nowrap; border-radius: 0; margin: 0; min-height: 16px; height: 16px;">
                        <span style="font-size: 12px;">Ã—</span>
                        <span>CLOSE</span>
                    </button>
                    <button id="value-logic-claim-btn" style="background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; display: flex; align-items: center; gap: 2px; white-space: nowrap; border-radius: 0; margin: 0; justify-content: center; min-height: 16px; height: 16px;">
                        CLAIM
                    </button>
                </div>
                <div id="value-logic-color-btn" style="width: 16px; height: 16px; background: #808080; border: none; cursor: pointer; padding: 1px; display: flex; align-items: center; justify-content: center; border-radius: 0; margin: 0; position: absolute; top: 4px; right: 12px;">
                    <div id="value-logic-color-indicator" style="width: 12px; height: 12px; background: #000000; border-radius: 0;"></div>
                </div>
            </div>
            <div id="value-logic-content" style="font-size: 11px; line-height: 1.1; color: #000000; margin-top: 5px;">
                <!-- Content will be generated here -->
            </div>
            <div id="value-logic-overview-container" style="width: 100%; max-width: 100%; height: 150px; background: #000000; border: 1px solid #ffffff; margin-top: 5px; margin-bottom: 5px; border-radius: 0; position: relative; display: none; overflow: hidden; box-sizing: border-box;">
                <canvas id="value-logic-overview-canvas" style="width: 100%; height: 100%; display: block;"></canvas>
            </div>
            <div id="value-logic-top5-grid" style="display: none; margin-top: 5px; margin-bottom: 5px;">
                <!-- Top 4 nodes and fractals will be generated here -->
            </div>
            <div id="value-logic-total-box" style="background: #000000; border: 1px solid #ffffff; padding: 6px; margin-top: 5px; border-radius: 0; display: none;">
                <div style="color: #ffffff; font-size: 11px;"><strong>Total Value:</strong> <span id="value-logic-total-display">-</span></div>
            </div>
        </div>
    </div>

    <!-- Info Modal -->
    <div id="info-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0); z-index: 10001; overflow-y: auto; pointer-events: none; scrollbar-width: none; -ms-overflow-style: none;">
        <style>
            #info-modal::-webkit-scrollbar {
                display: none;
            }
        </style>
        <div id="info-modal-container" style="position: absolute; max-width: 400px; background: rgba(220, 220, 220, 0.76); padding: 4px 12px 12px 12px; border-radius: 0; color: #000000; font-family: Helvetica, Arial, sans-serif; pointer-events: auto;" onclick="event.stopPropagation();">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 3px; margin-top: 0;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <button id="close-info-modal" style="background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; display: flex; align-items: center; gap: 2px; white-space: nowrap; border-radius: 0; margin: 0; min-height: 16px; height: 16px;">
                        <span style="font-size: 12px;">Ã—</span>
                        <span>CLOSE</span>
                    </button>
                </div>
                <div id="info-color-btn" style="width: 16px; height: 16px; background: #808080; border: none; cursor: pointer; padding: 1px; display: flex; align-items: center; justify-content: center; border-radius: 0; margin: 0; position: absolute; top: 4px; right: 12px;">
                    <div id="info-color-indicator" style="width: 12px; height: 12px; background: #000000; border-radius: 0;"></div>
                </div>
            </div>
            <div id="info-modal-content" style="font-size: 11px; line-height: 1.1; color: #000000; margin-top: 5px;">
                <!-- Content will be generated here -->
            </div>
        </div>
    </div>

    <!-- Claim Modal -->
    <div id="claim-modal" style="display: none; position: fixed; top: 25px; left: 0; width: 100%; height: calc(100% - 25px); background: rgba(0, 0, 0, 0); z-index: 30000; overflow-y: auto; pointer-events: auto; scrollbar-width: none; -ms-overflow-style: none; padding-top: 1px; padding-bottom: 0.5px; box-sizing: border-box;">
        <style>
            #claim-modal::-webkit-scrollbar {
                display: none;
            }
            #claim-total-value-container::-webkit-scrollbar {
                display: none;
                width: 0;
                height: 0;
            }
            #claim-nodes-list-container::-webkit-scrollbar {
                display: none;
                width: 0;
                height: 0;
            }
            #claim-modal-container::-webkit-scrollbar {
                display: none;
                width: 0;
                height: 0;
            }
            #claim-total-value-container {
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            #claim-nodes-list-container {
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
        </style>
        <div id="claim-modal-container" style="position: relative; width: 100%; max-width: 730px; margin: 0 auto; padding: 3px 5px 1px 8px; background: rgba(255, 255, 255, 0.7); border: none; box-sizing: border-box;">
            <div style="display: flex; justify-content: flex-start; align-items: center; margin-bottom: 5px; position: relative;">
                <button id="claim-back-btn" style="background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; border-radius: 0; display: flex; align-items: center; gap: 2px; white-space: nowrap;"><span style="font-size: 12px;">Ã—</span><span>CLOSE</span></button>
                <button id="claim-purchase-btn" style="background: #808080; color: #ffffff; border: none; padding: 1px 2px; font-size: 10px; font-family: Helvetica, Arial, sans-serif; cursor: pointer; border-radius: 0; position: absolute; right: 8px;">PURCHASE</button>
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: nowrap; margin-bottom: 5px; align-items: flex-start; overflow: visible;">
                <div style="display: flex; flex-direction: column; gap: 5px;">
                    <div id="claim-3d-container" style="flex: 0 0 auto; width: 350px; height: 500px; background: #000000; position: relative; border: 1px solid #000000;"></div>
                    <div id="claim-expanded-section" style="display: none; width: 350px; background: #000000; padding: 5px; border: 1px solid #000000;">
                        <div id="claim-top4-fractals-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px; width: 100%;"></div>
                    </div>
                </div>
                <div id="claim-total-value-container" style="flex: 0 0 auto; width: 350px; height: 500px; min-height: 500px; max-height: none; background: rgba(220, 220, 220, 0.95); padding: 4px 8px 8px 8px; border-radius: 0; color: #000000; font-family: Helvetica, Arial, sans-serif; overflow-y: auto; overflow-x: hidden; scrollbar-width: none; -ms-overflow-style: none; border: 1px solid #000000; position: relative; transition: height 0.3s ease;">
                    <div id="claim-total-value-content" style="min-height: 100%;"></div>
                    <button id="claim-scroll-down-btn" style="position: absolute; bottom: 5px; right: 5px; background: rgba(128, 128, 128, 0.7); color: #ffffff; border: none; padding: 2px 4px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 8px; border-radius: 0; z-index: 10;">â†“</button>
                </div>
            </div>
            <div style="position: relative; margin-top: -13px; min-height: 30px;">
                <button id="claim-expand-btn" style="position: absolute; left: 0; bottom: 2px; background: #808080; color: #ffffff; border: none; padding: 1px 2px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 10px; border-radius: 0; display: flex; align-items: center; justify-content: center; gap: 3px;">
                    <span>EXPAND</span>
                    <span style="font-size: 7px;">â†“</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Fractal Modal -->
    <div id="fractal-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0); z-index: 20000; overflow-y: auto; pointer-events: none;">
        <div id="fractal-modal-container" style="position: absolute; top: 25px; right: 0px; max-width: 300px; background: rgba(220, 220, 220, 0.76); padding: 4px 6px 6px 6px; border-radius: 0; color: #000000; font-family: Helvetica, Arial, sans-serif; pointer-events: auto;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 3px; margin-top: 0;">
                <button id="close-fractal-modal" style="background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; display: flex; align-items: center; gap: 2px; white-space: nowrap; border-radius: 0; margin: 0; min-height: 16px; height: 16px;">
                    <span style="font-size: 12px;">Ã—</span>
                    <span>CLOSE</span>
                </button>
                <div id="fractal-word-title" style="color: #000000; font-size: 10px; font-weight: bold; font-family: Helvetica, Arial, sans-serif; text-transform: uppercase; position: absolute; left: 50%; transform: translateX(-50%);">CP: <span id="fractal-word-name">-</span></div>
                <div></div>
            </div>
            <canvas id="fractal-canvas" style="width: 100%; max-width: 100%; height: 200px; display: block; background: #000000; border: 1px solid #ffffff;"></canvas>
        </div>
    </div>

    <!-- Purchase Visualization Modal -->
    <div id="purchase-visualization-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0); z-index: 40000; overflow: hidden; pointer-events: auto;">
        <style>
            #purchase-visualization-modal::-webkit-scrollbar {
                display: none;
            }
        </style>
        <!-- Top Bar (identical to main screen) -->
        <div id="purchase-vis-top-bar" style="position: fixed; top: 0; left: 0; right: 0; height: 30px; background: rgba(255, 255, 255, 0.98); border-bottom: 1px solid rgba(255, 140, 0, 0.98); z-index: 40001; display: flex; align-items: center; gap: 2px; padding: 2px;">
            <button id="purchase-vis-close-btn" style="background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; border-radius: 0; display: flex; align-items: center; gap: 2px; white-space: nowrap; min-height: 16px; height: 16px;">
                <span style="font-size: 12px;">Ã—</span><span>CLOSE</span>
            </button>
            <button id="purchase-vis-top-nodes-btn" class="top-bar-item grey" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px;">TOP NODES</button>
            <button id="purchase-vis-bg-color-btn" class="top-bar-item grey" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px; display: flex; align-items: center; gap: 4px;">
                <span id="purchase-vis-bg-color-square" style="display: inline-block; width: 10px; height: 10px; background: #0000FF; border: 1px solid #000000;"></span>
            </button>
            <button id="purchase-vis-nametags-btn" class="top-bar-item grey" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 11px;">SHOW NAMETAGS</button>
        </div>
        <!-- FPS Bar (orange line below top bar) -->
        <div id="purchase-vis-fps-bar" style="position: fixed; top: 30px; left: 0; right: 0; height: 7px; background: rgba(255, 140, 0, 0.98); z-index: 40001;"></div>
        <!-- Canvas Container -->
        <div id="purchase-vis-canvas-container" style="position: fixed; top: 37px; left: 0; right: 0; bottom: 200px; z-index: 40000;">
            <canvas id="purchase-vis-canvas" style="width: 100%; height: 100%; display: block;"></canvas>
        </div>
        <!-- Text Container (Map Text Mode) - Same style as main text container -->
        <div id="purchase-vis-text-container" style="position: fixed; bottom: 0; left: 0; right: 0; height: 200px; background: #000000; border-top: 1px solid rgba(255, 140, 0, 0.98); z-index: 40001; overflow-y: auto; padding: 4px;">
            <div id="purchase-vis-mapped-text" style="font-size: 12px; line-height: 1.4; color: #ffffff; padding: 4px; white-space: pre-wrap; word-wrap: break-word;"></div>
        </div>
        <!-- Bottom FPS Bar (orange line above text container) -->
        <div id="purchase-vis-bottom-fps-bar" style="position: fixed; bottom: 200px; left: 0; right: 0; height: 7px; background: rgba(255, 140, 0, 0.98); z-index: 40001;"></div>
        <!-- Right Panel (for node details) -->
        <div id="purchase-vis-right-panel" style="display: none; position: fixed; bottom: 207px; right: 0; width: 300px; max-height: calc(100% - 237px); background: rgba(255, 255, 255, 0.95); border-left: 1px solid #e0e0e0; z-index: 40002; overflow-y: auto; padding: 8px;">
            <button id="purchase-vis-right-panel-close" style="background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; margin-bottom: 8px; border-radius: 0; display: flex; align-items: center; gap: 2px;">
                <span style="font-size: 12px;">Ã—</span><span>CLOSE</span>
            </button>
            <div id="purchase-vis-right-panel-content"></div>
        </div>
        <!-- Node List Container -->
        <div id="purchase-vis-node-list-container" style="display: none; position: fixed; top: 37px; left: 0; right: 0; bottom: 207px; background: rgba(255, 255, 255, 0.98); z-index: 40003; overflow-y: auto; padding: 8px; display: flex; flex-wrap: wrap; gap: 4px;"></div>
    </div>

    <div id="max-value-panel">
        <div id="max-value-panel-header">
            <span id="max-value-panel-hashtag">#1</span>
            <h3 id="max-value-panel-word" style="color: #000000; font-size: 11px; margin: 0; font-family: Helvetica, Arial, sans-serif;">-</h3>
        </div>
        <div id="max-value-panel-canvas-container">
            <canvas id="max-value-panel-canvas"></canvas>
            <img id="max-value-panel-image" style="display: none; width: 100%; height: 100%; object-fit: contain; background: #000000;" />
        </div>
        <div id="max-value-panel-info">
            <div><strong>Word:</strong> <span id="max-value-word">-</span></div>
            <div><strong>Individual Value:</strong> <span id="max-value-individual-value">-</span></div>
            <div><strong>Position in Text:</strong> <span id="max-value-position">-</span></div>
            <div><strong>Value / Total:</strong> <span id="max-value-relative-value">-</span></div>
            <div><strong>Connections:</strong> <span id="max-value-connections">-</span></div>
            <div><strong>Size (KB):</strong> <span id="max-value-size">-</span></div>
            <div><strong>Performance:</strong> <span id="max-value-performance">-</span></div>
            <div><strong>3D Coordinates:</strong> <span id="max-value-3d-coords">-</span></div>
        </div>
    </div>

    <div id="right-panel">
        <div id="right-panel-header">
            <button id="right-panel-close" style="padding: 0 !important; margin: 0 !important;">
                <span style="font-size: 8px !important; padding: 0 !important; margin: 0 !important;">Ã—</span>
                <span style="padding: 0 !important; margin: 0 !important;">CLOSE</span>
            </button>
        </div>
        <h3 id="right-panel-word" style="position: absolute; top: 2px; right: 5px; color: #000000; font-size: 11px; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; z-index: 10;">-</h3>
        <div id="right-panel-canvas-container">
            <canvas id="right-panel-canvas"></canvas>
        </div>
        <div id="node-details-content">
            <div><strong>Word:</strong> <span id="detail-word">-</span></div>
            <div><strong>Individual Value:</strong> <span id="detail-individual-value">-</span></div>
            <div><strong>Position in Text:</strong> <span id="detail-position">-</span></div>
            <div><strong>Value / Total:</strong> <span id="detail-relative-value">-</span></div>
            <div><strong>Connections:</strong> <span id="detail-connections">-</span></div>
            <div><strong>Size (KB):</strong> <span id="detail-size">-</span></div>
            <div><strong>Performance:</strong> <span id="detail-performance">-</span></div>
            <div><strong>3D Coordinates:</strong> <span id="detail-3d-coords">-</span></div>
        </div>
    </div>

    <script>
        // ==================== VARIABLES GLOBALES ====================
        let scene, camera, renderer;
        let nodes = [];
        let connections = [];
        let analyzedWords = [];
        let convergenceZones = [];
        let isDragging = false;
        let isPanning = false; // Track if we're panning (Shift + middle mouse) vs rotating (middle mouse)
        let isViewingPurchase = false; // Flag to track if we're viewing a purchase from leaderboard
        let alternativeControlMode = false; // Track if alternative control mode is active - false = default (any mouse button, high sensitivity), true = alternative (middle mouse, normal sensitivity)
        
        // Grid mode variables
        let gridMode = false;
        let gridContainer = null;
        let lastGridLabelUpdate = 0;
        const GRID_LABEL_UPDATE_INTERVAL = 1000; // Update every second
        const gridSquareValueHistory = new Map(); // Store value history for each square
        const MAX_HISTORY_POINTS = 20; // Maximum number of points in graph
        const gridSquareCache = []; // Cache square data to avoid repeated DOM queries
        
        // Project version
        // Update this version number each time a change is made
        // Format: v0.5.0 -> v0.5.01 -> v0.5.02 -> ... -> v0.5.20 -> v0.6.0 -> v0.6.01, etc.
        // The third number goes from 00 to 20, then increments the second number
        const PROJECT_VERSION = 'v0.6.4';
        
        // Generate unique user ID on first access
        function generateUserId() {
            let userId = localStorage.getItem('user_id');
            if (!userId) {
                // Generate ID in format: 0x followed by random digits
                const randomDigits = Array.from({length: 21}, () => Math.floor(Math.random() * 10)).join('');
                userId = '0x' + randomDigits;
                localStorage.setItem('user_id', userId);
            }
            return userId;
        }
        
        const USER_ID = generateUserId();
        
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngleX = 0;
        let cameraAngleY = 0;
        let cameraRadius = 10;
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        // Store initial camera values for reset
        const initialCameraRadius = 10;
        const initialCameraAngleX = 0;
        const initialCameraAngleY = 0;
        const initialCameraTarget = new THREE.Vector3(0, 0, 0);
        let nametagsVisible = false;
        let nametags = [];
        let mappedTextVisible = false;
        let nodeListVisible = false;
        let galleryVisible = false;
        let nodeListItems = [];
        let nodeListScenes = [];
        let nodeListRenderers = [];
        let nodeListMeshes = [];
        let nodeListAnimationIds = [];
        let nodeListIntersectionObserver = null;
        // Renderer compartido para nodos de la lista (evita mÃºltiples contextos WebGL)
        let sharedTopNodesRenderer = null;
        let sharedTopNodesScene = null;
        let sharedTopNodesCamera = null;
        let ethPriceUSD = null; // Store Ethereum conversion rate (used to convert points directly to ETH)
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let hoveredNode = null;
        let selectedNode = null; // Node currently displayed in right-panel
        let nodeInfoPanel = null;
        let nodeInfoCanvas = null;
        let nodeInfoRenderer = null;
        let nodeInfoScene = null;
        let nodeInfoCamera = null;
        let nodeInfoMesh = null;
        let rightPanelCanvas = null;
        let rightPanelRenderer = null;
        let rightPanelScene = null;
        let rightPanelCamera = null;
        let rightPanelMesh = null;
        let rightPanelAnimationId = null;
        
        // Multiple right panels system
        let rightPanels = []; // Array of active panel objects: { id, element, node, scene, renderer, camera, mesh, animationId, offset }
        let rightPanelCounter = 0; // Counter for unique panel IDs
        const MAX_RIGHT_PANELS = 3; // Maximum 3 panels - when exceeded, close all and start fresh
        let availableOffsets = []; // Stack of available offsets when panels are closed
        let maxValuePanelCanvas = null;
        let maxValuePanelRenderer = null;
        let maxValuePanelScene = null;
        let maxValuePanelCamera = null;
        let maxValuePanelMesh = null;
        
        // Fractal generation
        let fractalCanvas = null;
        let fractalCtx = null;
        let fractalWorker = null;
        let currentFractalWordIndex = -1;
        let fractalGenerationInProgress = false;
        let maxValuePanelAnimationId = null;
        let maxValueNode = null;
        let currentBackgroundColor = 0x0000FF; // Start with blue (AZUL)
        let backgroundColorIndex = 0; // 0=AZUL, 1=NEGRO, 2=GRIS, 3=BLANCO
        const backgroundColors = [0x0000FF, 0x000000, 0x808080, 0xFFFFFF]; // AZUL, NEGRO, GRIS, BLANCO
        const backgroundColorNames = ['AZUL', 'NEGRO', 'GRIS', 'BLANCO'];
        
        // Store references to reference sphere lines and crosses for color updates
        let referenceSphereLines = [];
        let referenceSphereCrosses = [];
        let keysPressed = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };
        let valueLogicColorMode = false; // false = black boxes, true = white boxes
        let convergenceZonesColorMode = false; // false = black boxes, true = white boxes
        let infoColorMode = false; // false = black boxes, true = white boxes
        let valueLogicOverviewScene = null;
        let valueLogicOverviewRenderer = null;
        let valueLogicOverviewCamera = null;
        let valueLogicOverviewNodes = [];
        let valueLogicOverviewAnimationId = null;
        let visualizationGenerationDate = null; // Store date/time when visualization is generated

        // ==================== INICIALIZACIÃ“N ====================
        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.background = null; // Always transparent - background is handled by background-container

            // Create camera with reduced far plane for performance
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500); // Reduced far plane from 1000 to 500
            updateCameraPosition();

            // Create renderer with reduced quality for better performance
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, // Enable antialiasing for better line quality
                powerPreference: "low-power", // Use low power mode
                alpha: true // Enable alpha channel for transparency
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Always transparent - background is handled by background-container
            // Use device pixel ratio capped at 2.0 for better quality without excessive performance cost
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2.0));
            // Enable sortObjects so renderOrder works correctly
            renderer.sortObjects = true;
            
            // Handle WebGL context loss
            renderer.domElement.addEventListener('webglcontextlost', function(event) {
                event.preventDefault();
                console.warn('WebGL context lost');
            });
            
            renderer.domElement.addEventListener('webglcontextrestored', function() {
                console.log('WebGL context restored');
                // Re-initialize if needed
                // Always keep transparent when grid is active, otherwise use current background color
                if (gridMode) {
                    renderer.setClearColor(0x000000, 0);
                } else {
                    renderer.setClearColor(currentBackgroundColor, 1);
                }
            });
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights (increased for better color visibility)
            const ambientLight = new THREE.AmbientLight(0x404040, 1.2); // Significantly increased for better visibility
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Significantly increased for better color distinction
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = false; // Disable shadows for performance
            scene.add(directionalLight);

            // Create transparent sphere with reference lines and crosses
            createReferenceSphere();

            // Event listeners
            setupEventListeners();

            // Initialize node info panel for hover
            nodeInfoPanel = document.getElementById('node-info-panel');
            nodeInfoCanvas = document.getElementById('node-info-canvas');
            
            // Create 3D scene for enlarged node view
            nodeInfoScene = new THREE.Scene();
            nodeInfoScene.background = new THREE.Color(0x000000);
            
            nodeInfoCamera = new THREE.PerspectiveCamera(50, 100 / 60, 0.1, 100);
            nodeInfoCamera.position.set(0, 0, 2);
            nodeInfoCamera.lookAt(0, 0, 0);
            
            nodeInfoRenderer = new THREE.WebGLRenderer({ 
                canvas: nodeInfoCanvas,
                antialias: false
            });
            nodeInfoRenderer.setSize(100, 60);
            nodeInfoRenderer.setPixelRatio(0.75);
            
            // Add lights
            const nodeInfoAmbientLight = new THREE.AmbientLight(0x404040, 0.6);
            nodeInfoScene.add(nodeInfoAmbientLight);
            
            const nodeInfoDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            nodeInfoDirectionalLight.position.set(2, 2, 2);
            nodeInfoScene.add(nodeInfoDirectionalLight);
            
            // Initialize right panel canvas for enlarged node view
            rightPanelCanvas = document.getElementById('right-panel-canvas');
            
            // Create 3D scene for right panel enlarged node view
            rightPanelScene = new THREE.Scene();
            rightPanelScene.background = new THREE.Color(0x000000);
            
            rightPanelCamera = new THREE.PerspectiveCamera(50, 200 / 150, 0.1, 100);
            rightPanelCamera.position.set(0, 0, 2);
            rightPanelCamera.lookAt(0, 0, 0);
            
            rightPanelRenderer = new THREE.WebGLRenderer({ 
                canvas: rightPanelCanvas,
                antialias: false
            });
            rightPanelRenderer.setSize(200, 150);
            rightPanelRenderer.setPixelRatio(0.75);
            
            // Add lights
            const rightPanelAmbientLight = new THREE.AmbientLight(0x404040, 0.6);
            rightPanelScene.add(rightPanelAmbientLight);
            
            const rightPanelDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            rightPanelDirectionalLight.position.set(2, 2, 2);
            rightPanelScene.add(rightPanelDirectionalLight);
            
            // Initialize max-value-panel
            maxValuePanelCanvas = document.getElementById('max-value-panel-canvas');
            
            // Create 3D scene for max-value-panel
            maxValuePanelScene = new THREE.Scene();
            maxValuePanelScene.background = new THREE.Color(0x000000);
            
            maxValuePanelCamera = new THREE.PerspectiveCamera(50, 200 / 120, 0.1, 100);
            maxValuePanelCamera.position.set(0, 0, 2);
            maxValuePanelCamera.lookAt(0, 0, 0);
            
            maxValuePanelRenderer = new THREE.WebGLRenderer({ 
                canvas: maxValuePanelCanvas,
                antialias: false
            });
            maxValuePanelRenderer.setSize(200, 120);
            maxValuePanelRenderer.setPixelRatio(0.75);
            
            // Add lights
            const maxValuePanelAmbientLight = new THREE.AmbientLight(0x404040, 0.6);
            maxValuePanelScene.add(maxValuePanelAmbientLight);
            
            const maxValuePanelDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            maxValuePanelDirectionalLight.position.set(2, 2, 2);
            maxValuePanelScene.add(maxValuePanelDirectionalLight);
            
            // Initialize max-value-panel visibility
            initializeMaxValuePanel();
            
            // Start animation
            animate();
        }

        function toggleTextBox() {
            const textContainer = document.getElementById('text-container');
            const leftPanel = document.getElementById('left-panel');
            const textBoxToggleBtn = document.getElementById('text-box-toggle-btn');
            const textBoxToggleBtnTop = document.getElementById('text-box-toggle-btn-top');
            textContainer.classList.toggle('collapsed');
            leftPanel.classList.toggle('collapsed');
            // Add/remove class to body to control fps-bar position
            if (leftPanel.classList.contains('collapsed')) {
                document.body.classList.add('left-panel-collapsed');
                // Hide original button and show top-bar button
                if (textBoxToggleBtn) {
                    textBoxToggleBtn.style.display = 'none';
                }
                if (textBoxToggleBtnTop) {
                    textBoxToggleBtnTop.style.display = 'flex';
                }
                // Position all bars at the left edge of the screen when panel is collapsed
                setTimeout(() => {
                    const topBar = document.getElementById('top-bar');
                    const fpsBar = document.getElementById('fps-bar');
                    const bottomBar = document.getElementById('bottom-bar');
                    
                    // Position all bars at left: 0 when panel is collapsed
                    if (topBar) {
                        topBar.style.left = '0';
                        topBar.style.position = 'fixed';
                        topBar.style.top = '0';
                        topBar.style.right = '0';
                        topBar.style.paddingLeft = '10px'; // Add left margin
                    }
                    if (fpsBar) {
                        fpsBar.style.left = '0';
                        fpsBar.style.position = 'fixed';
                        fpsBar.style.top = '18px';
                        fpsBar.style.right = '0';
                    }
                    if (bottomBar) {
                        bottomBar.style.left = '0';
                        bottomBar.style.position = 'fixed';
                        bottomBar.style.bottom = '0';
                        bottomBar.style.right = '0';
                    }
                }, 10);
            } else {
                document.body.classList.remove('left-panel-collapsed');
                // Show original button and hide top-bar button
                if (textBoxToggleBtn) {
                    textBoxToggleBtn.style.display = 'flex';
                    textBoxToggleBtn.textContent = 'TEXT BOX';
                }
                if (textBoxToggleBtnTop) {
                    textBoxToggleBtnTop.style.display = 'none';
                }
                // Reset all bars position when panel is expanded (remove inline styles to let CSS handle it)
                const topBar = document.getElementById('top-bar');
                const fpsBar = document.getElementById('fps-bar');
                const bottomBar = document.getElementById('bottom-bar');
                if (topBar) {
                    topBar.style.removeProperty('left');
                    topBar.style.position = 'fixed';
                    topBar.style.top = '0';
                    topBar.style.right = '0';
                }
                if (fpsBar) {
                    fpsBar.style.removeProperty('left');
                    fpsBar.style.position = 'fixed';
                    fpsBar.style.top = '18px';
                    fpsBar.style.right = '0';
                }
                if (bottomBar) {
                    bottomBar.style.removeProperty('left');
                    bottomBar.style.position = 'fixed';
                    bottomBar.style.bottom = '0';
                    bottomBar.style.right = '0';
                }
            }
            
            // On mobile, adjust canvas size and element positions when panel is toggled
            if (window.innerWidth <= 768 && renderer && camera) {
                setTimeout(() => {
                    positionMobileElements();
                    onWindowResize();
                }, 100);
            }
        }
        
        // Function to create transparent reference sphere with lines and crosses
        function createReferenceSphere() {
            const sphereRadius = 200; // Large enough to contain all nodes
            
            // Clear previous references
            referenceSphereLines = [];
            referenceSphereCrosses = [];
            
            // Create vertical line (meridian) - goes around the sphere vertically
            const verticalLineGeometry = new THREE.BufferGeometry();
            const verticalPoints = [];
            const verticalSegments = 256; // Increased resolution for smoother lines
            for (let i = 0; i <= verticalSegments; i++) {
                const theta = (i / verticalSegments) * Math.PI * 2; // Full circle
                const x = sphereRadius * Math.cos(theta);
                const z = sphereRadius * Math.sin(theta);
                verticalPoints.push(new THREE.Vector3(x, 0, z));
            }
            verticalLineGeometry.setFromPoints(verticalPoints);
            const verticalLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x000000, 
                linewidth: 2,
                depthTest: true,
                depthWrite: false,
                transparent: false
            });
            const verticalLine = new THREE.Line(verticalLineGeometry, verticalLineMaterial);
            verticalLine.renderOrder = -1; // Render before everything else
            scene.add(verticalLine);
            referenceSphereLines.push(verticalLine);
            
            // Create second vertical line (perpendicular to first) - goes around the sphere vertically in YZ plane
            const verticalLine2Geometry = new THREE.BufferGeometry();
            const vertical2Points = [];
            const vertical2Segments = 256; // Increased resolution for smoother lines
            for (let i = 0; i <= vertical2Segments; i++) {
                const theta = (i / vertical2Segments) * Math.PI * 2; // Full circle
                const y = sphereRadius * Math.cos(theta);
                const z = sphereRadius * Math.sin(theta);
                vertical2Points.push(new THREE.Vector3(0, y, z));
            }
            verticalLine2Geometry.setFromPoints(vertical2Points);
            const verticalLine2Material = new THREE.LineBasicMaterial({ 
                color: 0x000000, 
                linewidth: 2,
                depthTest: true,
                depthWrite: false,
                transparent: false
            });
            const verticalLine2 = new THREE.Line(verticalLine2Geometry, verticalLine2Material);
            verticalLine2.renderOrder = -1; // Render before everything else
            scene.add(verticalLine2);
            referenceSphereLines.push(verticalLine2);
            
            // Create horizontal line (equator) - goes around the sphere horizontally
            const horizontalLineGeometry = new THREE.BufferGeometry();
            const horizontalPoints = [];
            const horizontalSegments = 256; // Increased resolution for smoother lines
            for (let i = 0; i <= horizontalSegments; i++) {
                const theta = (i / horizontalSegments) * Math.PI * 2; // Full circle
                const x = sphereRadius * Math.cos(theta);
                const y = sphereRadius * Math.sin(theta);
                horizontalPoints.push(new THREE.Vector3(x, y, 0));
            }
            horizontalLineGeometry.setFromPoints(horizontalPoints);
            const horizontalLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x000000, 
                linewidth: 2,
                depthTest: true,
                depthWrite: false,
                transparent: false
            });
            const horizontalLine = new THREE.Line(horizontalLineGeometry, horizontalLineMaterial);
            horizontalLine.renderOrder = -1; // Render before everything else
            scene.add(horizontalLine);
            referenceSphereLines.push(horizontalLine);
            
            // Create 8 simple X marks (equis) in the 8 octants formed by the lines
            // Lines divide sphere: 2 vertical (x=0 and y=0 planes) and 1 horizontal (z=0 plane)
            // This creates 8 octants - place crosses at the center of each octant on the sphere surface
            const crossSize = 10; // Half-length of each line in the cross
            const octantPositions = [
                // Octant 1: +x, +y, +z
                { x: sphereRadius * 0.577, y: sphereRadius * 0.577, z: sphereRadius * 0.577 },
                // Octant 2: -x, +y, +z
                { x: -sphereRadius * 0.577, y: sphereRadius * 0.577, z: sphereRadius * 0.577 },
                // Octant 3: -x, -y, +z
                { x: -sphereRadius * 0.577, y: -sphereRadius * 0.577, z: sphereRadius * 0.577 },
                // Octant 4: +x, -y, +z
                { x: sphereRadius * 0.577, y: -sphereRadius * 0.577, z: sphereRadius * 0.577 },
                // Octant 5: +x, +y, -z
                { x: sphereRadius * 0.577, y: sphereRadius * 0.577, z: -sphereRadius * 0.577 },
                // Octant 6: -x, +y, -z
                { x: -sphereRadius * 0.577, y: sphereRadius * 0.577, z: -sphereRadius * 0.577 },
                // Octant 7: -x, -y, -z
                { x: -sphereRadius * 0.577, y: -sphereRadius * 0.577, z: -sphereRadius * 0.577 },
                // Octant 8: +x, -y, -z
                { x: sphereRadius * 0.577, y: -sphereRadius * 0.577, z: -sphereRadius * 0.577 }
            ];
            
            octantPositions.forEach(pos => {
                // Position vector normalized to sphere surface
                const posVec = new THREE.Vector3(pos.x, pos.y, pos.z).normalize();
                const centerPoint = posVec.clone().multiplyScalar(sphereRadius);
                
                // Create two perpendicular tangent vectors on the sphere surface
                let tangent1, tangent2;
                
                // Choose a reference vector that's not parallel to posVec
                if (Math.abs(posVec.x) < 0.9) {
                    tangent1 = new THREE.Vector3(1, 0, 0).cross(posVec).normalize();
                } else if (Math.abs(posVec.y) < 0.9) {
                    tangent1 = new THREE.Vector3(0, 1, 0).cross(posVec).normalize();
                } else {
                    tangent1 = new THREE.Vector3(0, 0, 1).cross(posVec).normalize();
                }
                
                // Second tangent is perpendicular to both posVec and tangent1
                tangent2 = posVec.clone().cross(tangent1).normalize();
                
                // Create diagonal directions for the X (45 degrees rotated from tangents)
                const diag1 = tangent1.clone().add(tangent2).normalize();
                const diag2 = tangent1.clone().sub(tangent2).normalize();
                
                // Create simple X (equis) - two diagonal lines crossing with equal length
                const xGroup = new THREE.Group();
                
                // First diagonal line of X (equal length)
                const x1Start = centerPoint.clone().add(diag1.clone().multiplyScalar(-crossSize));
                const x1End = centerPoint.clone().add(diag1.clone().multiplyScalar(crossSize));
                const x1Geometry = new THREE.BufferGeometry().setFromPoints([x1Start, x1End]);
                const x1Line = new THREE.Line(x1Geometry, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
                xGroup.add(x1Line);
                
                // Second diagonal line of X (equal length)
                const x2Start = centerPoint.clone().add(diag2.clone().multiplyScalar(-crossSize));
                const x2End = centerPoint.clone().add(diag2.clone().multiplyScalar(crossSize));
                const x2Geometry = new THREE.BufferGeometry().setFromPoints([x2Start, x2End]);
                const x2Line = new THREE.Line(x2Geometry, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
                xGroup.add(x2Line);
                
                scene.add(xGroup);
                referenceSphereCrosses.push(xGroup);
            });
            
            // Update colors based on current background
            updateReferenceSphereColors();
        }
        
        // Function to update reference sphere colors based on background
        function updateReferenceSphereColors() {
            // Determine line color based on background
            // White lines for: black, blue
            // Black lines for: grey, white
            let lineColor = 0x000000; // Default black
            if (currentBackgroundColor === 0x000000 || // Black
                currentBackgroundColor === 0x0000FF) { // Blue
                lineColor = 0xffffff; // White
            }
            
            // Update line colors
            referenceSphereLines.forEach(line => {
                if (line.material) {
                    line.material.color.setHex(lineColor);
                }
            });
            
            // Update cross colors (same as lines)
            referenceSphereCrosses.forEach(crossGroup => {
                crossGroup.children.forEach(child => {
                    if (child.material) {
                        child.material.color.setHex(lineColor);
                    }
                });
            });
        }

        function setupEventListeners() {
            // Buttons
            const generateBtn = document.getElementById('generateBtn');
            if (generateBtn) {
                generateBtn.addEventListener('click', function() {
                    // Check if button is disabled
                    if (generateBtn.disabled) {
                        return;
                    }
                    // Simply generate/update the visualization (don't export GLB)
                    generateVisualization();
                });
            }
            
            // Initialize button states on page load
            updateButtonStates();
            document.getElementById('resetCameraBtn').addEventListener('click', resetCamera);
            document.getElementById('switchControlModesBtn').addEventListener('click', toggleControlMode);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            document.getElementById('toggleNametagsBtn').addEventListener('click', toggleNametags);
            const nodeListBtn = document.getElementById('nodeListBtn');
            if (nodeListBtn) {
                nodeListBtn.addEventListener('click', function(e) {
                    console.log('[TOP NODES] Button clicked');
                    e.preventDefault();
                    e.stopPropagation();
                    toggleNodeList();
                });
                console.log('[TOP NODES] Event listener attached');
            } else {
                console.error('[TOP NODES] Button not found when attaching event listener!');
            }
            document.getElementById('convergenceZoneBtn').addEventListener('click', showConvergenceZonesModal);
            document.getElementById('galleryBtn').addEventListener('click', toggleGallery);
            document.getElementById('mapTextBtn').addEventListener('click', mapText);
            document.getElementById('backgroundColorBtn').addEventListener('click', changeBackgroundColor);
            document.getElementById('crossButton').addEventListener('click', toggleGrid);
            
            // Initialize leaderboard button state
            updateLeaderboardButtonState();
            
            // Disable Map Text and related buttons initially
            disableMapTextButtons();
            
            // Initialize convergence zone button (disabled initially)
            updateConvergenceZoneButton();
            
            // Version button dropdown
            const testBtn = document.getElementById('testBtn');
            const testDropdown = document.getElementById('testDropdown');
            const versionDisplay = document.getElementById('versionDisplay');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
            
            if (testBtn && testDropdown && versionDisplay) {
                // Set initial version
                versionDisplay.textContent = PROJECT_VERSION;
                
                // Set user ID display
                const userIdDisplay = document.getElementById('userIdDisplay');
                if (userIdDisplay) {
                    userIdDisplay.textContent = USER_ID;
                }
                
                // Load saved API key if available
                if (apiKeyInput) {
                    const savedKey = localStorage.getItem('openai_api_key');
                    if (savedKey) {
                        apiKeyInput.value = savedKey;
                    }
                }
                
                testBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const isVisible = testDropdown.style.display === 'block';
                    testDropdown.style.display = isVisible ? 'none' : 'block';
                });
                
                // Save API key button
                if (saveApiKeyBtn && apiKeyInput) {
                    saveApiKeyBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const key = apiKeyInput.value.trim();
                        if (key && key.length > 10) {
                            saveOpenAIApiKey(key);
                            alert('API key saved successfully!');
                            testDropdown.style.display = 'none';
                        } else {
                            alert('Please enter a valid API key (should start with sk-)');
                        }
                    });
                }
                
                // Close dropdown when clicking outside
                document.addEventListener('click', function(e) {
                    if (!testBtn.contains(e.target) && !testDropdown.contains(e.target)) {
                        testDropdown.style.display = 'none';
                    }
                });
            }
            
            document.getElementById('right-panel-close').addEventListener('click', hideNodeDetails);
            document.getElementById('total-value-display').addEventListener('click', function() {
                const totalValueBtn = document.getElementById('total-value-display');
                // Check if button is disabled (no text)
                if (totalValueBtn.style.pointerEvents === 'none') {
                    return;
                }
                if (isViewingPurchase) {
                    returnToInputMode();
                } else {
                    showValueLogicSummary();
                }
            });
            document.getElementById('close-value-logic-modal').addEventListener('click', hideValueLogicSummary);
            document.getElementById('value-logic-claim-btn').addEventListener('click', navigateToClaim);
            
            // Info button
            const infoBtn = document.getElementById('infoBtn');
            if (infoBtn) {
                infoBtn.addEventListener('click', showInfoModal);
            }
            const closeInfoModalBtn = document.getElementById('close-info-modal');
            if (closeInfoModalBtn) {
                closeInfoModalBtn.addEventListener('click', hideInfoModal);
            }
            const infoColorBtn = document.getElementById('info-color-btn');
            if (infoColorBtn) {
                infoColorBtn.addEventListener('click', toggleInfoColorMode);
                // Initialize color indicator
                const indicator = document.getElementById('info-color-indicator');
                if (indicator) {
                    indicator.style.background = infoColorMode ? '#ffffff' : '#000000';
                }
            }

            // Claim modal buttons
            const claimBackBtn = document.getElementById('claim-back-btn');
            const claimPurchaseBtn = document.getElementById('claim-purchase-btn');
            if (claimBackBtn) {
                claimBackBtn.addEventListener('click', hideClaimModal);
            }
            if (claimPurchaseBtn) {
                claimPurchaseBtn.addEventListener('click', downloadClaimPurchasePack);
            }
            const claimScrollDownBtn = document.getElementById('claim-scroll-down-btn');
            if (claimScrollDownBtn) {
                claimScrollDownBtn.addEventListener('click', function() {
                    const totalValueContainer = document.getElementById('claim-total-value-container');
                    if (totalValueContainer) {
                        totalValueContainer.scrollTo({
                            top: totalValueContainer.scrollHeight,
                            behavior: 'smooth'
                        });
                    }
                });
            }
            const claimExpandBtn = document.getElementById('claim-expand-btn');
            if (claimExpandBtn) {
                claimExpandBtn.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevenir que el evento se propague y cierre otros modales
                    toggleClaimExpanded();
                });
            }
            const colorBtn = document.getElementById('value-logic-color-btn');
            if (colorBtn) {
                colorBtn.addEventListener('click', toggleValueLogicColorMode);
                // Initialize color indicator
                const indicator = document.getElementById('value-logic-color-indicator');
                if (indicator) {
                    indicator.style.background = valueLogicColorMode ? '#ffffff' : '#000000';
                }
            }
            // Close modal when clicking outside (only on the modal container, not the overlay)
            const modalContainer = document.getElementById('value-logic-modal-container');
            if (modalContainer) {
                document.addEventListener('click', (e) => {
                    const modal = document.getElementById('value-logic-modal');
                    if (modal.style.display === 'block' && !modalContainer.contains(e.target) && e.target.id !== 'total-value-display' && !e.target.closest('#total-value-display')) {
                        hideValueLogicSummary();
                    }
                });
            }
            document.getElementById('clearTextBtn').addEventListener('click', clearTextBox);
            document.getElementById('text-box-toggle-btn').addEventListener('click', toggleTextBox);
            const textBoxToggleBtnTop = document.getElementById('text-box-toggle-btn-top');
            if (textBoxToggleBtnTop) {
                textBoxToggleBtnTop.addEventListener('click', toggleTextBox);
            }
            
            // Initialize fractal modal
            fractalCanvas = document.getElementById('fractal-canvas');
            if (fractalCanvas) {
                fractalCtx = fractalCanvas.getContext('2d');
                fractalCanvas.width = 288; // Match modal width (300px - padding 6px * 2)
                fractalCanvas.height = 200;
            }
            document.getElementById('close-fractal-modal').addEventListener('click', function() {
                document.getElementById('fractal-modal').style.display = 'none';
                fractalGenerationInProgress = false;
            });
            
            // Close fractal modal when clicking outside
            const fractalModal = document.getElementById('fractal-modal');
            const fractalModalContainer = document.getElementById('fractal-modal-container');
            if (fractalModal && fractalModalContainer) {
                fractalModal.addEventListener('click', (e) => {
                    // Only close if clicking directly on the modal background (not on the container)
                    if (e.target === fractalModal || (e.target.id === 'fractal-modal')) {
                        fractalModal.style.display = 'none';
                        fractalGenerationInProgress = false;
                    }
                });
            }

            // Setup fractal click listeners
            setupFractalClickListeners();
            
            // Text input validation - limit to 500 words
            const textInput = document.getElementById('textInput');
            textInput.addEventListener('input', limitWordCount);
            textInput.addEventListener('input', updateButtonStates);
            textInput.addEventListener('paste', handlePaste);
            textInput.addEventListener('keydown', function(event) {
                // Handle Enter key to generate/update visualization (but allow Shift+Enter for new line)
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault(); // Prevent new line
                    // Generate/update visualization (same as Export Body button)
                    generateVisualization();
                    return;
                }
                
                // Allow backspace, delete, arrow keys, etc.
                if (event.key === 'Backspace' || event.key === 'Delete' || 
                    event.key.startsWith('Arrow') || event.key === 'Tab' ||
                    (event.ctrlKey && (event.key === 'a' || event.key === 'c' || event.key === 'v' || event.key === 'x'))) {
                    return; // Allow these keys
                }
                
                // Check if adding this character would exceed the limit
                const currentText = textInput.value;
                const selectionStart = textInput.selectionStart;
                const selectionEnd = textInput.selectionEnd;
                const newText = currentText.substring(0, selectionStart) + 
                              (event.key.length === 1 ? event.key : '') + 
                              currentText.substring(selectionEnd);
                const words = splitTextIntoWords(newText);
                
                if (words.length > 500) {
                    event.preventDefault();
                    // Show warning
                    const existingWarning = document.getElementById('wordLimitWarning');
                    if (existingWarning) {
                        existingWarning.remove();
                    }
                    const warning = document.createElement('div');
                    warning.id = 'wordLimitWarning';
                    warning.style.cssText = 'color: #ff6600; font-size: 11px; margin-top: 5px;';
                    warning.textContent = 'Maximum 500 words reached. Cannot type more.';
                    textInput.parentNode.appendChild(warning);
                    setTimeout(() => {
                        if (warning.parentNode) {
                            warning.parentNode.removeChild(warning);
                        }
                    }, 3000);
                }
            });

            // Camera controls
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Mouse move for hover (condensed info)
            renderer.domElement.addEventListener('mousemove', onMouseMoveHover);
            
            // Mouse move for coordinates update
            renderer.domElement.addEventListener('mousemove', onMouseMoveCoordinates);
            
            // Mouse click for detailed info in side panel
            renderer.domElement.addEventListener('click', onNodeClick);
            
            // Keyboard navigation
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            // Resize
            window.addEventListener('resize', onWindowResize);
        }

        function updateCameraPosition() {
            // Calculate camera position in spherical coordinates relative to cameraTarget
            const x = Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraRadius;
            const y = Math.sin(cameraAngleX) * cameraRadius;
            const z = Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraRadius;

            // Set camera position relative to cameraTarget (not origin)
            camera.position.set(
                cameraTarget.x + x,
                cameraTarget.y + y,
                cameraTarget.z + z
            );
            camera.lookAt(cameraTarget);
            
            // Update coordinates display when camera moves
            updateCoordinatesDisplay();
        }

        // ==================== ANÃLISIS LINGÃœÃSTICO ====================
        // Conjunto ampliado de palabras comunes que pueden ir en mayÃºscula sin ser nombres propios
        const COMMON_CAPITALIZED_WORDS = new Set([
            // English articles / determiners / pronouns / conjunctions
            'I','The','A','An','This','That','These','Those','He','She','We','They','You','It','And','Or','But','If','When','Where','How','Why','What','Who',
            // Spanish equivalents
            'El','La','Los','Las','Un','Una','Unos','Unas','Este','Esta','Estos','Estas','Ese','Esa','Esos','Esas','Aquel','Aquella','Aquellos','Aquellas',
            'Yo','TÃº','Ã‰l','Ella','Nosotros','Nosotras','Vosotros','Vosotras','Ellos','Ellas','Usted','Ustedes','Y','O','Pero','Si','Cuando','Donde','Como',
            // Common discourse markers often capitalized at line start
            'Thus','Therefore','Hence','However','Nevertheless','Moreover','Meanwhile','Entonces','Sin','Embargo','AdemÃ¡s','Asimismo',
            // Months / days (frequently capitalized but not names)
            'Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday',
            'January','February','March','April','May','June','July','August','September','October','November','December',
            'Lunes','Martes','MiÃ©rcoles','Jueves','Viernes','SÃ¡bado','Domingo',
            'Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'
        ]);

        // ==================== CONTEXT-ONLY UPOS TAGGING SYSTEM ====================
        // Universal POS Tagging using ONLY text-internal evidence (no capitalization, no external dictionaries)
        //
        // ARCHITECTURE OVERVIEW:
        // This system implements context-only POS tagging following the algorithm in the prompt:
        // 1. Tokenization: Language-agnostic tokenization that separates punctuation
        // 2. Context Statistics: Builds co-occurrence, bigram/trigram, and position features from text
        // 3. High-Precision Anchors: Tags PUNCT, SYM, NUM using shape patterns
        // 4. Category Induction: Uses syntactic frames and distributional patterns to tag:
        //    - AUX: auxiliary/modal verbs (be, have, do, will, can, etc.) detected by patterns
        //    - VERB: main verbs between subject-like and object-like spans, after AUX
        //    - NOUN: tokens after DET/ADP/NUM, modified by ADJ
        //    - ADJ: tokens modifying NOUN
        //    - ADV: tokens near VERB, modifying ADJ
        //    - DET/ADP/PRON: based on position and context patterns
        // 5. PROPN vs NOUN: Distinguishes using repeated sequences, resistance to determiners
        // 6. Ambiguity Resolution: Resolves CCONJ vs SCONJ, ADP vs SCONJ based on following structure
        // 7. Iterative Bootstrapping: Multiple passes refine tags as more context becomes available
        //
        // KEY FEATURES:
        // - NO capitalization signals (all words treated as lowercase)
        // - NO external dictionaries or gazetteers
        // - Uses ONLY evidence from the input text itself
        // - Maps UPOS tags to legacy POS tags for compatibility with value system
        //
        // USAGE:
        // - tagUPOSContextOnly(text): Returns full UPOS tagging result with evidence
        // - getPOSFromUPOS(text, wordIndex): Gets legacy POS tag for specific word
        // - mapUPOStoLegacyPOS(upos): Converts UPOS tag to legacy POS tag
        // - isAuxiliaryOrModalVerb(word): Checks if a word is an auxiliary/modal verb
        
        /**
         * Maps UPOS tags to legacy POS tags for compatibility with value system
         * Note: AUX (auxiliary/modal verbs) maps to 'verb' since the legacy system
         * doesn't distinguish between auxiliary and main verbs. The original UPOS tag
         * is preserved separately for advanced use cases.
         */
        function mapUPOStoLegacyPOS(upos) {
            const mapping = {
                'ADJ': 'adjective',
                'ADP': 'preposition',
                'ADV': 'adverb',
                'AUX': 'verb', // Auxiliary/modal verbs treated as regular verbs in legacy system
                'CCONJ': 'conjunction',
                'DET': 'determiner',
                'INTJ': 'interjection',
                'NOUN': 'noun',
                'NUM': 'noun', // Numbers treated as nouns in legacy system
                'PART': 'adverb', // Particles often map to adverbs
                'PRON': 'pronoun',
                'PROPN': 'noun', // Proper nouns are nouns in legacy system (value system will check isName flag)
                'PUNCT': 'noun', // Punctuation mapped to noun (usually filtered out anyway)
                'SCONJ': 'conjunction',
                'SYM': 'noun', // Symbols mapped to noun
                'VERB': 'verb',
                'X': 'noun' // Miscellaneous defaults to noun
            };
            return mapping[upos] || 'noun';
        }

        /**
         * Context-only UPOS tagging for a single text
         * Returns array of tokens with UPOS tags, confidence, and evidence
         */
        function tagUPOSContextOnly(rawText) {
            if (!rawText || rawText.trim().length === 0) {
                return {
                    language_guess: { code: 'unknown', confidence: 0, method: 'context-only' },
                    tokens: [],
                    notes: ['Empty input']
                };
            }

            // Step 0: Degenerate case
            const nonPunctTokens = tokenizeText(rawText).filter(t => t.upos !== 'PUNCT');
            if (nonPunctTokens.length === 1) {
                const singleToken = nonPunctTokens[0];
                return {
                    language_guess: { code: 'unknown', confidence: 0.3, method: 'context-only' },
                    tokens: [{
                        i: 0,
                        surface: singleToken.surface,
                        norm: singleToken.norm,
                        upos: 'X',
                        confidence: 0.3,
                        evidence: ['Single token input - insufficient context'],
                        spans: singleToken.spans
                    }],
                    notes: ['Single token - defaulting to X']
                };
            }

            // Step 1: Tokenize
            let tokens = tokenizeText(rawText);
            
            // Step 2: Build context statistics
            const contextStats = buildContextStatistics(tokens);
            
            // Step 3-8: Tag tokens iteratively
            tokens = tagTokensIteratively(tokens, contextStats);
            
            // Format output
            return {
                language_guess: { code: 'unknown', confidence: 0.5, method: 'context-only' },
                tokens: tokens.map((t, i) => ({
                    i: i,
                    surface: t.surface,
                    norm: t.norm,
                    upos: t.upos,
                    confidence: t.confidence || 0.5,
                    evidence: t.evidence || [],
                    spans: t.spans
                })),
                notes: []
            };
        }

        /**
         * Step 1: Tokenize text (language-agnostic, separates punctuation)
         */
        function tokenizeText(text) {
            const tokens = [];
            let current = '';
            let charOffset = 0;
            
            // Characters that should split words (act as spaces): / : [ ] \ ( ) , ; # ~ " " ? Â¿ ! Â¡ + { < > Â· Âº Âª *
            // These characters should be treated as word separators (like spaces)
            // NOTE: Apostrophe (') splits words so "I'm" becomes "I" + "m"
            // NOTE: - _ @ are NOT separators - they create compound names
            // NOTE: . (dot) is special: if followed immediately by letters, it's part of compound name (palabra.palabra)
            //       if followed by space or end of text, it acts as separator (palabra.)
            // NOTE: Em dash (â€”) and en dash (â€“) are treated as spaces
            const wordSplitChars = /[\/:\[\]\\\(\),;#~"`"?Â¿!Â¡+\{<>Â·ÂºÂª*'\u2014\u2013]/;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const isPunct = /[^\w\s\u4e00-\u9fff]/.test(char);
                const isWhitespace = /\s/.test(char) || char === '\u2014' || char === '\u2013'; // Include em dash (â€”) and en dash (â€“) as whitespace
                const isSymbol = /[$â‚¬Â£Â¥â‚¹+=\-*\/<>]/.test(char);
                const isDigit = /\d/.test(char);
                const isWordSplitter = wordSplitChars.test(char);
                const isDot = char === '.';
                
                // Special handling for dots
                if (isDot) {
                    // Check if there are letters immediately after the dot (no space)
                    const nextChar = i < text.length - 1 ? text[i + 1] : null;
                    const hasLettersAfter = nextChar && /[a-zA-Z\u4e00-\u9fff]/.test(nextChar);
                    
                    if (hasLettersAfter) {
                        // Dot is part of compound name (palabra.palabra) - include it in current token
                        current += char;
                    } else {
                        // Dot is at end of word (palabra.) - treat as separator
                        if (current.trim()) {
                            tokens.push({
                                surface: current.trim(),
                                norm: current.trim().toLowerCase(),
                                spans: { start: charOffset, end: i }
                            });
                        }
                        // Do NOT create a token for the dot itself - treat as separator
                        current = '';
                        charOffset = i + 1;
                    }
                } else if (isWhitespace) {
                    if (current.trim()) {
                        tokens.push({
                            surface: current.trim(),
                            norm: current.trim().toLowerCase(),
                            spans: { start: charOffset, end: i }
                        });
                        charOffset = i + 1;
                    }
                    current = '';
                } else if (isWordSplitter) {
                    // Word splitting character - treat as separator (don't include in tokens, just split)
                    // This includes punctuation like , ; : ! ? etc. that should act as separators
                    if (current.trim()) {
                        tokens.push({
                            surface: current.trim(),
                            norm: current.trim().toLowerCase(),
                            spans: { start: charOffset, end: i }
                        });
                    }
                    // Do NOT create a token for the punctuation character itself - treat as separator
                    current = '';
                    charOffset = i + 1;
                } else {
                    // All other characters (including - _ @ which create compound names)
                    // These form part of the current word/token
                    current += char;
                }
            }
            
            if (current.trim()) {
                tokens.push({
                    surface: current.trim(),
                    norm: current.trim().toLowerCase(),
                    spans: { start: charOffset, end: text.length }
                });
            }
            
            return tokens;
        }

        /**
         * Tokenize text with splitter characters (alias for tokenizeText)
         * This function applies splitting rules to tokenize text
         */
        function tokenizeWithSplitters(text) {
            return tokenizeText(text);
        }

        /**
         * Step 2: Build context statistics from tokens
         */
        function buildContextStatistics(tokens) {
            const stats = {
                leftContext: new Map(), // token -> Set of left neighbors
                rightContext: new Map(), // token -> Set of right neighbors
                bigrams: new Map(), // "prev norm" -> Map("next norm" -> count)
                trigrams: new Map(),
                positionFeatures: new Map(), // token -> { sentenceInitial: count, afterPunct: count, ... }
                frequencies: new Map(),
                typeCounts: new Map() // normalized form -> count
            };
            
            tokens.forEach((token, i) => {
                const norm = token.norm;
                const prevNorm = i > 0 ? tokens[i - 1].norm : null;
                const nextNorm = i < tokens.length - 1 ? tokens[i + 1].norm : null;
                
                // Frequency
                stats.frequencies.set(norm, (stats.frequencies.get(norm) || 0) + 1);
                stats.typeCounts.set(norm, (stats.typeCounts.get(norm) || 0) + 1);
                
                // Left context
                if (prevNorm) {
                    if (!stats.leftContext.has(norm)) stats.leftContext.set(norm, []);
                    stats.leftContext.get(norm).push(prevNorm);
                }
                
                // Right context
                if (nextNorm) {
                    if (!stats.rightContext.has(norm)) stats.rightContext.set(norm, []);
                    stats.rightContext.get(norm).push(nextNorm);
                }
                
                // Bigrams
                if (prevNorm) {
                    if (!stats.bigrams.has(prevNorm)) stats.bigrams.set(prevNorm, new Map());
                    const nextMap = stats.bigrams.get(prevNorm);
                    nextMap.set(norm, (nextMap.get(norm) || 0) + 1);
                }
                
                // Position features
                if (!stats.positionFeatures.has(norm)) {
                    stats.positionFeatures.set(norm, {
                        sentenceInitial: 0,
                        afterPunct: 0,
                        beforePunct: 0
                    });
                }
                const features = stats.positionFeatures.get(norm);
                if (i === 0 || (i > 0 && /[.!?]/.test(tokens[i - 1].surface))) {
                    features.sentenceInitial++;
                }
                if (prevNorm && /[.!?,;:]/.test(tokens[i - 1].surface)) {
                    features.afterPunct++;
                }
                if (nextNorm && /[.!?,;:]/.test(tokens[i + 1].surface)) {
                    features.beforePunct++;
                }
            });
            
            return stats;
        }

        /**
         * Steps 3-8: Tag tokens iteratively using bootstrapping
         */
        function tagTokensIteratively(tokens, contextStats) {
            // Initialize all tokens
            tokens.forEach(token => {
                token.upos = null;
                token.confidence = 0;
                token.evidence = [];
            });
            
            // Step 3: High-precision anchors
            anchorHighPrecisionTags(tokens, contextStats);
            
            // Step 4-7: Induce categories iteratively (3-8 passes)
            for (let pass = 0; pass < 5; pass++) {
                induceCategoriesFromFrames(tokens, contextStats);
                refineAuxDetection(tokens, contextStats); // Refine AUX detection after each pass
                distinguishPROPNfromNOUN(tokens, contextStats);
                resolveAmbiguities(tokens, contextStats);
            }
            
            // Step 9: Fallback to X for unclassified
            tokens.forEach(token => {
                if (!token.upos) {
                    token.upos = 'X';
                    token.confidence = 0.3;
                    token.evidence = ['Insufficient context to classify'];
                }
            });
            
            return tokens;
        }

        /**
         * Helper function to check if a word is a common auxiliary/modal verb
         * (context-only, no external dictionaries - using common patterns)
         */
        function isAuxiliaryOrModal(norm) {
            // Common auxiliary verbs (English + Spanish patterns)
            // These are high-frequency function verbs that typically precede main verbs
            const auxPatterns = [
                // English auxiliaries
                'be', 'am', 'is', 'are', 'was', 'were', 'been', 'being',
                'have', 'has', 'had', 'having',
                'do', 'does', 'did', 'done', 'doing',
                'will', 'would', 'shall', 'should',
                'can', 'could', 'may', 'might', 'must',
                // Spanish auxiliaries
                'ser', 'estar', 'es', 'son', 'estÃ¡', 'estÃ¡n', 'fue', 'fueron',
                'haber', 'ha', 'han', 'habÃ­a', 'habÃ­an', 'habrÃ¡', 'habrÃ¡n',
                'tener', 'tiene', 'tienen', 'tenÃ­a', 'tenÃ­an',
                'hacer', 'hace', 'hacen', 'hizo', 'hicieron'
            ];
            return auxPatterns.includes(norm);
        }

        /**
         * Step 3: Initialize high-precision anchors
         */
        function anchorHighPrecisionTags(tokens, contextStats) {
            tokens.forEach((token, i) => {
                const surface = token.surface;
                const norm = token.norm;
                
                // PUNCT anchors
                if (/^[.,;:!?()\[\]{}\-â€”â€“"'Â«Â»â€¹â€ºâ€žâ€š`Â´]$/.test(surface)) {
                    token.upos = 'PUNCT';
                    token.confidence = 0.95;
                    token.evidence = ['Pure punctuation character'];
                    return;
                }
                
                // SYM anchors
                if (/^[$â‚¬Â£Â¥â‚¹+=\-*\/<>@#%&]$/.test(surface)) {
                    token.upos = 'SYM';
                    token.confidence = 0.95;
                    token.evidence = ['Symbol character'];
                    return;
                }
                
                // NUM anchors - but these should be PROPN (names), not NUM
                if (/^\d+([.,:/\-]\d+)*$/.test(surface)) {
                    token.upos = 'PROPN';
                    token.confidence = 0.95;
                    token.evidence = ['Pure number - always a name'];
                    return;
                }
                
                // Single letters are always PROPN (names)
                if (surface.length === 1 && /[a-zA-Z]/.test(surface)) {
                    token.upos = 'PROPN';
                    token.confidence = 0.95;
                    token.evidence = ['Single letter - always a name'];
                    return;
                }
                
                // Words containing numbers mixed with letters are PROPN (names)
                // Examples: "h2o", "word123", "r2d2", "hola2hola"
                if (/[0-9]/.test(surface) && /[a-zA-Z]/.test(surface)) {
                    token.upos = 'PROPN';
                    token.confidence = 0.95;
                    token.evidence = ['Word contains numbers - always a name'];
                    return;
                }
                
                // AUX anchors: Common auxiliary/modal verbs
                // Check if it's a known auxiliary pattern AND appears before a verb-like token
                if (isAuxiliaryOrModal(norm)) {
                    const nextToken = i < tokens.length - 1 ? tokens[i + 1] : null;
                    const nextNorm = nextToken ? nextToken.norm : null;
                    
                    // If followed by a likely verb (by pattern or context), tag as AUX
                    // Also tag if sentence-initial or after pronoun (common AUX positions)
                    const prevToken = i > 0 ? tokens[i - 1] : null;
                    const isSentenceInitial = i === 0 || (prevToken && /[.!?]/.test(prevToken.surface));
                    const afterPronoun = prevToken && prevToken.upos === 'PRON';
                    
                    // Check if next token looks verb-like (ends in common verb endings, or we'll tag it later)
                    const looksLikeVerbFollowing = nextNorm && (
                        nextNorm.length > 3 || // Short tokens after AUX are often verbs
                        /(ing|ed|en)$/.test(nextNorm) // Common verb endings
                    );
                    
                    if (looksLikeVerbFollowing || isSentenceInitial || afterPronoun) {
                        token.upos = 'AUX';
                        token.confidence = 0.85;
                        token.evidence = ['Common auxiliary/modal verb pattern'];
                        return;
                    }
                }
            });
        }

        /**
         * Step 4: Induce categories from syntactic frames
         */
        function induceCategoriesFromFrames(tokens, contextStats) {
            // Build candidate sets for each category
            const verbCandidates = new Set();
            const nounCandidates = new Set();
            const adjCandidates = new Set();
            const advCandidates = new Set();
            const auxCandidates = new Set();
            const pronCandidates = new Set();
            const detCandidates = new Set();
            const adpCandidates = new Set();
            const partCandidates = new Set();
            const intjCandidates = new Set();
            const cconjCandidates = new Set();
            const sconjCandidates = new Set();
            
            tokens.forEach((token, i) => {
                if (token.upos) return; // Already tagged
                
                const norm = token.norm;
                const prevToken = i > 0 ? tokens[i - 1] : null;
                const nextToken = i < tokens.length - 1 ? tokens[i + 1] : null;
                const prevNorm = prevToken ? prevToken.norm : null;
                const nextNorm = nextToken ? nextToken.norm : null;
                
                // AUX candidates: Check for auxiliary patterns
                // Pattern: AUX often appears before VERB, after PRON/NOUN, in questions, etc.
                if (isAuxiliaryOrModal(norm) && !token.upos) {
                    // Already checked in anchors, but double-check here for tokens that might be AUX
                    const nextNorm = nextToken ? nextToken.norm : null;
                    const prevNorm = prevToken ? prevToken.norm : null;
                    
                    // If followed by verb-like token or at sentence start
                    if (nextToken && (nextToken.upos === 'VERB' || nextToken.upos === null)) {
                        // Check if next token could be a verb (has verb-like characteristics)
                        const couldBeVerb = !nextToken.upos || nextToken.upos === 'VERB' || 
                                           (nextNorm && nextNorm.length > 2 && !/[.!?]/.test(nextNorm));
                        if (couldBeVerb) {
                            auxCandidates.add(norm);
                        }
                    }
                    // After pronoun/subject, before potential verb
                    if (prevToken && (prevToken.upos === 'PRON' || prevToken.upos === 'NOUN' || prevToken.upos === 'PROPN') &&
                        nextToken && !nextToken.upos) {
                        auxCandidates.add(norm);
                    }
                }
                
                // VERB candidates: PRON/NOUN v (NOUN/ADP/DET/ADV) but NOT if it's an AUX candidate
                if (!isAuxiliaryOrModal(norm)) {
                    if (prevToken && (prevToken.upos === 'PRON' || prevToken.upos === 'NOUN' || prevToken.upos === 'PROPN') &&
                        nextToken && (nextToken.upos === 'NOUN' || nextToken.upos === 'PROPN' || nextToken.upos === 'DET' || nextToken.upos === 'ADP' || nextToken.upos === 'ADV')) {
                        verbCandidates.add(norm);
                    }
                    // After AUX, before object-like tokens
                    if (prevToken && prevToken.upos === 'AUX' &&
                        nextToken && (nextToken.upos === 'NOUN' || nextToken.upos === 'PROPN' || nextToken.upos === 'DET' || nextToken.upos === 'ADP' || nextToken.upos === 'ADV' || !nextToken.upos)) {
                        verbCandidates.add(norm);
                    }
                }
                
                // NOUN candidates: DET/ADP/NUM + n, ADJ + n, coordination lists
                if (prevToken && (prevToken.upos === 'DET' || prevToken.upos === 'ADP' || prevToken.upos === 'NUM')) {
                    nounCandidates.add(norm);
                }
                if (prevToken && prevToken.upos === 'ADJ') {
                    nounCandidates.add(norm);
                }
                if (prevToken && prevToken.upos === 'NOUN' && nextToken && /^[,&]/.test(nextToken.surface)) {
                    nounCandidates.add(norm); // Coordination
                }
                
                // ADJ candidates: ADJ + NOUN pattern
                if (nextToken && (nextToken.upos === 'NOUN' || nextToken.upos === 'PROPN')) {
                    adjCandidates.add(norm);
                }
                
                // ADV candidates: near VERB candidates, modify ADJ
                if ((prevToken && verbCandidates.has(prevNorm)) || (nextToken && verbCandidates.has(nextNorm))) {
                    advCandidates.add(norm);
                }
                if (nextToken && nextToken.upos === 'ADJ') {
                    advCandidates.add(norm);
                }
                
                // DET candidates: frequently precede NOUN, rarely sentence-final
                if (nextToken && (nextToken.upos === 'NOUN' || nounCandidates.has(nextNorm))) {
                    detCandidates.add(norm);
                }
                
                // ADP candidates: frequently precede NOUN/PROPN
                if (nextToken && (nextToken.upos === 'NOUN' || nextToken.upos === 'PROPN' || nounCandidates.has(nextNorm))) {
                    adpCandidates.add(norm);
                }
                
                // PRON candidates: in subject/object slots around verbs
                if ((prevToken && verbCandidates.has(prevNorm)) || (nextToken && verbCandidates.has(nextNorm))) {
                    if (contextStats.frequencies.get(norm) > 2 && norm.length <= 4) {
                        pronCandidates.add(norm);
                    }
                }
            });
            
            // Apply candidates with confidence scores (AUX first, as it's more specific than VERB)
            tokens.forEach(token => {
                if (token.upos) return;
                const norm = token.norm;
                
                // AUX candidates take priority over VERB (more specific category)
                if (auxCandidates.has(norm) || isAuxiliaryOrModal(norm)) {
                    token.upos = 'AUX';
                    token.confidence = 0.75;
                    token.evidence = ['Auxiliary/modal verb patterns'];
                } else if (verbCandidates.has(norm)) {
                    token.upos = 'VERB';
                    token.confidence = 0.7;
                    token.evidence = ['Verb-like frame patterns'];
                } else if (adjCandidates.has(norm)) {
                    // ADJ candidates take priority over NOUN when they modify nouns (more specific pattern)
                    token.upos = 'ADJ';
                    token.confidence = 0.7; // Increased confidence for ADJ to prioritize over NOUN
                    token.evidence = ['Adjective-like patterns (modifies noun)'];
                } else if (nounCandidates.has(norm) && !verbCandidates.has(norm) && !adjCandidates.has(norm)) {
                    token.upos = 'NOUN';
                    token.confidence = 0.7;
                    token.evidence = ['Noun-like frame patterns'];
                } else if (advCandidates.has(norm)) {
                    token.upos = 'ADV';
                    token.confidence = 0.65;
                    token.evidence = ['Adverb-like patterns'];
                } else if (detCandidates.has(norm)) {
                    token.upos = 'DET';
                    token.confidence = 0.7;
                    token.evidence = ['Determiner-like patterns'];
                } else if (adpCandidates.has(norm)) {
                    token.upos = 'ADP';
                    token.confidence = 0.7;
                    token.evidence = ['Adposition-like patterns'];
                } else if (pronCandidates.has(norm)) {
                    token.upos = 'PRON';
                    token.confidence = 0.65;
                    token.evidence = ['Pronoun-like patterns'];
                }
            });
        }

        /**
         * Step 5: Distinguish PROPN from NOUN without capitalization
         */
        function distinguishPROPNfromNOUN(tokens, contextStats) {
            // First, check for names that should NEVER be NOUN:
            // 1. Numbers (already handled in anchors, but double-check)
            // 2. Single letters (already handled in anchors, but double-check)
            // 3. Words with numbers (already handled in anchors, but double-check)
            tokens.forEach((token, i) => {
                const surface = token.surface;
                
                // If already PROPN, don't change it
                if (token.upos === 'PROPN') return;
                
                // Numbers are always PROPN
                if (/^\d+([.,:/\-]\d+)*$/.test(surface)) {
                    token.upos = 'PROPN';
                    token.confidence = 0.95;
                    token.evidence = ['Pure number - always a name'];
                    return;
                }
                
                // Single letters are always PROPN
                if (surface.length === 1 && /[a-zA-Z]/.test(surface)) {
                    token.upos = 'PROPN';
                    token.confidence = 0.95;
                    token.evidence = ['Single letter - always a name'];
                    return;
                }
                
                // Words containing numbers mixed with letters are always PROPN
                if (/[0-9]/.test(surface) && /[a-zA-Z]/.test(surface)) {
                    token.upos = 'PROPN';
                    token.confidence = 0.95;
                    token.evidence = ['Word contains numbers - always a name'];
                    return;
                }
            });
            
            // Find fixed multi-token sequences (likely named entities) - for compound names
            const fixedSequences = new Map();
            for (let i = 0; i < tokens.length - 1; i++) {
                const bigram = tokens[i].norm + ' ' + tokens[i + 1].norm;
                fixedSequences.set(bigram, (fixedSequences.get(bigram) || 0) + 1);
            }
            
            // Find repeated bigrams (likely names)
            const repeatedBigrams = new Set();
            fixedSequences.forEach((count, bigram) => {
                if (count >= 2) {
                    repeatedBigrams.add(bigram);
                }
            });
            
            // Mark tokens in repeated sequences as PROPN (compound names)
            tokens.forEach((token, i) => {
                if (token.upos === 'NOUN' && i < tokens.length - 1) {
                    const bigram = token.norm + ' ' + tokens[i + 1].norm;
                    if (repeatedBigrams.has(bigram)) {
                        token.upos = 'PROPN';
                        token.confidence = Math.min(token.confidence + 0.2, 0.9);
                        if (!token.evidence.some(e => e.includes('repeated'))) {
                            token.evidence.push('Appears in repeated fixed sequence');
                        }
                    }
                }
                
                // Check if token resists determiners (rarely after DET) - names rarely appear after determiners
                if (token.upos === 'NOUN' && i > 0) {
                    const prevTag = tokens[i - 1].upos;
                    const leftContexts = contextStats.leftContext.get(token.norm) || [];
                    const detCount = leftContexts.filter(ctx => {
                        const ctxToken = tokens.find(t => t.norm === ctx);
                        return ctxToken && ctxToken.upos === 'DET';
                    }).length;
                    const totalLeft = leftContexts.length;
                    if (totalLeft > 0 && detCount / totalLeft < 0.2) {
                        // Rarely after determiners - likely a name
                        token.upos = 'PROPN';
                        token.confidence = Math.min(token.confidence + 0.15, 0.85);
                        if (!token.evidence.some(e => e.includes('determiner'))) {
                            token.evidence.push('Rarely appears after determiners');
                        }
                    }
                }
            });
        }

        /**
         * Refine AUX detection: Post-process to catch auxiliary verbs that might have been missed
         */
        function refineAuxDetection(tokens, contextStats) {
            tokens.forEach((token, i) => {
                // If already tagged as AUX or not tagged as VERB, skip
                if (token.upos === 'AUX' || token.upos !== 'VERB') return;
                
                const norm = token.norm;
                
                // If it's a known auxiliary pattern and appears in AUX-like context
                if (isAuxiliaryOrModal(norm)) {
                    const prevToken = i > 0 ? tokens[i - 1] : null;
                    const nextToken = i < tokens.length - 1 ? tokens[i + 1] : null;
                    
                    // Check for AUX patterns:
                    // 1. After pronoun/subject, before another verb or verb-like token
                    const afterSubject = prevToken && (prevToken.upos === 'PRON' || prevToken.upos === 'NOUN' || prevToken.upos === 'PROPN');
                    const beforeVerb = nextToken && (nextToken.upos === 'VERB' || nextToken.upos === 'AUX' || 
                                                     (nextToken.upos === null && nextToken.norm.length > 2));
                    
                    // 2. Sentence initial followed by verb-like token
                    const isSentenceStart = i === 0 || (prevToken && /[.!?]/.test(prevToken.surface));
                    
                    // 3. In question patterns (before pronoun/wh-word)
                    const beforePronoun = nextToken && nextToken.upos === 'PRON';
                    
                    if ((afterSubject && beforeVerb) || (isSentenceStart && beforeVerb) || (afterSubject && beforePronoun)) {
                        token.upos = 'AUX';
                        token.confidence = 0.8;
                        if (!token.evidence.some(e => e.includes('auxiliary'))) {
                            token.evidence.push('Auxiliary verb pattern in context');
                        }
                    }
                }
                
                // Also check: if VERB appears between AUX and another verb-like token, it might be AUX
                if (prevToken && prevToken.upos === 'AUX' && nextToken && 
                    (nextToken.upos === 'VERB' || nextToken.upos === 'AUX' || 
                     (nextToken.upos === null && !/[.!?]/.test(nextToken.surface)))) {
                    // This is likely a main verb, not AUX, so keep as VERB
                    // But if it's a known auxiliary pattern, reconsider
                    if (isAuxiliaryOrModal(norm)) {
                        // Might be a chain of auxiliaries (e.g., "have been", "will have")
                        token.upos = 'AUX';
                        token.confidence = 0.75;
                        if (!token.evidence.some(e => e.includes('auxiliary'))) {
                            token.evidence.push('Auxiliary chain pattern');
                        }
                    }
                }
            });
        }

        /**
         * Steps 6-7: Resolve ambiguities (CCONJ vs SCONJ, ADP vs SCONJ vs PART)
         */
        function resolveAmbiguities(tokens, contextStats) {
            tokens.forEach((token, i) => {
                if (!token.upos || token.upos === 'X') return;
                
                const nextToken = i < tokens.length - 1 ? tokens[i + 1] : null;
                
                // CCONJ vs SCONJ: CCONJ links like constituents, SCONJ introduces clauses
                if (token.upos === 'CCONJ' || token.upos === 'SCONJ') {
                    // Look ahead for verb to distinguish
                    let foundVerb = false;
                    for (let j = i + 1; j < Math.min(i + 5, tokens.length); j++) {
                        if (tokens[j].upos === 'VERB' || tokens[j].upos === 'AUX') {
                            foundVerb = true;
                            break;
                        }
                    }
                    if (foundVerb && nextToken && (nextToken.upos === 'PRON' || nextToken.upos === 'DET')) {
                        token.upos = 'SCONJ';
                        if (!token.evidence.some(e => e.includes('clause'))) {
                            token.evidence.push('Introduces clause-like structure');
                        }
                    } else if (token.upos === 'SCONJ') {
                        token.upos = 'CCONJ';
                        if (!token.evidence.some(e => e.includes('coordination'))) {
                            token.evidence.push('Links like constituents');
                        }
                    }
                }
                
                // ADP vs SCONJ: ADP followed by NOUN, SCONJ followed by clause
                if (token.upos === 'ADP' && nextToken && (nextToken.upos === 'VERB' || nextToken.upos === 'AUX')) {
                    // Check if there's a NOUN/PROPN before the verb
                    let hasNounBefore = false;
                    for (let j = i + 1; j < Math.min(i + 4, tokens.length); j++) {
                        if (tokens[j].upos === 'NOUN' || tokens[j].upos === 'PROPN') {
                            hasNounBefore = true;
                            break;
                        }
                        if (tokens[j].upos === 'VERB' || tokens[j].upos === 'AUX') break;
                    }
                    if (!hasNounBefore) {
                        token.upos = 'SCONJ';
                        if (!token.evidence.some(e => e.includes('clause'))) {
                            token.evidence.push('Followed by clause structure');
                        }
                    }
                }
            });
        }

        /**
         * Helper function to check if a word is likely an auxiliary or modal verb
         * This can be used by the value system or other parts of the codebase
         * @param {string} word - The word to check (will be normalized to lowercase)
         * @returns {boolean} True if the word matches auxiliary/modal verb patterns
         */
        function isAuxiliaryOrModalVerb(word) {
            if (!word) return false;
            const norm = word.toLowerCase().replace(/[^\w\u4e00-\u9fff]/g, '');
            return isAuxiliaryOrModal(norm);
        }

        /**
         * Check if a word is a "to be" verb (am, is, are, was, were, be, been, being)
         * Also checks for contractions and separated contractions
         * @param {string} word - The word to check
         * @param {Object|null} prevToken - Previous token object with surface property (for separated contractions)
         * @returns {boolean} - True if the word is a "to be" verb
         */
        function isToBeVerb(word, prevToken) {
            if (!word) return false;
            
            const cleanWord = word.toLowerCase().trim();
            const toBeVerbs = ['am', 'is', 'are', 'was', 'were', 'be', 'been', 'being'];
            
            // Direct match with "to be" verbs
            if (toBeVerbs.includes(cleanWord)) {
                return true;
            }
            
            // Check for contractions: it's, he's, she's, that's, what's, who's (where 's = "is")
            if (cleanWord.endsWith("'s")) {
                const base = cleanWord.split("'")[0];
                if (['it', 'he', 'she', 'that', 'this', 'what', 'who'].includes(base)) {
                    return true;
                }
            }
            
            // Check for contractions: we're, you're, they're (where 're = "are")
            if (cleanWord.endsWith("'re")) {
                const base = cleanWord.split("'")[0];
                if (['we', 'you', 'they'].includes(base)) {
                    return true;
                }
            }
            
            // Check for contractions: I'm (where 'm = "am")
            if (cleanWord.endsWith("'m")) {
                const base = cleanWord.split("'")[0];
                if (base === 'i') {
                    return true;
                }
            }
            
            // Check for separated contractions: "m" after "I", "s" after "it"/"he"/"she", "re" after "we"/"you"/"they"
            if (prevToken && prevToken.surface) {
                const prevSurface = prevToken.surface.toLowerCase().trim();
                
                if (cleanWord === 'm' && prevSurface === 'i') {
                    return true; // "I" + "m" = "I am"
                }
                
                if (cleanWord === 's' && ['it', 'he', 'she', 'that', 'this', 'what', 'who'].includes(prevSurface)) {
                    return true; // "it" + "s" = "it is"
                }
                
                if (cleanWord === 're' && ['we', 'you', 'they'].includes(prevSurface)) {
                    return true; // "we" + "re" = "we are"
                }
            }
            
            return false;
        }

        /**
         * Wrapper function to get POS tag using context-only UPOS system
         * This processes the full text context and maps UPOS to legacy POS tags
         * for compatibility with the value system.
         * 
         * Usage: Call this instead of getPOS when you want context-only tagging
         * without capitalization or external dictionaries.
         */
        function getPOSFromUPOS(fullText, wordIndex) {
            try {
                const uposResult = tagUPOSContextOnly(fullText);
                if (uposResult.tokens && uposResult.tokens.length > wordIndex) {
                    const token = uposResult.tokens[wordIndex];
                    const legacyPOS = mapUPOStoLegacyPOS(token.upos);
                    return legacyPOS;
                }
            } catch (error) {
                console.warn('UPOS tagging failed, falling back to default:', error);
            }
            return 'noun'; // Fallback
        }

        /**
         * Alternative analyzeText function using context-only UPOS tagging
         * This can be used as a drop-in replacement that uses the new architecture
         */
        function analyzeTextWithUPOS(text) {
            // This would replace the existing analyzeText function's POS tagging logic
            // For now, it's provided as reference implementation
            const uposResult = tagUPOSContextOnly(text);
            const words = splitTextIntoWords(text);
            
            // Map UPOS results to analyzedWords format
            // (This is a simplified version - the full implementation would need
            //  to handle word alignment between splitTextIntoWords and tokenizeText)
            return uposResult.tokens.map((token, i) => {
                const legacyPOS = mapUPOStoLegacyPOS(token.upos);
                return {
                    text: token.surface,
                    pos: legacyPOS,
                    upos: token.upos, // Store original UPOS tag too
                    confidence: token.confidence,
                    evidence: token.evidence,
                    // Other fields would be calculated as in original analyzeText
                };
            });
        }

        function getPOS(word, context) {
            // context = { prevWord: string, nextWord: string, index: number, allWords: array }
            // IMPORTANT: Capitalization is NOT used as a signal - all words treated as lowercase
            
            // Check if word contains numbers inside it (mixed with letters) - these are "other"
            const hasNumbersInside = /[0-9]/.test(word) && /[a-zA-Z\u4e00-\u9fff]/.test(word);
            if (hasNumbersInside) {
                return 'other'; // Word with numbers inside (like "h2o", "word123") = other
            }
            
            // Auxiliaries / modals: treat as verbs (legacy mapping)
            if (isAuxiliaryOrModal(word.toLowerCase())) {
                return 'verb';
            }
            
            // Check if word is only numbers (digits and separators like . - / etc)
            const isOnlyNumbers = /^[0-9]+([.,:/\-][0-9]+)*$/.test(word.trim());
            if (isOnlyNumbers) {
                return 'number'; // Pure number sequence = number
            }
            
            const cleanWord = word.replace(/[^\w\u4e00-\u9fff]/g, '').toLowerCase();
            
            // FIRST: Check if it's a known proper noun (like "Carbajal") - these are always nouns (case-insensitive)
            // Note: This uses a database lookup, not capitalization patterns
            if (KNOWN_PROPER_NOUNS.has(cleanWord) || KNOWN_PROPER_NOUNS_LOWER.has(cleanWord)) {
                return 'noun';
            }
            
            // Verificar si contiene caracteres chinos
            const hasChinese = /[\u4e00-\u9fff]/.test(cleanWord);
            
            if (hasChinese) {
                return classifyChineseCharacter(cleanWord);
            } else {
                return classifyLatinWord(cleanWord, context);
            }
        }

        function classifyChineseCharacter(char) {
            const chinesePOS = {
                'äºº': 'noun', 'å¤©': 'noun', 'åœ°': 'noun', 'æ°´': 'noun', 'ç«': 'noun',
                'æ˜¯': 'verb', 'æœ‰': 'verb', 'åœ¨': 'verb', 'æ¥': 'verb', 'åŽ»': 'verb',
                'å¤§': 'adjective', 'å°': 'adjective', 'å¥½': 'adjective', 'å': 'adjective',
                'å¾ˆ': 'adverb', 'å¤ª': 'adverb', 'éžå¸¸': 'adverb'
            };
            
            return chinesePOS[char] || 'noun';
        }

        // Helper function to use compromise for POS tagging
        function getPOSWithCompromise(word, context) {
            try {
                // Check if compromise is available
                if (typeof nlp === 'undefined' || !nlp) {
                    return null;
                }

                // Build a small context sentence for better accuracy
                const prevWord = context?.prevWord ? context.prevWord.replace(/[^\w\u4e00-\u9fff]/g, '') : '';
                const nextWord = context?.nextWord ? context.nextWord.replace(/[^\w\u4e00-\u9fff]/g, '') : '';

                // Create a context sentence for better tagging (use original word with context)
                let contextSentence = '';
                if (prevWord) contextSentence += prevWord + ' ';
                // Use original word if available from context, otherwise use the cleaned word
                const originalWord = context?.allWords?.[context?.index] || word;
                contextSentence += originalWord;
                if (nextWord) contextSentence += ' ' + nextWord;

                // Use compromise to tag the word in context
                const doc = nlp(contextSentence);
                const terms = doc.terms();

                // Find the term that matches our word
                const wordClean = word.toLowerCase().replace(/[^\w\u4e00-\u9fff]/g, '');

                for (let i = 0; i < terms.length; i++) {
                    const term = terms[i];
                    const termText = term.text().toLowerCase().replace(/[^\w\u4e00-\u9fff]/g, '');

                    // Check if this term matches our word
                    if (termText === wordClean) {
                        const tags = term.tags();

                        // Priority order for tag mapping (most specific first)
                        // Check for proper nouns/names first
                        if (tags.some(t => t === 'Person' || t === 'Place' || t === 'Organization' || t === 'ProperNoun')) {
                            return 'noun';
                        }
                        // Check for nouns
                        if (tags.some(t => t.startsWith('Noun') || t === 'Singular' || t === 'Plural')) {
                            return 'noun';
                        }
                        // Check for verbs
                        if (tags.some(t => t.startsWith('Verb') || t === 'PresentTense' || t === 'PastTense' || t === 'Gerund' || t === 'Infinitive')) {
                            return 'verb';
                        }
                        // Check for adjectives
                        if (tags.some(t => t.startsWith('Adjective') || t === 'Comparative' || t === 'Superlative')) {
                            return 'adjective';
                        }
                        // Check for adverbs
                        if (tags.some(t => t.startsWith('Adverb'))) {
                            return 'adverb';
                        }
                        // Check for pronouns
                        if (tags.some(t => t.startsWith('Pronoun') || t === 'Possessive' || t === 'PersonalPronoun' || t === 'Reflexive')) {
                            return 'pronoun';
                        }
                        // Check for determiners
                        if (tags.some(t => t.startsWith('Determiner') || t === 'Article' || t === 'DefiniteArticle' || t === 'IndefiniteArticle')) {
                            return 'determiner';
                        }
                        // Check for prepositions
                        if (tags.some(t => t.startsWith('Preposition'))) {
                            return 'preposition';
                        }
                        // Check for conjunctions
                        if (tags.some(t => t.startsWith('Conjunction') || t === 'CoordinatingConjunction' || t === 'SubordinatingConjunction')) {
                            return 'conjunction';
                        }
                        // Check for interjections
                        if (tags.some(t => t === 'Interjection' || t === 'Exclamation')) {
                            return 'interjection';
                        }

                        // If we have tags but none matched, try to infer from the first tag
                        if (tags.length > 0) {
                            const firstTag = tags[0];
                            if (firstTag.includes('Noun') || firstTag.includes('Person') || firstTag.includes('Place')) return 'noun';
                            if (firstTag.includes('Verb')) return 'verb';
                            if (firstTag.includes('Adjective')) return 'adjective';
                            if (firstTag.includes('Adverb')) return 'adverb';
                            if (firstTag.includes('Pronoun')) return 'pronoun';
                            if (firstTag.includes('Determiner') || firstTag.includes('Article')) return 'determiner';
                            if (firstTag.includes('Preposition')) return 'preposition';
                            if (firstTag.includes('Conjunction')) return 'conjunction';
                            if (firstTag.includes('Interjection')) return 'interjection';
                        }
                    }
                }

                // Fallback: try to tag just the word alone
                try {
                    const singleDoc = nlp(originalWord || word);
                    const singleTerms = singleDoc.terms();
                    if (singleTerms.length > 0) {
                        const tags = singleTerms[0].tags();
                        if (tags.some(t => t.startsWith('Noun') || t === 'Person' || t === 'Place')) return 'noun';
                        if (tags.some(t => t.startsWith('Verb'))) return 'verb';
                        if (tags.some(t => t.startsWith('Adjective'))) return 'adjective';
                        if (tags.some(t => t.startsWith('Adverb'))) return 'adverb';
                        if (tags.some(t => t.startsWith('Pronoun'))) return 'pronoun';
                        if (tags.some(t => t.startsWith('Determiner') || t === 'Article')) return 'determiner';
                        if (tags.some(t => t.startsWith('Preposition'))) return 'preposition';
                        if (tags.some(t => t.startsWith('Conjunction'))) return 'conjunction';
                        if (tags.some(t => t === 'Interjection')) return 'interjection';
                    }
                } catch (e2) {
                    // Ignore single word tagging errors
                }
            } catch (e) {
                // If compromise fails, return null to use fallback
                console.warn('Compromise tagging failed for word:', word, e);
            }
            return null;
        }

        function classifyLatinWord(word, context) {
            // context = { prevWord: string, nextWord: string, index: number, allWords: array }
            const prevWord = context?.prevWord ? context.prevWord.replace(/[^\w\u4e00-\u9fff]/g, '').toLowerCase() : '';
            const nextWord = context?.nextWord ? context.nextWord.replace(/[^\w\u4e00-\u9fff]/g, '').toLowerCase() : '';
            
            // Early check: auxiliaries / modals are verbs in legacy system
            if (isAuxiliaryOrModal(word)) {
                return 'verb';
            }
            
            // Most common English verbs (based on frequency lists)
            const commonVerbs = new Set([
                // Most frequent English verbs
                'have', 'has', 'had', 'having', 'do', 'does', 'did', 'done', 'doing', 'say', 'says', 'said', 'saying',
                'go', 'goes', 'went', 'gone', 'going', 'get', 'gets', 'got', 'gotten', 'getting', 'make', 'makes', 'made', 'making',
                'know', 'knows', 'knew', 'known', 'knowing', 'think', 'thinks', 'thought', 'thinking', 'take', 'takes', 'took', 'taken', 'taking',
                'see', 'sees', 'saw', 'seen', 'seeing', 'come', 'comes', 'came', 'coming', 'want', 'wants', 'wanted', 'wanting',
                'use', 'uses', 'used', 'using', 'find', 'finds', 'found', 'finding', 'give', 'gives', 'gave', 'given', 'giving',
                'tell', 'tells', 'told', 'telling', 'work', 'works', 'worked', 'working', 'call', 'calls', 'called', 'calling',
                'try', 'tries', 'tried', 'trying', 'ask', 'asks', 'asked', 'asking', 'need', 'needs', 'needed', 'needing',
                'feel', 'feels', 'felt', 'feeling', 'become', 'becomes', 'became', 'become', 'becoming', 'leave', 'leaves', 'left', 'leaving',
                'put', 'puts', 'putting', 'mean', 'means', 'meant', 'meaning', 'keep', 'keeps', 'kept', 'keeping',
                'let', 'lets', 'letting', 'begin', 'begins', 'began', 'begun', 'beginning', 'seem', 'seems', 'seemed', 'seeming',
                'help', 'helps', 'helped', 'helping', 'talk', 'talks', 'talked', 'talking', 'turn', 'turns', 'turned', 'turning',
                'start', 'starts', 'started', 'starting', 'show', 'shows', 'showed', 'shown', 'showing', 'hear', 'hears', 'heard', 'hearing',
                'play', 'plays', 'played', 'playing', 'run', 'runs', 'ran', 'running', 'move', 'moves', 'moved', 'moving',
                'like', 'likes', 'liked', 'liking', 'live', 'lives', 'lived', 'living', 'believe', 'believes', 'believed', 'believing',
                'hold', 'holds', 'held', 'holding', 'bring', 'brings', 'brought', 'bringing', 'happen', 'happens', 'happened', 'happening',
                'write', 'writes', 'wrote', 'written', 'writing', 'sit', 'sits', 'sat', 'sitting', 'stand', 'stands', 'stood', 'standing',
                'lose', 'loses', 'lost', 'losing', 'pay', 'pays', 'paid', 'paying', 'meet', 'meets', 'met', 'meeting',
                'include', 'includes', 'included', 'including', 'continue', 'continues', 'continued', 'continuing', 'set', 'sets', 'setting',
                'learn', 'learns', 'learned', 'learnt', 'learning', 'change', 'changes', 'changed', 'changing', 'lead', 'leads', 'led', 'leading',
                'understand', 'understands', 'understood', 'understanding', 'watch', 'watches', 'watched', 'watching', 'follow', 'follows', 'followed', 'following',
                'stop', 'stops', 'stopped', 'stopping', 'create', 'creates', 'created', 'creating', 'speak', 'speaks', 'spoke', 'spoken', 'speaking',
                'read', 'reads', 'reading', 'spend', 'spends', 'spent', 'spending', 'grow', 'grows', 'grew', 'grown', 'growing',
                'open', 'opens', 'opened', 'opening', 'walk', 'walks', 'walked', 'walking', 'win', 'wins', 'won', 'winning',
                'teach', 'teaches', 'taught', 'teaching', 'offer', 'offers', 'offered', 'offering', 'remember', 'remembers', 'remembered', 'remembering',
                'love', 'loves', 'loved', 'loving', 'consider', 'considers', 'considered', 'considering', 'appear', 'appears', 'appeared', 'appearing',
                'buy', 'buys', 'bought', 'buying', 'serve', 'serves', 'served', 'serving', 'die', 'dies', 'died', 'dying',
                'send', 'sends', 'sent', 'sending', 'build', 'builds', 'built', 'building', 'stay', 'stays', 'stayed', 'staying',
                'fall', 'falls', 'fell', 'fallen', 'falling', 'cut', 'cuts', 'cutting', 'reach', 'reaches', 'reached', 'reaching',
                'kill', 'kills', 'killed', 'killing', 'raise', 'raises', 'raised', 'raising', 'pass', 'passes', 'passed', 'passing',
                'sell', 'sells', 'sold', 'selling', 'decide', 'decides', 'decided', 'deciding', 'return', 'returns', 'returned', 'returning',
                'explain', 'explains', 'explained', 'explaining', 'develop', 'develops', 'developed', 'developing', 'carry', 'carries', 'carried', 'carrying',
                'break', 'breaks', 'broke', 'broken', 'breaking', 'receive', 'receives', 'received', 'receiving', 'agree', 'agrees', 'agreed', 'agreeing',
                'support', 'supports', 'supported', 'supporting', 'hit', 'hits', 'hitting', 'produce', 'produces', 'produced', 'producing',
                'eat', 'eats', 'ate', 'eaten', 'eating', 'cover', 'covers', 'covered', 'covering', 'catch', 'catches', 'caught', 'catching',
                'draw', 'draws', 'drew', 'drawn', 'drawing', 'choose', 'chooses', 'chose', 'chosen', 'choosing'
            ]);
            
            // Most common Spanish verbs
            const commonSpanishVerbs = new Set([
                'ser', 'estar', 'haber', 'tener', 'hacer', 'poder', 'decir', 'ir', 'ver', 'dar', 'saber', 'querer',
                'llegar', 'pasar', 'deber', 'poner', 'parecer', 'quedar', 'hablar', 'llevar', 'dejar', 'seguir',
                'encontrar', 'llamar', 'venir', 'pensar', 'salir', 'volver', 'tomar', 'conocer', 'vivir', 'sentir',
                'tratar', 'mirar', 'contar', 'empezar', 'esperar', 'buscar', 'existir', 'entrar', 'trabajar',
                'escribir', 'perder', 'producir', 'ocurrir', 'entender', 'pedir', 'recibir', 'recordar', 'terminar',
                'permitir', 'aparecer', 'conseguir', 'comenzar', 'servir', 'sacar', 'necesitar', 'mantener',
                'resultar', 'leer', 'caer', 'cambiar', 'presentar', 'crear', 'abrir', 'considerar', 'oÃ­r', 'acabar',
                'convertir', 'ganar', 'formar', 'traer', 'partir', 'morir', 'aceptar', 'realizar', 'suponer',
                'comprender', 'lograr', 'explicar', 'preguntar', 'tocar', 'reconocer', 'estudiar', 'alcanzar',
                'nacer', 'dirigir', 'correr', 'utilizar', 'pagar', 'ayudar', 'gustar', 'jugar', 'escuchar',
                'cumplir', 'ofrecer', 'descubrir', 'levantar', 'intentar', 'usar', 'decidir', 'reducir', 'establecer',
                'es', 'son', 'estÃ¡', 'estÃ¡n', 'fue', 'fueron', 'estuvo', 'estuvieron', 'tiene', 'tienen', 'tenÃ­a', 'tenÃ­an',
                'hace', 'hacen', 'hizo', 'hicieron', 'puede', 'pueden', 'pudo', 'pudieron', 'dice', 'dicen', 'dijo', 'dijeron',
                'va', 'van', 'fue', 'fueron', 've', 'ven', 'vio', 'vieron', 'da', 'dan', 'dio', 'dieron', 'sabe', 'saben',
                'sabÃ­a', 'sabÃ­an', 'quiere', 'quieren', 'quiso', 'quisieron', 'llega', 'llegan', 'llegÃ³', 'llegaron',
                'pasa', 'pasan', 'pasÃ³', 'pasaron', 'debe', 'deben', 'debiÃ³', 'debieron', 'pone', 'ponen', 'puso', 'pusieron',
                'parece', 'parecen', 'pareciÃ³', 'parecieron', 'queda', 'quedan', 'quedÃ³', 'quedaron', 'habla', 'hablan',
                'hablÃ³', 'hablaron', 'lleva', 'llevan', 'llevÃ³', 'llevaron', 'deja', 'dejan', 'dejÃ³', 'dejaron',
                'sigue', 'siguen', 'siguiÃ³', 'siguieron', 'encuentra', 'encuentran', 'encontrÃ³', 'encontraron',
                'llama', 'llaman', 'llamÃ³', 'llamaron', 'viene', 'vienen', 'vino', 'vinieron', 'piensa', 'piensan',
                'pensÃ³', 'pensaron', 'sale', 'salen', 'saliÃ³', 'salieron', 'vuelve', 'vuelven', 'volviÃ³', 'volvieron',
                'toma', 'toman', 'tomÃ³', 'tomaron', 'conoce', 'conocen', 'conociÃ³', 'conocieron', 'vive', 'viven',
                'viviÃ³', 'vivieron', 'siente', 'sienten', 'sintiÃ³', 'sintieron', 'trata', 'tratan', 'tratÃ³', 'trataron',
                'mira', 'miran', 'mirÃ³', 'miraron', 'cuenta', 'cuentan', 'contÃ³', 'contaron', 'empieza', 'empiezan',
                'empezÃ³', 'empezaron', 'espera', 'esperan', 'esperÃ³', 'esperaron', 'busca', 'buscan', 'buscÃ³', 'buscaron',
                'existe', 'existen', 'existiÃ³', 'existieron', 'entra', 'entran', 'entrÃ³', 'entraron', 'trabaja', 'trabajan',
                'trabajÃ³', 'trabajaron', 'escribe', 'escriben', 'escribiÃ³', 'escribieron', 'pierde', 'pierden', 'perdiÃ³', 'perdieron',
                'produce', 'producen', 'produjo', 'produjeron', 'ocurre', 'ocurren', 'ocurriÃ³', 'ocurrieron',
                'entiende', 'entienden', 'entendiÃ³', 'entendieron', 'pide', 'piden', 'pidiÃ³', 'pidieron',
                'recibe', 'reciben', 'recibiÃ³', 'recibieron', 'recuerda', 'recuerdan', 'recordÃ³', 'recordaron',
                'termina', 'terminan', 'terminÃ³', 'terminaron', 'permite', 'permiten', 'permitiÃ³', 'permitieron',
                'aparece', 'aparecen', 'apareciÃ³', 'aparecieron', 'consigue', 'consiguen', 'consiguiÃ³', 'consiguieron',
                'comienza', 'comienzan', 'comenzÃ³', 'comenzaron', 'sirve', 'sirven', 'sirviÃ³', 'sirvieron',
                'saca', 'sacan', 'sacÃ³', 'sacaron', 'necesita', 'necesitan', 'necesitÃ³', 'necesitaron',
                'mantiene', 'mantienen', 'mantuvo', 'mantuvieron', 'resulta', 'resultan', 'resultÃ³', 'resultaron',
                'lee', 'leen', 'leyÃ³', 'leyeron', 'cae', 'caen', 'cayÃ³', 'cayeron', 'cambia', 'cambian', 'cambiÃ³', 'cambiaron',
                'presenta', 'presentan', 'presentÃ³', 'presentaron', 'crea', 'crean', 'creÃ³', 'crearon',
                'abre', 'abren', 'abriÃ³', 'abrieron', 'considera', 'consideran', 'considerÃ³', 'consideraron',
                'oye', 'oyen', 'oyÃ³', 'oyeron', 'acaba', 'acaban', 'acabÃ³', 'acabaron', 'convierte', 'convierten',
                'convirtiÃ³', 'convirtieron', 'gana', 'ganan', 'ganÃ³', 'ganaron', 'forma', 'forman', 'formÃ³', 'formaron',
                'trae', 'traen', 'trajo', 'trajeron', 'parte', 'parten', 'partiÃ³', 'partieron', 'muere', 'mueren',
                'muriÃ³', 'murieron', 'acepta', 'aceptan', 'aceptÃ³', 'aceptaron', 'realiza', 'realizan', 'realizÃ³', 'realizaron',
                'supone', 'suponen', 'supuso', 'supusieron', 'comprende', 'comprenden', 'comprendiÃ³', 'comprendieron',
                'logra', 'logran', 'logrÃ³', 'lograron', 'explica', 'explican', 'explicÃ³', 'explicaron',
                'pregunta', 'preguntan', 'preguntÃ³', 'preguntaron', 'toca', 'tocan', 'tocÃ³', 'tocaron',
                'reconoce', 'reconocen', 'reconociÃ³', 'reconocieron', 'estudia', 'estudian', 'estudiÃ³', 'estudiaron',
                'alcanza', 'alcanzan', 'alcanzÃ³', 'alcanzaron', 'nace', 'nacen', 'naciÃ³', 'nacieron',
                'dirige', 'dirigen', 'dirigiÃ³', 'dirigieron', 'corre', 'corren', 'corriÃ³', 'corrieron',
                'utiliza', 'utilizan', 'utilizÃ³', 'utilizaron', 'paga', 'pagan', 'pagÃ³', 'pagaron',
                'ayuda', 'ayudan', 'ayudÃ³', 'ayudaron', 'gusta', 'gustan', 'gustÃ³', 'gustaron',
                'juega', 'juegan', 'jugÃ³', 'jugaron', 'escucha', 'escuchan', 'escuchÃ³', 'escucharon',
                'cumple', 'cumplen', 'cumpliÃ³', 'cumplieron', 'ofrece', 'ofrecen', 'ofreciÃ³', 'ofrecieron',
                'descubre', 'descubren', 'descubriÃ³', 'descubrieron', 'levanta', 'levantan', 'levantÃ³', 'levantaron',
                'intenta', 'intentan', 'intentÃ³', 'intentaron', 'usa', 'usan', 'usÃ³', 'usaron',
                'decide', 'deciden', 'decidiÃ³', 'decidieron', 'reduce', 'reducen', 'redujo', 'redujeron',
                'establece', 'establecen', 'estableciÃ³', 'establecieron', 'siendo', 'estando', 'habiendo',
                'teniendo', 'haciendo', 'pudiendo', 'diciendo', 'yendo', 'viendo', 'dando', 'sabiendo',
                'queriendo', 'llegando', 'pasando', 'debiendo', 'poniendo', 'pareciendo', 'quedando',
                'hablando', 'llevando', 'dejando', 'siguiendo', 'encontrando', 'llamando', 'viniendo',
                'pensando', 'saliendo', 'volviendo', 'tomando', 'conociendo', 'viviendo', 'sintiendo',
                'tratando', 'mirando', 'contando', 'empezando', 'esperando', 'buscando', 'existiendo',
                'entrando', 'trabajando', 'escribiendo', 'perdiendo', 'produciendo', 'ocurriendo',
                'entendiendo', 'pidiendo', 'recibiendo', 'recordando', 'terminando', 'permitiendo',
                'apareciendo', 'consiguiendo', 'comenzando', 'sirviendo', 'sacando', 'necesitando',
                'manteniendo', 'resultando', 'leyendo', 'cayendo', 'cambiando', 'presentando',
                'creando', 'abriendo', 'considerando', 'oyendo', 'acabando', 'convirtiendo',
                'ganando', 'formando', 'trayendo', 'partiendo', 'muriendo', 'aceptando',
                'realizando', 'suponiendo', 'comprendiendo', 'logrando', 'explicando', 'preguntando',
                'tocando', 'reconociendo', 'estudiando', 'alcanzando', 'naciendo', 'dirigiendo',
                'corriendo', 'utilizando', 'pagando', 'ayudando', 'gustando', 'jugando', 'escuchando',
                'cumpliendo', 'ofreciendo', 'descubriendo', 'levantando', 'intentando', 'usando',
                'decidiendo', 'reduciendo', 'estableciendo'
            ]);
            
            // Check if it's a common verb first (most reliable for verbs)
            if (commonVerbs.has(word) || commonSpanishVerbs.has(word)) {
                return 'verb';
            }
            
            // Expanded common words dictionary (most reliable classification)
            const commonWords = {
                // Determiners
                'the': 'determiner', 'a': 'determiner', 'an': 'determiner', 'this': 'determiner',
                'that': 'determiner', 'these': 'determiner', 'those': 'determiner', 'some': 'determiner',
                'any': 'determiner', 'each': 'determiner', 'every': 'determiner', 'all': 'determiner',
                'both': 'determiner', 'few': 'determiner', 'many': 'determiner', 'most': 'determiner',
                'other': 'determiner', 'another': 'determiner', 'such': 'determiner', 'what': 'determiner',
                'which': 'determiner', 'whose': 'determiner', 'el': 'determiner', 'la': 'determiner',
                'los': 'determiner', 'las': 'determiner', 'un': 'determiner', 'una': 'determiner',
                'unos': 'determiner', 'unas': 'determiner', 'este': 'determiner', 'esta': 'determiner',
                'estos': 'determiner', 'estas': 'determiner', 'ese': 'determiner', 'esa': 'determiner',
                'esos': 'determiner', 'esas': 'determiner', 'aquel': 'determiner', 'aquella': 'determiner',
                'aquellos': 'determiner', 'aquellas': 'determiner', 'mucho': 'determiner', 'mucha': 'determiner',
                'muchos': 'determiner', 'muchas': 'determiner', 'poco': 'determiner', 'poca': 'determiner',
                'pocos': 'determiner', 'pocas': 'determiner', 'todo': 'determiner', 'toda': 'determiner',
                'todos': 'determiner', 'todas': 'determiner', 'algÃºn': 'determiner', 'alguna': 'determiner',
                'algunos': 'determiner', 'algunas': 'determiner', 'ningÃºn': 'determiner', 'ninguna': 'determiner',
                'ningunos': 'determiner', 'ningunas': 'determiner',
                // Conjunctions
                'and': 'conjunction', 'or': 'conjunction', 'but': 'conjunction', 'nor': 'conjunction',
                'for': 'conjunction', 'so': 'conjunction', 'yet': 'conjunction', 'because': 'conjunction',
                'if': 'conjunction', 'although': 'conjunction', 'though': 'conjunction', 'while': 'conjunction',
                'since': 'conjunction', 'until': 'conjunction', 'unless': 'conjunction', 'when': 'conjunction',
                'where': 'conjunction', 'as': 'conjunction', 'than': 'conjunction', 'y': 'conjunction',
                'o': 'conjunction', 'u': 'conjunction', 'pero': 'conjunction', 'mas': 'conjunction',
                'sino': 'conjunction', 'aunque': 'conjunction', 'a pesar de': 'conjunction',
                'sin embargo': 'conjunction', 'no obstante': 'conjunction', 'porque': 'conjunction',
                'pues': 'conjunction', 'puesto que': 'conjunction', 'ya que': 'conjunction',
                'si': 'conjunction', 'como': 'conjunction', 'cuando': 'conjunction', 'donde': 'conjunction',
                'mientras': 'conjunction', 'mientras que': 'conjunction', 'antes de que': 'conjunction',
                'despuÃ©s de que': 'conjunction', 'hasta que': 'conjunction', 'desde que': 'conjunction',
                // Prepositions
                'in': 'preposition', 'on': 'preposition', 'at': 'preposition', 'to': 'preposition',
                'of': 'preposition', 'for': 'preposition', 'with': 'preposition', 'from': 'preposition',
                'by': 'preposition', 'about': 'preposition', 'into': 'preposition', 'onto': 'preposition',
                'upon': 'preposition', 'over': 'preposition', 'under': 'preposition', 'above': 'preposition',
                'below': 'preposition', 'between': 'preposition', 'among': 'preposition', 'through': 'preposition',
                'during': 'preposition', 'before': 'preposition', 'after': 'preposition', 'since': 'preposition',
                'until': 'preposition', 'within': 'preposition', 'without': 'preposition', 'against': 'preposition',
                'across': 'preposition', 'around': 'preposition', 'behind': 'preposition', 'beside': 'preposition',
                'beyond': 'preposition', 'near': 'preposition', 'off': 'preposition', 'out': 'preposition',
                'en': 'preposition', 'de': 'preposition', 'a': 'preposition', 'por': 'preposition',
                'para': 'preposition', 'con': 'preposition', 'sin': 'preposition', 'sobre': 'preposition',
                'bajo': 'preposition', 'entre': 'preposition', 'hasta': 'preposition', 'desde': 'preposition',
                'durante': 'preposition', 'mediante': 'preposition', 'segÃºn': 'preposition', 'contra': 'preposition',
                'hacia': 'preposition', 'tras': 'preposition', 'ante': 'preposition', 'bajo': 'preposition',
                // Pronouns (subject, object, possessive, reflexive)
                'i': 'pronoun', 'you': 'pronoun', 'he': 'pronoun', 'she': 'pronoun', 'it': 'pronoun',
                'we': 'pronoun', 'they': 'pronoun', 'me': 'pronoun', 'him': 'pronoun', 'her': 'pronoun',
                'us': 'pronoun', 'them': 'pronoun', 'my': 'pronoun', 'your': 'pronoun', 'his': 'pronoun',
                'her': 'pronoun', 'its': 'pronoun', 'our': 'pronoun', 'their': 'pronoun', 'mine': 'pronoun',
                'yours': 'pronoun', 'hers': 'pronoun', 'ours': 'pronoun', 'theirs': 'pronoun',
                'myself': 'pronoun', 'yourself': 'pronoun', 'himself': 'pronoun', 'herself': 'pronoun',
                'itself': 'pronoun', 'ourselves': 'pronoun', 'yourselves': 'pronoun', 'themselves': 'pronoun',
                'who': 'pronoun', 'whom': 'pronoun', 'whose': 'pronoun', 'which': 'pronoun', 'that': 'pronoun',
                'yo': 'pronoun', 'tÃº': 'pronoun', 'Ã©l': 'pronoun', 'ella': 'pronoun', 'ello': 'pronoun',
                'nosotros': 'pronoun', 'nosotras': 'pronoun', 'vosotros': 'pronoun', 'vosotras': 'pronoun',
                'ellos': 'pronoun', 'ellas': 'pronoun', 'usted': 'pronoun', 'ustedes': 'pronoun',
                'me': 'pronoun', 'te': 'pronoun', 'le': 'pronoun', 'nos': 'pronoun', 'os': 'pronoun', 'les': 'pronoun',
                'mÃ­': 'pronoun', 'ti': 'pronoun', 'sÃ­': 'pronoun', 'conmigo': 'pronoun', 'contigo': 'pronoun',
                'consigo': 'pronoun', 'mi': 'pronoun', 'tu': 'pronoun', 'su': 'pronoun', 'nuestro': 'pronoun',
                'nuestra': 'pronoun', 'nuestros': 'pronoun', 'nuestras': 'pronoun', 'vuestro': 'pronoun',
                'vuestra': 'pronoun', 'vuestros': 'pronoun', 'vuestras': 'pronoun', 'mÃ­o': 'pronoun',
                'mÃ­a': 'pronoun', 'mÃ­os': 'pronoun', 'mÃ­as': 'pronoun', 'tuyo': 'pronoun', 'tuya': 'pronoun',
                'tuyos': 'pronoun', 'tuyas': 'pronoun', 'suyo': 'pronoun', 'suya': 'pronoun', 'suyos': 'pronoun',
                'suyas': 'pronoun', 'mismo': 'pronoun', 'misma': 'pronoun', 'mismos': 'pronoun', 'mismas': 'pronoun',
                'quien': 'pronoun', 'quienes': 'pronoun', 'que': 'pronoun', 'cual': 'pronoun', 'cuales': 'pronoun',
                'cuanto': 'pronoun', 'cuanta': 'pronoun', 'cuantos': 'pronoun', 'cuantas': 'pronoun',
                // Interjections
                'oh': 'interjection', 'ah': 'interjection', 'wow': 'interjection', 'oops': 'interjection',
                'hey': 'interjection', 'hi': 'interjection', 'hello': 'interjection', 'yes': 'interjection',
                'no': 'interjection', 'well': 'interjection', 'hmm': 'interjection', 'uh': 'interjection',
                'ay': 'interjection', 'eh': 'interjection', 'oh': 'interjection', 'uf': 'interjection',
                'huy': 'interjection', 'oye': 'interjection', 'vaya': 'interjection',
                // Adverbs (common ones)
                'not': 'adverb', 'very': 'adverb', 'too': 'adverb', 'so': 'adverb', 'quite': 'adverb',
                'rather': 'adverb', 'just': 'adverb', 'only': 'adverb', 'also': 'adverb', 'even': 'adverb',
                'still': 'adverb', 'already': 'adverb', 'yet': 'adverb', 'again': 'adverb', 'here': 'adverb',
                'there': 'adverb', 'where': 'adverb', 'when': 'adverb', 'how': 'adverb', 'why': 'adverb',
                'now': 'adverb', 'then': 'adverb', 'today': 'adverb', 'yesterday': 'adverb', 'tomorrow': 'adverb',
                'always': 'adverb', 'never': 'adverb', 'often': 'adverb', 'sometimes': 'adverb', 'usually': 'adverb',
                'no': 'adverb', 'sÃ­': 'adverb', 'tambiÃ©n': 'adverb', 'tampoco': 'adverb', 'muy': 'adverb',
                'mucho': 'adverb', 'poco': 'adverb', 'mÃ¡s': 'adverb', 'menos': 'adverb', 'bastante': 'adverb',
                'demasiado': 'adverb', 'suficiente': 'adverb', 'casi': 'adverb', 'solo': 'adverb', 'sÃ³lo': 'adverb',
                'aÃºn': 'adverb', 'todavÃ­a': 'adverb', 'ya': 'adverb', 'ahora': 'adverb', 'entonces': 'adverb',
                'despuÃ©s': 'adverb', 'antes': 'adverb', 'luego': 'adverb', 'pronto': 'adverb', 'tarde': 'adverb',
                'temprano': 'adverb', 'siempre': 'adverb', 'nunca': 'adverb', 'jamÃ¡s': 'adverb', 'aquÃ­': 'adverb',
                'ahÃ­': 'adverb', 'allÃ­': 'adverb', 'allÃ¡': 'adverb', 'cerca': 'adverb', 'lejos': 'adverb',
                'dentro': 'adverb', 'fuera': 'adverb', 'arriba': 'adverb', 'abajo': 'adverb', 'adelante': 'adverb',
                'atrÃ¡s': 'adverb', 'bien': 'adverb', 'mal': 'adverb', 'mejor': 'adverb', 'peor': 'adverb',
                'asÃ­': 'adverb', 'como': 'adverb', 'cuando': 'adverb', 'donde': 'adverb', 'adonde': 'adverb',
                'cuanto': 'adverb', 'como': 'adverb',
                // Verbs "to be" - must check before pattern matching
                'am': 'verb', 'is': 'verb', 'are': 'verb', 'was': 'verb', 'were': 'verb',
                'be': 'verb', 'been': 'verb', 'being': 'verb'
            };
            
            // Check common words first (most reliable)
            if (commonWords[word]) {
                return commonWords[word];
            }
            
            // Context-based classification for ambiguous words
            // "be" can be verb (infinitive), but also check context
            if (word === 'be') {
                // After "to" -> infinitive verb
                if (prevWord === 'to') return 'verb';
                // After modal verbs -> infinitive verb
                const modalVerbs = ['can', 'could', 'may', 'might', 'must', 'shall', 'should', 'will', 'would'];
                if (modalVerbs.includes(prevWord)) return 'verb';
                // Before adjective/noun -> linking verb
                if (nextWord && (nextWord.endsWith('ing') || nextWord.endsWith('ed') || nextWord.length > 3)) {
                    return 'verb';
                }
                // Default: verb (most common use)
                return 'verb';
            }
            
            // "what" - can be pronoun, determiner, interjection, or adverb depending on context
            if (word === 'what') {
                // At start of sentence/question -> interjection or pronoun
                if (context?.index === 0 || prevWord === '' || prevWord === '?') {
                    return 'pronoun'; // "What is that?" or "What!"
                }
                // Before noun -> determiner
                if (nextWord && nextWord.length > 2 && !commonWords[nextWord]) {
                    return 'determiner'; // "What time is it?"
                }
                // Default: pronoun
                return 'pronoun';
            }
            
            // "that" - can be pronoun, determiner, or conjunction
            if (word === 'that') {
                // After verb/preposition -> pronoun
                const verbPreps = ['say', 'think', 'know', 'see', 'believe', 'tell', 'show', 'of', 'in', 'on', 'at'];
                if (verbPreps.includes(prevWord)) return 'pronoun';
                // Before noun -> determiner
                if (nextWord && nextWord.length > 2 && !commonWords[nextWord]) {
                    return 'determiner'; // "that book"
                }
                // Introducing clause -> conjunction
                if (nextWord && (nextWord === 'is' || nextWord === 'was' || nextWord === 'are' || nextWord === 'were')) {
                    return 'conjunction'; // "that is"
                }
                // Default: pronoun
                return 'pronoun';
            }
            
            // "as" - can be preposition, conjunction, or adverb
            if (word === 'as') {
                // Before noun/pronoun -> preposition
                if (nextWord && (nextWord.length > 2 || commonWords[nextWord] === 'pronoun')) {
                    return 'preposition'; // "as a child"
                }
                // After "such" or "same" -> conjunction
                if (prevWord === 'such' || prevWord === 'same') return 'conjunction';
                // Default: conjunction
                return 'conjunction';
            }
            
            // "for" - can be preposition or conjunction
            if (word === 'for') {
                // Before noun/pronoun -> preposition
                if (nextWord && (nextWord.length > 2 || commonWords[nextWord] === 'pronoun')) {
                    return 'preposition'; // "for you"
                }
                // Introducing reason -> conjunction
                if (nextWord && (nextWord === 'it' || nextWord === 'this' || nextWord === 'that')) {
                    return 'conjunction'; // "for it is"
                }
                // Default: preposition
                return 'preposition';
            }
            
            // "since" - can be preposition or conjunction
            if (word === 'since') {
                // Before noun -> preposition
                if (nextWord && nextWord.length > 2 && !commonWords[nextWord]) {
                    return 'preposition'; // "since Monday"
                }
                // Default: conjunction
                return 'conjunction';
            }
            
            // "until" - can be preposition or conjunction
            if (word === 'until') {
                // Before noun -> preposition
                if (nextWord && nextWord.length > 2 && !commonWords[nextWord]) {
                    return 'preposition'; // "until tomorrow"
                }
                // Default: conjunction
                return 'conjunction';
            }
            
            // "well" - can be adverb, interjection, or noun
            if (word === 'well') {
                // At start or after comma -> interjection
                if (context?.index === 0 || prevWord === '' || prevWord === ',') {
                    return 'interjection'; // "Well, I think..."
                }
                // Before adjective/verb -> adverb
                if (nextWord && (nextWord.endsWith('ing') || nextWord.endsWith('ed') || nextWord.length > 3)) {
                    return 'adverb'; // "well done"
                }
                // Default: adverb
                return 'adverb';
            }
            
            // Check if it's a "to be" verb (ser/estar)
            if (isSerEstar(word)) {
                return 'verb';
            }
            
            // Morphological patterns (more specific first)
            // Noun patterns
            if (word.endsWith('tion') || word.endsWith('sion') || word.endsWith('ness') || word.endsWith('ment') ||
                word.endsWith('ity') || word.endsWith('ism') || word.endsWith('ship') || word.endsWith('hood')) {
                return 'noun';
            }
            
            // CRITICAL: Context-based adjective detection - check if word modifies a following noun
            // Pattern: adjective + noun (e.g., "red car", "beautiful house")
            const nextWordForAdj = context?.nextWord ? context.nextWord.toLowerCase().replace(/[^\w\u4e00-\u9fff]/g, '') : '';
            const prevWordForAdj = context?.prevWord ? context.prevWord.toLowerCase().replace(/[^\w\u4e00-\u9fff]/g, '') : '';
            
            // If word is followed by a noun-like word, it's likely an adjective
            if (nextWordForAdj && nextWordForAdj.length > 2) {
                const nextPos = commonWords[nextWordForAdj];
                // If next word is NOT a known verb/adverb/determiner/pronoun, current word might be adjective
                if (!nextPos || (nextPos !== 'verb' && nextPos !== 'adverb' && nextPos !== 'determiner' && nextPos !== 'pronoun')) {
                    // Pattern: [word] [noun-like] suggests [word] is adjective
                    // Check for common adjective endings first
                    if (word.endsWith('ful') || word.endsWith('less') || word.endsWith('ous') || word.endsWith('ive') || 
                        word.endsWith('able') || word.endsWith('ible') || word.endsWith('ic') || word.endsWith('ical') ||
                        word.endsWith('ed') || word.endsWith('ing')) {
                        // But exclude if it's clearly a verb (has verb endings and context suggests verb)
                        if (!word.endsWith('ed') && !word.endsWith('ing')) {
                            return 'adjective';
                        }
                        // For -ed/-ing, check context: if after "to be" or determiner, likely adjective
                        if ((prevWordForAdj === 'is' || prevWordForAdj === 'are' || prevWordForAdj === 'was' || prevWordForAdj === 'were' ||
                             prevWordForAdj === 'the' || prevWordForAdj === 'a' || prevWordForAdj === 'an' || prevWordForAdj === 'el' || prevWordForAdj === 'la')) {
                            return 'adjective';
                        }
                    }
                }
            }
            
            // Adjective patterns (but check context - "al" can be noun ending too)
            if (word.endsWith('ful') || word.endsWith('less') || word.endsWith('ous') || word.endsWith('ive') ||
                word.endsWith('able') || word.endsWith('ible') || word.endsWith('ic') || word.endsWith('ical')) {
                return 'adjective';
            }
            // "al" ending - can be adjective or noun, check context
            if (word.endsWith('al') && word.length > 3) {
                // If it's a known proper noun, it's a noun (case-insensitive check)
                if (KNOWN_PROPER_NOUNS.has(word) || KNOWN_PROPER_NOUNS_LOWER.has(word.toLowerCase())) return 'noun';
                // If followed by noun-like word, it's adjective
                if (nextWordForAdj && nextWordForAdj.length > 2 && (!commonWords[nextWordForAdj] || commonWords[nextWordForAdj] === 'noun')) {
                    return 'adjective';
                }
                // Default: adjective (capitalization NOT used as signal)
                return 'adjective';
            }
            
            // Spanish adjective endings
            if (word.endsWith('oso') || word.endsWith('osa') || word.endsWith('oso') || word.endsWith('osa') ||
                word.endsWith('ado') || word.endsWith('ada') || word.endsWith('ido') || word.endsWith('ida') ||
                word.endsWith('ante') || word.endsWith('ente')) {
                return 'adjective';
            }
            
            // Adverb patterns
            if (word.endsWith('ly') && word.length > 4) { // "fly" is not an adverb
                return 'adverb';
            }
            // Spanish adverbs ending in -mente
            if (word.endsWith('mente') && word.length > 6) {
                return 'adverb';
            }
            
            // Verb patterns (more specific)
            if (word.endsWith('ing') && word.length > 4) { // "king", "ring", "thing" are not verbs
                // Check if it's a known noun
                const ingNouns = ['king', 'ring', 'thing', 'sing', 'wing', 'spring', 'string', 'bring', 'cling'];
                if (!ingNouns.includes(word)) {
                    return 'verb';
                }
            }
            if (word.endsWith('ed') && word.length > 3) { // "red", "bed", "led" are not verbs
                const edNouns = ['red', 'bed', 'led', 'wed', 'fed', 'shed', 'sled'];
                if (!edNouns.includes(word)) {
                    return 'verb';
                }
            }
            
            // Words ending in 's' - could be plural nouns, possessive nouns, or 3rd person verbs
            // Context helps: after determiner -> noun, after subject pronoun -> verb
            if (word.endsWith('s') && word.length > 2) {
                // Check if it's a known verb base form + 's'
                const baseForm = word.slice(0, -1); // Remove 's'
                const determiners = ['the', 'a', 'an', 'this', 'that', 'these', 'those', 'some', 'any', 'each', 'every',
                                     'el', 'la', 'los', 'las', 'un', 'una', 'unos', 'unas'];
                if (determiners.includes(prevWord)) {
                    return 'noun'; // "the cats", "los gatos"
                }
                const subjectPronouns = ['i', 'you', 'he', 'she', 'it', 'we', 'they', 'Ã©l', 'ella', 'ello', 'yo', 'tÃº'];
                if (subjectPronouns.includes(prevWord)) {
                    // After subject pronoun, more likely to be verb
                    if (commonVerbs.has(baseForm) || commonSpanishVerbs.has(baseForm)) {
                        return 'verb'; // "he runs", "Ã©l corre"
                    }
                    return 'verb'; // "he runs"
                }
                // If it's a known verb base, likely verb
                if (commonVerbs.has(baseForm) || commonSpanishVerbs.has(baseForm)) {
                    return 'verb';
                }
                // Default: noun (more common for plurals)
                return 'noun';
            }
            
            // Default: be more conservative, try context-based inference before defaulting
            // After determiner -> likely noun
            const determiners = ['the', 'a', 'an', 'this', 'that', 'these', 'those', 'some', 'any', 'each', 'every',
                                 'el', 'la', 'los', 'las', 'un', 'una', 'unos', 'unas'];
            if (determiners.includes(prevWord)) {
                return 'noun';
            }
            // After subject pronoun -> likely verb
            const subjectPronouns = ['i', 'you', 'he', 'she', 'it', 'we', 'they', 'Ã©l', 'ella', 'ello', 'yo', 'tÃº'];
            if (subjectPronouns.includes(prevWord)) {
                return 'verb';
            }
            // Before noun indicators -> likely adjective
            if (nextWord && (determiners.includes(nextWord) || commonWords[nextWord] === 'noun')) {
                return 'adjective';
            }
            
            // Use compromise as intelligent fallback before defaulting to 'other'
            const compromiseResult = getPOSWithCompromise(word, context);
            if (compromiseResult) {
                return compromiseResult;
            }

            // Last resort: if we truly can't determine, return 'other' instead of guessing 'noun'
            // This prevents false classifications and is more honest
            return 'other';
        }

        function isSerEstar(word) {
            if (!word) return false;
            const cleanWord = word.replace(/[^\w']/g, '').toLowerCase();
            const serEstarWords = [
                // Spanish
                'ser', 'estar', 'es', 'son', 'estÃ¡', 'estÃ¡n', 'fue', 'fueron',
                'estaba', 'estaban', 'sido', 'estado', 'siendo', 'estando',
                'sea', 'sean', 'estÃ©', 'estÃ©n', 'fuera', 'fueran',
                'soy', 'somos', 'eras', 'erais',
                // English core forms
                'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
                // English contractions
                "i'm", "it's", "he's", "she's", "that's", "this's", "what's", "who's",
                "we're", "you're", "they're",
                // Also check without apostrophe (some tokenizers might handle differently)
                "im", "its", "hes", "shes", "thats", "this", "whats", "whos",
                "were", "youre", "theyre"
            ];
            
            // Check direct matches
            if (serEstarWords.includes(cleanWord)) {
                return true;
            }
            
            // Check contractions with apostrophe
            if (cleanWord.includes("'")) {
                const parts = cleanWord.split("'");
                if (parts.length === 2) {
                    const base = parts[0];
                    const suffix = parts[1];
                    // Check if it's a contraction form of "to be"
                    if ((base === 'i' && suffix === 'm') || // I'm
                        (['it', 'he', 'she', 'that', 'this', 'what', 'who'].includes(base) && suffix === 's') || // it's, he's, etc.
                        (['we', 'you', 'they'].includes(base) && suffix === 're')) { // we're, you're, they're
                        return true;
                    }
                }
            }
            
            return false;
        }

        function splitTextIntoWords(text) {
            const words = [];
            let currentWord = '';
            
            // Characters that should split words (act as spaces): / : [ ] \ ( ) , ; # ~ " " ? Â¿ ! Â¡ + { < > Â· Âº Âª *
            // These characters should be treated as word separators (like spaces)
            // NOTE: Apostrophe (') splits words so "I'm" becomes "I" + "m"
            // NOTE: - . _ @ are NOT separators - they create compound names
            // NOTE: Em dash (â€”) and en dash (â€“) are treated as spaces
            const wordSplitChars = /[\/:\[\]\\\(\),;#~"`"?Â¿!Â¡+\{<>Â·ÂºÂª*'\u2014\u2013]/;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                
                if (/[\u4e00-\u9fff]/.test(char)) {
                    // Chinese character
                    if (currentWord.trim()) {
                        words.push(currentWord.trim());
                        currentWord = '';
                    }
                    words.push(char);
                } else if (/\s/.test(char) || char === '\u2014' || char === '\u2013') {
                    // Whitespace (including em dash â€” and en dash â€“)
                    if (currentWord.trim()) {
                        words.push(currentWord.trim());
                        currentWord = '';
                    }
                } else if (wordSplitChars.test(char)) {
                    // Word splitting character - treat as separator
                    if (currentWord.trim()) {
                        words.push(currentWord.trim());
                        currentWord = '';
                    }
                    // Don't add the splitting character itself to words (treat as space)
                } else {
                    currentWord += char;
                }
            }
            
            if (currentWord.trim()) {
                words.push(currentWord.trim());
            }
            
            return words.filter(word => word.length > 0);
        }
        
        // Limit text input to 500 words
        function limitWordCount(event) {
            const textInput = event.target;
            const text = textInput.value;
            const words = splitTextIntoWords(text);
            const MAX_WORDS = 500;
            
            if (words.length > MAX_WORDS) {
                // Truncate to 500 words
                const truncatedWords = words.slice(0, MAX_WORDS);
                
                // Reconstruct text from truncated words - simpler approach
                let truncatedText = '';
                let wordIndex = 0;
                let currentWord = '';
                let inWord = false;
                
                // Reconstruct by going through original text and counting words
                for (let i = 0; i < text.length && wordIndex < MAX_WORDS; i++) {
                    const char = text[i];
                    
                    if (/[\u4e00-\u9fff]/.test(char)) {
                        // Chinese character - each is a word
                        if (currentWord.trim()) {
                            truncatedText += currentWord;
                            currentWord = '';
                            wordIndex++;
                        }
                        truncatedText += char;
                        wordIndex++;
                        inWord = false;
                    } else if (/\s/.test(char)) {
                        // Whitespace
                        if (currentWord.trim()) {
                            truncatedText += currentWord;
                            currentWord = '';
                            wordIndex++;
                            inWord = false;
                        }
                        truncatedText += char;
                    } else {
                        // Regular character
                        currentWord += char;
                        inWord = true;
                    }
                }
                
                // If we're in the middle of a word and haven't reached the limit, add it
                if (wordIndex < MAX_WORDS && currentWord.trim()) {
                    truncatedText += currentWord;
                }
                
                // Update value
                const cursorPos = textInput.selectionStart;
                textInput.value = truncatedText;
                
                // Try to maintain cursor position if possible
                const newCursorPos = Math.min(cursorPos, truncatedText.length);
                textInput.setSelectionRange(newCursorPos, newCursorPos);
                
                // Show warning
                const existingWarning = document.getElementById('wordLimitWarning');
                if (existingWarning) {
                    existingWarning.remove();
                }
                const warning = document.createElement('div');
                warning.id = 'wordLimitWarning';
                warning.style.cssText = 'color: #ff6600; font-size: 11px; margin-top: 5px;';
                warning.textContent = `Maximum 500 words allowed. Text truncated.`;
                textInput.parentNode.appendChild(warning);
                setTimeout(() => {
                    if (warning.parentNode) {
                        warning.parentNode.removeChild(warning);
                    }
                }, 3000);
            }
        }
        
        // Handle paste events to limit word count
        function handlePaste(event) {
            event.preventDefault();
            
            const pastedText = (event.clipboardData || window.clipboardData).getData('text');
            const textInput = event.target;
            const currentText = textInput.value;
            const selectionStart = textInput.selectionStart;
            const selectionEnd = textInput.selectionEnd;
            
            // Get current word count
            const currentWords = splitTextIntoWords(currentText);
            const MAX_WORDS = 500;
            
            // Calculate how many words we can add
            const wordsAvailable = MAX_WORDS - currentWords.length;
            
            if (wordsAvailable <= 0) {
                // Already at limit, don't allow paste
                const existingWarning = document.getElementById('wordLimitWarning');
                if (existingWarning) {
                    existingWarning.remove();
                }
                const warning = document.createElement('div');
                warning.id = 'wordLimitWarning';
                warning.style.cssText = 'color: #ff6600; font-size: 11px; margin-top: 5px;';
                warning.textContent = 'Maximum 500 words reached. Cannot paste more text.';
                textInput.parentNode.appendChild(warning);
                setTimeout(() => {
                    if (warning.parentNode) {
                        warning.parentNode.removeChild(warning);
                    }
                }, 3000);
                return;
            }
            
            // Split pasted text into words and take only what fits
            const pastedWords = splitTextIntoWords(pastedText);
            const wordsToPaste = pastedWords.slice(0, wordsAvailable);
            
            // Reconstruct text from words (simplified - preserve original spacing when possible)
            let textToPaste = '';
            if (pastedWords.length > 0) {
                // Try to preserve original text structure
                const originalText = pastedText;
                let wordCount = 0;
                let currentWord = '';
                
                for (let i = 0; i < originalText.length && wordCount < wordsAvailable; i++) {
                    const char = originalText[i];
                    
                    if (/[\u4e00-\u9fff]/.test(char)) {
                        if (currentWord.trim()) {
                            textToPaste += currentWord;
                            currentWord = '';
                            wordCount++;
                        }
                        textToPaste += char;
                        wordCount++;
                    } else if (/\s/.test(char)) {
                        if (currentWord.trim()) {
                            textToPaste += currentWord;
                            currentWord = '';
                            wordCount++;
                        }
                        textToPaste += char;
                    } else {
                        currentWord += char;
                    }
                }
            }
            
            // Insert the text
            const newText = currentText.substring(0, selectionStart) + 
                          textToPaste + 
                          currentText.substring(selectionEnd);
            
            textInput.value = newText;
            textInput.setSelectionRange(selectionStart + textToPaste.length, selectionStart + textToPaste.length);
            
            // Trigger input event to validate word count
            textInput.dispatchEvent(new Event('input'));
            
            // Show warning if text was truncated
            if (pastedWords.length > wordsAvailable) {
                const existingWarning = document.getElementById('wordLimitWarning');
                if (existingWarning) {
                    existingWarning.remove();
                }
                const warning = document.createElement('div');
                warning.id = 'wordLimitWarning';
                warning.style.cssText = 'color: #ff6600; font-size: 11px; margin-top: 5px;';
                warning.textContent = `Pasted text truncated to fit 500 word limit.`;
                textInput.parentNode.appendChild(warning);
                setTimeout(() => {
                    if (warning.parentNode) {
                        warning.parentNode.removeChild(warning);
                    }
                }, 3000);
            }
        }

        // ============================================================================
        // OPENAI API INTEGRATION FOR POS RECOGNITION
        // ============================================================================
        let openaiApiKey = null;
        
        // Save API key to localStorage
        function saveOpenAIApiKey(key) {
            const trimmedKey = key.trim();
            if (trimmedKey) {
                openaiApiKey = trimmedKey;
                localStorage.setItem('openai_api_key', trimmedKey);
                console.log('API key saved to localStorage');
                return true;
            }
            return false;
        }
        
        // Load API key from localStorage or api-key.txt file
        async function loadOpenAIApiKey() {
            // First try localStorage
            const storedKey = localStorage.getItem('openai_api_key');
            if (storedKey && storedKey.trim()) {
                openaiApiKey = storedKey.trim();
                console.log('API key loaded from localStorage');
                return openaiApiKey;
            }
            
            // Then try file (try both paths: root and client directory)
            // The HTML is in client/ subdirectory, so ../api-key.txt should point to the root
            const pathsToTry = ['../api-key.txt', 'api-key.txt'];
            
            for (const path of pathsToTry) {
                try {
                    const response = await fetch(path);
                    if (response.ok) {
                        const key = (await response.text()).trim();
                        if (key) {
                            openaiApiKey = key;
                            localStorage.setItem('openai_api_key', key); // Cache it
                            console.log(`API key loaded from ${path}`);
                            return key;
                        }
                    }
                } catch (error) {
                    // Expected error when using file:// protocol - ignore
                    console.log(`Cannot load ${path} (expected with file:// protocol)`);
                }
            }
            
            // No key found
            console.warn('OpenAI API key not found. Please enter it in the Version dropdown.');
            return null;
        }
        
        // Call OpenAI API for POS tagging
        async function analyzeTextWithOpenAI(text, tokens) {
            console.log('analyzeTextWithOpenAI called with text:', text.substring(0, 200));
            const apiKey = await loadOpenAIApiKey();
            if (!apiKey) {
                console.error('OpenAI API key not available');
                return null;
            }
            console.log('API key loaded, length:', apiKey.length);
            
            // Extract word list from tokens for reference
            const wordList = tokens ? tokens.map(t => t.surface).join(' ') : text.split(/\s+/).filter(w => w.length > 0).join(' ');
            
            const prompt = `You are a linguistic analysis engine.

Your task is to analyze the given text and classify each word according to its grammatical function in context, not according to its isolated or dictionary meaning.

For each word, determine its correct word type based on:
â€“ its syntactic role in the sentence
â€“ its relationship to surrounding words
â€“ its tense, aspect, mood, or degree when applicable

You must distinguish accurately between:
â€“ parts of speech that change by context (e.g. noun vs verb vs adjective)
â€“ auxiliary verbs vs main verbs
â€“ participles used as verbs vs adjectives
â€“ nouns used attributively vs adjectives
â€“ pronouns by function (subject, object, possessive, reflexive, etc.)

Do not assume a word's type without contextual justification.
If a word can belong to multiple categories, choose only the one that applies in the given context.

You MUST follow the mandatory process below for EVERY word:

MANDATORY PROCESS FOR EACH WORD - Follow this EXACT order:

STEP 1: CHECK CONTEXT FIRST
- What word comes BEFORE this word?
- What word comes AFTER this word?
- What is the position in the sentence?

STEP 2: CHECK FUNCTION (MOST IMPORTANT)
- Is it functioning as PREDICATE (after subject)? â†’ VERB
- Is it MODIFYING a noun (before noun)? â†’ ADJECTIVE
- Is it REPLACING a noun? â†’ PRONOUN
- Is it MODIFYING a verb/adjective? â†’ ADVERB
- Only if NONE of the above â†’ consider NOUN

STEP 3: CHECK FORM
- Ends in -ed? â†’ Check function: predicate = VERB, modifier = ADJECTIVE
- Ends in -ing? â†’ Check function: predicate = VERB, modifier = ADJECTIVE
- Ends in -ly? â†’ ADVERB (always)
- Personal pronoun (I, you, he, she, it, we, they)? â†’ PRONOUN (always)

STEP 4: VERIFY AGAINST COMMON ERRORS
Before classifying as NOUN, verify:
- Is it NOT a verb functioning as predicate?
- Is it NOT an adjective modifying a noun?
- Is it NOT a pronoun replacing a noun?
- Is it NOT an adverb modifying something?

CRITICAL RULES (MUST FOLLOW):
1. NOUN IS YOUR LAST RESORT - Only classify as NOUN if it genuinely names something AND passed all checks above
2. NAME (proper noun) is ONLY for actual proper names (people, places, organizations, brands) - NOT for common words just because they're capitalized
3. Interrogative/relative words (how, why, when, where, what, who, which) â†’ ADVERB or PRONOUN, NEVER NAME, even if capitalized
4. Common verbs (live, go, come, see, know, think, get, make, take, give, say, tell, work, play, read, write, learn, teach) â†’ VERB, NEVER NAME, even if capitalized
5. Words ending in -ed: If predicate (after subject) â†’ VERB. If modifying noun â†’ ADJECTIVE.
6. Words ending in -ing: If predicate (after subject/am/is/are) â†’ VERB. If modifying noun â†’ ADJECTIVE.
7. Words ending in -ly â†’ ALWAYS ADVERB.
8. Personal pronouns (I, you, he, she, it, we, they) â†’ ALWAYS PRONOUN, NEVER NOUN or NAME.
9. Words functioning as predicate (after subject) â†’ VERB.
10. Words modifying nouns â†’ ADJECTIVE.
11. Words modifying verbs/adjectives â†’ ADVERB.
12. NOUN vs NAME: NOUN = common noun (cat, house, book). NAME = proper noun (John, Paris, Microsoft). Common words capitalized at sentence start are NOT names.

CRITICAL: RECOGNIZING PREVIOUSLY IMPORTED WORDS:
- The system has a database of known proper nouns (names) that have been imported previously
- These include common first names and surnames in multiple languages (English, Spanish, Italian, French, German, etc.)
- Examples: John, Mary, JosÃ©, MarÃ­a, Elena, Ian, Michael, Sarah, Carlos, etc.
- If a word matches a name from this database (case-insensitive), it MUST be classified as NAME, NOT NOUN
- IMPORTANT: Check if the word (ignoring capitalization) matches any known proper noun from the imported database
- If it matches â†’ classify as NAME with isName: true
- This applies regardless of capitalization: "john", "John", "JOHN" should all be recognized as NAME if "John" is in the database

POS TYPES: VERB_AUXILIARY, VERB, VERB_MODAL, PRONOUN, ADJECTIVE, ADVERB, NOUN, NAME, DETERMINER, PREPOSITION, CONJUNCTION, PART, MISC

SYNTACTIC ROLES: subject, predicate, predicate_complement, object, modifier, determiner, connector, isolated, null

SEMANTIC ROLES: identity, action, quality, relation, comparison, negation, question, existence, null

FEW-SHOT EXAMPLES - Study these examples carefully and apply the same logic:

Example 1 - Text: "we reviewed blueprints"
[
  {"word": "we", "pos": "PRONOUN", "person": "1st_plural", "possessive": false, "isName": false, "syntacticRole": "subject", "isNucleus": true, "semanticRole": "identity", "isOntological": false, "isComparison": false, "closureLevel": "HIGH"},
  {"word": "reviewed", "pos": "VERB", "subclass": "action", "tense": "PAST", "mood": "INDICATIVE", "isName": false, "syntacticRole": "predicate", "isNucleus": true, "semanticRole": "action", "isOntological": false, "isComparison": false, "closureLevel": "HIGH"},
  {"word": "blueprints", "pos": "NOUN", "subclass": "concrete", "isName": false, "syntacticRole": "object", "isNucleus": true, "semanticRole": "identity", "isOntological": false, "isComparison": false, "closureLevel": "HIGH"}
]

Example 2 - Text: "stained glass windows"
[
  {"word": "stained", "pos": "ADJECTIVE", "semanticType": "descriptive", "isName": false, "syntacticRole": "modifier", "isNucleus": false, "semanticRole": "quality", "isOntological": false, "isComparison": false, "closureLevel": null},
  {"word": "glass", "pos": "NOUN", "subclass": "concrete", "isName": false, "syntacticRole": "modifier", "isNucleus": false, "semanticRole": "identity", "isOntological": false, "isComparison": false, "closureLevel": null},
  {"word": "windows", "pos": "NOUN", "subclass": "concrete", "isName": false, "syntacticRole": "object", "isNucleus": true, "semanticRole": "identity", "isOntological": false, "isComparison": false, "closureLevel": "HIGH"}
]

Example 3 - Text: "flying buttresses"
[
  {"word": "flying", "pos": "ADJECTIVE", "semanticType": "descriptive", "isName": false, "syntacticRole": "modifier", "isNucleus": false, "semanticRole": "quality", "isOntological": false, "isComparison": false, "closureLevel": null},
  {"word": "buttresses", "pos": "NOUN", "subclass": "concrete", "isName": false, "syntacticRole": "object", "isNucleus": true, "semanticRole": "identity", "isOntological": false, "isComparison": false, "closureLevel": "HIGH"}
]

Example 4 - Text: "approximately 110"
[
  {"word": "approximately", "pos": "ADVERB", "semanticType": "degree", "isName": false, "syntacticRole": "modifier", "isNucleus": false, "semanticRole": null, "isOntological": false, "isComparison": false, "closureLevel": null},
  {"word": "110", "pos": "NAME", "isName": true, "syntacticRole": "object", "isNucleus": true, "semanticRole": "identity", "isOntological": false, "isComparison": false, "closureLevel": null}
]

CRITICAL LESSONS FROM EXAMPLES:
- "reviewed" after "we" â†’ VERB (predicate), NOT NOUN
- "stained" before "glass" â†’ ADJECTIVE (modifies noun), NOT NOUN
- "flying" before "buttress" â†’ ADJECTIVE (modifies noun), NOT NOUN
- "approximately" before number â†’ ADVERB (modifies number), NOT NAME or NOUN
- "John" and "Elena" â†’ NAME (recognized from imported database), NOT NOUN, regardless of capitalization
- IMPORTANT: If a word matches a name from the imported database (case-insensitive), it MUST be NAME, NOT NOUN

COMMON ERRORS TO AVOID - These words are OFTEN misclassified as NOUN or NAME when they are NOT:
- Interrogative/relative adverbs â†’ ADVERB (how, why, when, where, here, there, now, then) - These are NEVER names, even if capitalized
- Common verbs â†’ VERB (live, lives, lived, living, go, goes, went, gone, going, come, comes, came, coming) - These are NEVER names, even if capitalized
- Past tense verbs ending in -ed functioning as predicate â†’ VERB (walked, ran, ate, thought, saw, went, came, took, gave, got, put, made, did, said, told, spoke, worked, played, read, wrote, learned, taught, helped, created, built, broke, fixed, opened, closed, started, stopped, finished, began, ended, loved, hated, liked, wanted, needed, believed, knew, understood, remembered, forgot, felt, heard, looked, seemed, appeared, became, remained, stayed, kept, reviewed, stained, designed, planned, constructed, painted, colored, decorated, arranged, organized, prepared, completed, finished, started, ended, continued, stopped, moved, changed, transformed, modified, improved, developed, created, built, destroyed, repaired, fixed, cleaned, washed, dried, cooked, baked, served, delivered, received, accepted, rejected, approved, denied, confirmed, verified, checked, examined, inspected, analyzed, studied, researched, investigated, explored, discovered, found, lost, searched, looked, watched, observed, noticed, recognized, identified, named, called, labeled, marked, noted, recorded, documented, written, typed, printed, copied, pasted, cut, edited, revised, corrected, updated, changed, modified, saved, stored, kept, held, carried, brought, took, gave, received, sent, delivered, returned, came, went, left, arrived, departed, traveled, moved, walked, ran, jumped, climbed, fell, dropped, lifted, raised, lowered, pushed, pulled, dragged, carried, held, grabbed, caught, released, threw, dropped, placed, put, set, positioned, located, found, searched, looked, watched, observed, saw, noticed, recognized, identified, knew, understood, learned, taught, studied, researched, investigated, explored, discovered, found, created, made, built, constructed, designed, planned, organized, arranged, prepared)
- Present participles ending in -ing functioning as predicate â†’ VERB (walking, running, eating, thinking, seeing, going, coming, taking, giving, getting, putting, making, doing, saying, telling, speaking, working, playing, reading, writing, learning, teaching, helping, creating, building, breaking, fixing, opening, closing, starting, stopping, continuing, finishing, beginning, ending, loving, hating, liking, wanting, needing, believing, knowing, understanding, remembering, forgetting, feeling, hearing, looking, seeming, appearing, becoming, remaining, staying, keeping, flying, reviewing, staining)
- Past participles ending in -ed modifying nouns â†’ ADJECTIVE (stained, painted, broken, fixed, opened, closed, started, stopped, finished, completed, reviewed, examined, analyzed, studied, researched, investigated, explored, discovered, found, created, made, built, constructed, designed, planned, organized, arranged, prepared)
- Present participles ending in -ing modifying nouns â†’ ADJECTIVE (flying, running, walking, working, playing, reading, writing, learning, teaching, helping, creating, building, breaking, fixing, opening, closing, starting, stopping, continuing, finishing, beginning, ending, loving, hating, liking, wanting, needing, believing, knowing, understanding, remembering, forgetting, feeling, hearing, looking, seeming, appearing, becoming, remaining, staying, keeping)
- Personal pronouns â†’ PRONOUN (I, you, he, she, it, we, they, my, your, his, her, its, our, their)
- Words ending in -ly â†’ ADVERB (quickly, slowly, carefully, approximately, exactly, precisely, obviously, clearly, apparently, evidently, presumably, probably, possibly, perhaps, maybe, certainly, definitely, absolutely, positively, negatively, directly, indirectly, immediately, instantly, suddenly, gradually, carefully, carelessly, easily, hardly, barely, completely, entirely, fully, partly, partially, mostly, mainly, primarily, secondarily, additionally, also, too, as well, either, neither, however, therefore, thus, hence, consequently, accordingly, similarly, likewise, differently, otherwise, instead, rather, quite, rather, fairly, pretty, very, extremely, incredibly, amazingly, surprisingly)

FINAL VERIFICATION CHECKLIST - Before returning your answer, verify EACH word:
For EVERY word classified as NOUN, ask:
1. Is it REALLY functioning as predicate? â†’ If yes, change to VERB
2. Is it REALLY modifying a noun? â†’ If yes, change to ADJECTIVE
3. Is it REALLY replacing a noun? â†’ If yes, change to PRONOUN
4. Is it REALLY modifying a verb/adjective? â†’ If yes, change to ADVERB
5. Only if ALL checks pass â†’ keep as NOUN

CRITICAL: Analyze the complete text below in its full context. Consider how each word functions within the entire sentence structure, not in isolation.

Complete text to analyze:
"${text}"

Words to classify (in order, extracted from text):
${wordList}

IMPORTANT: Return a JSON array with ONE entry per word listed above, in order. Use the EXACT word as it appears in the text. Analyze each word based on its function in the complete text context provided above.

Return format (JSON array only, no other text):
[
  {"word": "exact_word_as_in_text", "pos": "VERB", "subclass": "action", "tense": "PRESENT", "mood": "INDICATIVE", "isName": false, "syntacticRole": "predicate", "isNucleus": true, "semanticRole": "action", "isOntological": false, "isComparison": false, "closureLevel": "HIGH"},
  {"word": "exact_word_as_in_text", "pos": "NOUN", "subclass": "concrete", "isName": false, "syntacticRole": "subject", "isNucleus": true, "semanticRole": "identity", "isOntological": false, "isComparison": false, "closureLevel": "HIGH"},
  {"word": "Mike", "pos": "NAME", "isName": true, "syntacticRole": "subject", "isNucleus": true, "semanticRole": "identity", "isOntological": false, "isComparison": false, "closureLevel": null}
]`;

            try {
                console.log('Sending request to OpenAI API...');
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        temperature: 0.0,
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a linguistic analysis expert. Return ONLY valid JSON arrays for POS tagging, no explanations or additional text. Always return a valid JSON array.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        temperature: 0.0,
                        max_tokens: 16384
                    })
                });
                
                console.log('OpenAI API response status:', response.status);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('OpenAI API error:', response.status, errorText);
                    return null;
                }
                
                const data = await response.json();
                console.log('OpenAI API response received, checking choices...');
                
                if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                    console.error('Invalid OpenAI response structure:', data);
                    return null;
                }
                
                const content = data.choices[0].message.content.trim();
                const finishReason = data.choices[0].finish_reason;
                
                console.log('OpenAI raw response length:', content.length);
                console.log('OpenAI finish_reason:', finishReason);
                console.log('OpenAI raw response (first 500 chars):', content.substring(0, 500));
                
                // Check if response was truncated
                if (finishReason === 'length') {
                    console.warn('OpenAI response was truncated due to token limit. Consider splitting the text or increasing max_tokens.');
                }
                
                // Extract JSON from response (handle code blocks if present)
                let jsonText = content;
                if (content.startsWith('```json')) {
                    jsonText = content.replace(/```json\n?/g, '').replace(/```\n?$/g, '');
                } else if (content.startsWith('```')) {
                    jsonText = content.replace(/```\n?/g, '').replace(/```$/g, '');
                }
                
                console.log('Extracted JSON text length:', jsonText.length);
                console.log('Extracted JSON text (first 500 chars):', jsonText.substring(0, 500));
                if (jsonText.length > 1000) {
                    console.log('Extracted JSON text (last 500 chars):', jsonText.substring(jsonText.length - 500));
                }
                
                try {
                    // Check if JSON appears to be truncated (doesn't end with ])
                    const trimmedJsonText = jsonText.trim();
                    if (!trimmedJsonText.endsWith(']')) {
                        console.warn('JSON response may be truncated - does not end with ]');
                        // Try to find the last complete JSON object and close the array
                        const lastCompleteBrace = trimmedJsonText.lastIndexOf('}');
                        if (lastCompleteBrace > 0) {
                            const potentialJson = trimmedJsonText.substring(0, lastCompleteBrace + 1) + ']';
                            try {
                                const analysis = JSON.parse(potentialJson);
                                if (Array.isArray(analysis)) {
                                    console.warn(`Using truncated JSON with ${analysis.length} items (original was incomplete)`);
                                    return analysis;
                                }
                            } catch (e) {
                                // Fall through to try parsing original
                            }
                        }
                    }
                    
                    const analysis = JSON.parse(jsonText);
                    
                    if (!Array.isArray(analysis)) {
                        console.error('OpenAI response is not an array:', typeof analysis);
                        return null;
                    }
                    
                    console.log('Successfully parsed OpenAI response:', analysis.length, 'items');
                    if (analysis.length > 0) {
                        console.log('First item:', analysis[0]);
                        console.log('Last item:', analysis[analysis.length - 1]);
                    }
                    return analysis;
                } catch (parseError) {
                    console.error('JSON parse error:', parseError);
                    console.error('Failed to parse JSON. Content length:', jsonText.length);
                    console.error('Content (first 1000 chars):', jsonText.substring(0, 1000));
                    if (jsonText.length > 1000) {
                        console.error('Content (last 1000 chars):', jsonText.substring(jsonText.length - 1000));
                    }
                    // Try to extract valid JSON from the truncated response
                    const lastCompleteBrace = jsonText.lastIndexOf('}');
                    if (lastCompleteBrace > 0) {
                        try {
                            const potentialJson = jsonText.substring(0, lastCompleteBrace + 1) + ']';
                            const partialAnalysis = JSON.parse(potentialJson);
                            if (Array.isArray(partialAnalysis) && partialAnalysis.length > 0) {
                                console.warn(`Extracted partial JSON with ${partialAnalysis.length} items from truncated response`);
                                return partialAnalysis;
                            }
                        } catch (e) {
                            console.error('Failed to extract partial JSON:', e);
                        }
                    }
                    return null;
                }
            } catch (error) {
                console.error('Error calling OpenAI API:', error);
                console.error('Error stack:', error.stack);
                return null;
            }
        }
        
        // Map OpenAI POS tags to legacy POS system
        function mapOpenAIPosToLegacy(openAIPos) {
            if (!openAIPos) return 'other';
            const upperPos = (openAIPos || '').toUpperCase().trim();
            const mapping = {
                'VERB': 'verb',
                'VERB_MODAL': 'verb',
                'VERB_AUXILIARY': 'verb',
                'AUX': 'verb',
                'NOUN': 'noun',
                'NAME': 'noun', // Names are treated as nouns in legacy system
                'PROPN': 'noun', // Proper noun
                'ADJECTIVE': 'adjective',
                'ADJ': 'adjective',
                'ADVERB': 'adverb',
                'ADV': 'adverb',
                'PRONOUN': 'pronoun',
                'PRON': 'pronoun',
                'DETERMINER': 'determiner',
                'DET': 'determiner',
                'PREPOSITION': 'preposition',
                'ADP': 'preposition',
                'CONJUNCTION': 'conjunction',
                'CCONJ': 'conjunction',
                'SCONJ': 'conjunction',
                'INTERJECTION': 'interjection',
                'INTJ': 'interjection',
                'PART': 'adverb', // Particles
                'NUM': 'noun', // Numbers
                'NUMERAL': 'noun',
                'PUNCT': 'other', // Punctuation
                'SYM': 'other', // Symbols
                'MISC': 'other',
                'OTHER': 'other'
            };
            return mapping[upperPos] || 'other';
        }

        // Process text with OpenAI API
        async function processTextWithOpenAI(text) {
            console.log('processTextWithOpenAI called with text:', text.substring(0, 100));
            const analysis = await analyzeTextWithOpenAI(text);
            if (!analysis || !Array.isArray(analysis)) {
                console.error('Failed to get valid analysis from OpenAI');
                return null;
            }
            
            console.log('OpenAI analysis received:', analysis.length, 'items');
            
            // Convert OpenAI analysis to legacy format
            const words = text.split(/\s+/).filter(w => w.trim());
            const processedWords = [];
            
            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const openAIData = analysis[i] || {};
                
                // Map OpenAI POS to legacy POS
                const legacyPos = mapOpenAIPosToLegacy(openAIData.pos);
                
                processedWords.push({
                    text: word,
                    pos: legacyPos,
                    uposType: openAIData.pos || 'MISC',
                    isName: openAIData.isName || false,
                    syntacticRole: openAIData.syntacticRole || null,
                    semanticRole: openAIData.semanticRole || null,
                    isNucleus: openAIData.isNucleus || false,
                    isOntological: openAIData.isOntological || false,
                    isComparison: openAIData.isComparison || false,
                    closureLevel: openAIData.closureLevel || null,
                    // Keep original OpenAI data for reference
                    openAIData: openAIData
                });
            }
            
            return processedWords;
        }

        // Fallback to legacy analysis if OpenAI fails
        async function analyzeText(text) {
            console.log('analyzeText called with text:', text.substring(0, 100));
            
            // Try OpenAI first
            const openAIResult = await processTextWithOpenAI(text);
            if (openAIResult) {
                console.log('Using OpenAI analysis');
                return openAIResult;
            }
            
            // Fallback to main analysis function
            console.warn('OpenAI analysis failed, falling back to main analysis');
            return await analyzeText(text);
        }

        // Note: analyzeText function is defined below (after helper functions)
        
        // Helper: Get word frequency in text (case-insensitive)

        function getWordFrequency(tokens, index) {
            if (index < 0 || index >= tokens.length) return 0;
            const currentToken = tokens[index];
            if (!currentToken) return 0;
            
            const surface = (currentToken.surface || '').toLowerCase().trim();
            if (!surface) return 0;
            
            let count = 0;
            tokens.forEach(token => {
                const tokenSurface = (token.surface || '').toLowerCase().trim();
                if (tokenSurface === surface) {
                    count++;
                }
            });
            
            return count;
        }
        
        // Helper: Get rarity multiplier based on word frequency and text length
        // Cuanto menos aparezca una palabra mÃ¡s valor tiene a medida que el texto es mÃ¡s grande
        function getRarityMultiplier(tokens, index, totalTokens, tokenType) {
            // Si el texto tiene menos de 10 palabras, la rareza prÃ¡cticamente no tiene efecto
            if (totalTokens < 10) {
                return 1.0;
            }
            
            const frequency = getWordFrequency(tokens, index);
            
            // Si la palabra aparece mÃ¡s de una vez, no hay boost de rareza
            if (frequency > 1) {
                return 1.0;
            }
            
            // Si aparece solo 1 vez (palabra Ãºnica/no repetida)
            // El boost aumenta con el tamaÃ±o del texto
            // Para textos de ~500 palabras, palabras Ãºnicas tienen boost significativo
            
            // Calcular el boost basado en el tamaÃ±o del texto
            // Textos mÃ¡s grandes = boost mÃ¡s alto para palabras Ãºnicas
            let baseBoost = 1.0;
            
            if (totalTokens >= 500) {
                // Texto grande (~500 palabras): boost mÃ¡ximo
                if (tokenType === 'NOUN' || tokenType === 'NAME') {
                    // Sustantivos: Ã—5 a Ã—10
                    baseBoost = 7.5; // Valor medio entre 5 y 10
                } else if (tokenType === 'VERB' || tokenType === 'AUX' || tokenType === 'VERB_AUXILIARY' || tokenType === 'VERB_MODAL') {
                    // Verbos: similar a sustantivos (siguen a sustantivos)
                    baseBoost = 7.0; // Ligeramente menos que sustantivos
                } else if (tokenType === 'ADJ' || tokenType === 'ADJECTIVE') {
                    // Adjetivos: tambiÃ©n tienen boost alto
                    baseBoost = 6.5; // Similar a verbos
                } else {
                    // Otros tipos: Ã—3 a Ã—1.5
                    baseBoost = 2.25; // Valor medio entre 3 y 1.5
                }
            } else if (totalTokens >= 200) {
                // Texto mediano: boost moderado
                if (tokenType === 'NOUN' || tokenType === 'NAME') {
                    baseBoost = 5.0;
                } else if (tokenType === 'VERB' || tokenType === 'AUX' || tokenType === 'VERB_AUXILIARY' || tokenType === 'VERB_MODAL') {
                    baseBoost = 4.5;
                } else if (tokenType === 'ADJ' || tokenType === 'ADJECTIVE') {
                    baseBoost = 4.0;
                } else {
                    baseBoost = 2.0;
                }
            } else if (totalTokens >= 50) {
                // Texto pequeÃ±o-mediano: boost bajo
                if (tokenType === 'NOUN' || tokenType === 'NAME') {
                    baseBoost = 3.0;
                } else if (tokenType === 'VERB' || tokenType === 'AUX' || tokenType === 'VERB_AUXILIARY' || tokenType === 'VERB_MODAL') {
                    baseBoost = 2.5;
                } else if (tokenType === 'ADJ' || tokenType === 'ADJECTIVE') {
                    baseBoost = 2.0;
                } else {
                    baseBoost = 1.5;
                }
            } else if (totalTokens >= 10) {
                // Texto pequeÃ±o: boost mÃ­nimo
                if (tokenType === 'NOUN' || tokenType === 'NAME') {
                    baseBoost = 1.5;
                } else if (tokenType === 'VERB' || tokenType === 'AUX' || tokenType === 'VERB_AUXILIARY' || tokenType === 'VERB_MODAL') {
                    baseBoost = 1.3;
                } else if (tokenType === 'ADJ' || tokenType === 'ADJECTIVE') {
                    baseBoost = 1.2;
                } else {
                    baseBoost = 1.1;
                }
            }
            
            return baseBoost;
        }
        
        async function analyzeText(text) {
            console.log('=== OPENAI API: analyzeText called ===');
            console.log('Text:', text.substring(0, 100) + (text.length > 100 ? '...' : ''));
            
            // Detect text structure type
            textStructureType = detectTextStructure(text);
            console.log('Detected text structure type:', textStructureType);
            updateLoadingProgress(10); // Tokenization started
            
            // Step 1: Tokenize FIRST with splitter characters (apply our splitting rules)
            let tokens = tokenizeWithSplitters(text);
            console.log(`Tokenized into ${tokens.length} tokens after splitter rules`);
            updateLoadingProgress(15); // Tokenization complete
            
            if (tokens.length === 0) {
                console.error('No tokens found after tokenization!');
                analyzedWords = [];
                return analyzedWords;
            }
            
            // Limit to 500 tokens maximum
            const MAX_TOKENS = 500;
            tokens = tokens.slice(0, MAX_TOKENS);
            updateLoadingProgress(20); // Token limit applied
            
            // Step 2: Send the complete original text to OpenAI for contextual analysis
            // This allows OpenAI to analyze each word in its proper context
            const textForOpenAI = text; // Use original text, not tokenized version
            console.log('Text for OpenAI (first 200 chars):', textForOpenAI.substring(0, 200));
            updateLoadingProgress(25); // Text prepared
            
            // Step 3: Call OpenAI API with complete text for contextual analysis
            console.log('Calling OpenAI API for POS analysis with full context...');
            updateLoadingProgress(30); // API call started
            const openAIAnalysis = await analyzeTextWithOpenAI(textForOpenAI, tokens);
            updateLoadingProgress(35); // API call complete
            
            if (!openAIAnalysis || !Array.isArray(openAIAnalysis)) {
                console.error('OpenAI API analysis failed or returned invalid data');
                console.error('openAIAnalysis type:', typeof openAIAnalysis);
                console.error('openAIAnalysis value:', openAIAnalysis);
                // Fallback: mark all as MISC
                analyzedWords = tokens.map((token, idx) => ({
                    text: token.surface || '',
                    pos: 'other',
                    frequency: 1,
                    normalizedFrequency: 1,
                    isSerEstar: false,
                    isName: false,
                    isNumber: false,
                    wasOriginallyOther: true,
                    uposType: 'MISC',
                    name_group: null
                }));
                console.log(`Fallback: Created ${analyzedWords.length} words marked as 'other'`);
                return analyzedWords;
            }
            
            console.log(`OpenAI returned analysis for ${openAIAnalysis.length} words`);
            
            // Step 4: Map OpenAI analysis to our tokens
            // Match tokens to OpenAI words by comparing actual word text (case-insensitive)
            const tokenAnalysis = [];
            const usedOpenAIIndices = new Set();
            
            console.log('Matching tokens to OpenAI analysis. Tokens:', tokens.length, 'OpenAI words:', openAIAnalysis.length);
            
            // Match tokens to OpenAI words by text comparison
            for (let tokenIdx = 0; tokenIdx < tokens.length; tokenIdx++) {
                const token = tokens[tokenIdx];
                const tokenSurface = token.surface || '';
                const tokenSurfaceLower = tokenSurface.toLowerCase().trim();
                
                // Try to find matching OpenAI word by text comparison
                let aiWord = null;
                let aiWordIndex = -1;
                
                // First, try sequential match (most common case)
                if (tokenIdx < openAIAnalysis.length && !usedOpenAIIndices.has(tokenIdx)) {
                    const candidate = openAIAnalysis[tokenIdx];
                    const candidateText = (candidate.word || '').trim().toLowerCase();
                    if (candidateText === tokenSurfaceLower) {
                        aiWord = candidate;
                        aiWordIndex = tokenIdx;
                        usedOpenAIIndices.add(tokenIdx);
                    }
                }
                
                // If sequential match failed, search for matching word
                if (!aiWord) {
                    for (let aiIdx = 0; aiIdx < openAIAnalysis.length; aiIdx++) {
                        if (usedOpenAIIndices.has(aiIdx)) continue;
                        const candidate = openAIAnalysis[aiIdx];
                        const candidateText = (candidate.word || '').trim().toLowerCase();
                        if (candidateText === tokenSurfaceLower) {
                            aiWord = candidate;
                            aiWordIndex = aiIdx;
                            usedOpenAIIndices.add(aiIdx);
                            break;
                        }
                    }
                }
                
                // If still no match, use sequential index as fallback
                if (!aiWord && tokenIdx < openAIAnalysis.length) {
                    aiWord = openAIAnalysis[tokenIdx];
                    aiWordIndex = tokenIdx;
                    console.warn(`Token "${tokenSurface}" at index ${tokenIdx} matched by position (no text match found)`);
                }
                
                // Extract all detailed fields from OpenAI response
                tokenAnalysis.push({
                    tokenIndex: tokenIdx,
                    analysis: aiWord || null,
                    pos: aiWord ? mapOpenAIPosToLegacy(aiWord.pos || 'MISC') : 'other',
                    isName: aiWord ? (aiWord.isName === true || aiWord.pos === 'NAME') : false,
                    tense: aiWord ? (aiWord.tense || null) : null,
                    // Extract detailed subclassification
                    subclass: aiWord ? (aiWord.subclass || null) : null,
                    mood: aiWord ? (aiWord.mood || null) : null,
                    person: aiWord ? (aiWord.person || null) : null,
                    possessive: aiWord ? (aiWord.possessive || false) : false,
                    semanticType: aiWord ? (aiWord.semanticType || null) : null,
                    // Extract syntactic context
                    syntacticRole: aiWord ? (aiWord.syntacticRole || null) : null,
                    isNucleus: aiWord ? (aiWord.isNucleus !== undefined ? aiWord.isNucleus : null) : null,
                    // Extract semantic context
                    semanticRole: aiWord ? (aiWord.semanticRole || null) : null,
                    isOntological: aiWord ? (aiWord.isOntological !== undefined ? aiWord.isOntological : false) : false,
                    isComparison: aiWord ? (aiWord.isComparison !== undefined ? aiWord.isComparison : false) : false,
                    closureLevel: aiWord ? (aiWord.closureLevel || null) : null
                });
                
                if (tokenIdx < 5 && aiWord) {
                    const aiWordText = (aiWord.word || '').trim();
                    console.log(`Token ${tokenIdx} "${tokenSurface}" -> OpenAI "${aiWordText}" (${aiWord.pos})`);
                }
            }
            
            // Handle case where there are more tokens than OpenAI words
            if (tokens.length > openAIAnalysis.length) {
                console.warn(`Warning: ${tokens.length - openAIAnalysis.length} tokens have no corresponding OpenAI analysis`);
            }
            
            // Handle case where there are more OpenAI words than tokens (shouldn't happen, but handle gracefully)
            if (openAIAnalysis.length > tokens.length) {
                console.warn(`Warning: ${openAIAnalysis.length - tokens.length} OpenAI words have no corresponding token`);
            }
            
            console.log(`Mapped ${tokenAnalysis.filter(ta => ta.analysis !== null).length} tokens successfully out of ${tokenAnalysis.length}`);
            updateLoadingProgress(37); // Token mapping complete
            
            // Step 4: Apply hard rules for numbers (override OpenAI if needed, mark as NAME)
            tokenAnalysis.forEach((item, idx) => {
                const token = tokens[item.tokenIndex];
                const surface = token.surface || '';
                const trimmed = surface.trim();
                
                // Pure numbers: "1", "123", "11111" => always NAME
                const isPureNumber = /^[0-9]+$/.test(trimmed);
                
                // Numbers with separators: "1.23", "12-34" => always NAME
                const isNumberWithSeparators = /^[0-9]+([.,:/\-][0-9]+)+$/.test(trimmed);
                
                // Words containing numbers: "h2o", "word123", "r2d2" => always NAME
                const hasNumbers = /[0-9]/.test(surface);
                
                if (isPureNumber || isNumberWithSeparators || hasNumbers) {
                    item.pos = 'noun';
                    item.isName = true;
                    // Override OpenAI analysis for numbers
                    if (item.analysis) {
                        item.analysis.pos = 'NAME';
                        item.analysis.isName = true;
                    }
                }
                
                // Words containing - . _ @ are compound names (should NOT be split)
                const isCompoundName = /[-._@]/.test(trimmed);
                if (isCompoundName) {
                    item.pos = 'noun';
                    item.isName = true;
                    // Override OpenAI analysis for compound names
                    if (item.analysis) {
                        item.analysis.pos = 'NAME';
                        item.analysis.isName = true;
                    }
                }
                
                // Single letters are treated as names
                if (trimmed.length === 1 && /[a-zA-Z]/.test(trimmed)) {
                    item.pos = 'noun';
                    item.isName = true;
                    // Override OpenAI analysis for single letters
                    if (item.analysis) {
                        item.analysis.pos = 'NAME';
                        item.analysis.isName = true;
                    }
                }
            });
            
            // Step 4a: ENHANCED NAME DETECTION - Detect names even if OpenAI misses them (especially lowercase names)
            // CRITICAL: This runs BEFORE the correction step to ensure names are detected based on context
            // AGGRESSIVE DETECTION: If a word appears after "is"/"am"/"are" and before another potential name, mark both as names
            
            // First pass: Mark names after "is", "am", "are", "was", "were" if they don't look like common words
            tokenAnalysis.forEach((item, idx) => {
                const token = tokens[item.tokenIndex];
                const surface = token.surface || '';
                const trimmed = surface.trim();
                const cleanSurface = trimmed.toLowerCase();
                
                // Skip if already marked as name
                if (item.isName === true) return;
                
                // Skip if it's a pronoun
                if (item.pos === 'pronoun') return;
                
                // Skip common words that are never names
                const commonWordsNeverNames = new Set([
                    'the', 'a', 'an', 'and', 'or', 'but', 'if', 'because', 'when', 'where', 'what', 'who', 'which', 'that',
                    'this', 'these', 'those', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
                    'do', 'does', 'did', 'will', 'would', 'should', 'could', 'may', 'might', 'must', 'can', 'shall',
                    'to', 'of', 'in', 'on', 'at', 'for', 'with', 'by', 'from', 'into', 'onto', 'upon', 'over', 'under',
                    'name', 'last', 'first', 'middle',
                    // Adverbs that are never names
                    'how', 'why', 'when', 'where', 'here', 'there', 'now', 'then', 'very', 'much', 'more', 'most', 'less', 'least',
                    'well', 'better', 'best', 'worse', 'worst', 'so', 'too', 'also', 'just', 'only', 'even', 'still', 'yet', 'already',
                    'always', 'never', 'often', 'sometimes', 'usually', 'rarely', 'seldom', 'hardly', 'barely', 'quite', 'rather',
                    'really', 'actually', 'probably', 'possibly', 'certainly', 'definitely', 'absolutely', 'exactly', 'approximately',
                    // Verbs that are never names
                    'live', 'lives', 'lived', 'living', 'go', 'goes', 'went', 'gone', 'going', 'come', 'comes', 'came', 'coming',
                    'see', 'sees', 'saw', 'seen', 'seeing', 'know', 'knows', 'knew', 'known', 'knowing', 'think', 'thinks', 'thought', 'thinking',
                    'get', 'gets', 'got', 'gotten', 'getting', 'make', 'makes', 'made', 'making', 'take', 'takes', 'took', 'taken', 'taking',
                    'give', 'gives', 'gave', 'given', 'giving', 'say', 'says', 'said', 'saying', 'tell', 'tells', 'told', 'telling',
                    'work', 'works', 'worked', 'working', 'play', 'plays', 'played', 'playing', 'read', 'reads', 'reading',
                    'write', 'writes', 'wrote', 'written', 'writing', 'learn', 'learns', 'learned', 'learning', 'teach', 'teaches', 'taught', 'teaching'
                ]);
                
                if (commonWordsNeverNames.has(cleanSurface)) return;
                
                // Common adjectives/adverbs that are NOT names
                const commonAdjectives = new Set([
                    'good', 'bad', 'nice', 'big', 'small', 'old', 'new', 'young', 'red', 'blue', 'green', 'black', 'white', 'yellow',
                    'very', 'much', 'more', 'most', 'less', 'least', 'well', 'better', 'best', 'worse', 'worst',
                    'how', 'why', 'when', 'where', 'here', 'there', 'now', 'then', 'so', 'too', 'also', 'just', 'only', 'even', 'still', 'yet', 'already',
                    'always', 'never', 'often', 'sometimes', 'usually', 'rarely', 'seldom', 'hardly', 'barely', 'quite', 'rather',
                    'really', 'actually', 'probably', 'possibly', 'certainly', 'definitely', 'absolutely', 'exactly', 'approximately'
                ]);
                
                // Check context: if previous word is "name", "is", "am", "are", "was", "were", "my", "his", "her", etc.
                let hasNameContext = false;
                let prevIsToBe = false;
                if (idx > 0) {
                    const prevItem = tokenAnalysis[idx - 1];
                    const prevToken = tokens[prevItem?.tokenIndex];
                    const prevSurface = (prevToken?.surface || '').toLowerCase().trim();
                    const nameContextWords = ['name', 'is', 'am', 'are', 'was', 'were', 'my', 'his', 'her', 'its', 'our', 'their', 'i', 'he', 'she', 'we', 'they'];
                    hasNameContext = nameContextWords.includes(prevSurface);
                    prevIsToBe = ['is', 'am', 'are', 'was', 'were'].includes(prevSurface);
                }
                
                // Check if next word exists and what it is
                let nextExists = false;
                let nextIsName = false;
                let nextIsCommon = false;
                let nextSurface = '';
                if (idx < tokenAnalysis.length - 1) {
                    nextExists = true;
                    const nextItem = tokenAnalysis[idx + 1];
                    const nextToken = tokens[nextItem?.tokenIndex];
                    nextSurface = (nextToken?.surface || '').trim();
                    const nextCleanSurface = nextSurface.toLowerCase();
                    nextIsName = nextItem?.isName === true;
                    nextIsCommon = commonWordsNeverNames.has(nextCleanSurface) || commonAdjectives.has(nextCleanSurface);
                }
                
                // Check if previous word is a name (already marked)
                let prevIsName = false;
                if (idx > 0) {
                    prevIsName = tokenAnalysis[idx - 1]?.isName === true;
                }
                
                // AGGRESSIVE DETECTION RULES:
                // 1. After "is"/"am"/"are" AND next word is NOT a common word â†’ this is likely a name
                // 2. After "is"/"am"/"are" AND next word is also a potential name â†’ both are names (compound name)
                // 3. Previous word is a name AND this word doesn't look like a common word â†’ compound name continuation
                // 4. After "name" â†’ likely a name
                
                const looksLikeCommonWord = commonWordsNeverNames.has(cleanSurface) || commonAdjectives.has(cleanSurface);
                
                let shouldBeName = false;
                
                if (prevIsToBe && !looksLikeCommonWord) {
                    // After "is"/"am"/"are" - likely a name unless it's clearly an adjective
                    if (!commonAdjectives.has(cleanSurface)) {
                        shouldBeName = true;
                        console.log(`[ENHANCED NAME DETECTION] Marking "${trimmed}" as NAME (after "to be" verb)`);
                    }
                } else if (hasNameContext && !looksLikeCommonWord) {
                    // After "name", "my", "his", etc.
                    shouldBeName = true;
                    console.log(`[ENHANCED NAME DETECTION] Marking "${trimmed}" as NAME (name context)`);
                } else if (prevIsName && !looksLikeCommonWord && cleanSurface.length > 2) {
                    // Previous word is a name - compound name continuation
                    shouldBeName = true;
                    console.log(`[ENHANCED NAME DETECTION] Marking "${trimmed}" as NAME (compound name continuation)`);
                } else if (prevIsToBe && nextExists && !nextIsCommon && !nextIsName && !looksLikeCommonWord) {
                    // After "is" and before a word that's not common - both might be names
                    shouldBeName = true;
                    console.log(`[ENHANCED NAME DETECTION] Marking "${trimmed}" as NAME (after "to be", before potential name)`);
                }
                
                if (shouldBeName) {
                    // Additional check: make sure it's not a common capitalized word
                    const isCommonCapitalized = ['The', 'A', 'An', 'This', 'That', 'These', 'Those', 'I', 'He', 'She', 'We', 'They'].includes(trimmed);
                    
                    if (!isCommonCapitalized) {
                        item.isName = true;
                        item.pos = 'noun';
                        if (item.analysis) {
                            item.analysis.pos = 'NAME';
                            item.analysis.isName = true;
                        }
                        console.log(`[ENHANCED NAME DETECTION] âœ“ Marked "${trimmed}" as NAME`);
                    }
                }
            });
            
            // Second pass: If we marked a name, check if the next word should also be a name (compound name)
            tokenAnalysis.forEach((item, idx) => {
                if (item.isName === true && idx < tokenAnalysis.length - 1) {
                    const nextItem = tokenAnalysis[idx + 1];
                    const nextToken = tokens[nextItem?.tokenIndex];
                    const nextSurface = (nextToken?.surface || '').trim();
                    const nextCleanSurface = nextSurface.toLowerCase();
                    
                    // Skip if next is already a name
                    if (nextItem.isName === true) return;
                    
                    // Skip if next is a pronoun
                    if (nextItem.pos === 'pronoun') return;
                    
                    // Skip common words
                    const commonWordsNeverNames = new Set([
                        'the', 'a', 'an', 'and', 'or', 'but', 'if', 'because', 'when', 'where', 'what', 'who', 'which', 'that',
                        'this', 'these', 'those', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
                        'do', 'does', 'did', 'will', 'would', 'should', 'could', 'may', 'might', 'must', 'can', 'shall',
                        'to', 'of', 'in', 'on', 'at', 'for', 'with', 'by', 'from', 'into', 'onto', 'upon', 'over', 'under',
                        'good', 'bad', 'nice', 'big', 'small', 'old', 'new', 'young', 'red', 'blue', 'green'
                    ]);
                    
                    if (commonWordsNeverNames.has(nextCleanSurface)) return;
                    
                    // If current is a name and next word doesn't look like a common word, mark next as name too (compound name)
                    if (nextCleanSurface.length > 2 && !['the', 'a', 'an', 'is', 'are', 'was', 'were'].includes(nextCleanSurface)) {
                        nextItem.isName = true;
                        nextItem.pos = 'noun';
                        if (nextItem.analysis) {
                            nextItem.analysis.pos = 'NAME';
                            nextItem.analysis.isName = true;
                        }
                        console.log(`[ENHANCED NAME DETECTION] âœ“ Marked "${nextSurface}" as NAME (compound name continuation after "${tokens[item.tokenIndex]?.surface}")`);
                    }
                }
            });
            
            // Step 4b: POST-PROCESSING VALIDATION - Fix words incorrectly marked as names due to capitalization
            // CRITICAL: If OpenAI says a word is NOT a NAME (has a different POS), but it's marked as NAME, correct it
            // BUT: NEVER correct names that were detected by context (Step 4a) - trust context over OpenAI for names
            // This handles cases where capitalization might have influenced the initial marking
            
            tokenAnalysis.forEach((item, idx) => {
                const token = tokens[item.tokenIndex];
                const surface = token.surface || '';
                const cleanSurface = surface.toLowerCase().trim();
                
                // Check if word is entirely uppercase
                const isAllUppercase = surface === surface.toUpperCase() && surface !== surface.toLowerCase();
                
                // CRITICAL CHECK: If OpenAI analysis says it's NOT a NAME (has a different POS), but item.isName is true
                // ONLY correct if it's clearly NOT a name based on context
                if (item.isName && item.analysis && item.analysis.pos) {
                    const openAIPos = item.analysis.pos.toUpperCase();
                    
                    // Check if this looks like a proper name based on context
                    let hasNameContext = false;
                    let prevIsToBe = false;
                    if (idx > 0) {
                        const prevItem = tokenAnalysis[idx - 1];
                        const prevToken = tokens[prevItem?.tokenIndex];
                        const prevSurface = (prevToken?.surface || '').toLowerCase().trim();
                        const nameContextWords = ['name', 'is', 'am', 'are', 'was', 'were', 'my', 'his', 'her', 'its', 'our', 'their'];
                        hasNameContext = nameContextWords.includes(prevSurface);
                        prevIsToBe = ['is', 'am', 'are', 'was', 'were'].includes(prevSurface);
                    }
                    
                    // Check if previous word is a name (might be part of compound name)
                    let prevIsName = false;
                    if (idx > 0) {
                        prevIsName = tokenAnalysis[idx - 1]?.isName === true;
                    }
                    
                    // Check if next word is a name (compound name)
                    let nextIsName = false;
                    if (idx < tokenAnalysis.length - 1) {
                        nextIsName = tokenAnalysis[idx + 1]?.isName === true;
                    }
                    
                    // Common words that should NEVER be names
                    const commonWordsNeverNames = new Set([
                        'the', 'a', 'an', 'and', 'or', 'but', 'if', 'because', 'when', 'where', 'what', 'who', 'which', 'that',
                        'this', 'these', 'those', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
                        'do', 'does', 'did', 'will', 'would', 'should', 'could', 'may', 'might', 'must', 'can', 'shall',
                        'good', 'bad', 'nice', 'big', 'small', 'old', 'new', 'young', 'red', 'blue', 'green',
                        // Adverbs that are never names
                        'how', 'why', 'here', 'there', 'now', 'then', 'very', 'much', 'more', 'most', 'less', 'least',
                        'well', 'better', 'best', 'worse', 'worst', 'so', 'too', 'also', 'just', 'only', 'even', 'still', 'yet', 'already',
                        'always', 'never', 'often', 'sometimes', 'usually', 'rarely', 'seldom', 'hardly', 'barely', 'quite', 'rather',
                        'really', 'actually', 'probably', 'possibly', 'certainly', 'definitely', 'absolutely', 'exactly', 'approximately',
                        // Verbs that are never names
                        'live', 'lives', 'lived', 'living', 'go', 'goes', 'went', 'gone', 'going', 'come', 'comes', 'came', 'coming'
                    ]);
                    const isCommonWord = commonWordsNeverNames.has(cleanSurface);
                    
                    // CRITICAL: Never correct names that were identified by:
                    // 1. Numbers (pure numbers or words with numbers)
                    // 2. Single letters
                    // 3. Compound names (words with - . _ @)
                    const isNumber = /^\d+([.,:/\-]\d+)*$/.test(surface);
                    const isSingleLetter = surface.length === 1 && /[a-zA-Z]/.test(surface);
                    const hasNumbers = /[0-9]/.test(surface) && /[a-zA-Z]/.test(surface);
                    const isCompoundName = /[-._@]/.test(surface);
                    const isNameByRule = isNumber || isSingleLetter || hasNumbers || isCompoundName;
                    
                    // If OpenAI says it's NOT a NAME (any POS except NAME), trust OpenAI ONLY if:
                    // 1. It's a common word that should never be a name
                    // 2. It doesn't have name context
                    // 3. Previous word is not a name
                    // 4. Next word is not a name
                    // 5. AND it's not a name by rule (numbers, letters, compound names)
                    if (openAIPos !== 'NAME' && openAIPos !== 'PROPN') {
                        // Never correct names identified by rules (numbers, letters, compound names)
                        if (isNameByRule) {
                            console.log(`[NAME DETECTION] Keeping "${surface}" as NAME (identified by rule: number/letter/compound)`);
                            return; // Keep as name
                        }
                        
                        // Only correct if it's clearly not a name
                        if (isCommonWord || (!hasNameContext && !prevIsName && !nextIsName && !prevIsToBe)) {
                            // OpenAI got it right - use its POS
                            item.pos = mapOpenAIPosToLegacy(openAIPos);
                            item.isName = false;
                            if (item.analysis) {
                                item.analysis.isName = false;
                            }
                            console.log(`Corrected "${surface}": was marked as NAME but OpenAI says ${openAIPos}, corrected to ${item.pos}`);
                        } else {
                            // Keep it as name - has name context, previous/next is name, or after "to be"
                            console.log(`[NAME DETECTION] Keeping "${surface}" as NAME despite OpenAI saying ${openAIPos} (has name context or compound name)`);
                        }
                    }
                }
                
                // Additional check: Common words that should NEVER be names, regardless of capitalization
                const commonWordsNeverNames = new Set([
                    'the', 'a', 'an', 'and', 'or', 'but', 'if', 'because', 'when', 'where', 'what', 'who', 'which', 'that',
                    'this', 'these', 'those', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
                    'do', 'does', 'did', 'will', 'would', 'should', 'could', 'may', 'might', 'must', 'can', 'shall',
                    'to', 'of', 'in', 'on', 'at', 'for', 'with', 'by', 'from', 'into', 'onto', 'upon', 'over', 'under',
                    'above', 'below', 'between', 'among', 'through', 'during', 'before', 'after', 'since', 'until',
                    'while', 'as', 'than', 'so', 'too', 'very', 'much', 'more', 'most', 'less', 'least', 'all', 'some',
                    'any', 'each', 'every', 'both', 'either', 'neither', 'one', 'two', 'three', 'first', 'second', 'third',
                    'i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them', 'my', 'your', 'his',
                    'her', 'its', 'our', 'their', 'mine', 'yours', 'hers', 'ours', 'theirs', 'myself', 'yourself',
                    'himself', 'herself', 'itself', 'ourselves', 'yourselves', 'themselves', 'who', 'whom', 'whose',
                    'which', 'what', 'where', 'when', 'why', 'how', 'yes', 'no', 'not', 'nor', 'here', 'there', 'now',
                    'then', 'today', 'tomorrow', 'yesterday', 'always', 'never', 'often', 'sometimes', 'usually',
                    // Common adverbs that should never be names
                    'halfway', 'straight', 'quickly', 'slowly', 'carefully', 'suddenly', 'immediately', 'recently',
                    'already', 'still', 'yet', 'just', 'only', 'even', 'also', 'too', 'again', 'once', 'twice',
                    'here', 'there', 'everywhere', 'nowhere', 'somewhere', 'anywhere', 'up', 'down', 'away', 'back',
                    'forward', 'ahead', 'behind', 'inside', 'outside', 'above', 'below', 'near', 'far', 'close',
                    'well', 'badly', 'hard', 'fast', 'slow', 'early', 'late', 'soon', 'now', 'then', 'today',
                    'yesterday', 'tomorrow', 'always', 'never', 'often', 'sometimes', 'usually', 'rarely', 'seldom'
                ]);
                
                const isCommonWord = commonWordsNeverNames.has(cleanSurface);
                
                // CRITICAL: Never correct names that were identified by rules (numbers, letters, compound names)
                const isNumber = /^\d+([.,:/\-]\d+)*$/.test(surface);
                const isSingleLetter = surface.length === 1 && /[a-zA-Z]/.test(surface);
                const hasNumbers = /[0-9]/.test(surface) && /[a-zA-Z]/.test(surface);
                const isCompoundName = /[-._@]/.test(surface);
                const isNameByRule = isNumber || isSingleLetter || hasNumbers || isCompoundName;
                
                // If marked as NAME but it's a common word in uppercase, correct it
                // BUT: Never correct if it's a name by rule (numbers, letters, compound names)
                if (item.isName && isAllUppercase && isCommonWord && !isNameByRule) {
                    // Try to infer POS from word type
                    if (['the', 'a', 'an'].includes(cleanSurface)) {
                        item.pos = 'determiner';
                        item.isName = false;
                    } else if (['and', 'or', 'but'].includes(cleanSurface)) {
                        item.pos = 'conjunction';
                        item.isName = false;
                    } else if (['is', 'are', 'was', 'were', 'be', 'been', 'being'].includes(cleanSurface)) {
                        item.pos = 'verb';
                        item.isName = false;
                    } else if (['to', 'of', 'in', 'on', 'at', 'for', 'with', 'by', 'from', 'into', 'onto', 'upon'].includes(cleanSurface)) {
                        item.pos = 'preposition';
                        item.isName = false;
                    } else {
                        // Default: mark as adverb if it's a common word that shouldn't be a name
                        item.pos = 'adverb';
                        item.isName = false;
                    }
                    
                    if (item.analysis) {
                        item.analysis.isName = false;
                        item.analysis.pos = item.pos.toUpperCase();
                    }
                    console.log(`Corrected "${surface}": common word in uppercase incorrectly marked as NAME, corrected to ${item.pos}`);
                }
            });
            
            // Step 5: Group compound names - COMPLETELY REBUILT LOGIC
            // COMPOUND NAMES DEFINITION:
            // - A compound name is composed of 2+ consecutive names (name+name, name+name+name, etc.)
            // - Names must be DIRECTLY consecutive in tokenAnalysis (no other analyzed items between them)
            // - A compound name acts as ONE SINGLE WORD (namename, ignoring spaces)
            // - Example: "Ian Martin" = compound name (2 parts), interpreted as "ianmartin"
            // - Example: "Ian Martin GonzÃ¡lez" = compound name (3 parts), interpreted as "ianmartingonzalez"
            // - Example: "elena carbajal" = compound name (2 parts), even without capitalization
            
            const nameGroups = [];
            let currentNameGroup = null;
            
            console.log(`[COMPOUND RECOGNITION] Starting compound name recognition. Total tokenAnalysis items: ${tokenAnalysis.length}`);
            
            // CRITICAL FIX: Use tokenAnalysis index directly, not tokenIndex
            // tokenAnalysis is already in order, and analyzedWords will be created by mapping tokenAnalysis
            // So we can use the index in tokenAnalysis directly as the index for analyzedWords
            tokenAnalysis.forEach((item, analyzedIdx) => {
                // Check if this is a NAME (not pronoun)
                const isName = item.isName === true && item.pos !== 'pronoun';
                
                if (isName) {
                    if (!currentNameGroup) {
                        // Start a new potential compound name group
                        currentNameGroup = {
                            id: `NG${nameGroups.length + 1}`,
                            indices: [analyzedIdx], // Use analyzedIdx directly
                            startIndex: analyzedIdx
                        };
                        const token = tokens[item.tokenIndex];
                        console.log(`[COMPOUND RECOGNITION] Starting group ${currentNameGroup.id} with "${token?.surface}" at analyzedIdx ${analyzedIdx} (tokenIndex ${item.tokenIndex})`);
                    } else {
                        // Check if this name is CONSECUTIVE to the last name in the group
                        // CRITICAL: Check if analyzedIdx is consecutive to the last index in the group
                        const lastAnalyzedIdx = currentNameGroup.indices[currentNameGroup.indices.length - 1];
                        const distance = analyzedIdx - lastAnalyzedIdx;
                        
                        if (distance === 1) {
                            // CONSECUTIVE in tokenAnalysis - add to current group (this is a compound name)
                            currentNameGroup.indices.push(analyzedIdx);
                            const names = currentNameGroup.indices.map(idx => {
                                const taItem = tokenAnalysis[idx];
                                return tokens[taItem?.tokenIndex]?.surface || '?';
                            }).join(' ');
                            console.log(`[COMPOUND RECOGNITION] Added "${tokens[item.tokenIndex]?.surface}" to group ${currentNameGroup.id} (consecutive in tokenAnalysis). Compound: "${names}"`);
                        } else {
                            // NOT consecutive in tokenAnalysis - save current group if it has 2+ names, then start new
                            if (currentNameGroup.indices.length >= 2) {
                                const names = currentNameGroup.indices.map(idx => {
                                    const taItem = tokenAnalysis[idx];
                                    return tokens[taItem?.tokenIndex]?.surface || '?';
                                }).join(' ');
                                console.log(`[COMPOUND RECOGNITION] Saving compound name "${names}" (${currentNameGroup.indices.length} parts)`);
                                nameGroups.push(currentNameGroup);
                            }
                            currentNameGroup = {
                                id: `NG${nameGroups.length + 1}`,
                                indices: [analyzedIdx], // Use analyzedIdx directly
                                startIndex: analyzedIdx
                            };
                            const token = tokens[item.tokenIndex];
                            console.log(`[COMPOUND RECOGNITION] Starting new group ${currentNameGroup.id} with "${token?.surface}" at analyzedIdx ${analyzedIdx} (tokenIndex ${item.tokenIndex})`);
                        }
                    }
                } else {
                    // Not a name - end current group if it has 2+ names
                    if (currentNameGroup && currentNameGroup.indices.length >= 2) {
                        const names = currentNameGroup.indices.map(idx => {
                            const taItem = tokenAnalysis[idx];
                            return tokens[taItem?.tokenIndex]?.surface || '?';
                        }).join(' ');
                        console.log(`[COMPOUND RECOGNITION] Saving compound name "${names}" (${currentNameGroup.indices.length} parts)`);
                        nameGroups.push(currentNameGroup);
                    }
                    currentNameGroup = null;
                }
            });
            
            // Don't forget the last group
            if (currentNameGroup && currentNameGroup.indices.length >= 2) {
                const names = currentNameGroup.indices.map(idx => {
                    const taItem = tokenAnalysis[idx];
                    return tokens[taItem?.tokenIndex]?.surface || '?';
                }).join(' ');
                console.log(`[COMPOUND RECOGNITION] Saving final compound name "${names}" (${currentNameGroup.indices.length} parts)`);
                nameGroups.push(currentNameGroup);
            }
            
            console.log(`[COMPOUND RECOGNITION] Found ${nameGroups.length} compound name groups`);
            
            // CRITICAL: The indices in nameGroups are now already analyzedWords indices!
            // No conversion needed - analyzedWords is created by mapping tokenAnalysis
            // So analyzedWords[idx] corresponds to tokenAnalysis[idx]
            
            // Store directly (indices are already correct)
            window.nameGroups = nameGroups;
            console.log(`[COMPOUND RECOGNITION] Stored ${nameGroups.length} compound name groups with analyzedWords indices`);
            
            // Step 6: Mark tokens with name group info
            nameGroups.forEach(group => {
                group.indices.forEach((analyzedIdx, pos) => {
                    // analyzedIdx is already the index in tokenAnalysis/analyzedWords
                    if (analyzedIdx >= 0 && analyzedIdx < tokenAnalysis.length) {
                        const analysisItem = tokenAnalysis[analyzedIdx];
                        if (analysisItem) {
                            analysisItem.nameGroup = group;
                            analysisItem.nameGroupRole = pos === 0 ? 'HEAD' : 'CONTINUATION';
                        }
                    }
                });
            });
            
            // Step 7: Calculate frequencies for legacy compatibility
            const wordFreq = {};
            tokens.forEach(token => {
                const cleanWord = (token.surface || '').toLowerCase();
                wordFreq[cleanWord] = (wordFreq[cleanWord] || 0) + 1;
            });
            const freqValues = Object.values(wordFreq);
            const maxFreq = freqValues.length > 0 ? Math.max(...freqValues) : 1;
            
            // Step 8: Convert to analyzedWords format (legacy compatibility)
            // Filter out punctuation tokens - they should not count as words
            analyzedWords = tokenAnalysis
                .filter((item, idx) => {
                    const token = tokens[item.tokenIndex];
                    const surface = token.surface || '';
                    // Exclude tokens that are pure punctuation (PUNCT upos or single punctuation character)
                    const isPunctToken = item.analysis?.pos === 'PUNCT' || 
                                        /^[.,;:!?()\[\]{}\-â€”â€“"'Â«Â»â€¹â€ºâ€žâ€š`Â´]+$/.test(surface.trim());
                    return !isPunctToken;
                })
                .map((item, idx) => {
                const token = tokens[item.tokenIndex];
                const surface = token.surface || '';
                const cleanWord = surface.toLowerCase();
                const pos = item.pos || 'other';
                const isName = item.isName && pos !== 'pronoun';
                const isNumberWord = /^[0-9]+([.,:/\-][0-9]+)*$/.test(surface.trim());
                const wasOriginallyOther = (item.pos === 'other' || item.pos === 'MISC') && pos !== 'pronoun';
                
                // Check if "to be" verb - CRITICAL: "is" is always "to be" (third person singular)
                // Also check for contractions with 's (it's, he's, she's, etc.) where 's = "is"
                const cleanSurface = surface.toLowerCase().trim();
                
                // Get previous token to check for separated contractions ('m, 's, 're)
                // Find the previous non-punctuation token in tokenAnalysis based on tokenIndex
                const currentTokenIndex = item.tokenIndex;
                let prevToken = null;
                for (let i = currentTokenIndex - 1; i >= 0; i--) {
                    const candidateToken = tokens[i];
                    const candidateSurface = candidateToken?.surface || '';
                    const isPunct = /^[.,;:!?()\[\]{}\-â€”â€“"'Â«Â»â€¹â€ºâ€žâ€š`Â´]+$/.test(candidateSurface.trim());
                    if (!isPunct) {
                        // Find the corresponding tokenAnalysis item
                        prevToken = tokenAnalysis.find(ta => ta.tokenIndex === i);
                        break;
                    }
                }
                const prevTokenSurface = prevToken && tokens[prevToken.tokenIndex] ? tokens[prevToken.tokenIndex].surface : null;
                
                const isSerEstarWord = isToBeVerb(surface, prevTokenSurface ? { surface: prevTokenSurface } : null) || 
                                      (item.analysis && item.analysis.pos === 'VERB_AUXILIARY' && 
                                       (cleanSurface === 'am' || cleanSurface === 'is' || 
                                        cleanSurface === 'are' || cleanSurface === 'was' || 
                                        cleanSurface === 'were' || cleanSurface === 'be' ||
                                        cleanSurface === 'been' || cleanSurface === 'being')) ||
                                      // Check for contractions: it's, he's, she's, that's, what's, who's (where 's = "is")
                                      (cleanSurface.endsWith("'s") && ['it', 'he', 'she', 'that', 'this', 'what', 'who'].includes(cleanSurface.split("'")[0])) ||
                                      (cleanSurface.endsWith("'re") && ['we', 'you', 'they'].includes(cleanSurface.split("'")[0])) ||
                                      (cleanSurface.endsWith("'m") && cleanSurface.split("'")[0] === 'i') ||
                                      // Check for separated contractions: "m" after "I", "s" after "it"/"he"/"she", "re" after "we"/"you"/"they"
                                      (cleanSurface === 'm' && prevTokenSurface && prevTokenSurface.toLowerCase().trim() === 'i') ||
                                      (cleanSurface === 's' && prevTokenSurface && ['it', 'he', 'she', 'that', 'this', 'what', 'who'].includes(prevTokenSurface.toLowerCase().trim())) ||
                                      (cleanSurface === 're' && prevTokenSurface && ['we', 'you', 'they'].includes(prevTokenSurface.toLowerCase().trim()));
                
                // Mark as part of compound name if applicable
                const isPartOfCompoundName = item.nameGroup && item.nameGroup.indices.length > 1;
                
                // CRITICAL: If isName is true, uposType must be 'NAME' (for proper value calculation)
                // This ensures names with numbers, special characters, or enhanced detection are correctly typed
                let uposType = item.analysis?.pos || 'MISC';
                if (isName && uposType !== 'NAME') {
                    uposType = 'NAME';
                    // Also update item.analysis if it exists
                    if (item.analysis) {
                        item.analysis.pos = 'NAME';
                        item.analysis.isName = true;
                    }
                }
                
                return {
                    text: surface,
                    pos: pos,
                    frequency: wordFreq[cleanWord] || 1,
                    normalizedFrequency: (wordFreq[cleanWord] || 1) / maxFreq,
                    isSerEstar: isSerEstarWord,
                    isName: isName,
                    isNumber: isNumberWord,
                    wasOriginallyOther: wasOriginallyOther,
                    // Store OpenAI info for reference - CRITICAL: Names must have uposType = 'NAME'
                    uposType: uposType,
                    name_group: item.nameGroup ? {
                        id: item.nameGroup.id,
                        role: item.nameGroupRole || 'NONE'
                    } : null,
                    compoundNameGroup: item.nameGroup || null,
                    isPartOfCompoundName: isPartOfCompoundName,
                    tense: item.tense || null,
                    // Store full OpenAI analysis for question and tense detection
                    analysis: item.analysis || null
                };
            });
            
            console.log(`analyzeText completed. Total analyzed words: ${analyzedWords.length}`);
            updateLoadingProgress(40); // Analysis complete
            return analyzedWords;
        }
        
        // Map OpenAI POS tags to legacy POS system (duplicate - kept for compatibility)
        function mapOpenAIPosToLegacy(openAIPos) {
            if (!openAIPos) return 'other';
            const upperPos = (openAIPos || '').toUpperCase().trim();
            const mapping = {
                'VERB': 'verb',
                'VERB_MODAL': 'verb',
                'VERB_AUXILIARY': 'verb',
                'AUX': 'verb',
                'NOUN': 'noun',
                'NAME': 'noun', // Names are treated as nouns in legacy system
                'PROPN': 'noun', // Proper noun
                'ADJECTIVE': 'adjective',
                'ADJ': 'adjective',
                'ADVERB': 'adverb',
                'ADV': 'adverb',
                'PRONOUN': 'pronoun',
                'PRON': 'pronoun',
                'DETERMINER': 'determiner',
                'DET': 'determiner',
                'PREPOSITION': 'preposition',
                'ADP': 'preposition',
                'CONJUNCTION': 'conjunction',
                'CCONJ': 'conjunction',
                'SCONJ': 'conjunction',
                'INTERJECTION': 'interjection',
                'INTJ': 'interjection',
                'PART': 'adverb', // Particles
                'NUM': 'noun', // Numbers
                'NUMERAL': 'noun',
                'PUNCT': 'other', // Punctuation
                'SYM': 'other', // Symbols
                'MISC': 'other',
                'OTHER': 'other'
            };
            return mapping[upperPos] || 'other';
        }

        // ==================== SISTEMA DE PUNTUACIÃ“N LINGÃœÃSTICA ====================
        // LINGUISTIC VALUE SCORING SYSTEM (Ontologicalâ€“Contextual Accumulation Model)
        // LEDGER-BASED SYSTEM: No averages, no normalization, no cap. Value is cumulative and additive.
        // Each word generates value independently, modified by context. Total = sum of all adjusted word values.
        
        // 1. BASE VALUE BY WORD TYPE
        function getBaseValue(word, pos) {
            const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
            
            // Pronouns
            if (pos === 'pronoun') {
                if (cleanWord === 'i' || cleanWord === 'we' || cleanWord === 'yo' || cleanWord === 'nosotros' || cleanWord === 'nosotras') {
                    return 7.5;
                }
                if (cleanWord === 'you' || cleanWord === 'tÃº' || cleanWord === 'vosotros' || cleanWord === 'vosotras') {
                    return 6.0;
                }
                if (cleanWord === 'he' || cleanWord === 'she' || cleanWord === 'they' || cleanWord === 'it' ||
                    cleanWord === 'Ã©l' || cleanWord === 'ella' || cleanWord === 'ellos' || cleanWord === 'ellas') {
                    return 5.0;
                }
                return 5.0; // Default for pronouns
            }
            
            // Verbs
            if (pos === 'verb') {
                // Ontological/Existential verbs
                const ontologicalVerbs = ['is', 'am', 'are', 'was', 'were', 'be', 'been', 'being',
                                         'exist', 'exists', 'existed', 'remaining', 'remain', 'remains',
                                         'become', 'becomes', 'became',
                                         'ser', 'estar', 'es', 'son', 'estÃ¡', 'estÃ¡n', 'fue', 'fueron',
                                         'existir', 'existe', 'existen', 'permanecer', 'permanece', 'permanecen',
                                         'convertirse', 'convertir'];
                if (ontologicalVerbs.includes(cleanWord)) {
                    // "To be" verbs have high value (aligned with ledger system: 8.0)
                    if (cleanWord === 'is' || cleanWord === 'am' || cleanWord === 'are' || cleanWord === 'was' || cleanWord === 'were' ||
                        cleanWord === 'be' || cleanWord === 'been' || cleanWord === 'being' ||
                        cleanWord === 'ser' || cleanWord === 'estar' || cleanWord === 'es' || cleanWord === 'son' || 
                        cleanWord === 'estÃ¡' || cleanWord === 'estÃ¡n') {
                        return 8.0; // Base value for "to be" (ledger system alignment)
                    }
                    return 7.0;
                }
                
                // Modal/Capacity verbs
                const modalVerbs = ['can', 'could', 'must', 'should', 'may', 'might', 'will', 'would',
                                   'poder', 'debe', 'deber', 'deberÃ­a', 'podrÃ­a'];
                if (modalVerbs.includes(cleanWord)) {
                    return 6.0;
                }
                
                // Narrative/reporting verbs
                const narrativeVerbs = ['say', 'says', 'said', 'tell', 'tells', 'told', 'describe', 'describes', 'described',
                                       'decir', 'dice', 'dijo', 'contar', 'cuenta', 'contÃ³', 'describir', 'describe', 'describiÃ³'];
                if (narrativeVerbs.includes(cleanWord)) {
                    return 4.0;
                }
                
                return 5.0; // Default for concrete action verbs
            }
            
            // Nouns
            if (pos === 'noun') {
                // IMPORTANT: We NO LONGER use the name database to determine base values
                // Compound names are handled in calculateScores() where we set baseValue = 25.0 for each part
                // For non-compound nouns, use default noun value below
                // The database is completely ignored - only compound name logic determines names and their values
                
                // Ontological nouns
                const ontologicalNouns = ['human', 'humans', 'body', 'bodies', 'life', 'lives', 'world', 'worlds', 'self', 'selves',
                                         'humano', 'humanos', 'cuerpo', 'cuerpos', 'vida', 'vidas', 'mundo', 'mundos', 'yo', 'ser'];
                if (ontologicalNouns.includes(cleanWord)) {
                    return 6.5;
                }
                
                // Abstract but overused
                const abstractOverused = ['identity', 'identities', 'freedom', 'freedoms', 'value', 'values',
                                         'identidad', 'identidades', 'libertad', 'libertades', 'valor', 'valores'];
                if (abstractOverused.includes(cleanWord)) {
                    return 4.5;
                }
                
                // Technical nouns
                const technicalNouns = ['algorithm', 'algorithms', 'protocol', 'protocols', 'system', 'systems',
                                       'algoritmo', 'algoritmos', 'protocolo', 'protocolos', 'sistema', 'sistemas'];
                if (technicalNouns.includes(cleanWord)) {
                    return 3.5;
                }
                
                return 4.0; // Default for concrete specific nouns
            }
            
            // Adjectives
            if (pos === 'adjective') {
                // Essential/ontological adjectives
                const essentialAdj = ['good', 'human', 'alive', 'real', 'true', 'existent',
                                     'bueno', 'buena', 'humano', 'humana', 'vivo', 'viva', 'real', 'verdadero', 'verdadera'];
                if (essentialAdj.includes(cleanWord)) {
                    return 6.0;
                }
                
                // Evaluative soft
                const evaluativeSoft = ['nice', 'interesting', 'beautiful', 'pretty',
                                       'bonito', 'bonita', 'interesante', 'hermoso', 'hermosa', 'lindo', 'linda'];
                if (evaluativeSoft.includes(cleanWord)) {
                    return 3.5;
                }
                
                return 3.0; // Default for purely descriptive adjectives
            }
            
            // Function Words
            if (pos === 'conjunction' || pos === 'preposition' || pos === 'determiner') {
                // Negation
                if (cleanWord === 'not' || cleanWord === 'no' || cleanWord === 'sin' || cleanWord === 'nada') {
                    return 6.0;
                }
                
                // Conditional
                if (cleanWord === 'if' || cleanWord === 'si') {
                    return 5.5;
                }
                
                // Causal
                if (cleanWord === 'because' || cleanWord === 'porque' || cleanWord === 'por') {
                    return 5.0;
                }
                
                // Articles, prepositions, conjunctions
                const functionWords = ['the', 'a', 'an', 'of', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                                      'el', 'la', 'los', 'las', 'un', 'una', 'de', 'y', 'o', 'pero', 'en', 'con', 'por', 'para'];
                if (functionWords.includes(cleanWord)) {
                    // Deterministic value based on word hash (0.5-1.0 range)
                    let hash = 0;
                    for (let i = 0; i < cleanWord.length; i++) {
                        hash = ((hash << 5) - hash) + cleanWord.charCodeAt(i);
                        hash = hash & hash; // Convert to 32-bit integer
                    }
                    return 0.5 + (Math.abs(hash) % 51) / 100; // Value between 0.5-1.0
                }
                
                return 1.0; // Default for function words
            }
            
            // Other/Miscellaneous: words that are not recognized - treat as nouns (same value as names)
            return 4.0; // Default for unrecognized words (treat as nouns)
        }

        /**
         * Get base value for a word using the new system
         * Based on the safety file version - handles names with high value (33.75)
         * @param {string} tokenType - POS type (e.g., 'NAME', 'NOUN', 'VERB', etc.)
         * @param {Object} features - Additional features (subclass, person, etc.)
         * @param {string} surface - The word text
         * @param {Object} analyzedWord - Full word data object
         * @returns {number} - Base value for the word
         */
        function getNewBaseValue(tokenType, features = {}, surface = '', analyzedWord = null) {
            const cleanWord = (surface || '').toLowerCase();
            
            // Normalize tokenType to handle both OpenAI UPOS tags and legacy types
            const normalizedType = (tokenType || '').toUpperCase().trim();
            
            // Check if this is a name (for PROPN that might be names)
            const isName = analyzedWord && (analyzedWord.isName === true || analyzedWord.isPartOfCompoundName === true);
            
            // A) Pronouns - UPDATED VALUES (20% reduction applied)
            if (normalizedType === 'PRON' || normalizedType === 'PRONOUN') {
                // Check if possessive pronoun (my, your, his, her, its, our, their, mine, yours, hers, ours, theirs)
                const possessivePronouns = ['my', 'your', 'his', 'her', 'its', 'our', 'their', 'mine', 'yours', 'hers', 'ours', 'theirs',
                                          'mi', 'tu', 'su', 'sus', 'mÃ­o', 'mÃ­a', 'mÃ­os', 'mÃ­as', 'tuyo', 'tuya', 'tuyos', 'tuyas',
                                          'suyo', 'suya', 'suyos', 'suyas', 'nuestro', 'nuestra', 'nuestros', 'nuestras'];
                const isPossessive = possessivePronouns.includes(cleanWord) || features.possessive === true;
                
                if (isPossessive) {
                    return 6.045 * 0.8; // Posesivos: 6.045 â†’ 4.836 (20% reduction)
                }
                
                // Updated values for pronouns (20% reduction applied)
                const person = features.person;
                if (person === '1st_singular' || cleanWord === 'i' || cleanWord === 'yo') return 6.4 * 0.8; // 1ra persona singular: 6.4 â†’ 5.12
                if (person === '1st_plural' || cleanWord === 'we' || cleanWord === 'nosotros' || cleanWord === 'nosotras') return 5.8 * 0.8; // 1ra persona plural: 5.8 â†’ 4.64
                if (person === '2nd' || cleanWord === 'you' || cleanWord === 'tÃº') return 6.0 * 0.8; // 2da persona: 6.0 â†’ 4.8
                if (person === '3rd') return 6.0 * 0.8; // 3ra persona: 6.0 â†’ 4.8
                return 6.0 * 0.8; // Default: 3ra persona: 6.0 â†’ 4.8
            }
            
            // B) Verbal classes - UPDATED VALUES (20% reduction applied)
            if (normalizedType === 'AUX' || normalizedType === 'VERB_AUXILIARY') {
                // Note: prevToken not available in getNewBaseValue, but isToBeVerb handles it gracefully
                if (features.lemma === 'be' || isToBeVerb(surface, null)) return 6.9 * 0.8; // "To be" auxiliar: 6.9 â†’ 5.52
                return 2.5 * 0.8; // Auxiliares generales: 2.5 â†’ 2.0
            }
            if (normalizedType === 'VERB' || normalizedType === 'VERB_MODAL') {
                // Check if it's "to be" verb
                // Note: prevToken not available in getNewBaseValue, but isToBeVerb handles it gracefully
                if (features.lemma === 'be' || isToBeVerb(surface, null)) {
                    return 7.923 * 0.8; // "To be": 7.923 â†’ 6.3384
                }
                if (features.subclass === 'existential') return 6.281 * 0.8; // Existenciales: 6.281 â†’ 5.0248
                if (features.subclass === 'action') return 3.8 * 0.8; // AcciÃ³n: 3.8 â†’ 3.04
                if (features.subclass === 'reporting') return 2.08 * 0.8; // Reporte: 2.08 â†’ 1.664
                return 2.8 * 0.8; // Verbos generales: 2.8 â†’ 2.24
            }
            if (normalizedType === 'MODAL') {
                return 2.021 * 0.8; // Modales: 2.021 â†’ 1.6168
            }
            
            // C) Nouns - UPDATED VALUES (20% reduction + 50% additional reduction = 60% total reduction)
            // NOTE: Names (NAME/PROPN that are names) are handled separately below and NOT reduced
            if (normalizedType === 'NOUN' || (normalizedType === 'PROPN' && !isName)) {
                // PROPN that is NOT a name gets reduced (common nouns)
                // Additional 50% reduction applied: multiply by 0.5 (0.8 * 0.5 = 0.4)
                if (features.subclass === 'ontological') return 2.425 * 0.4; // OntolÃ³gicos: 2.425 â†’ 0.97 (50% additional reduction)
                if (features.subclass === 'abstract') return 2.67 * 0.4; // Abstractos: 2.67 â†’ 1.068 (50% additional reduction)
                if (features.subclass === 'concrete') return 3.13 * 0.4; // Concretos: 3.13 â†’ 1.252 (50% additional reduction)
                if (features.subclass === 'technical') return 1.7 * 0.4; // TÃ©cnicos: 1.7 â†’ 0.68 (50% additional reduction)
                return 2.4 * 0.4; // Generales: 2.4 â†’ 0.96 (50% additional reduction)
            }
            
            // D) Adjectives - UPDATED VALUES (20% reduction applied)
            if (normalizedType === 'ADJ' || normalizedType === 'ADJECTIVE') {
                return 4.4 * 0.8; // Todos los adjetivos: 4.4 â†’ 3.52
            }
            
            // D2) Adverbs - UPDATED VALUES (20% reduction applied)
            if (normalizedType === 'ADV' || normalizedType === 'ADVERB') {
                return 3.0 * 0.8; // Todos los adverbios: 3.0 â†’ 2.4
            }
            
            // E) Function words - UPDATED VALUES (20% reduction applied)
            if (normalizedType === 'PART') {
                if (features.subclass === 'negation') return 6.456 * 0.8; // PartÃ­culas de negaciÃ³n: 6.456 â†’ 5.1648
                return 1.5 * 0.8; // PartÃ­culas generales: 1.5 â†’ 1.2
            }
            if (normalizedType === 'SCONJ' || normalizedType === 'CONJUNCTION') {
                if (features.subclass === 'conditional') return 2.5 * 0.8; // Condicionales: 2.5 â†’ 2.0
                if (features.subclass === 'causal') return 3.0 * 0.8; // Causales: 3.0 â†’ 2.4
                return 2.5 * 0.8; // Otras: 2.5 â†’ 2.0
            }
            if (normalizedType === 'CCONJ') {
                return 4.0 * 0.8; // Conjunciones coordinantes: 4.0 â†’ 3.2
            }
            if (normalizedType === 'DET' || normalizedType === 'DETERMINER') {
                return 2.223 * 0.8; // Determinantes: 2.223 â†’ 1.7784
            }
            // ADP (prepositions) - handled separately in calculateNewTokenValue based on context
            if (normalizedType === 'ADP' || normalizedType === 'PREPOSITION') {
                return 3.45 * 0.8; // Preposiciones: 3.45 â†’ 2.76 (puede ajustarse a 12.0 si van acompaÃ±adas)
            }
            if (normalizedType === 'INTJ' || normalizedType === 'INTERJECTION') {
                return 1.1273 * 0.8; // Interjecciones: 1.1273 â†’ 0.90184
            }
            if (normalizedType === 'MISC' || normalizedType === 'OTHER') {
                return 6.5 * 0.8; // MISC/OTHER: 6.5 â†’ 5.2
            }
            if (normalizedType === 'SYM' || normalizedType === 'PUNCT' || normalizedType === 'PUNCTUATION') {
                return 1.0 * 0.8; // SÃ­mbolos/PuntuaciÃ³n: 1.0 â†’ 0.8 (mÃ­nimo)
            }
            if (normalizedType === 'NUM' || normalizedType === 'NUMBER' || normalizedType === 'NUMERAL') {
                // Numbers: if isolated (single token text), count as normal noun
                // Otherwise, use default number value
                return 2.07678 * 0.8; // NÃºmeros: 2.07678 â†’ 1.661424
            }
            
            // F) Names (CRITICAL - base value for names) - REDUCED 50%
            // NOTE: Names are NOT reduced by 20% - they keep their full value
            if (normalizedType === 'NAME' || (normalizedType === 'PROPN' && isName)) {
                return 33.75; // Reduced 50% from 67.5 (names are NOT reduced by 20%)
            }
            
            // Default minimum value (20% reduction applied)
            return 1.0 * 0.8; // Default: 1.0 â†’ 0.8 (20% reduction)
        }
        
        // ============================================================================
        // NEW LINGUISTIC VALUE ENGINE - COMPLETE IMPLEMENTATION
        // Based on SYSTEM PROMPT specifications
        // ============================================================================
        function calculateNewTokenValue(token, index, tokens, nameGroups, analyzedWords, repetitionMultiplier = 1.0, diversityDevaluationMultiplier = 1.0, nonNameWordDevaluation = 1.0, adjectiveMultiplier = 1.0, textLengthDevaluation = 1.0) {
            const totalTokens = tokens.length;
            const multipliers = [];
            const analyzedWord = analyzedWords && analyzedWords[index] ? analyzedWords[index] : null;
            
            // Get token features from analyzedWord if available
            const features = token.features || {};
            if (analyzedWord) {
                // Extract features from analyzedWord
                if (analyzedWord.isSerEstar) features.is_be_copula = true;
                if (analyzedWord.tense) features.tense = analyzedWord.tense.toUpperCase();
                if (analyzedWord.person) features.person = analyzedWord.person;
                if (analyzedWord.number) features.number = analyzedWord.number;
            }
            
            // 1) BASE VALUE
            // CRITICAL: Use uposType if available, otherwise fall back to token.type
            const tokenType = (analyzedWord && analyzedWord.uposType) ? analyzedWord.uposType : (token.type || 'MISC');
            let baseValue = getNewBaseValue(tokenType, features, token.surface || '', analyzedWord);
            baseValue = Math.max(baseValue, 1.0); // Floor (changed from 0.1 to 1.0)
            
            // 1b) ADP (PREPOSITION) CONTEXT-BASED VALUE ADJUSTMENT
            // ADP debe tener un valor base de 12.0 si estÃ¡ acompaÃ±ado de un pronombre o un sustantivo o un nombre o nombre compuesto
            // Si no, el valor base debe ser de 5.0
            if (token.type === 'ADP') {
                let hasAccompaniment = false;
                
                // Check previous token (preposition usually precedes noun/pronoun/name)
                if (index > 0) {
                    const prevToken = tokens[index - 1];
                    const prevAnalyzed = analyzedWords && analyzedWords[index - 1] ? analyzedWords[index - 1] : null;
                    if (prevToken && (prevToken.type === 'PRON' || prevToken.type === 'PRONOUN' || 
                                     prevToken.type === 'NOUN' || prevToken.type === 'NAME' ||
                                     (prevAnalyzed && (prevAnalyzed.isName || prevAnalyzed.isPartOfCompoundName)))) {
                        hasAccompaniment = true;
                    }
                }
                
                // Check next token (preposition can also follow noun/pronoun/name)
                if (index < tokens.length - 1) {
                    const nextToken = tokens[index + 1];
                    const nextAnalyzed = analyzedWords && analyzedWords[index + 1] ? analyzedWords[index + 1] : null;
                    if (nextToken && (nextToken.type === 'PRON' || nextToken.type === 'PRONOUN' || 
                                     nextToken.type === 'NOUN' || nextToken.type === 'NAME' ||
                                     (nextAnalyzed && (nextAnalyzed.isName || nextAnalyzed.isPartOfCompoundName)))) {
                        hasAccompaniment = true;
                    }
                }
                
                // Check if part of compound name
                if (nameGroups && nameGroups.some(group => 
                    group.indices && group.indices.length > 1 && group.indices.includes(index))) {
                    hasAccompaniment = true;
                }
                
                if (hasAccompaniment) {
                    // Set base value first, then apply repetition multiplier
                    baseValue = 12.0 * 0.8; // 12.0 â†’ 9.6 (20% reduction) when accompanied by pronoun/noun/name/compound name
                } else {
                    // baseValue already has 20% reduction from getNewBaseValue (3.45 * 0.8 = 2.76)
                    // No need to change it here
                }
            }
            
            // CRITICAL: Apply repetition multiplier to base value AFTER all base value adjustments
            // but BEFORE contextual multipliers. This ensures all repetitions have the same base adjustment.
            baseValue = baseValue * repetitionMultiplier;
            if (repetitionMultiplier !== 1.0) {
                multipliers.push({
                    name: 'repetition_devaluation_base',
                    factor: repetitionMultiplier,
                    why: `Repetition multiplier applied to base value: Ã—${repetitionMultiplier.toFixed(2)}`
                });
            }
            
            // CRITICAL: Apply diversity devaluation multiplier AFTER repetition multiplier
            // The more DIFFERENT names/compound names/nouns appear in the text, the less each one is worth
            // This applies ONLY to names, compound names, and nouns
            const isNameOrNoun = (analyzedWord && (
                analyzedWord.isName === true || 
                analyzedWord.isPartOfCompoundName === true ||
                token.type === 'NOUN' || 
                token.type === 'NAME' ||
                (analyzedWord.uposType === 'NOUN' || analyzedWord.pos === 'noun')
            ));
            
            if (isNameOrNoun) {
                baseValue = baseValue * diversityDevaluationMultiplier;
                if (diversityDevaluationMultiplier !== 1.0) {
                    const devaluationPercent = ((1.0 - diversityDevaluationMultiplier) * 100).toFixed(1);
                    multipliers.push({
                        name: 'diversity_devaluation',
                        factor: diversityDevaluationMultiplier,
                        why: `Diversity devaluation: Ã—${diversityDevaluationMultiplier.toFixed(3)} (-${devaluationPercent}% due to high diversity of names/nouns)`
                    });
                }
            }
            
            // 1c) MISC/OTHER MULTIPLIER FOR LONG TEXTS (500+ words) - REDUCED 70%
            // Las palabras que aparecen solo una vez deben multiplicarse por 10*0.3=3.0 si el texto es muy largo (500 palabras)
            if ((token.type === 'MISC' || token.type === 'OTHER') && totalTokens >= 500) {
                multipliers.push({
                    name: 'misc_long_text_multiplier',
                    factor: 10.0 * 0.3, // 3.0 (reduced 70%)
                    why: `MISC/OTHER word in long text (${totalTokens} tokens >= 500) - multiplied by 3.0 (reduced 70%)`
                });
            }
            
            // Check if text is composed exclusively of a compound name (no length devaluation)
            // This check needs to be done early to determine if length devaluation should apply
            let isExclusivelyCompoundName = false;
            if (nameGroups && nameGroups.length === 1) {
                // Check if there's only one name group and it covers all tokens
                const singleGroup = nameGroups[0];
                if (singleGroup.indices && singleGroup.indices.length > 1 && 
                    singleGroup.indices.length === totalTokens) {
                    // All tokens are part of a single compound name
                    isExclusivelyCompoundName = true;
                }
            }
            
            // 2) GLOBAL LENGTH DENSITY MULTIPLIER (applies to every token)
            // BUT: Skip if text is exclusively a compound name
            const lengthBucket = getLengthBucket(totalTokens);
            // Length multipliers removed - no devaluations applied
            multipliers.push({
                name: 'length_density',
                factor: 1.0,
                why: `${totalTokens} tokens (no devaluation)`
            });
            
            // Text length devaluation removed - no devaluations
            multipliers.push({
                name: 'text_length_devaluation',
                factor: 1.0,
                why: `No text length devaluation applied`
            });
            
            // 3) ONTOLOGICAL ASSERTION MULTIPLIER (Ã—5 reduced 70% = Ã—1.5)
            // Apply to tokens participating in predication nucleus
            // EXCLUDE ADVERBS: Adverbs are modifiers and should not receive the same boost as predicate nucleus
            // CRITICAL: For compound names, only apply to the FIRST part to ensure all parts have same value
            const isNucleusToken = isOntologicalNucleusToken(tokens, index, analyzedWords);
            const isAdverb = token.type === 'ADV' || token.type === 'ADVERB';
            
            // Check if this is part of a compound name (but not the first part)
            let isPartOfCompoundName = false;
            let isFirstPartOfCompound = false;
            if (token.type === 'NAME' || token.type === 'MISC' || token.type === 'OTHER') {
                const nameGroup = token.name_group;
                let actualGroup = null;
                if (nameGroup) {
                    actualGroup = nameGroups.find(g => g.id === nameGroup.id || 
                                                     (g.indices && g.indices.includes(index)));
                }
                if (actualGroup && actualGroup.indices && actualGroup.indices.length > 1) {
                    isPartOfCompoundName = true;
                    // Check if this is the first part of the compound name
                    const sortedIndices = [...actualGroup.indices].sort((a, b) => a - b);
                    isFirstPartOfCompound = (index === sortedIndices[0]);
                }
            }
            
            // Only apply ontological multiplier if NOT part of compound name, OR if it's the first part
            if (isNucleusToken && !isAdverb && (!isPartOfCompoundName || isFirstPartOfCompound)) {
                multipliers.push({
                    name: 'ontological_assertion',
                    factor: 5.0 * 0.3, // Ã—1.5 (reduced 70%)
                    why: 'Participates in predication nucleus (subject/predicate/complement) - Ã—1.5 multiplier (reduced 70%)'
                });
            } else if (isNucleusToken && isAdverb && (!isPartOfCompoundName || isFirstPartOfCompound)) {
                // Adverbs get a reduced multiplier (Ã—2*0.3=Ã—0.6 instead of Ã—1.5)
                multipliers.push({
                    name: 'ontological_assertion_reduced',
                    factor: 2.0 * 0.3, // Ã—0.6 (reduced 70%)
                    why: 'Adverb in predication nucleus - reduced multiplier (Ã—0.6 instead of Ã—1.5) as modifiers'
                });
            }
            
            // 4) SEMANTIC CLOSURE MULTIPLIER (simplified - use MEDIUM as default) - REDUCED 70%
            // In full implementation, this would come from clause.closure
            const closureLevel = 'MEDIUM'; // Default - would come from clause analysis
            const closureMult = closureLevel === 'HIGH' ? 1.4 * 0.3 : (closureLevel === 'MEDIUM' ? 1.2 * 0.3 : 1.0 * 0.3);
            // HIGH: Ã—0.42, MEDIUM: Ã—0.36, LOW: Ã—0.3
            multipliers.push({
                name: 'semantic_closure',
                factor: closureMult,
                why: `Closure level: ${closureLevel}`
            });
            
            // 5) IDENTITY REPETITION MULTIPLIER (nucleus reward/penalty)
            // Exclude adverbs from repetition multiplier
            // CRITICAL: For compound names, only apply to the FIRST part to ensure all parts have same value
            if (isNucleusToken && !isAdverb && (!isPartOfCompoundName || isFirstPartOfCompound)) {
                const repetitionMult = getNucleusRepetitionMultiplier(totalTokens, tokens, index, analyzedWords);
                if (repetitionMult !== 1.0) {
                    multipliers.push({
                        name: 'nucleus_repetition',
                        factor: repetitionMult,
                        why: repetitionMult > 1.0 ? 'Repeated nucleus in short text' : 'Repeated nucleus in long text'
                    });
                }
            }
            
            // 8) NAME SPECIAL RULES (CRITICAL - UPDATED)
            // Apply same rules to MISC/OTHER (unrecognized words) as to names
            if (token.type === 'NAME' || token.type === 'MISC' || token.type === 'OTHER' || 
                (analyzedWord && (analyzedWord.isName === true || analyzedWord.isPartOfCompoundName === true)) ||
                (analyzedWord && analyzedWord.uposType === 'NAME')) {
                const nameGroup = token.name_group;
                
                // Find the actual name group from nameGroups array
                let actualGroup = null;
                if (nameGroup) {
                    actualGroup = nameGroups.find(g => g.id === nameGroup.id || 
                                                     (g.indices && g.indices.includes(index)));
                }
                
                const isCompoundName = actualGroup && actualGroup.indices && actualGroup.indices.length > 1;
                const compoundLength = isCompoundName ? actualGroup.indices.length : 1;
                
                // Check if isolated (entire text is only this name/compound name)
                // Also check if text contains ONLY names (no other content)
                const isIsolatedSimple = totalTokens === 1;
                const isIsolatedCompound = isCompoundName && nameGroups.length === 1 && 
                                         actualGroup.indices.length === totalTokens;
                
                // Check if text contains ONLY names (no other content besides names)
                const hasOnlyNames = nameGroups.length > 0 && 
                                   nameGroups.reduce((sum, group) => sum + (group.indices ? group.indices.length : 0), 0) === totalTokens;
                const isOnlyNamesSimple = hasOnlyNames && !isCompoundName && totalTokens === 1;
                const isOnlyNamesCompound = hasOnlyNames && isCompoundName && nameGroups.length === 1 && 
                                          actualGroup.indices.length === totalTokens;
                
                const isIsolated = isIsolatedSimple || isIsolatedCompound || isOnlyNamesSimple || isOnlyNamesCompound;
                
                // NEW LOGIC:
                // 1. Nombres simples aislados: Ã—40.2 total (sin importar cantidad de repeticiones)
                // 2. Nombres compuestos aislados: Ã—1.5 adicional sobre Ã—40.2 base
                // 3. Nombres en contexto (no aislados): Ã—1 base + devaluaciÃ³n Ã—0.6 (y mÃ¡s segÃºn longitud)
                
                if (isIsolatedSimple || isOnlyNamesSimple) {
                    // A) Isolated Simple NAME - Ã—40.2 total
                    multipliers.push({
                        name: 'isolated_simple_name_boost',
                        factor: 40.2, // Ã—40.2 para nombres simples aislados
                        why: 'Isolated simple name - Ã—40.2 multiplier'
                    });
                } else if (isIsolatedCompound || isOnlyNamesCompound) {
                    // B) Isolated Compound NAME - Ã—1.5 adicional sobre Ã—40.2 base
                    multipliers.push({
                        name: 'isolated_compound_name_boost',
                        factor: 1.5, // Ã—1.5 adicional (sobre Ã—40.2 base)
                        why: `Isolated compound name - Ã—1.5 additional multiplier (on Ã—40.2 base, ${compoundLength} parts)`
                    });
                } else {
                    // C) NAME-in-text (not isolated) - Ã—1 base + devaluaciÃ³n Ã—0.6 (y mÃ¡s segÃºn longitud)
                    // CRITICAL: Compound names in context should NOT receive length devaluation
                    // Only simple names in context receive length devaluation
                    const isCompoundNameInContext = isCompoundName && !isIsolated;
                    
                    multipliers.push({
                        name: 'name_base_boost',
                        factor: 1.0, // Ã—1 base para nombres en contexto
                        why: 'Name in context - base multiplier Ã—1'
                    });
                    
                    // Compound names in context: 30% more than simple names
                    if (isCompoundNameInContext) {
                        multipliers.push({
                            name: 'compound_name_boost',
                            factor: 1.3, // Ã—1.3 (30% more than simple names)
                            why: `Compound name in context - 30% more than simple names (Ã—1.3 multiplier, ${compoundLength} parts)`
                        });
                    }
                    
                    // DevaluaciÃ³n base Ã—0.6 (solo para nombres simples, no para compuestos)
                    if (!isCompoundNameInContext) {
                        multipliers.push({
                            name: 'name_in_context_devaluation',
                            factor: 0.6, // Ã—0.6 devaluaciÃ³n base
                            why: 'Name in context (not isolated) - Ã—0.6 devaluation'
                        });
                    }
                    
                    // DevaluaciÃ³n adicional segÃºn longitud del texto (solo para nombres simples, NO para compuestos)
                    // Textos cortos (â‰¤10 palabras): sin devaluaciÃ³n adicional
                    // Textos largos (â‰¥500 palabras): devaluaciÃ³n adicional hasta Ã—0.5
                    if (!isCompoundNameInContext) {
                        let lengthDevaluation = 1.0;
                        if (totalTokens > 10 && totalTokens < 500) {
                            // Progresivo: 1.0 - (0.5 * (tokens - 10) / 490)
                            lengthDevaluation = 1.0 - (0.5 * (totalTokens - 10) / 490);
                        } else if (totalTokens >= 500) {
                            lengthDevaluation = 0.5; // Ã—0.5 mÃ­nimo en textos muy largos
                        }
                        
                        if (lengthDevaluation < 1.0) {
                            multipliers.push({
                                name: 'name_length_devaluation',
                                factor: lengthDevaluation,
                                why: `Name length devaluation: Ã—${lengthDevaluation.toFixed(2)} (text length: ${totalTokens} tokens)`
                            });
                        }
                    } else {
                        // Compound names in context: no length devaluation
                        multipliers.push({
                            name: 'compound_name_no_length_devaluation',
                            factor: 1.0,
                            why: 'Compound name in context - no length devaluation applied'
                        });
                    }
                }
            }
            
            // Calculate final value (ledger-based: product of all multipliers)
            let finalValue = baseValue;
            multipliers.forEach(m => {
                finalValue *= m.factor;
            });
            
            // 9a) SPECIFIC REDUCTIONS BEFORE GLOBAL MULTIPLIER
            // Get normalized type for reductions
            const normalizedTypeForReduction = (tokenType || '').toUpperCase().trim();
            
            // Reduce negation particles by 30%
            if (normalizedTypeForReduction === 'PART' && features.subclass === 'negation') {
                finalValue *= 0.7; // -30% reduction
                multipliers.push({
                    name: 'negation_particle_reduction',
                    factor: 0.7,
                    why: 'Negation particle - 30% reduction applied'
                });
            }
            
            // Reduce nouns by 20%
            if (normalizedTypeForReduction === 'NOUN' || normalizedTypeForReduction === 'PROPN') {
                // Check if it's a name (names should not be reduced)
                const isName = analyzedWord && (analyzedWord.isName === true || analyzedWord.isPartOfCompoundName === true);
                if (!isName) {
                    finalValue *= 0.8; // -20% reduction for nouns (not names)
                    multipliers.push({
                        name: 'noun_general_reduction',
                        factor: 0.8,
                        why: 'Noun (not a name) - 20% reduction applied'
                    });
                }
            }
            
            // 11.5) ADDITIONAL DEVALUATION MULTIPLIERS (applied before global multiplier)
            // Apply non-name word devaluation (if more than 2 non-name words, -10%)
            const isNameOrCompoundName = (analyzedWord && (
                analyzedWord.isName === true || 
                analyzedWord.isPartOfCompoundName === true ||
                token.type === 'NAME'
            ));
            
            if (!isNameOrCompoundName && nonNameWordDevaluation !== 1.0) {
                finalValue *= nonNameWordDevaluation;
                multipliers.push({
                    name: 'non_name_word_devaluation',
                    factor: nonNameWordDevaluation,
                    why: `Non-name word devaluation: Ã—${nonNameWordDevaluation.toFixed(2)} (more than 2 non-name words in text)`
                });
            }
            
            // Apply adjective-specific multiplier
            const isAdjective = token.type === 'ADJ' || token.type === 'ADJECTIVE' || 
                               (analyzedWord && (analyzedWord.uposType === 'ADJ' || analyzedWord.pos === 'adjective'));
            
            if (isAdjective && adjectiveMultiplier !== 1.0) {
                finalValue *= adjectiveMultiplier;
                multipliers.push({
                    name: 'adjective_count_multiplier',
                    factor: adjectiveMultiplier,
                    why: `Adjective count multiplier: Ã—${adjectiveMultiplier.toFixed(2)}`
                });
            }
            
            // Apply text length devaluation (>200 words: -20%)
            if (textLengthDevaluation !== 1.0) {
                finalValue *= textLengthDevaluation;
                multipliers.push({
                    name: 'text_length_devaluation_final',
                    factor: textLengthDevaluation,
                    why: `Text length devaluation: Ã—${textLengthDevaluation.toFixed(2)} (text has ${totalTokens} words > 200)`
                });
            }
            
            // 12) GLOBAL MULTIPLIER REMOVED - No boosts by length
            // Length devaluation is now applied at the end to total value (not individual words)
            // This ensures names are protected from length devaluation
            const globalMultiplier = 1.0; // No multiplier - length devaluation applied separately
            finalValue *= globalMultiplier;
            multipliers.push({
                name: 'global_length_multiplier',
                factor: globalMultiplier,
                why: `No length-based multiplier (length devaluation applied to total value separately)`
            });
            
            // 13) GENERAL MINIMUM FLOOR (APPLIED AFTER GLOBAL MULTIPLIER)
            finalValue = Math.max(finalValue, 1.0); // Minimum 1.0 points (changed from 0.1 to 1.0)
            
            return {
                base_value: baseValue,
                multipliers: multipliers,
                final_value: finalValue
            };
        }
        
        // Helper: Get length bucket
        function getLengthBucket(tokenCount) {
            if (tokenCount >= 1 && tokenCount <= 10) return '1-10';
            if (tokenCount >= 11 && tokenCount <= 50) return '11-50';
            if (tokenCount >= 51 && tokenCount <= 200) return '51-200';
            if (tokenCount >= 201 && tokenCount <= 500) return '201-500';
            return '500+';
        }
        
        // Helper: Check if token is ontological nucleus
        function isOntologicalNucleusToken(tokens, index, analyzedWords) {
            if (index < 0 || index >= tokens.length) return false;
            
            const token = tokens[index];
            const analyzedWord = analyzedWords && analyzedWords[index] ? analyzedWords[index] : null;
            
            // Check for subject nucleus
            if (analyzedWord && analyzedWord.roles && analyzedWord.roles.is_subject_nucleus) return true;
            
            // Check for predicate nucleus
            if (analyzedWord && analyzedWord.roles && analyzedWord.roles.is_predicate_nucleus) return true;
            
            // Check for predicate complement
            if (analyzedWord && analyzedWord.roles && analyzedWord.roles.is_predicate_complement) return true;
            
            // Pattern-based detection: [PRON/NOUN/NAME] + [AUX(be)] + [ADJ/NOUN/NAME]
            if (index >= 2 && index < tokens.length - 1) {
                const prev2 = tokens[index - 2];
                const prev1 = tokens[index - 1];
                const current = tokens[index];
                
                const isSubject = prev2 && (prev2.type === 'PRON' || prev2.type === 'NOUN' || prev2.type === 'NAME' || 
                                           prev2.type === 'PRONOUN');
                const prev2ForBeLike = index > 1 ? tokens[index - 2] : null;
                const isBeLike = prev1 && (prev1.type === 'AUX' || prev1.type === 'VERB_AUXILIARY' || 
                                         isToBeVerb(prev1.surface || '', prev2ForBeLike));
                const isPredicate = current && (current.type === 'ADJ' || current.type === 'NOUN' || 
                                               current.type === 'NAME' || current.type === 'ADJECTIVE');
                
                if (isSubject && isBeLike && isPredicate) return true;
            }
            
            return false;
        }
        
        // Helper: Get nucleus repetition multiplier
        function getNucleusRepetitionMultiplier(totalTokens, tokens, index, analyzedWords) {
            if (totalTokens <= 50) {
                // Strategic repetition => Ã—1.3 for repeated nuclei (occurrence index >=2)
                const surface = tokens[index]?.surface || '';
                let occurrenceCount = 0;
                for (let i = 0; i <= index; i++) {
                    if (tokens[i]?.surface === surface && isOntologicalNucleusToken(tokens, i, analyzedWords)) {
                        occurrenceCount++;
                    }
                }
                if (occurrenceCount >= 2) return 1.3;
            } else if (totalTokens > 200) {
                // Inflated repetition => Ã—0.9 for repeated nuclei
                const surface = tokens[index]?.surface || '';
                let occurrenceCount = 0;
                for (let i = 0; i < tokens.length; i++) {
                    if (tokens[i]?.surface === surface && isOntologicalNucleusToken(tokens, i, analyzedWords)) {
                        occurrenceCount++;
                    }
                }
                if (occurrenceCount >= 2) return 0.9;
            }
            return 1.0; // No repetition multiplier
        }
        
        // Helper: Get tense multiplier
        function getTenseMultiplier(tense) {
            if (tense === 'PRESENT') return 1.25;
            if (tense === 'PAST') return 1.05;
            if (tense === 'FUTURE') return 0.95;
            return 1.0; // UNKNOWN
        }
        
        // Helper: Get future volatility multiplier
        function getFutureVolatilityMultiplier(tokens, index, analyzedWords) {
            // Simplified: check for speculative context vs bubble
            // In full implementation, this would use clause.future_speculative_context and clause.closure
            const closureLevel = 'MEDIUM'; // Would come from clause analysis
            const isSpeculative = true; // Would come from clause.future_speculative_context
            
            if (isSpeculative) {
                return 1.15; // FUTURE_SPECULATIVE_BOOST
            } else if (closureLevel === 'LOW') {
                return 0.85; // FUTURE_BUBBLE_HAIRCUT
            }
            return 1.0; // No extra volatility multiplier
        }
        
        // Helper: Check if token is part of a comparison pattern
        function isComparisonToken(tokens, index, analyzedWords) {
            const token = tokens[index];
            if (!token) return false;
            
            const surface = (token.surface || '').toLowerCase();
            const comparisonWords = ['than', 'more', 'less', 'better', 'worse', 'best', 'worst', 
                                    'most', 'least', 'much', 'many', 'fewer', 'fewest',
                                    'greater', 'greatest', 'smaller', 'smallest', 'bigger', 'biggest',
                                    'taller', 'tallest', 'shorter', 'shortest', 'longer', 'longest',
                                    'que', 'mÃ¡s', 'menos', 'mejor', 'peor', 'mayor', 'menor'];
            
            // Check if current token is a comparison word
            if (comparisonWords.includes(surface)) {
                return true;
            }
            
            // Check for comparison patterns: adjective/adverb + "than" or "more/less" + adjective
            if (index > 0 && index < tokens.length - 1) {
                const prevToken = tokens[index - 1];
                const nextToken = tokens[index + 1];
                const prevSurface = (prevToken?.surface || '').toLowerCase();
                const nextSurface = (nextToken?.surface || '').toLowerCase();
                
                // Pattern: "more/less" + adjective/adverb
                if ((prevSurface === 'more' || prevSurface === 'less' || prevSurface === 'most' || prevSurface === 'least') &&
                    (token.type === 'ADJ' || token.type === 'ADJECTIVE' || token.type === 'ADV' || token.type === 'ADVERB')) {
                    return true;
                }
                
                // Pattern: adjective/adverb + "than"
                if ((token.type === 'ADJ' || token.type === 'ADJECTIVE' || token.type === 'ADV' || token.type === 'ADVERB') &&
                    (nextSurface === 'than' || comparisonWords.includes(nextSurface))) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Helper: Check if token is in a comparison phrase (within 3 tokens of a comparison word)
        function isInComparisonPhrase(tokens, index, analyzedWords) {
            // Check if current token is a comparison token
            if (isComparisonToken(tokens, index, analyzedWords)) {
                return true;
            }
            
            // Check if any token within 3 positions is a comparison token
            const windowSize = 3;
            for (let i = Math.max(0, index - windowSize); i <= Math.min(tokens.length - 1, index + windowSize); i++) {
                if (i !== index && isComparisonToken(tokens, i, analyzedWords)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Helper: Get context-based multiplier (en textos con mÃ¡s de 1-2 palabras, extraer valor del contexto)
        function getContextBasedMultiplier(tokens, index, analyzedWords, totalTokens) {
            const token = tokens[index];
            if (!token) return 1.0;
            
            // For texts with more than 1-2 words, extract value from context
            // This applies to all tokens to reflect contextual value
            
            // Strong ontological contexts (I am X, X is Y, etc.)
            if (isOntologicalNucleusToken(tokens, index, analyzedWords)) {
                return 1.2; // Higher value in ontological assertions
            }
            
            // Patterns with "to be"
            if (index > 0) {
                const prevToken = tokens[index - 1];
                const prevAnalyzed = analyzedWords && analyzedWords[index - 1] ? analyzedWords[index - 1] : null;
                const isToBeBefore = (prevToken && (prevToken.type === 'AUX' || prevToken.type === 'VERB_AUXILIARY')) &&
                                   (isToBeVerb(prevToken.surface || '') || 
                                    (prevAnalyzed && prevAnalyzed.isSerEstar));
                
                if (isToBeBefore && (token.type === 'ADJ' || token.type === 'ADJECTIVE' || token.type === 'NAME' || token.type === 'NOUN')) {
                    return 1.15; // Higher value after "to be"
                }
            }
            
            // Default: no context multiplier (context is already handled by specific patterns)
            return 1.0;
        }
        
        // Helper: Get adjective context multiplier (adjetivos deben valer mÃ¡s dependiendo del contexto)
        function getAdjectiveContextMultiplier(tokens, index, analyzedWords, totalTokens) {
            const token = tokens[index];
            if (!token) return 1.0;
            
            // Check if adjective is in a strong context (after to be, in comparisons, etc.)
            if (index > 0) {
                const prevToken = tokens[index - 1];
                const prevAnalyzed = analyzedWords && analyzedWords[index - 1] ? analyzedWords[index - 1] : null;
                const prevPrevToken = index > 1 ? tokens[index - 2] : null;
                const isToBeBefore = (prevToken && (prevToken.type === 'AUX' || prevToken.type === 'VERB_AUXILIARY')) &&
                                   (isToBeVerb(prevToken.surface || '', prevPrevToken) || 
                                    (prevAnalyzed && prevAnalyzed.isSerEstar));
                
                if (isToBeBefore) {
                    return 1.3; // Higher value when after "to be" (additional to the to_be_plus_adjective boost)
                }
            }
            
            // Check if in comparison pattern
            if (isComparisonToken(tokens, index, analyzedWords)) {
                return 1.2; // Higher value in comparisons
            }
            
            // Base context boost for adjectives in longer texts
            if (totalTokens > 10) {
                return 1.1; // Slight boost for adjectives in longer contexts
            }
            
            return 1.0;
        }
        
        // Helper: Get adjective tense multiplier (different from verbs: more in present, even more in past, less in future)
        function getAdjectiveTenseMultiplier(tense) {
            if (tense === 'PAST') return 1.4 * 0.3; // 0.42 (reduced 70%)
            if (tense === 'PRESENT') return 1.3 * 0.3; // 0.39 (reduced 70%)
            if (tense === 'FUTURE') return 0.85 * 0.3; // 0.255 (reduced 70%)
            return 1.0 * 0.3; // 0.3 UNKNOWN
        }
        
        // 2. CONTEXTUAL MULTIPLIERS
        
        // A. Text Length Density Multiplier (ledger-based: short texts concentrate ontological force)
        function getLengthMultiplier(wordCount) {
            // Synthesized: maintains premium for extreme brevity while aligning with ledger system ranges
            if (wordCount === 1) return 3.0; // Single word = maximum ontological concentration
            if (wordCount === 2) return 2.5; // Two words = very high concentration
            if (wordCount === 3) return 2.2; // "I am X" = perfect ontological density
            if (wordCount >= 4 && wordCount <= 5) return 2.0; // Still very concentrated
            if (wordCount >= 6 && wordCount <= 10) return 1.6; // Ledger: 1-10 words = Ã—1.6
            if (wordCount >= 11 && wordCount <= 50) return 1.3; // Ledger: 11-50 words = Ã—1.3
            if (wordCount >= 51 && wordCount <= 200) return 1.0; // Ledger: 51-200 words = Ã—1.0
            if (wordCount >= 201 && wordCount <= 500) return 0.7; // Ledger: 201-500 words = Ã—0.7
            return 0.7; // Default for texts beyond 500 words
        }
        
        // B. Name with "to be" Multiplier (names near "to be" verbs get bonus)
        function getNameWithToBeMultiplier(wordIndex, words) {
            const word = words[wordIndex];
            
            // Skip extra names - they don't exist for context
            if (word && word.isExtraName) return 1.0;
            
            // Check if this word is a name - use wordData.isName directly (works for database names AND promoted "other" words)
            // IMPORTANT: wordData.isName is true for both database names and words promoted from "other" in compound names
            if (!word.isName || word.pos !== 'noun') {
                return 1.0; // Not a name, no bonus
            }
            
            // Check if there's a "to be" verb nearby (within 3 words)
            // Filter out extra names from context
            const windowSize = 3;
            const start = Math.max(0, wordIndex - windowSize);
            const end = Math.min(words.length, wordIndex + windowSize + 1);
            const window = [];
            for (let i = start; i < end; i++) {
                if (words[i] && !words[i].isExtraName) {
                    window.push(words[i]);
                }
            }
            
            // Look for "to be" verbs in the window
            let hasToBe = false;
            window.forEach(w => {
                if (w.isSerEstar) {
                    hasToBe = true;
                }
            });
            
            if (hasToBe) {
                // Check if it forms a pattern: "I am Name" or "Name is X" or "X is Name"
                for (let i = 0; i < window.length - 2; i++) {
                    const w1 = window[i];
                    const w2 = window[i + 1];
                    const w3 = window[i + 2];
                    
                    // Pattern 1: I/pronoun + "to be" + Name
                    // IMPORTANT: Use w.isName directly to treat promoted "other" words equally
                    const isFirstPerson = (w1.text.toLowerCase() === 'i' || w1.text.toLowerCase() === 'yo' || 
                                          w1.text.toLowerCase() === 'we' || w1.text.toLowerCase() === 'nosotros') && 
                                         w1.pos === 'pronoun';
                    const isToBe = w2.isSerEstar;
                    const isNameWord = w3 && w3.isName && w3.pos === 'noun';
                    
                    if (isFirstPerson && isToBe && isNameWord && (wordIndex === start + i + 2)) {
                        return 2.0; // High bonus for "I am Name" pattern
                    }
                    
                    // Pattern 2: Name + "to be" + complement
                    // IMPORTANT: Use w.isName directly to treat promoted "other" words equally
                    const w1IsName = w1 && w1.isName && w1.pos === 'noun';
                    const w3IsName = w3 && w3.isName && w3.pos === 'noun';
                    
                    if (w1IsName && isToBe && (wordIndex === start + i)) {
                        return 1.8; // Good bonus for "Name is X"
                    }
                    
                    if (w3IsName && isToBe && (wordIndex === start + i + 2)) {
                        return 1.8; // Good bonus for "X is Name"
                    }
                }
                
                // If "to be" is nearby but not in a clear pattern, still give a bonus
                return 1.5; // Moderate bonus for proximity to "to be"
            }
            
            return 1.0; // No "to be" nearby, no bonus
        }
        
        // C. Ontological Assertion Multiplier
        function isOntologicalAssertion(wordIndex, words) {
            if (wordIndex < 0 || wordIndex >= words.length) return false;
            // Skip extra names - they don't exist for context
            if (words[wordIndex] && words[wordIndex].isExtraName) return false;
            
            const windowSize = 5;
            const start = Math.max(0, wordIndex - windowSize);
            const end = Math.min(words.length, wordIndex + windowSize + 1);
            // Filter out extra names from context window
            const window = [];
            for (let i = start; i < end; i++) {
                if (words[i] && !words[i].isExtraName) {
                    window.push(words[i]);
                }
            }
            
            // Check for: I + am/is/are + essential adjective/noun/name
            for (let i = 0; i < window.length - 2; i++) {
                const w1 = window[i];
                const w2 = window[i + 1];
                const w3 = window[i + 2];
                
                // Pattern: I/pronoun + am/is/are + adjective/noun/name
                const isFirstPerson = (w1.text.toLowerCase() === 'i' || w1.text.toLowerCase() === 'yo') && w1.pos === 'pronoun';
                const isToBe = (w2.text.toLowerCase() === 'am' || w2.text.toLowerCase() === 'is' || w2.text.toLowerCase() === 'are' ||
                               w2.text.toLowerCase() === 'es' || w2.text.toLowerCase() === 'son' || w2.text.toLowerCase() === 'estoy' ||
                               w2.text.toLowerCase() === 'estÃ¡' || w2.text.toLowerCase() === 'estÃ¡n') && w2.pos === 'verb';
                
                // Check if w3 is essential word OR a proper noun (name)
                const isEssentialWord = (w3.pos === 'adjective' || w3.pos === 'noun') && 
                                   (w3.text.toLowerCase() === 'human' || w3.text.toLowerCase() === 'good' || w3.text.toLowerCase() === 'alive' ||
                                    w3.text.toLowerCase() === 'real' || w3.text.toLowerCase() === 'humano' || w3.text.toLowerCase() === 'bueno' ||
                                    w3.text.toLowerCase() === 'vivo' || w3.text.toLowerCase() === 'real');
                
                // Check if w3 is a name - use w3.isName directly to treat promoted "other" words equally
                const actualIndex = start + i + 2;
                const isNameProperNoun = w3 && w3.isName && w3.pos === 'noun';
                
                const isEssential = isEssentialWord || isNameProperNoun;
                
                if (isFirstPerson && isToBe && isEssential && 
                    (wordIndex === start + i || wordIndex === start + i + 1 || wordIndex === start + i + 2)) {
                    return true;
                }
            }
            
            // Check for: Noun + is/are + noun/adjective
            for (let i = 0; i < window.length - 2; i++) {
                const w1 = window[i];
                const w2 = window[i + 1];
                const w3 = window[i + 2];
                
                const isNoun = w1.pos === 'noun';
                const isToBe = (w2.text.toLowerCase() === 'is' || w2.text.toLowerCase() === 'are' ||
                               w2.text.toLowerCase() === 'es' || w2.text.toLowerCase() === 'son') && w2.pos === 'verb';
                const isComplement = (w3.pos === 'noun' || w3.pos === 'adjective');
                
                if (isNoun && isToBe && isComplement && 
                    (wordIndex === start + i || wordIndex === start + i + 1 || wordIndex === start + i + 2)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // C. Semantic Closure Multiplier (ledger-based system: self-contained assertions > dependent statements)
        function getSemanticClosureMultiplier(wordIndex, words, totalWords) {
            // Synthesized with existing logic: maintains high values for short texts while aligning with ledger system
            // Self-contained assertion (short text = maximum ontological density)
            if (totalWords === 1) return 2.0; // Single word = maximum concentration (beyond ledger Ã—1.4 for extreme cases)
            if (totalWords === 2) return 1.8; // Two words = very high concentration
            if (totalWords === 3) return 1.7; // "I am X" = perfect (beyond ledger Ã—1.4)
            if (totalWords >= 4 && totalWords <= 5) return 1.5; // Still very self-contained
            if (totalWords >= 6 && totalWords <= 10) {
                return 1.4; // Ledger system: self-contained assertion = Ã—1.4
            }
            
            // Productive ambiguity (medium text, some context)
            if (totalWords >= 11 && totalWords <= 50) {
                return 1.2; // Ledger system: productive ambiguity = Ã—1.2
            }
            
            // Heavy dependence on external context (long text = explanations = less value)
            if (totalWords >= 51 && totalWords <= 200) {
                return 0.8; // Ledger system: heavy dependence = Ã—0.8
            }
            
            return 0.8; // Very long texts have heavy dependence on context
        }
        
        // D. Scarcity/Density Multiplier (penaliza repeticiÃ³n excesiva)
        // A mÃ¡s repeticiones, menos valor por instancia (ley de escasez)
        function getRepetitionMultiplier(wordIndex, words, wordText, totalWords) {
            const cleanWord = wordText.toLowerCase().replace(/[^\w]/g, '');
            
            // Check if this is a "to be" verb (special handling)
            const toBeVerbs = ['is', 'am', 'are', 'was', 'were', 'be', 'been', 'being',
                               'ser', 'estar', 'es', 'son', 'estÃ¡', 'estÃ¡n'];
            const isToBe = toBeVerbs.includes(cleanWord);
            
            // Check if this word is an ontological nucleus (pronouns, "to be", essential words)
            const ontologicalNuclei = ['i', 'we', 'you', 'am', 'is', 'are', 'be', 'human', 'good', 'real', 'alive',
                                      'yo', 'nosotros', 'tÃº', 'ser', 'estar', 'es', 'humano', 'bueno', 'real', 'vivo'];
            
            // Count occurrences of this word (excluding extra names)
            let count = 0;
            words.forEach(w => {
                // Skip extra names - they don't count
                if (w && w.isExtraName) return;
                if (w.text.toLowerCase().replace(/[^\w]/g, '') === cleanWord) {
                    count++;
                }
            });
            
            // Special handling for "to be" verbs - escasez = mÃ¡s valor
            if (isToBe) {
                // Calcular densidad relativa (cuÃ¡ntas veces aparece "to be" en relaciÃ³n al texto total)
                const toBeDensity = count / totalWords;
                
                // Si aparece solo una vez: valor mÃ¡ximo (mÃ¡xima escasez)
                if (count === 1) {
                    return 3.5; // Muy alto para "to be" Ãºnico - mÃ¡xima escasez
                }
                
                // Si hay muy pocas apariciones (alta escasez): valor muy alto
                if (count === 2) {
                    return 2.8; // Muy alto - alta escasez
                }
                if (count === 3) {
                    return 2.2; // Alto - buena escasez
                }
                
                // Si hay pocas apariciones: buen valor
                if (count === 4) {
                    return 1.8;
                }
                if (count === 5) {
                    return 1.5;
                }
                
                // Si hay moderadas apariciones: valor moderado
                if (count === 6) {
                    return 1.2;
                }
                if (count === 7) {
                    return 1.0;
                }
                if (count === 8) {
                    return 0.9;
                }
                
                // Si hay muchas apariciones: penalizaciÃ³n progresiva
                if (count === 9) {
                    return 0.7;
                }
                if (count === 10) {
                    return 0.5;
                }
                
                // MÃ¡s de 10 apariciones: degradaciÃ³n muy agresiva (baja escasez = bajo valor)
                return Math.max(0.3, 0.5 - (count - 10) * 0.03);
            }
            
            // Special handling for names - scarcity increases value (fewer names = more value per name)
            // IMPORTANT: Use wordData.isName directly instead of isName() function
            // This ensures that words promoted from "other" to "name" in compound names are treated the same as database names
            const wordData = words[wordIndex];
            const isNameWord = wordData && wordData.isName && wordData.pos === 'noun';
            
            if (isNameWord) {
                // Count name groups (compound names count as one)
                const nameGroups = window.nameGroups || [];
                
                // Find if this name is part of a compound name group
                let nameGroup = null;
                for (let i = 0; i < nameGroups.length; i++) {
                    if (nameGroups[i].indices.includes(wordIndex)) {
                        nameGroup = nameGroups[i];
                        break;
                    }
                }
                
                // Count distinct name groups (compound names = 1 group, single names = 1 group each)
                // This ensures "John Smith" counts as 1 name group, not 2
                const distinctNameGroups = new Set();
                
                nameGroups.forEach(group => {
                    distinctNameGroups.add(group.startIndex); // Each group identified by start index
                });
                
                // Also count single names (not part of any compound)
                // IMPORTANT: Use w.isName directly to treat promoted "other" words equally
                words.forEach((w, idx) => {
                    if (w && w.isName && w.pos === 'noun') {
                        // Check if it's not part of any compound name group
                        let isPartOfGroup = false;
                        nameGroups.forEach(group => {
                            if (group.indices.includes(idx)) {
                                isPartOfGroup = true;
                            }
                        });
                        if (!isPartOfGroup) {
                            distinctNameGroups.add(idx); // Single name = its own index
                        }
                    }
                });
                
                // Use distinctNameGroups count for scarcity calculation (compound names count as one)
                const effectiveNameCount = distinctNameGroups.size;
                
                // Count how many words are NOT names (to check if text only has names)
                // Count verbs and other significant words (not just common words)
                let nonNameWordCount = 0;
                let hasVerbs = false;
                words.forEach((w, idx) => {
                    const isNameWord = isName(w.text, idx) && w.pos === 'noun';
                    if (!isNameWord) {
                        // Check if it's a verb (significant word that reduces name value)
                        if (w.pos === 'verb') {
                            hasVerbs = true;
                            nonNameWordCount++;
                        } else {
                            // Exclude very common short words (articles, prepositions, etc.)
                            const commonWords = ['the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'to', 'of', 'in', 'on', 'at', 'for', 'with', 'and', 'or', 'but'];
                            const cleanW = w.text.toLowerCase().replace(/[^\w]/g, '');
                            if (!commonWords.includes(cleanW) && cleanW.length > 1) {
                                nonNameWordCount++;
                            }
                        }
                    }
                });
                
                // Calculate multiplier based on effective name count
                // All names in a compound will get the same multiplier
                let scarcityMultiplier;
                
                // Special case: if text ONLY has names (no verbs, no other significant words), maximum value
                if (nonNameWordCount === 0 && !hasVerbs) {
                    // Text only contains names (individual or compound) - highest possible value
                    if (effectiveNameCount === 1) {
                        scarcityMultiplier = 25.0; // Maximum value for names alone
                    } else if (effectiveNameCount === 2) {
                        scarcityMultiplier = 20.0; // Very high value for 2 name groups alone
                    } else {
                        scarcityMultiplier = 15.0; // High value for multiple name groups alone
                    }
                } else if ((effectiveNameCount === 1 || effectiveNameCount === 2) && nonNameWordCount <= 2 && !hasVerbs) {
                    scarcityMultiplier = 15.0; // Enormous value - text only has names (with minimal other words)
                } else if (effectiveNameCount === 1) {
                    scarcityMultiplier = 10.0; // Maximum value for single name/compound (maximum scarcity)
                } else if (effectiveNameCount === 2) {
                    scarcityMultiplier = 8.0; // Very high value for 2 name groups
                } else if (effectiveNameCount === 3) {
                    scarcityMultiplier = 3.0; // High value for 3 name groups
                } else if (effectiveNameCount === 4) {
                    scarcityMultiplier = 2.0; // Good value for 4 name groups
                } else if (effectiveNameCount === 5) {
                    scarcityMultiplier = 1.5; // Moderate value for 5 name groups
                } else if (effectiveNameCount <= 7) {
                    scarcityMultiplier = 1.2; // Slightly above normal for 6-7 name groups
                } else if (effectiveNameCount <= 10) {
                    scarcityMultiplier = 1.0; // Normal value for 8-10 name groups
                } else {
                    // Many name groups: progressive penalty (more names = less value per name)
                    scarcityMultiplier = Math.max(0.3, 1.0 - (effectiveNameCount - 10) * 0.07);
                }
                
                // Calculate repetition multiplier: if this specific name appears many times, it has more value
                // Count how many times this specific name (or name group) appears
                let nameRepetitionCount = 0;
                
                if (nameGroup) {
                    // For compound names: create a unique identifier from the concatenated texts
                    const groupText = nameGroup.indices.map(idx => words[idx].text.toLowerCase().replace(/[^\w]/g, '')).join(' ');
                    // Count how many times this same compound name group appears
                    nameGroups.forEach(g => {
                        const gText = g.indices.map(idx => words[idx].text.toLowerCase().replace(/[^\w]/g, '')).join(' ');
                        if (gText === groupText) {
                            nameRepetitionCount++;
                        }
                    });
                } else {
                    // For single names: count exact matches (case-insensitive)
                    const currentNameText = wordText.toLowerCase().replace(/[^\w]/g, '');
                    words.forEach((w, idx) => {
                        // IMPORTANT: Use w.isName directly to treat promoted "other" words equally
                        const wIsName = w && w.isName && w.pos === 'noun';
                        // Only count if it's not part of a compound name group
                        if (wIsName) {
                            let isPartOfAnyGroup = false;
                            nameGroups.forEach(g => {
                                if (g.indices.includes(idx)) {
                                    isPartOfAnyGroup = true;
                                }
                            });
                            if (!isPartOfAnyGroup) {
                                const wClean = w.text.toLowerCase().replace(/[^\w]/g, '');
                                if (wClean === currentNameText) {
                                    nameRepetitionCount++;
                                }
                            }
                        }
                    });
                }
                
                // Repetition multiplier: more repetitions = more value (up to a limit)
                let repetitionMultiplier = 1.0;
                if (nameRepetitionCount >= 10) {
                    repetitionMultiplier = 2.5; // Very high value for names repeated 10+ times
                } else if (nameRepetitionCount >= 7) {
                    repetitionMultiplier = 2.0; // High value for 7-9 repetitions
                } else if (nameRepetitionCount >= 5) {
                    repetitionMultiplier = 1.7; // Good value for 5-6 repetitions
                } else if (nameRepetitionCount >= 3) {
                    repetitionMultiplier = 1.4; // Moderate value for 3-4 repetitions
                } else if (nameRepetitionCount >= 2) {
                    repetitionMultiplier = 1.2; // Slight bonus for 2 repetitions
                }
                
                // Compound name multiplier: 2 names > 1 name, 3+ names = same as 2 names
                let compoundMultiplier = 1.0;
                if (nameGroup) {
                    const nameCount = nameGroup.indices.length;
                    if (nameCount >= 2) {
                        // 2 or more names: apply bonus (2 names get bonus, 3+ get same bonus as 2)
                        compoundMultiplier = 1.8; // 2+ names are more valuable than single names
                    }
                    // Single names (nameCount === 1) keep compoundMultiplier = 1.0
                }
                
                // Combine scarcity, repetition, and compound multipliers
                let multiplier = scarcityMultiplier * repetitionMultiplier * compoundMultiplier;
                
                // Store multiplier in name group so all names in compound get same value
                if (nameGroup) {
                    if (!nameGroup.scarcityMultiplier) {
                        nameGroup.scarcityMultiplier = multiplier;
                    }
                    // Use the stored multiplier for consistency
                    return nameGroup.scarcityMultiplier;
                }
                
                return multiplier;
            }
            
            // Si aparece solo una vez: valor mÃ¡ximo (rareza = valor)
            if (count === 1) {
                return 1.5; // Premiar la singularidad
            }
            
            // Si es nÃºcleo ontolÃ³gico y aparece pocas veces en texto corto: repeticiÃ³n estratÃ©gica
            if (ontologicalNuclei.includes(cleanWord)) {
                if (totalWords <= 10 && count <= 3) {
                    return 1.3; // RepeticiÃ³n estratÃ©gica en textos muy cortos
                }
                if (totalWords <= 20 && count <= 5) {
                    return 1.1; // RepeticiÃ³n moderada
                }
                // Penalizar repeticiÃ³n excesiva: mÃ¡s repeticiones = menos valor cada una
                if (count > 5) {
                    return Math.max(0.5, 1.0 - (count - 5) * 0.1); // DegradaciÃ³n progresiva
                }
                return 1.0;
            }
            
            // Para palabras no ontolÃ³gicas: penalizar mÃ¡s la repeticiÃ³n
            if (count > 1) {
                return Math.max(0.3, 1.0 - (count - 1) * 0.15); // DegradaciÃ³n mÃ¡s agresiva
            }
            
            return 1.0;
        }
        
        // E. Tense-Based Multiplier (Temporal Value System)
        // Aplica multiplicadores segÃºn el tiempo verbal del texto y su complejidad
        // NOTE: This is a different function from getTenseMultiplier(tense) - renamed to avoid conflict
        function getTenseMultiplierForWord(wordIndex, words, totalWords) {
            // 1. Detectar tiempo verbal de cada verbo
            function detectVerbTense(word, pos) {
                if (pos !== 'verb') return null;
                
                const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
                
                // Presente
                const presentVerbs = ['is', 'am', 'are', 'be', 'being', 'exist', 'exists', 'remain', 'remains',
                                     'es', 'son', 'estar', 'ser', 'existe', 'existen', 'permanece', 'permanecen',
                                     'have', 'has', 'do', 'does', 'go', 'goes', 'come', 'comes', 'see', 'sees',
                                     'tengo', 'tiene', 'hago', 'hace', 'voy', 'va', 'vengo', 'viene', 'veo', 've'];
                
                // Pasado
                const pastVerbs = ['was', 'were', 'been', 'existed', 'remained', 'became', 'had', 'did', 'went',
                                  'came', 'saw', 'fue', 'fueron', 'estuvo', 'estuvieron', 'existiÃ³', 'existieron',
                                  'tuvo', 'hizo', 'fue', 'vino', 'vio', 'said', 'told', 'thought', 'knew',
                                  'dijo', 'contÃ³', 'pensÃ³', 'supo'];
                
                // Futuro (will, going to, modales de futuro)
                const futureVerbs = ['will', 'shall', 'would', 'going', 'gonna',
                                    'serÃ¡', 'serÃ¡n', 'estarÃ¡', 'estarÃ¡n', 'tendrÃ¡', 'tendrÃ¡n', 'harÃ¡', 'harÃ¡n',
                                    'irÃ¡', 'irÃ¡n', 'vendrÃ¡', 'vendrÃ¡n', 'verÃ¡', 'verÃ¡n'];
                
                // Futuro implÃ­cito (verbos modales que indican futuro)
                const futureModal = ['will', 'shall', 'would', 'can', 'could', 'may', 'might',
                                    'podrÃ¡', 'podrÃ¡n', 'deberÃ¡', 'deberÃ¡n', 'puede', 'pueden'];
                
                if (presentVerbs.includes(cleanWord)) return 'present';
                if (pastVerbs.includes(cleanWord)) return 'past';
                if (futureVerbs.includes(cleanWord) || futureModal.includes(cleanWord)) return 'future';
                
                // DetecciÃ³n por sufijos (ing = presente continuo, ed = pasado)
                if (cleanWord.endsWith('ing')) return 'present';
                if (cleanWord.endsWith('ed')) return 'past';
                
                return null;
            }
            
            // 2. Analizar todos los verbos del texto para determinar tiempo predominante
            // Skip extra names - they don't exist for context
            let presentCount = 0;
            let pastCount = 0;
            let futureCount = 0;
            const wordTenses = [];
            
            words.forEach((w, idx) => {
                // Skip extra names - they don't count for context
                if (w && w.isExtraName) {
                    wordTenses[idx] = null;
                    return;
                }
                const tense = detectVerbTense(w.text, w.pos);
                wordTenses[idx] = tense;
                if (tense === 'present') presentCount++;
                else if (tense === 'past') pastCount++;
                else if (tense === 'future') futureCount++;
            });
            
            const totalVerbs = presentCount + pastCount + futureCount;
            const currentWordTense = wordTenses[wordIndex];
            
            // Si no hay verbos o la palabra actual no es verbo, retornar 1.0
            if (totalVerbs === 0 || !currentWordTense) {
                return 1.0;
            }
            
            // 3. Determinar tiempo predominante
            let predominantTense = null;
            if (presentCount > pastCount && presentCount > futureCount) predominantTense = 'present';
            else if (pastCount > presentCount && pastCount > futureCount) predominantTense = 'past';
            else if (futureCount > presentCount && futureCount > pastCount) predominantTense = 'future';
            else if (presentCount > 0 && (pastCount > 0 || futureCount > 0)) {
                // Mezcla: presente con otro tiempo
                if (futureCount > 0) predominantTense = 'present_future';
                if (pastCount > 0) predominantTense = 'present_past';
            }
            
            // 4. Aplicar multiplicadores segÃºn las reglas
            
            // REGLA 1: TEXTO EN PASADO - mÃ¡s largo = mÃ¡s valor (aumentada influencia)
            if (predominantTense === 'past' && currentWordTense === 'past') {
                // Multiplicador positivo con longitud (incrementado significativamente)
                if (totalWords <= 10) return 1.5; // Textos muy cortos en pasado se benefician mÃ¡s
                if (totalWords <= 50) return 1.5 + (totalWords / 50) * 0.9; // 1.5 a 2.4
                if (totalWords <= 200) return 2.4 + ((totalWords - 50) / 150) * 1.2; // 2.4 a 3.6
                return 3.6 + Math.min(0.9, (totalWords - 200) / 500); // Hasta 4.5 para textos muy largos
            }
            
            // REGLA 2: TEXTO EN PRESENTE - mÃ¡s simple/corto = mÃ¡s valor (aumentada influencia)
            if (predominantTense === 'present' && currentWordTense === 'present') {
                // Multiplicador negativo con longitud (mÃ¡s corto = mÃ¡s valor, incrementado significativamente)
                if (totalWords === 1) return 5.0; // MÃ¡ximo valor para palabra Ãºnica (duplicado)
                if (totalWords === 2) return 4.4;
                if (totalWords === 3) return 4.0; // "I am X" = ideal (duplicado)
                if (totalWords <= 5) return 3.6;
                if (totalWords <= 10) return 3.0;
                if (totalWords <= 20) return 2.4;
                if (totalWords <= 50) return 2.0;
                if (totalWords <= 200) return 1.6; // PenalizaciÃ³n para textos largos en presente
                return 1.2; // PenalizaciÃ³n fuerte para textos muy largos
            }
            
            // REGLA 3: TEXTO EN FUTURO - mÃ¡s largo = menos valor (aumentada influencia)
            if (predominantTense === 'future' && currentWordTense === 'future') {
                // Multiplicador negativo con longitud (mÃ¡s largo = menos valor, incrementado significativamente)
                if (totalWords <= 5) return 3.0; // Textos cortos en futuro valen mÃ¡s (duplicado)
                if (totalWords <= 10) return 2.4;
                if (totalWords <= 20) return 2.0;
                if (totalWords <= 50) return 1.6;
                if (totalWords <= 200) return 1.2;
                return 0.8; // PenalizaciÃ³n fuerte para textos largos en futuro
            }
            
            // REGLA 4: PRESENTE + FUTURO - las partes en futuro acumulan mucho mÃ¡s valor (aumentada influencia)
            if (predominantTense === 'present_future') {
                if (currentWordTense === 'future') {
                    // Las partes en futuro valen mucho mÃ¡s (incrementado significativamente)
                    if (totalWords <= 10) return 6.0; // MÃ¡ximo valor para futuro en textos cortos (duplicado)
                    if (totalWords <= 20) return 5.0;
                    if (totalWords <= 50) return 4.0;
                    if (totalWords <= 200) return 3.0;
                    return 2.4; // AÃºn alto para textos largos
                } else if (currentWordTense === 'present') {
                    // Las partes en presente mantienen valor normal o ligeramente reducido (incrementado)
                    if (totalWords <= 10) return 3.0;
                    if (totalWords <= 20) return 2.4;
                    return 2.0;
                }
            }
            
            // REGLA 5: PRESENTE + PASADO - mÃ¡s corto y simple = mÃ¡s valor; mÃ¡s extenso y conexiones = menos valor (aumentada influencia)
            if (predominantTense === 'present_past') {
                // Calcular complejidad (nÃºmero de conexiones aproximado por densidad de palabras)
                const complexity = totalWords; // MÃ¡s palabras = mÃ¡s complejidad
                
                if (currentWordTense === 'present' || currentWordTense === 'past') {
                    // Textos cortos y simples valen mÃ¡s (incrementado significativamente)
                    if (totalWords <= 3) return 4.0; // MÃ¡ximo valor (duplicado)
                    if (totalWords <= 5) return 3.6;
                    if (totalWords <= 10) return 3.0;
                    if (totalWords <= 20) return 2.4;
                    if (totalWords <= 50) return 2.0;
                    // PenalizaciÃ³n por extensiÃ³n y conexiones
                    if (totalWords <= 200) return 1.4; // Menos valor para textos extensos
                    return 1.0; // PenalizaciÃ³n fuerte para textos muy extensos con muchas conexiones
                }
            }
            
            // Default: sin multiplicador especial
            return 1.0;
        }
        
        // F. Narrative/Explanatory Penalty Multiplier
        // Penaliza textos que explican/describen en lugar de afirmar ser
        function getNarrativePenalty(wordIndex, words, totalWords) {
            // Detectar verbos narrativos/explicativos
            const narrativeVerbs = ['say', 'says', 'said', 'tell', 'tells', 'told', 'describe', 'describes', 'described',
                                   'explain', 'explains', 'explained', 'mean', 'means', 'meant', 'think', 'thinks', 'thought',
                                   'decir', 'dice', 'dijo', 'contar', 'cuenta', 'contÃ³', 'describir', 'describe', 'describiÃ³',
                                   'explicar', 'explica', 'explicÃ³', 'significar', 'significa', 'pensar', 'piensa', 'pensÃ³'];
            
            let narrativeWordCount = 0;
            words.forEach(w => {
                // Skip extra names - they don't count for context
                if (w && w.isExtraName) return;
                const cleanWord = w.text.toLowerCase().replace(/[^\w]/g, '');
                if (narrativeVerbs.includes(cleanWord) || 
                    (w.pos === 'verb' && !w.isSerEstar && 
                     !['am', 'is', 'are', 'be', 'was', 'were', 'es', 'son', 'estar', 'ser'].includes(cleanWord))) {
                    narrativeWordCount++;
                }
            });
            
            // Si hay muchos verbos narrativos, el texto estÃ¡ explicando (penalizar)
            if (narrativeWordCount > totalWords * 0.2) {
                // MÃ¡s del 20% son verbos narrativos = texto explicativo
                return 0.6; // PenalizaciÃ³n significativa
            }
            if (narrativeWordCount > totalWords * 0.1) {
                // MÃ¡s del 10% son verbos narrativos
                return 0.8;
            }
            
            return 1.0; // Sin penalizaciÃ³n para textos afirmativos
        }
        
        // Identify compound names (consecutive names treated as one)
        // IMPORTANT: 2 names followed = compound name (name+name)
        // Each part (name1 and name2) must have the same baseValue of 25.0
        // Total value of compound name = much higher than simple name (25.0 + 25.0 base, plus multipliers)
        function identifyCompoundNames() {
            const nameGroups = [];
            let currentGroup = null;
            
            // Pre-pass: Handle ALL combinations as compound names - IGNORE name database completely
            // We ONLY use pos (noun/other) to determine compound names
            // All combinations must be treated the same: noun+noun, noun+other, other+noun, other+other
            for (let i = 0; i < analyzedWords.length - 1; i++) {
                const current = analyzedWords[i];
                const next = analyzedWords[i + 1];
                
                // Check if these two consecutive words can form a compound name
                // CRITICAL: Pronouns can NEVER form compound names
                // Pattern 1: noun + noun => compound name
                // Pattern 2: noun + other => compound name (both become names)
                // Pattern 3: other + noun => compound name (both become names)
                // Pattern 4: other + other => compound name (both become names)
                // BUT: If either word is a pronoun, they CANNOT form a compound name
                const currentIsPronoun = current.pos === 'pronoun';
                const nextIsPronoun = next.pos === 'pronoun';
                // CRITICAL: Exclude adjectives and pronouns from forming compound names
                const currentIsAdjective = current.pos === 'adjective';
                const nextIsAdjective = next.pos === 'adjective';
                const canFormCompound = !currentIsPronoun && !nextIsPronoun && !currentIsAdjective && !nextIsAdjective && (
                    (current.pos === 'noun' && next.pos === 'noun') ||
                    (current.pos === 'noun' && next.pos === 'other') ||
                    (current.pos === 'other' && next.pos === 'noun') ||
                    (current.pos === 'other' && next.pos === 'other')
                );
                
                if (canFormCompound) {
                    // Mark both words as names and part of compound - NO distinction, all treated equally
                    current.isName = true;
                    current.pos = 'noun'; // Ensure both are nouns
                    current.isPartOfCompoundName = true;
                    current.isMiscellaneous = false;
                    
                    next.isName = true;
                    next.pos = 'noun'; // Ensure both are nouns
                    next.isPartOfCompoundName = true;
                    next.isMiscellaneous = false;
                }
            }
            
            // Special case: if there's only one word and it's a name (isolated number or isolated "other")
            // Treat it as a SINGLE name (not compound) - it will get normal name multipliers
            if (analyzedWords.length === 1) {
                const wordData = analyzedWords[0];
                const hasNumbers = /\d/.test(wordData.text);
                const isUnrecognized = wordData.pos === 'other' || (wordData.frequency === 1 && wordData.pos === 'noun' && !wordData.isName);
                
                // Special handling: if it's already marked as name (isolated "other" or isolated number)
                // OR if it's "other" type, mark it as name (but NOT as miscellaneous or compound)
                // CRITICAL: Pronouns can NEVER be names, even if isolated or "other"
                const isPronoun = wordData.pos === 'pronoun';
                if ((wordData.isName || wordData.pos === 'other') && !isPronoun) {
                    // If it was "other" and is isolated, it should already be marked as name in analyzeText
                    // But if for some reason it's still "other", we mark it here too
                    // BUT NOT if it's a pronoun!
                    if (wordData.pos === 'other') {
                        wordData.pos = 'noun';
                        wordData.isName = true;
                    }
                    
                    // DO NOT mark as miscellaneous or compound name - treat as simple name
                    // This ensures it gets normal name baseValue (not 50.0) and normal multipliers
                    wordData.isMiscellaneous = false;
                    wordData.isPartOfCompoundName = false;
                    wordData.compoundNameGroup = null;
                    
                    window.nameGroups = nameGroups;
                    console.log(`Identified 1 isolated name (treated as simple name, not compound)`);
                    return nameGroups;
                } else if (isPronoun) {
                    // CRITICAL: Ensure pronouns NEVER become names
                    wordData.pos = 'pronoun';
                    wordData.isName = false;
                    wordData.isMiscellaneous = false;
                    wordData.isPartOfCompoundName = false;
                    wordData.compoundNameGroup = null;
                }
                
                if (hasNumbers || isUnrecognized) {
                    // Mark as name if it's a noun
                    if (wordData.pos === 'noun') {
                        wordData.isName = true;
                    }
                    
                    // Create a compound name group (even though it's single word, treat as nombre+nombre)
                    const compoundGroup = {
                        indices: [0],
                        startIndex: 0
                    };
                    nameGroups.push(compoundGroup);
                    
                    // Mark as part of compound name
                    wordData.isPartOfCompoundName = true;
                    wordData.compoundNameGroup = compoundGroup;
                    
                    window.nameGroups = nameGroups;
                    console.log(`Identified 1 name group (treated as compound name: unrecognized or has numbers)`);
                    return nameGroups;
                }
            }
            
            // Now group consecutive names into compound name groups
            analyzedWords.forEach((wordData, index) => {
                // Check if this word is a name (marked as name in pre-pass based on compound logic)
                // We ONLY use wordData.isName which is set by compound logic, NOT by database
                const isNameWord = wordData.isName && wordData.pos === 'noun';
                
                if (isNameWord) {
                    if (currentGroup === null) {
                        // Start new group
                        currentGroup = {
                            indices: [index],
                            startIndex: index
                        };
                    } else {
                        // Check if this name is consecutive to the previous one
                        const lastIndex = currentGroup.indices[currentGroup.indices.length - 1];
                        if (index === lastIndex + 1) {
                            // Consecutive name - add to current group
                            currentGroup.indices.push(index);
                        } else {
                            // Not consecutive - save current group and start new one
                            if (currentGroup.indices.length > 0) {
                                nameGroups.push(currentGroup);
                            }
                            currentGroup = {
                                indices: [index],
                                startIndex: index
                            };
                        }
                    }
                } else {
                    // Not a name - close current group if exists
                    if (currentGroup !== null && currentGroup.indices.length > 0) {
                        nameGroups.push(currentGroup);
                        currentGroup = null;
                    }
                }
            });
            
            // Don't forget the last group
            if (currentGroup !== null && currentGroup.indices.length > 0) {
                nameGroups.push(currentGroup);
            }
            
            // Store in global for use in repetition multiplier
            window.nameGroups = nameGroups;
            
            // Mark words that are part of compound names
            nameGroups.forEach(group => {
                // Treat single-word groups that are marked as compound (unrecognized or with numbers) as compound names
                const isSingleWordCompound = group.indices.length === 1 && analyzedWords[group.indices[0]]?.isPartOfCompoundName;
                
                if (group.indices.length > 1 || isSingleWordCompound) {
                    // This is a compound name - mark all words in the group
                    group.indices.forEach((idx, position) => {
                        analyzedWords[idx].isPartOfCompoundName = true;
                        analyzedWords[idx].compoundNameGroup = group;
                        // Mark 3rd+ names as "extra" - they don't count for context
                        if (position >= 2) {
                            analyzedWords[idx].isExtraName = true; // 3rd name or later
                        }
                    });
                }
            });
            
            console.log(`Identified ${nameGroups.length} name groups (${nameGroups.filter(g => g.indices.length > 1).length} compound names)`);
            return nameGroups;
        }
        
        // MAIN CALCULATION FUNCTION - NEW ENGINE
        function calculateScores() {
            console.log('=== NEW ENGINE: calculateScores called ===');
            console.log('Words to process:', analyzedWords.length);
            
            if (!analyzedWords || analyzedWords.length === 0) {
                console.error('calculateScores: No analyzed words to process!');
                return;
            }
            
            // Get name groups from global (set by analyzeText)
            const nameGroups = window.nameGroups || [];
            const totalTokens = analyzedWords.length;
            
            // Mark words that are part of compound names for legacy compatibility
            nameGroups.forEach((group, groupIdx) => {
                if (group.indices && group.indices.length > 0) {
                    group.indices.forEach((idx) => {
                        if (analyzedWords[idx]) {
                            analyzedWords[idx].isPartOfCompoundName = group.indices.length > 1;
                            analyzedWords[idx].compoundNameGroup = group;
                            // Mark as name if part of compound
                            if (group.indices.length > 1) {
                                analyzedWords[idx].isName = true;
                                analyzedWords[idx].pos = 'noun';
                            }
                        }
                    });
                }
            });
            
            // Reconstruct tokens from analyzedWords for value calculation
            const tokens = analyzedWords.map((wordData, idx) => ({
                surface: wordData.text || '',
                type: wordData.uposType || (wordData.isName ? 'NAME' : 'NOUN'),
                name_group: wordData.name_group || null,
                features: {}
            }));
            
            // ========== STEP 1: Calculate repetition multipliers FIRST ==========
            // CRITICAL: Calculate repetition multipliers BEFORE applying contextual multipliers
            // This ensures all repetitions of the same word have the same base devaluation
            // CRITICAL FIX: Compound names must be counted as complete units, not individual words
            console.log('=== Calculating repetition multipliers (BEFORE contextual multipliers) ===');
            
            const repetitionMultipliers = new Map();
            const compoundNameRepetitionMultipliers = new Map(); // Map for compound names as complete units
            const compoundNamePartIndices = new Set(); // Track which indices are part of compound names
            
            // Get nameGroups from global scope if not passed
            const actualNameGroups = nameGroups || window.nameGroups || [];
            
            // STEP 1a: First, calculate repetition multipliers for compound names as complete units
            console.log('=== Calculating compound name repetition multipliers (as complete units) ===');
            actualNameGroups.forEach((group, groupIdx) => {
                if (group.indices && group.indices.length > 1) {
                    // Create unique identifier for the complete compound name
                    const compoundText = group.indices
                        .map(idx => (analyzedWords[idx]?.text || '').toLowerCase().replace(/[^\w]/g, ''))
                        .join(' ');
                    
                    // Mark all indices as part of a compound name
                    group.indices.forEach(idx => {
                        compoundNamePartIndices.add(idx);
                    });
                    
                    // Skip if already calculated for this compound name
                    if (compoundNameRepetitionMultipliers.has(compoundText)) {
                        return;
                    }
                    
                    // Count how many times this exact compound name appears in the text
                    let compoundCount = 0;
                    actualNameGroups.forEach(g => {
                        if (g.indices && g.indices.length > 1) {
                            const gText = g.indices
                                .map(idx => (analyzedWords[idx]?.text || '').toLowerCase().replace(/[^\w]/g, ''))
                                .join(' ');
                            if (gText === compoundText) {
                                compoundCount++;
                            }
                        }
                    });
                    
                    // Calculate repetition multiplier for compound name as a unit
                    // CRITICAL: Repeated compound names should be DEVALUED, not boosted
                    let compoundRepetitionMult = 1.0;
                    if (compoundCount === 1) {
                        compoundRepetitionMult = 1.5; // Unique compound name: bonus
                    } else if (compoundCount === 2) {
                        compoundRepetitionMult = 0.9; // Repeated 2 times: devaluation
                    } else if (compoundCount === 3) {
                        compoundRepetitionMult = 0.8; // Repeated 3 times: more devaluation
                    } else if (compoundCount === 4) {
                        compoundRepetitionMult = 0.7; // Repeated 4 times: significant devaluation
                    } else if (compoundCount === 5) {
                        compoundRepetitionMult = 0.6; // Repeated 5 times: heavy devaluation
                    } else {
                        // Progressive devaluation for very frequent compound names
                        compoundRepetitionMult = Math.max(0.1, 0.6 - ((compoundCount - 5) * 0.1));
                    }
                    
                    compoundNameRepetitionMultipliers.set(compoundText, compoundRepetitionMult);
                    console.log(`[COMPOUND REPETITION] "${compoundText}": appears ${compoundCount} times â†’ multiplier: Ã—${compoundRepetitionMult.toFixed(2)}`);
                }
            });
            
            // STEP 1b: Calculate repetition multipliers for individual words (excluding compound name parts)
            // CRITICAL: All instances of the same word must receive the SAME devaluation multiplier
            // based on the total number of repetitions, regardless of order
            analyzedWords.forEach((wordData, index) => {
                // Skip if this word is part of a compound name (compound names have their own repetition logic)
                if (compoundNamePartIndices.has(index)) {
                    return;
                }
                
                const wordText = (wordData.text || '').toLowerCase().replace(/[^\w]/g, '');
                
                // Skip if already calculated
                if (repetitionMultipliers.has(wordText)) {
                    return;
                }
                
                // Count ALL occurrences of this word (case-insensitive, excluding extra names and compound name parts)
                // This count determines the devaluation for ALL instances of the word
                let count = 0;
                analyzedWords.forEach((w, idx) => {
                    if (w && w.isExtraName) return;
                    if (compoundNamePartIndices.has(idx)) return; // Skip compound name parts
                    const wText = (w.text || '').toLowerCase().replace(/[^\w]/g, '');
                    if (wText === wordText) {
                        count++;
                    }
                });
                
                // Calculate repetition multiplier based on total count
                // CRITICAL: This same multiplier will be applied to ALL instances of the word
                let repetitionMult = 1.0;
                if (count === 1) {
                    repetitionMult = 1.5; // Unique word bonus
                } else if (count === 2) {
                    repetitionMult = 1.2; // Slight bonus for rare repetition
                } else if (count === 3) {
                    repetitionMult = 1.0; // Neutral
                } else if (count === 4) {
                    repetitionMult = 0.9; // Slight devaluation
                } else if (count === 5) {
                    repetitionMult = 0.8; // Moderate devaluation
                } else if (count <= 10) {
                    // Progressive devaluation: 0.8 - (0.1 * (count - 5))
                    repetitionMult = Math.max(0.3, 0.8 - ((count - 5) * 0.1));
                } else {
                    // Heavy devaluation for very frequent words
                    repetitionMult = Math.max(0.1, 0.3 - ((count - 10) * 0.02));
                }
                
                // Store multiplier for this word (ALL occurrences will use the SAME multiplier)
                repetitionMultipliers.set(wordText, repetitionMult);
                console.log(`[REPETITION] Word "${wordData.text}" appears ${count} times â†’ multiplier: Ã—${repetitionMult.toFixed(2)} (applied to ALL ${count} instances)`);
            });
            
            console.log(`Calculated repetition multipliers for ${repetitionMultipliers.size} unique words`);
            console.log(`Calculated repetition multipliers for ${compoundNameRepetitionMultipliers.size} unique compound names`);
            
            // ========== STEP 1.5: Calculate diversity devaluation multiplier ==========
            // Cuantos mÃ¡s nombres, nombres compuestos o sustantivos aparezcan DIFERENTES entre ellos, menos vale cada uno
            // If there are 2 different entities, each is devalued by 2%
            // If there are more than 100 different entities, each is devalued by 20%
            // If there are more than 300 different entities, each is devalued by 50%
            console.log('=== Calculating diversity devaluation multiplier ===');
            
            const uniqueSimpleNames = new Set();
            const uniqueCompoundNames = new Set();
            const uniqueNouns = new Set();
            
            // Count unique simple names
            analyzedWords.forEach((wordData, index) => {
                const isPartOfCompound = compoundNamePartIndices.has(index);
                if (!isPartOfCompound && wordData.isName === true) {
                    const nameText = (wordData.text || '').toLowerCase().trim();
                    if (nameText) {
                        uniqueSimpleNames.add(nameText);
                    }
                }
            });
            
            // Count unique compound names (as complete units)
            actualNameGroups.forEach((group) => {
                if (group.indices && group.indices.length > 1) {
                    const compoundText = group.indices
                        .map(idx => (analyzedWords[idx]?.text || '').toLowerCase().trim())
                        .join(' ');
                    if (compoundText) {
                        uniqueCompoundNames.add(compoundText);
                    }
                }
            });
            
            // Count unique nouns (excluding names)
            analyzedWords.forEach((wordData, index) => {
                const isPartOfCompound = compoundNamePartIndices.has(index);
                const isName = wordData.isName === true;
                if (!isPartOfCompound && !isName && (wordData.uposType === 'NOUN' || wordData.pos === 'noun')) {
                    const nounText = (wordData.text || '').toLowerCase().trim();
                    if (nounText) {
                        uniqueNouns.add(nounText);
                    }
                }
            });
            
            const totalUniqueEntities = uniqueSimpleNames.size + uniqueCompoundNames.size + uniqueNouns.size;
            console.log(`Unique entities: ${uniqueSimpleNames.size} simple names, ${uniqueCompoundNames.size} compound names, ${uniqueNouns.size} nouns = ${totalUniqueEntities} total`);
            
            // Calculate diversity devaluation multiplier
            let diversityDevaluationMult = 1.0;
            if (totalUniqueEntities === 2) {
                diversityDevaluationMult = 0.98; // -2% devaluation
            } else if (totalUniqueEntities > 2 && totalUniqueEntities <= 100) {
                // Progressive devaluation from 2% to 20%
                // Formula: 0.98 - ((count - 2) / 98) * 0.18
                const factor = (totalUniqueEntities - 2) / 98;
                diversityDevaluationMult = 0.98 - (factor * 0.18);
            } else if (totalUniqueEntities > 100 && totalUniqueEntities <= 300) {
                // Progressive devaluation from 20% to 50%
                // Formula: 0.80 - ((count - 100) / 200) * 0.30
                const factor = (totalUniqueEntities - 100) / 200;
                diversityDevaluationMult = 0.80 - (factor * 0.30);
            } else if (totalUniqueEntities > 300) {
                diversityDevaluationMult = 0.50; // -50% devaluation
            }
            
            console.log(`Diversity devaluation multiplier: Ã—${diversityDevaluationMult.toFixed(3)} (${totalUniqueEntities} unique entities)`);
            
            // ========== STEP 1.6: Calculate additional devaluation multipliers ==========
            // 1. If text has more than 2 words and those words are NOT names/compound names, rest of words worth 10% less
            // 2. Adjective-specific multipliers based on count
            // 3. Text length devaluation (>200 words: -20%)
            
            // Count names and compound names (as complete units)
            const nameAndCompoundNameIndices = new Set();
            actualNameGroups.forEach((group) => {
                if (group.indices && group.indices.length > 0) {
                    group.indices.forEach(idx => nameAndCompoundNameIndices.add(idx));
                }
            });
            analyzedWords.forEach((wordData, index) => {
                if (wordData.isName === true && !nameAndCompoundNameIndices.has(index)) {
                    nameAndCompoundNameIndices.add(index);
                }
            });
            
            const nonNameWordCount = totalTokens - nameAndCompoundNameIndices.size;
            const nonNameWordDevaluation = (nonNameWordCount > 2) ? 0.9 : 1.0; // -10% if more than 2 non-name words
            
            // Count adjectives
            const adjectiveCount = analyzedWords.filter((wordData, index) => {
                if (nameAndCompoundNameIndices.has(index)) return false; // Exclude names
                return wordData.uposType === 'ADJ' || wordData.pos === 'adjective';
            }).length;
            
            // Calculate adjective multiplier
            let adjectiveMultiplier = 1.0;
            if (adjectiveCount === 1) {
                adjectiveMultiplier = 1.05; // +5% for single adjective
            } else if (adjectiveCount > 4 && adjectiveCount <= 10) {
                adjectiveMultiplier = 1.0; // No change
            } else if (adjectiveCount > 10 && adjectiveCount <= 20) {
                adjectiveMultiplier = 0.9; // -10%
            } else if (adjectiveCount > 20 && adjectiveCount <= 60) {
                adjectiveMultiplier = 0.7; // -30%
            } else if (adjectiveCount > 60) {
                adjectiveMultiplier = 0.5; // -50%
            }
            
            // Text length devaluation (>200 words: -20%)
            const textLengthDevaluation = (totalTokens > 200) ? 0.8 : 1.0;
            
            console.log(`Additional multipliers: non-name words (${nonNameWordCount}): Ã—${nonNameWordDevaluation.toFixed(2)}, adjectives (${adjectiveCount}): Ã—${adjectiveMultiplier.toFixed(2)}, text length (>200): Ã—${textLengthDevaluation.toFixed(2)}`);
            
            // ========== STEP 2: Identify compound name parts FIRST ==========
            // CRITICAL: Mark which words are part of compound names BEFORE calculating values
            // Compound name parts will be calculated as unified blocks later
            const compoundNamePartIndicesSet = new Set();
            nameGroups.forEach((group) => {
                if (group.indices && group.indices.length >= 2) {
                    group.indices.forEach(idx => {
                        if (idx >= 0 && idx < analyzedWords.length) {
                            compoundNamePartIndicesSet.add(idx);
                        }
                    });
                }
            });
            console.log(`[COMPOUND VALUES] Identified ${compoundNamePartIndicesSet.size} words that are part of compound names`);
            
            // ========== STEP 3: Calculate values for NON-compound words ==========
            // Calculate values using new engine (skip compound name parts - they'll be calculated as blocks)
            const totalWords = analyzedWords.length;
            analyzedWords.forEach((wordData, index) => {
                // Update progress during value calculation (40% to 70%)
                if ((index + 1) % Math.max(1, Math.floor(totalWords / 10)) === 0 || index === totalWords - 1) {
                    const calcProgress = 40 + ((index + 1) / totalWords) * 30;
                    updateLoadingProgress(calcProgress);
                }
                
                try {
                    // CRITICAL: Skip compound name parts - they will be calculated as unified blocks later
                    if (compoundNamePartIndicesSet.has(index)) {
                        console.log(`[VALUE CALC] Skipping "${wordData.text}" (index ${index}) - part of compound name, will calculate as block`);
                        return; // Skip - will be calculated as part of compound name block
                    }
                    
                    // Skip if already processed (shouldn't happen, but safety check)
                    if (wordData.finalValue !== undefined && wordData.finalValue !== null) {
                        // Already calculated, skip
                        return;
                    }
                    
                    // Create token object for value calculation
                    const token = {
                        surface: wordData.text || '',
                        type: wordData.uposType || (wordData.isName ? 'NAME' : uposToLegacyPOS(wordData.pos || 'noun')),
                        name_group: wordData.name_group || null,
                        features: {}
                    };
                    
                    // Get repetition multiplier for this word (applied to base value)
                    const wordText = (wordData.text || '').toLowerCase().replace(/[^\w]/g, '');
                    const repetitionMult = repetitionMultipliers.get(wordText) || 1.0;
                    
                    // Calculate value using new engine (will apply repetition multiplier and diversity devaluation to base)
                    const valueInfo = calculateNewTokenValue(token, index, tokens, nameGroups, analyzedWords, repetitionMult, diversityDevaluationMult, nonNameWordDevaluation, adjectiveMultiplier, textLengthDevaluation);
                    
                    // Assign values to wordData (legacy compatibility)
                    wordData.baseValue = valueInfo.base_value;
                    wordData.finalValue = valueInfo.final_value;
                    wordData.totalScore = valueInfo.final_value;
                    wordData.repetitionMultiplier = repetitionMult;
                    
                    // Store multiplier info for debugging
                    wordData.lengthMultiplier = valueInfo.multipliers.find(m => m.name === 'length_density')?.factor || 1.0;
                    wordData.ontologicalMultiplier = valueInfo.multipliers.find(m => m.name === 'ontological_assertion')?.factor || 1.0;
                    wordData.semanticMultiplier = valueInfo.multipliers.find(m => m.name === 'semantic_closure')?.factor || 1.0;
                    
                    if (index < 5) {
                        console.log(`Word ${index} "${wordData.text}": base=${valueInfo.base_value.toFixed(2)}, final=${valueInfo.final_value.toFixed(2)}, type=${token.type}`);
                    }
                } catch (error) {
                    console.error(`Error calculating value for word ${index}:`, error);
                    // Set default minimum values
                    wordData.baseValue = 1.0;
                    wordData.finalValue = 1.0;
                    wordData.totalScore = 1.0;
                }
            });
            
            // ========== COMPOUND NAMES VALUE CALCULATION - COMPLETELY REBUILT ==========
            // COMPOUND NAMES RULES:
            // 1. A compound name is 2+ consecutive names (name+name, name+name+name, etc.)
            // 2. Acts as ONE SINGLE WORD (namename, ignoring spaces)
            // 3. Worth 20% MORE than a simple name (Ã—1.2 multiplier)
            // 4. If isolated (only text): ~2386 points total value (100% more = double)
            // 5. SAME TOTAL VALUE regardless of number of parts (2 parts = 3 parts = same total)
            // 6. Value distributed EQUALLY among all parts
            // 7. Functions as UNIFIED BLOCK - boosts/devaluations apply to ALL parts equally
            
            console.log(`[COMPOUND VALUES] Processing ${nameGroups.length} compound name groups`);
            
            nameGroups.forEach((group, groupIdx) => {
                if (!group.indices || group.indices.length < 2) return;
                
                // Verify all indices are valid
                const invalidIndices = group.indices.filter(idx => idx < 0 || idx >= analyzedWords.length || !analyzedWords[idx]);
                if (invalidIndices.length > 0) {
                    console.error(`[COMPOUND VALUES] Group ${groupIdx} has invalid indices: [${invalidIndices.join(', ')}]`);
                    return;
                }
                
                const compoundLength = group.indices.length;
                const compoundNames = group.indices.map(idx => analyzedWords[idx]?.text || '?').join(' ');
                
                // Check if isolated (entire text is ONLY this compound name)
                const isIsolated = nameGroups.length === 1 && group.indices.length === totalTokens;
                
                console.log(`[COMPOUND VALUES] Processing "${compoundNames}" (${compoundLength} parts, isolated: ${isIsolated})`);
                
                // Step 1: Get base value for a NAME (compound names use NAME base value)
                const firstIdx = group.indices[0];
                const firstWordData = analyzedWords[firstIdx];
                
                if (!firstWordData) {
                    console.error(`[COMPOUND VALUES] No word data for first part at index ${firstIdx}`);
                    return;
                }
                
                // Get base value for NAME type
                let baseValue = getNewBaseValue('NAME', {}, firstWordData.text || '', firstWordData);
                baseValue = Math.max(baseValue, 1.0); // Floor
                
                // Step 2: Apply repetition multiplier (compound name as a unit)
                const compoundText = group.indices
                    .map(idx => (analyzedWords[idx]?.text || '').toLowerCase().replace(/[^\w]/g, ''))
                    .join(' ');
                const repetitionMult = compoundNameRepetitionMultipliers.get(compoundText) || 1.0;
                baseValue = baseValue * repetitionMult;
                
                // Step 3: Apply diversity devaluation
                baseValue = baseValue * diversityDevaluationMult;
                
                console.log(`[COMPOUND VALUES] Base value: ${baseValue.toFixed(2)}, repetitionMult: Ã—${repetitionMult.toFixed(2)}, diversityMult: Ã—${diversityDevaluationMult.toFixed(2)}`);
                
                // Step 4: Calculate compound name value
                let compoundValue = baseValue;
                
                // Apply semantic closure: Ã—0.36 (MEDIUM, reduced 70%)
                compoundValue *= 0.36;
                
                // Step 5: Apply compound name multiplier (20% more than simple name = Ã—1.2)
                compoundValue *= 1.2;
                
                // Step 6: Check for verb boost BEFORE compound name (applies to entire block)
                let verbBoostBeforeCompound = 1.0;
                let verbBoostType = null;
                
                if (firstIdx > 0) {
                    for (let checkIdx = firstIdx - 1; checkIdx >= Math.max(0, firstIdx - 3); checkIdx--) {
                        const checkAnalyzed = analyzedWords[checkIdx];
                        if (!checkAnalyzed) continue;
                        
                        // Skip determiners and possessive pronouns
                        const isDetOrPoss = checkAnalyzed.uposType === 'DET' || checkAnalyzed.uposType === 'PRON';
                        if (isDetOrPoss) continue;
                        
                        // Check if it's a "to be" verb
                        const checkText = (checkAnalyzed.text || '').toLowerCase().trim();
                        const toBeForms = ['am', 'is', 'are', 'was', 'were', 'be', 'been', 'being'];
                        const isToBeHere = toBeForms.includes(checkText) || checkAnalyzed.isSerEstar;
                        
                        if (isToBeHere) {
                            verbBoostBeforeCompound = 30.0; // Ã—30 for "to be" before compound name
                            verbBoostType = 'to_be';
                            console.log(`[COMPOUND VALUES] Found "to be" verb "${checkText}" before compound - applying Ã—30 boost to ALL parts`);
                            break;
                        } else if (checkAnalyzed.uposType === 'VERB' || checkAnalyzed.pos === 'verb') {
                            verbBoostBeforeCompound = 20.0; // Ã—20 for normal verb
                            verbBoostType = 'normal';
                            console.log(`[COMPOUND VALUES] Found verb "${checkText}" before compound - applying Ã—20 boost to ALL parts`);
                            break;
                        }
                    }
                }
                
                // Apply verb boost if present
                if (verbBoostBeforeCompound !== 1.0) {
                    compoundValue *= verbBoostBeforeCompound;
                }
                
                // Step 7: Apply name-specific multipliers
                if (isIsolated) {
                    // Isolated compound name: should be ~2386 points total value (100% more = double)
                    // We need to calculate the multiplier to reach ~2386 points
                    // Target: ~2386 points for isolated compound name (100% more than base)
                    // Current value after steps 1-6: baseValue Ã— repetitionMult Ã— diversityMult Ã— 0.36 Ã— 1.2 Ã— verbBoost
                    // We need: compoundValue Ã— isolated_multiplier Ã— global_multiplier â‰ˆ 150
                    // For isolated: global_multiplier = Ã—1.5 (short text)
                    // So: compoundValue Ã— isolated_multiplier Ã— 1.5 â‰ˆ 150
                    // isolated_multiplier â‰ˆ 150 / (compoundValue Ã— 1.5) â‰ˆ 100 / compoundValue
                    // But we also want it to be 20% more than simple isolated name (Ã—60)
                    // So: isolated_multiplier = Ã—60 Ã— 1.2 = Ã—72
                    compoundValue *= 72.0; // Isolated compound name: Ã—72 (Ã—60 for isolated Ã— 1.2 for compound)
                } else {
                    // Compound name in context: Ã—1.0 base Ã— 1.2 compound boost
                    compoundValue *= 1.0; // Base multiplier for names in context
                    // Ã—1.2 already applied above for compound boost
                }
                
                // Step 8: Apply global multiplier
                const isLongText = totalTokens >= 100;
                const globalMultiplier = isLongText ? 10.0 * 0.3 : 5.0 * 0.3; // Ã—3.0 or Ã—1.5
                compoundValue *= globalMultiplier;
                
                // Step 8b: For isolated compound names, ensure total is ~2386 points (100% more than base)
                if (isIsolated) {
                    // Adjust to target ~2386 points total (100% more = double the base value)
                    // If current total is too low or too high, scale it
                    const currentTotal = compoundValue;
                    const targetTotal = 2386.0; // Target for isolated compound names (100% more = double)
                    if (currentTotal > 0 && Math.abs(currentTotal - targetTotal) > 10) {
                        // Scale to target
                        const scaleFactor = targetTotal / currentTotal;
                        compoundValue = compoundValue * scaleFactor;
                        console.log(`[COMPOUND VALUES] Scaled isolated compound from ${currentTotal.toFixed(2)} to ${compoundValue.toFixed(2)} (target: ~2386 points, 100% more)`);
                    }
                }
                
                // Step 9: Minimum floor
                compoundValue = Math.max(compoundValue, 1.0);
                
                // Step 10: CRITICAL - Distribute value EQUALLY among all parts
                // The TOTAL value is compoundValue, and it's divided equally among all parts
                // This ensures that 2-part compound = 3-part compound = same TOTAL value
                const valuePerPart = compoundValue / compoundLength;
                const totalCompoundValue = valuePerPart * compoundLength;
                
                console.log(`[COMPOUND VALUES] "${compoundNames}": total=${totalCompoundValue.toFixed(2)}, per part=${valuePerPart.toFixed(2)} (${compoundLength} parts)`);
                
                // Step 11: Apply the SAME value to ALL parts equally
                group.indices.forEach(idx => {
                    if (analyzedWords[idx]) {
                        analyzedWords[idx].baseValue = baseValue / compoundLength; // Base value per part
                        analyzedWords[idx].finalValue = valuePerPart;
                        analyzedWords[idx].totalScore = valuePerPart;
                        analyzedWords[idx].repetitionMultiplier = repetitionMult;
                        analyzedWords[idx].lengthMultiplier = 1.0; // No length devaluation (acts as one word)
                        analyzedWords[idx].semanticMultiplier = 0.36; // MEDIUM closure
                    }
                });
                
                const status = isIsolated ? 'isolated' : 'in context';
                console.log(`[COMPOUND VALUES] âœ“ Applied ${valuePerPart.toFixed(2)} to each of ${compoundLength} parts (${status}), TOTAL = ${totalCompoundValue.toFixed(2)}`);
            });
            
            // ========== REPETITION DEVALUATION ==========
            // NOTE: Repetition devaluation is now applied to BASE VALUE BEFORE contextual multipliers
            // This was moved to the beginning of calculateScores() to ensure all repetitions
            // have the same base value adjustment before contextual multipliers are applied
            // Final values can still differ based on context (ontological, semantic, etc.)
            
            // ========== ONTOLOGICAL STATEMENT VALUE EQUALIZATION ==========
            // CRITICAL: This MUST run AFTER all value calculations and devaluations
            // Pattern: [PRON/NOUN/NAME] + [to be] + [ADJ/NOUN]
            // The predicate (third part) must have the same value as the subject (first part or sum if multiple words)
            // This ensures that if "I am good", then "good" equals "I"
            // If "The dog is big", then "big" equals "dog" (ignoring "The")
            // If "my wife is a house", then "house" equals "my"+"wife" (sum of both)
            console.log('=== Applying ontological statement value equalization (AFTER all calculations) ===');
            
            // Helper function to check if a word is a determiner (should be ignored in pattern detection)
            function isDeterminer(wordData) {
                if (!wordData) return false;
                const text = (wordData.text || '').toLowerCase().trim();
                const uposType = wordData.uposType || '';
                const pos = wordData.pos || '';
                
                // Check POS tags
                if (uposType === 'DET' || pos === 'determiner') return true;
                
                // Check common determiners
                const determiners = ['the', 'a', 'an', 'this', 'that', 'these', 'those', 'some', 'any', 'all', 'every', 'each',
                                   'el', 'la', 'los', 'las', 'un', 'una', 'este', 'esta', 'estos', 'estas', 'ese', 'esa', 'esos', 'esas'];
                return determiners.includes(text);
            }
            
            // Helper function to check if a word is a subject (pronoun, noun, or name)
            function isSubject(wordData) {
                if (!wordData) return false;
                const uposType = wordData.uposType || '';
                const pos = wordData.pos || '';
                const isName = wordData.isName === true;
                
                // Check pronoun
                if (uposType === 'PRON' || uposType === 'PRONOUN' || pos === 'pronoun') return true;
                
                // Check noun
                if (uposType === 'NOUN' || pos === 'noun') return true;
                
                // Check proper noun/name
                if (uposType === 'PROPN' || isName) return true;
                
                return false;
            }
            
            // Helper function to check if a word is a predicate (adjective or noun)
            function isPredicate(wordData) {
                if (!wordData) return false;
                const uposType = wordData.uposType || '';
                const pos = wordData.pos || '';
                const isName = wordData.isName === true;
                
                // Check adjective
                if (uposType === 'ADJ' || uposType === 'ADJECTIVE' || pos === 'adjective') return true;
                
                // Check noun
                if (uposType === 'NOUN' || pos === 'noun') return true;
                
                // Check proper noun/name
                if (uposType === 'PROPN' || isName) return true;
                
                return false;
            }
            
            // Pattern 1: [subject(s)] + [to be] + [predicate]
            // CRITICAL: Do NOT modify values of compound name parts - they must remain equal
            console.log(`[ONTOLOGICAL] ====== STARTING EQUALIZATION (AFTER ALL CALCULATIONS) ======`);
            console.log(`[ONTOLOGICAL] Total words: ${analyzedWords.length}`);
            
            // Get compound name part indices to protect them
            const compoundNamePartIndicesForProtection = new Set();
            nameGroups.forEach((group) => {
                if (group.indices && group.indices.length >= 2) {
                    group.indices.forEach(idx => {
                        if (idx >= 0 && idx < analyzedWords.length) {
                            compoundNamePartIndicesForProtection.add(idx);
                        }
                    });
                }
            });
            
            for (let i = 1; i < analyzedWords.length - 1; i++) {
                const toBeWord = analyzedWords[i];
                if (!toBeWord) continue;
                
                // SIMPLE CHECK: Is this a "to be" verb?
                const toBeText = (toBeWord.text || '').toLowerCase().trim();
                const toBeForms = ['am', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
                                  'ser', 'estar', 'es', 'son', 'estÃ¡', 'estÃ¡n', 'fue', 'fueron', 'soy', 'somos'];
                const isToBe = toBeForms.includes(toBeText) || (toBeWord.isSerEstar === true);
                
                if (!isToBe) continue;
                
                console.log(`[ONTOLOGICAL] âœ“âœ“âœ“ Found "to be" verb "${toBeText}" at index ${i}`);
                
                // Find subject: scan backwards (max 5 words)
                let subjectValue = 0;
                let subjectTexts = [];
                let subjectIndices = [];
                
                for (let j = i - 1; j >= 0 && j >= i - 5; j--) {
                    const word = analyzedWords[j];
                    if (!word) break;
                    
                    const wordText = (word.text || '').toLowerCase().trim();
                    
                    // Skip determiners (don't count in value)
                    if (isDeterminer(word)) {
                        subjectTexts.unshift(word.text);
                        continue;
                    }
                    
                    // Count possessive pronouns AND subject words in value
                    const possessivePronouns = ['my', 'your', 'his', 'her', 'its', 'our', 'their', 'mi', 'tu', 'su', 'nuestro', 'vuestro'];
                    const isPossessive = possessivePronouns.includes(wordText);
                    const isSubj = isSubject(word);
                    
                    if (isPossessive || isSubj) {
                        const wordValue = word.finalValue || 0;
                        subjectValue += wordValue;
                        subjectTexts.unshift(`${word.text}(${wordValue.toFixed(2)})`);
                        subjectIndices.push(j);
                        console.log(`[ONTOLOGICAL] Added to subject: "${word.text}" = ${wordValue.toFixed(2)}, total now: ${subjectValue.toFixed(2)}`);
                    } else {
                        // Stop if we hit something that's not part of subject
                        break;
                    }
                }
                
                if (subjectValue <= 0) {
                    console.log(`[ONTOLOGICAL] âœ— No subject value found before "${toBeText}" at index ${i}`);
                    continue;
                }
                
                console.log(`[ONTOLOGICAL] Subject total value: ${subjectValue.toFixed(2)}`);
                
                // Find predicate: scan forwards (skip determiners)
                let predicateWord = null;
                let predicateIndex = -1;
                for (let j = i + 1; j < analyzedWords.length && j <= i + 3; j++) {
                    const word = analyzedWords[j];
                    if (!word) break;
                    
                    if (isDeterminer(word)) continue;
                    
                    if (isPredicate(word)) {
                        predicateWord = word;
                        predicateIndex = j;
                        break;
                    }
                    
                    break;
                }
                
                if (!predicateWord || predicateIndex === -1) {
                    console.log(`[ONTOLOGICAL] âœ— No predicate found after "${toBeText}" at index ${i}`);
                    continue;
                }
                
                // CRITICAL: Check if subject or predicate are part of compound names
                // If subject contains compound name parts, we need to handle it differently
                const subjectHasCompoundParts = subjectIndices.some(idx => compoundNamePartIndicesForProtection.has(idx));
                const predicateIsCompoundPart = compoundNamePartIndicesForProtection.has(predicateIndex);
                
                // CRITICAL: Do NOT modify compound name parts - they must remain equal
                if (predicateIsCompoundPart) {
                    console.log(`[ONTOLOGICAL] SKIPPING: Predicate "${predicateWord.text}" is part of compound name - cannot modify (must remain equal to other parts)`);
                    continue;
                }
                
                // If subject has compound parts, we need to recalculate subjectValue as the TOTAL value of the compound name
                if (subjectHasCompoundParts) {
                    // Find the compound name group that contains the subject
                    let compoundGroup = null;
                    for (const group of nameGroups) {
                        if (group.indices && group.indices.length >= 2) {
                            const hasSubjectPart = subjectIndices.some(idx => group.indices.includes(idx));
                            if (hasSubjectPart) {
                                compoundGroup = group;
                                break;
                            }
                        }
                    }
                    
                    if (compoundGroup) {
                        // Use the TOTAL value of the compound name as subjectValue
                        const compoundTotalValue = compoundGroup.indices.reduce((sum, idx) => {
                            return sum + (analyzedWords[idx]?.finalValue || 0);
                        }, 0);
                        subjectValue = compoundTotalValue;
                        const compoundNames = compoundGroup.indices.map(idx => analyzedWords[idx]?.text || '?').join(' ');
                        console.log(`[ONTOLOGICAL] Subject is compound name "${compoundNames}" - using total value: ${subjectValue.toFixed(2)}`);
                    }
                }
                
                console.log(`[ONTOLOGICAL] Found predicate: "${predicateWord.text}" at index ${predicateIndex}`);
                
                // CRITICAL: Set predicate value to subject value - FORCE IT DIRECTLY IN ARRAY
                const oldValue = analyzedWords[predicateIndex].finalValue || 0;
                
                // Set it directly in the analyzedWords array (this is the source of truth)
                analyzedWords[predicateIndex].finalValue = subjectValue;
                analyzedWords[predicateIndex].totalScore = subjectValue;
                // Also set it on the predicateWord object reference
                predicateWord.finalValue = subjectValue;
                predicateWord.totalScore = subjectValue;
                
                // Verify the change immediately
                const newValue = analyzedWords[predicateIndex].finalValue || 0;
                
                const subjectDisplay = subjectTexts.join(' ');
                console.log(`[ONTOLOGICAL EQUALIZATION] âœ“âœ“âœ“âœ“âœ“ SUCCESS: "${subjectDisplay}" (${subjectValue.toFixed(2)}) + "${toBeText}" + "${predicateWord.text}"`);
                console.log(`[ONTOLOGICAL EQUALIZATION] âœ“âœ“âœ“âœ“âœ“ "${predicateWord.text}" = ${newValue.toFixed(2)} (was ${oldValue.toFixed(2)})`);
                
                if (Math.abs(newValue - subjectValue) > 0.01) {
                    console.error(`[ONTOLOGICAL ERROR] Value NOT set correctly! "${predicateWord.text}" should be ${subjectValue.toFixed(2)} but is ${newValue.toFixed(2)}`);
                    // Force it again directly in array
                    analyzedWords[predicateIndex].finalValue = subjectValue;
                    analyzedWords[predicateIndex].totalScore = subjectValue;
                    predicateWord.finalValue = subjectValue;
                    predicateWord.totalScore = subjectValue;
                }
            }
            
            // Pattern 2: [PRON+to_be contraction] + [predicate] (2-word pattern, e.g., "I'm good")
            for (let i = 0; i < analyzedWords.length - 1; i++) {
                const firstWord = analyzedWords[i];
                const secondWord = analyzedWords[i + 1];
                
                if (!firstWord || !secondWord) continue;
                
                // Check if first word is a pronoun + "to be" contraction
                const firstText = (firstWord.text || '').toLowerCase().trim();
                const firstIsPronounWithToBe = firstText.includes("'") && 
                    (firstText.endsWith("'m") || firstText.endsWith("'re") || firstText.endsWith("'s")) &&
                    ['i', 'you', 'he', 'she', 'we', 'they', 'it'].includes(firstText.split("'")[0]);
                
                if (!firstIsPronounWithToBe) continue;
                
                // Find predicate: scan forwards (skip determiners)
                let predicateWord = null;
                let predicateIndex = -1;
                for (let j = i + 1; j < analyzedWords.length && j <= i + 3; j++) {
                    const word = analyzedWords[j];
                    if (!word) break;
                    
                    // CRITICAL: Skip compound name parts - they cannot be modified
                    if (compoundNamePartIndicesForProtection.has(j)) {
                        console.log(`[ONTOLOGICAL] Pattern 2: Skipping compound name part "${word.text}" at index ${j} - cannot modify`);
                        continue;
                    }
                    
                    if (isDeterminer(word)) continue;
                    
                    if (isPredicate(word)) {
                        predicateWord = word;
                        predicateIndex = j;
                        break;
                    }
                    
                    break;
                }
                
                if (!predicateWord || predicateIndex === -1) continue;
                
                // Equalize: predicate gets the same value as first part
                const firstValue = firstWord.finalValue || 0;
                if (firstValue > 0) {
                    const oldPredicateValue = analyzedWords[predicateIndex].finalValue || 0;
                    analyzedWords[predicateIndex].finalValue = firstValue;
                    analyzedWords[predicateIndex].totalScore = firstValue;
                    predicateWord.finalValue = firstValue;
                    predicateWord.totalScore = firstValue;
                    
                    console.log(`[ONTOLOGICAL EQUALIZATION] Pattern 2: "${firstWord.text}" (${firstValue.toFixed(2)}) + "${predicateWord.text}" (${oldPredicateValue.toFixed(2)} â†’ ${firstValue.toFixed(2)})`);
                }
            }
            
            console.log('=== Ontological statement value equalization complete ===');
            
            // ========== TO BE VERB VALUE TRANSFER TO ADJECTIVE/NOUN ==========
            // CRITICAL: After calculating all values, transfer value from "to be" verb to following adjective/noun
            // CRITICAL: Do NOT modify compound name parts - they must remain equal
            // If "to be" is followed by an adjective (ignoring determiners/possessive pronouns), transfer 30% of "to be" value
            // If "to be" is followed by a noun (ignoring determiners/possessive pronouns), transfer 45% of "to be" value
            console.log('=== Applying "to be" verb value transfer to adjective/noun ===');
            
            // Get compound name part indices to protect them
            const compoundNamePartIndicesForTransfer = new Set();
            nameGroups.forEach((group) => {
                if (group.indices && group.indices.length >= 2) {
                    group.indices.forEach(idx => {
                        if (idx >= 0 && idx < analyzedWords.length) {
                            compoundNamePartIndicesForTransfer.add(idx);
                        }
                    });
                }
            });
            
            // Helper function to check if a word is a possessive pronoun
            function isPossessivePronoun(wordData) {
                if (!wordData) return false;
                const text = (wordData.text || '').toLowerCase().trim();
                const possessivePronouns = ['my', 'your', 'his', 'her', 'its', 'our', 'their', 'mi', 'tu', 'su', 'nuestro', 'vuestro'];
                return possessivePronouns.includes(text);
            }
            
            // Helper function to check if a word is an adjective
            function isAdjective(wordData) {
                if (!wordData) return false;
                const uposType = wordData.uposType || '';
                const pos = wordData.pos || '';
                return uposType === 'ADJ' || uposType === 'ADJECTIVE' || pos === 'adjective';
            }
            
            // Helper function to check if a word is a noun (excluding names)
            function isNoun(wordData) {
                if (!wordData) return false;
                const uposType = wordData.uposType || '';
                const pos = wordData.pos || '';
                const isName = wordData.isName === true;
                // Exclude proper nouns/names
                if (uposType === 'PROPN' || isName) return false;
                return uposType === 'NOUN' || pos === 'noun';
            }
            
            for (let i = 0; i < analyzedWords.length - 1; i++) {
                const toBeWord = analyzedWords[i];
                if (!toBeWord) continue;
                
                // Check if this is a "to be" verb
                const toBeText = (toBeWord.text || '').toLowerCase().trim();
                const toBeForms = ['am', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
                                  'ser', 'estar', 'es', 'son', 'estÃ¡', 'estÃ¡n', 'fue', 'fueron', 'soy', 'somos'];
                const isToBe = toBeForms.includes(toBeText) || (toBeWord.isSerEstar === true);
                
                if (!isToBe) continue;
                
                const toBeFinalValue = toBeWord.finalValue || 0;
                if (toBeFinalValue <= 0) continue;
                
                console.log(`[TO_BE_TRANSFER] Found "to be" verb "${toBeText}" at index ${i} with value ${toBeFinalValue.toFixed(2)}`);
                
                // Scan forwards to find the next adjective or noun (skip determiners and possessive pronouns)
                let targetWord = null;
                let targetIndex = -1;
                let isTargetAdjective = false;
                let isTargetNoun = false;
                
                for (let j = i + 1; j < analyzedWords.length && j <= i + 5; j++) {
                    const word = analyzedWords[j];
                    if (!word) break;
                    
                    // CRITICAL: Skip compound name parts - they cannot be modified
                    if (compoundNamePartIndicesForTransfer.has(j)) {
                        console.log(`[TO_BE_TRANSFER] Skipping compound name part "${word.text}" at index ${j} - cannot modify`);
                        continue;
                    }
                    
                    // Skip determiners
                    if (isDeterminer(word)) {
                        console.log(`[TO_BE_TRANSFER] Skipping determiner "${word.text}" at index ${j}`);
                        continue;
                    }
                    
                    // Skip possessive pronouns
                    if (isPossessivePronoun(word)) {
                        console.log(`[TO_BE_TRANSFER] Skipping possessive pronoun "${word.text}" at index ${j}`);
                        continue;
                    }
                    
                    // Check if it's an adjective
                    if (isAdjective(word)) {
                        targetWord = word;
                        targetIndex = j;
                        isTargetAdjective = true;
                        console.log(`[TO_BE_TRANSFER] Found adjective "${word.text}" at index ${j}`);
                        break;
                    }
                    
                    // Check if it's a noun
                    if (isNoun(word)) {
                        targetWord = word;
                        targetIndex = j;
                        isTargetNoun = true;
                        console.log(`[TO_BE_TRANSFER] Found noun "${word.text}" at index ${j}`);
                        break;
                    }
                    
                    // If we hit something else that's not a determiner/possessive, stop searching
                    break;
                }
                
                if (!targetWord || targetIndex === -1) {
                    console.log(`[TO_BE_TRANSFER] No adjective or noun found after "${toBeText}" at index ${i}`);
                    continue;
                }
                
                // Calculate transfer amount
                let transferAmount = 0;
                let transferPercentage = 0;
                
                if (isTargetAdjective) {
                    transferPercentage = 0.30; // 30%
                    transferAmount = toBeFinalValue * transferPercentage;
                } else if (isTargetNoun) {
                    transferPercentage = 0.45; // 45%
                    transferAmount = toBeFinalValue * transferPercentage;
                }
                
                if (transferAmount > 0) {
                    const oldTargetValue = analyzedWords[targetIndex].finalValue || 0;
                    const newTargetValue = oldTargetValue + transferAmount;
                    
                    // Update value directly in array (source of truth)
                    analyzedWords[targetIndex].finalValue = newTargetValue;
                    analyzedWords[targetIndex].totalScore = newTargetValue;
                    targetWord.finalValue = newTargetValue;
                    targetWord.totalScore = newTargetValue;
                    
                    const wordType = isTargetAdjective ? 'adjective' : 'noun';
                    console.log(`[TO_BE_TRANSFER] âœ“âœ“âœ“ SUCCESS: "${toBeText}" (${toBeFinalValue.toFixed(2)}) â†’ ${(transferPercentage * 100).toFixed(0)}% = ${transferAmount.toFixed(2)} â†’ "${targetWord.text}" (${wordType})`);
                    console.log(`[TO_BE_TRANSFER] "${targetWord.text}" = ${newTargetValue.toFixed(2)} (was ${oldTargetValue.toFixed(2)}, added ${transferAmount.toFixed(2)})`);
                }
            }
            
            console.log('=== "To be" verb value transfer complete ===');
            
            // ========== POSSESSIVE SENTENCE BOOST: Ã—4 FOR NOUNS AND PRONOUNS IN SENTENCES WITH POSSESSIVES ==========
            console.log('=== Checking for possessive sentence boost ===');
            
            // Get original text to detect sentence boundaries
            const originalTextForPossessive = document.getElementById('textInput')?.value || '';
            
            // Detect sentence boundaries (split by punctuation: ., !, ?, ã€‚, ï¼, ï¼Ÿ)
            const sentenceBoundaries = [];
            if (originalTextForPossessive) {
                // Find all sentence-ending punctuation
                const sentenceEnders = /[.!?ã€‚ï¼ï¼Ÿ]/g;
                let match;
                let lastIndex = 0;
                while ((match = sentenceEnders.exec(originalTextForPossessive)) !== null) {
                    sentenceBoundaries.push(match.index);
                }
                // Add end of text as final boundary
                sentenceBoundaries.push(originalTextForPossessive.length);
            } else {
                // If no original text, treat entire text as one sentence
                sentenceBoundaries.push(analyzedWords.length);
            }
            
            // List of possessive pronouns
            const possessivePronouns = new Set(['my', 'your', 'yours', 'mine', 'his', 'her', 'hers', 'its', 'our', 'ours', 'their', 'theirs',
                                              'mi', 'tu', 'su', 'sus', 'mÃ­o', 'mÃ­a', 'mÃ­os', 'mÃ­as', 'tuyo', 'tuya', 'tuyos', 'tuyas',
                                              'suyo', 'suya', 'suyos', 'suyas', 'nuestro', 'nuestra', 'nuestros', 'nuestras']);
            
            // Map words to sentences and detect which sentences have possessives
            const sentenceIndices = new Map(); // sentenceIndex -> array of word indices
            const sentencesWithPossessives = new Set();
            
            // Better sentence detection: use token positions to map words to sentences
            // Split text into sentences based on punctuation
            let currentSentenceIndex = 0;
            let currentCharPosition = 0;
            
            // Create a map of character positions to sentence indices
            const charToSentenceMap = new Map();
            if (originalTextForPossessive) {
                const sentences = originalTextForPossessive.split(/[.!?ã€‚ï¼ï¼Ÿ]+/).filter(s => s.trim().length > 0);
                let charPos = 0;
                sentences.forEach((sentence, idx) => {
                    const sentenceLength = sentence.length;
                    for (let i = 0; i <= sentenceLength; i++) {
                        charToSentenceMap.set(charPos + i, idx);
                    }
                    charPos += sentenceLength + 1; // +1 for punctuation
                });
            }
            
            // Map each word to its sentence based on token position
            analyzedWords.forEach((wordData, wordIndex) => {
                const wordText = (wordData.text || '').toLowerCase().trim();
                
                // Check if this word is a possessive
                const isPossessive = possessivePronouns.has(wordText) ||
                                   (wordData.analysis && wordData.analysis.possessive === true) ||
                                   (wordData.uposType === 'PRON' && wordData.pos === 'pronoun' && 
                                    (wordData.analysis && wordData.analysis.possessive === true));
                
                // Determine sentence index for this word
                // Use approximate position based on word index (words are roughly in order)
                let sentenceIndex = currentSentenceIndex;
                
                // Check if word ends with sentence-ending punctuation
                const wordSurface = wordData.text || '';
                const endsWithPunct = /[.!?ã€‚ï¼ï¼Ÿ]$/.test(wordSurface.trim());
                
                if (endsWithPunct && wordIndex > 0) {
                    // This word ends a sentence, next word starts new sentence
                    sentenceIndex = currentSentenceIndex;
                    currentSentenceIndex++;
                } else if (wordIndex > 0) {
                    // Check if previous word ended with punctuation
                    const prevWord = analyzedWords[wordIndex - 1];
                    const prevSurface = (prevWord.text || '').trim();
                    const prevEndsWithPunct = /[.!?ã€‚ï¼ï¼Ÿ]$/.test(prevSurface);
                    if (prevEndsWithPunct) {
                        sentenceIndex = currentSentenceIndex;
                    }
                }
                
                // Initialize sentence array if needed
                if (!sentenceIndices.has(sentenceIndex)) {
                    sentenceIndices.set(sentenceIndex, []);
                }
                sentenceIndices.get(sentenceIndex).push(wordIndex);
                
                // Mark sentence as having possessive if this word is possessive
                if (isPossessive) {
                    sentencesWithPossessives.add(sentenceIndex);
                    console.log(`[POSSESSIVE SENTENCE] Found possessive "${wordText}" in sentence ${sentenceIndex}`);
                }
            });
            
            // Apply Ã—4 boost to nouns and pronouns in sentences with possessives
            let possessiveBoostCount = 0;
            sentencesWithPossessives.forEach(sentenceIndex => {
                const sentenceWordIndices = sentenceIndices.get(sentenceIndex) || [];
                
                sentenceWordIndices.forEach(wordIndex => {
                    const wordData = analyzedWords[wordIndex];
                    if (!wordData) return;
                    
                    // Check if word is a noun (excluding names) or pronoun (excluding possessives themselves)
                    const uposType = wordData.uposType || '';
                    const pos = wordData.pos || '';
                    const wordText = (wordData.text || '').toLowerCase().trim();
                    const isPossessive = possessivePronouns.has(wordText);
                    
                    const isNoun = (uposType === 'NOUN' || pos === 'noun') && !wordData.isName;
                    const isPronoun = (uposType === 'PRON' || pos === 'pronoun') && !isPossessive;
                    
                    if (isNoun || isPronoun) {
                        const valueBeforeBoost = wordData.finalValue || 0;
                        const possessiveSentenceBoost = 4.0; // Ã—4 boost
                        
                        wordData.finalValue = valueBeforeBoost * possessiveSentenceBoost;
                        wordData.totalScore = wordData.finalValue;
                        possessiveBoostCount++;
                        
                        console.log(`[POSSESSIVE SENTENCE BOOST] Applied Ã—4 boost to ${isNoun ? 'noun' : 'pronoun'} "${wordData.text}" in sentence ${sentenceIndex} (sentence has possessive)`);
                    }
                });
            });
            
            if (possessiveBoostCount > 0) {
                console.log(`[POSSESSIVE SENTENCE BOOST] Applied Ã—4 boost to ${possessiveBoostCount} nouns/pronouns in ${sentencesWithPossessives.size} sentence(s) with possessives`);
            } else {
                console.log(`[POSSESSIVE SENTENCE BOOST] No sentences with possessives found - no boost applied`);
            }
            
            // Calculate total value (sum of all final values) - AFTER ontological equalization and value transfer
            // NO LIMITS - values can be as high as they need to be
            let totalValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
            
            // ========== GLOBAL FINAL VALUE DEVALUATIONS ==========
            // These devaluations apply to the TOTAL final value, not individual words
            console.log('=== Applying global final value devaluations ===');
            
            // Count nouns (sustantivos) - exclude names
            const nounCount = analyzedWords.filter(w => {
                const uposType = w.uposType || '';
                const pos = w.pos || '';
                return (uposType === 'NOUN' || pos === 'noun') && !w.isName;
            }).length;
            
            // Count adjectives (adjetivos) for global devaluation
            const globalAdjectiveCount = analyzedWords.filter(w => {
                const uposType = w.uposType || '';
                const pos = w.pos || '';
                return uposType === 'ADJ' || uposType === 'ADJECTIVE' || pos === 'adjective';
            }).length;
            
            // Count word repetitions (how many times each word appears)
            const wordFrequencyMap = new Map();
            analyzedWords.forEach(w => {
                const wordText = (w.text || '').toLowerCase().replace(/[^\w]/g, '');
                if (wordText) {
                    wordFrequencyMap.set(wordText, (wordFrequencyMap.get(wordText) || 0) + 1);
                }
            });
            
            // Find maximum repetition count
            let maxRepetitionCount = 0;
            wordFrequencyMap.forEach(count => {
                if (count > maxRepetitionCount) {
                    maxRepetitionCount = count;
                }
            });
            
            console.log(`[GLOBAL DEVALUATION] Nouns: ${nounCount}, Adjectives: ${globalAdjectiveCount}, Max repetition: ${maxRepetitionCount}`);
            
            // Apply noun-based devaluations
            let nounDevaluationMult = 1.0;
            if (nounCount > 200) {
                nounDevaluationMult = 0.50; // -50%
                console.log(`[GLOBAL DEVALUATION] >200 nouns: applying -50% devaluation`);
            } else if (nounCount > 100) {
                nounDevaluationMult = 0.55; // -45%
                console.log(`[GLOBAL DEVALUATION] >100 nouns: applying -45% devaluation`);
            } else if (nounCount > 70) {
                nounDevaluationMult = 0.65; // -35%
                console.log(`[GLOBAL DEVALUATION] >70 nouns: applying -35% devaluation`);
            } else if (nounCount > 40) {
                nounDevaluationMult = 0.70; // -30%
                console.log(`[GLOBAL DEVALUATION] >40 nouns: applying -30% devaluation`);
            } else if (nounCount > 20) {
                nounDevaluationMult = 0.75; // -25%
                console.log(`[GLOBAL DEVALUATION] >20 nouns: applying -25% devaluation`);
            } else if (nounCount > 10) {
                nounDevaluationMult = 0.80; // -20%
                console.log(`[GLOBAL DEVALUATION] >10 nouns: applying -20% devaluation`);
            } else if (nounCount > 5) {
                nounDevaluationMult = 0.90; // -10%
                console.log(`[GLOBAL DEVALUATION] >5 nouns: applying -10% devaluation`);
            }
            
            // Apply adjective-based devaluations
            let adjectiveDevaluationMult = 1.0;
            if (globalAdjectiveCount > 100) {
                adjectiveDevaluationMult = 0.85; // -15%
                console.log(`[GLOBAL DEVALUATION] >100 adjectives: applying -15% devaluation`);
            } else if (globalAdjectiveCount > 20) {
                adjectiveDevaluationMult = 0.90; // -10%
                console.log(`[GLOBAL DEVALUATION] >20 adjectives: applying -10% devaluation`);
            } else if (globalAdjectiveCount > 5) {
                adjectiveDevaluationMult = 0.95; // -5%
                console.log(`[GLOBAL DEVALUATION] >5 adjectives: applying -5% devaluation`);
            }
            
            // Apply repetition-based devaluations
            let repetitionDevaluationMult = 1.0;
            if (maxRepetitionCount > 100) {
                repetitionDevaluationMult = 0.90; // -10%
                console.log(`[GLOBAL DEVALUATION] Word repeated >100 times: applying -10% devaluation`);
            } else if (maxRepetitionCount > 50) {
                repetitionDevaluationMult = 0.95; // -5%
                console.log(`[GLOBAL DEVALUATION] Word repeated >50 times: applying -5% devaluation`);
            } else if (maxRepetitionCount > 15) {
                repetitionDevaluationMult = 0.98; // -2%
                console.log(`[GLOBAL DEVALUATION] Word repeated >15 times: applying -2% devaluation`);
            } else if (maxRepetitionCount > 2) {
                repetitionDevaluationMult = 0.99; // -1%
                console.log(`[GLOBAL DEVALUATION] Word repeated >2 times: applying -1% devaluation`);
            }
            
            // Apply all devaluations to total value
            const valueBeforeDevaluation = totalValue;
            totalValue = totalValue * nounDevaluationMult * adjectiveDevaluationMult * repetitionDevaluationMult;
            
            console.log(`[GLOBAL DEVALUATION] Total value before: ${valueBeforeDevaluation.toFixed(2)}, after: ${totalValue.toFixed(2)}`);
            console.log(`[GLOBAL DEVALUATION] Multipliers: nouns=${nounDevaluationMult.toFixed(3)}, adjectives=${adjectiveDevaluationMult.toFixed(3)}, repetition=${repetitionDevaluationMult.toFixed(3)}`);
            
            // Apply devaluation proportionally to all words
            if (valueBeforeDevaluation > 0) {
                const devaluationFactor = totalValue / valueBeforeDevaluation;
                analyzedWords.forEach(wordData => {
                    if (wordData.finalValue !== undefined && wordData.finalValue !== null) {
                        wordData.finalValue = wordData.finalValue * devaluationFactor;
                        wordData.totalScore = wordData.finalValue;
                    }
                });
                console.log(`[GLOBAL DEVALUATION] Applied devaluation factor ${devaluationFactor.toFixed(4)} to all words`);
            }
            
            // ========== GENERAL VALUE REDUCTION: 50% for all except isolated names/compound names ==========
            console.log('=== Applying 50% reduction to all values except isolated names/compound names ===');
            
            // Check if text is isolated (only names/compound names)
            const totalWordsCount = analyzedWords.length;
            const isIsolatedText = totalWordsCount === 1 || (nameGroups.length === 1 && nameGroups[0].indices.length === totalWordsCount);
            
            // Identify which words are part of isolated names/compound names
            const isolatedNameIndices = new Set();
            if (isIsolatedText && nameGroups.length > 0) {
                nameGroups.forEach(group => {
                    if (group.indices && group.indices.length > 0) {
                        group.indices.forEach(idx => {
                            if (idx >= 0 && idx < analyzedWords.length) {
                                isolatedNameIndices.add(idx);
                            }
                        });
                    }
                });
            } else if (isIsolatedText && totalWordsCount === 1 && analyzedWords[0]?.isName) {
                // Single isolated name
                isolatedNameIndices.add(0);
            }
            
            console.log(`[VALUE REDUCTION] Isolated text: ${isIsolatedText}, Isolated name indices: [${Array.from(isolatedNameIndices).join(', ')}]`);
            
            // Identify which words are names (to protect them from 25% reduction)
            const nameIndices = new Set();
            analyzedWords.forEach((wordData, index) => {
                if (wordData.isName === true || wordData.isPartOfCompoundName === true) {
                    nameIndices.add(index);
                }
            });
            // Also add isolated name indices
            isolatedNameIndices.forEach(idx => nameIndices.add(idx));
            
            // Apply 50% reduction to all words EXCEPT isolated names/compound names
            // AND apply 25% reduction to all words EXCEPT names (including names in context)
            let totalBeforeReduction = 0;
            let totalAfterReduction = 0;
            
            analyzedWords.forEach((wordData, index) => {
                if (wordData.finalValue !== undefined && wordData.finalValue !== null) {
                    totalBeforeReduction += wordData.finalValue;
                    
                    // Skip 50% reduction if this is an isolated name/compound name part
                    if (!isolatedNameIndices.has(index)) {
                        // Apply 50% reduction
                        wordData.finalValue = wordData.finalValue * 0.5;
                        wordData.totalScore = wordData.finalValue;
                    }
                    
                    // Apply 25% reduction to all words EXCEPT names (including names in context)
                    if (!nameIndices.has(index)) {
                        // Apply 25% reduction (Ã—0.75)
                        wordData.finalValue = wordData.finalValue * 0.75;
                        wordData.totalScore = wordData.finalValue;
                    }
                    
                    totalAfterReduction += wordData.finalValue;
                }
            });
            
            // Update total value
            totalValue = totalAfterReduction;
            
            console.log(`[VALUE REDUCTION] Total before: ${totalBeforeReduction.toFixed(2)}, after: ${totalAfterReduction.toFixed(2)}`);
            console.log(`[VALUE REDUCTION] Protected ${isolatedNameIndices.size} isolated name/compound name words from 50% reduction`);
            console.log(`[VALUE REDUCTION] Protected ${nameIndices.size} names (including in context) from 25% reduction`);
            
            // ========== LENGTH-BASED DEVALUATION (applies to total value, NOT to names) ==========
            console.log('=== Applying length-based devaluation to total value (names protected) ===');
            
            // Calculate devaluation percentage based on text length
            let lengthDevaluationPercent = 0.0;
            if (totalWordsCount > 200) {
                lengthDevaluationPercent = 10.0; // -10%
                console.log(`[LENGTH DEVALUATION] Text has ${totalWordsCount} words (>200) - applying -10% devaluation`);
            } else if (totalWordsCount > 100) {
                lengthDevaluationPercent = 5.0; // -5%
                console.log(`[LENGTH DEVALUATION] Text has ${totalWordsCount} words (>100) - applying -5% devaluation`);
            } else if (totalWordsCount > 50) {
                lengthDevaluationPercent = 3.0; // -3%
                console.log(`[LENGTH DEVALUATION] Text has ${totalWordsCount} words (>50) - applying -3% devaluation`);
            } else if (totalWordsCount > 25) {
                lengthDevaluationPercent = 2.0; // -2%
                console.log(`[LENGTH DEVALUATION] Text has ${totalWordsCount} words (>25) - applying -2% devaluation`);
            } else if (totalWordsCount > 15) {
                lengthDevaluationPercent = 1.0; // -1%
                console.log(`[LENGTH DEVALUATION] Text has ${totalWordsCount} words (>15) - applying -1% devaluation`);
            }
            
            // Apply devaluation to total value
            const valueBeforeLengthDevaluation = totalValue;
            if (lengthDevaluationPercent > 0) {
                const devaluationFactor = 1.0 - (lengthDevaluationPercent / 100.0);
                totalValue = totalValue * devaluationFactor;
                
                console.log(`[LENGTH DEVALUATION] Total value before: ${valueBeforeLengthDevaluation.toFixed(2)}, after: ${totalValue.toFixed(2)} (${lengthDevaluationPercent}% reduction)`);
                
                // Distribute devaluation proportionally to all words EXCEPT names
                // This ensures names are protected from length devaluation
                if (valueBeforeLengthDevaluation > 0) {
                    const lengthDevaluationFactor = totalValue / valueBeforeLengthDevaluation;
                    analyzedWords.forEach((wordData, index) => {
                        if (wordData.finalValue !== undefined && wordData.finalValue !== null) {
                            // Skip devaluation if this is a name (including names in context)
                            if (!nameIndices.has(index)) {
                                // Apply length devaluation proportionally
                                wordData.finalValue = wordData.finalValue * lengthDevaluationFactor;
                                wordData.totalScore = wordData.finalValue;
                            }
                        }
                    });
                    console.log(`[LENGTH DEVALUATION] Applied devaluation factor ${lengthDevaluationFactor.toFixed(4)} to all words except ${nameIndices.size} names`);
                }
            } else {
                console.log(`[LENGTH DEVALUATION] No devaluation applied (text has ${totalWordsCount} words, threshold is >15)`);
            }
            
            // ========== SINGLE SENTENCE BOOST (10% boost for single sentence texts) ==========
            console.log('=== Checking for single sentence boost ===');
            
            // Get original text to check for sentence boundaries
            const originalText = document.getElementById('textInput')?.value || '';
            
            // Check if text is a single sentence:
            // - No periods in the middle (only possibly at the end)
            // - Or only punctuation at the end
            let isSingleSentence = false;
            if (originalText) {
                // Remove trailing punctuation (., !, ?, etc.)
                const textWithoutTrailingPunct = originalText.trim().replace(/[.!?ã€‚ï¼ï¼Ÿ]+$/, '');
                // Check if there are any periods/exclamation/question marks in the middle
                const hasMiddlePunctuation = /[.!?ã€‚ï¼ï¼Ÿ]/.test(textWithoutTrailingPunct);
                // Check if there are any periods before the last character
                const textLength = originalText.trim().length;
                const textWithoutLastChar = originalText.trim().substring(0, textLength - 1);
                const hasPunctuationBeforeEnd = /[.!?ã€‚ï¼ï¼Ÿ]/.test(textWithoutLastChar);
                
                // It's a single sentence if:
                // 1. No punctuation in the middle, OR
                // 2. Only punctuation at the very end
                isSingleSentence = !hasMiddlePunctuation || (!hasPunctuationBeforeEnd && /[.!?ã€‚ï¼ï¼Ÿ]/.test(originalText.trim().charAt(textLength - 1)));
            }
            
            if (isSingleSentence) {
                console.log(`[SINGLE SENTENCE BOOST] Text is a single sentence - applying 10% boost to total value`);
                
                const valueBeforeBoost = totalValue;
                const boostFactor = 1.1; // +10% boost
                totalValue = totalValue * boostFactor;
                
                console.log(`[SINGLE SENTENCE BOOST] Total value before: ${valueBeforeBoost.toFixed(2)}, after: ${totalValue.toFixed(2)} (+10%)`);
                
                // Distribute boost proportionally to all words EXCEPT names
                // This ensures names are protected from the boost
                if (valueBeforeBoost > 0) {
                    const boostMultiplier = totalValue / valueBeforeBoost;
                    analyzedWords.forEach((wordData, index) => {
                        if (wordData.finalValue !== undefined && wordData.finalValue !== null) {
                            // Skip boost if this is a name (including names in context)
                            if (!nameIndices.has(index)) {
                                // Apply boost proportionally
                                wordData.finalValue = wordData.finalValue * boostMultiplier;
                                wordData.totalScore = wordData.finalValue;
                            }
                        }
                    });
                    console.log(`[SINGLE SENTENCE BOOST] Applied boost factor ${boostMultiplier.toFixed(4)} to all words except ${nameIndices.size} names`);
                }
            } else {
                console.log(`[SINGLE SENTENCE BOOST] Text is NOT a single sentence (has multiple sentences) - no boost applied`);
            }
            
            // ========== MULTIPLE SENTENCES DEVALUATION ==========
            console.log('=== Checking for multiple sentences devaluation ===');
            
            // Count sentences by counting sentence-ending punctuation (., !, ?, ã€‚, ï¼, ï¼Ÿ)
            let sentenceCount = 0;
            if (originalText) {
                // Count sentence-ending punctuation
                const sentenceEnders = /[.!?ã€‚ï¼ï¼Ÿ]/g;
                const matches = originalText.match(sentenceEnders);
                sentenceCount = matches ? matches.length : 0;
                
                // If text doesn't end with punctuation, count it as one sentence
                if (sentenceCount === 0 && originalText.trim().length > 0) {
                    sentenceCount = 1;
                }
            }
            
            console.log(`[SENTENCE COUNT] Text has ${sentenceCount} sentence(s)`);
            
            // Apply devaluation based on sentence count
            let sentenceDevaluationPercent = 0.0;
            if (sentenceCount > 5 && totalWordsCount > 100) {
                sentenceDevaluationPercent = 40.0; // -40%
                console.log(`[SENTENCE DEVALUATION] Text has ${sentenceCount} sentences (>5) AND ${totalWordsCount} words (>100) - applying -40% devaluation`);
            } else if (sentenceCount > 2) {
                sentenceDevaluationPercent = 20.0; // -20%
                console.log(`[SENTENCE DEVALUATION] Text has ${sentenceCount} sentences (>2) - applying -20% devaluation`);
            }
            
            // Apply devaluation to total value
            if (sentenceDevaluationPercent > 0) {
                const valueBeforeSentenceDevaluation = totalValue;
                const devaluationFactor = 1.0 - (sentenceDevaluationPercent / 100.0);
                totalValue = totalValue * devaluationFactor;
                
                console.log(`[SENTENCE DEVALUATION] Total value before: ${valueBeforeSentenceDevaluation.toFixed(2)}, after: ${totalValue.toFixed(2)} (${sentenceDevaluationPercent}% reduction)`);
                
                // Distribute devaluation proportionally to all words EXCEPT names
                // This ensures names are protected from sentence devaluation
                if (valueBeforeSentenceDevaluation > 0) {
                    const sentenceDevaluationFactor = totalValue / valueBeforeSentenceDevaluation;
                    analyzedWords.forEach((wordData, index) => {
                        if (wordData.finalValue !== undefined && wordData.finalValue !== null) {
                            // Skip devaluation if this is a name (including names in context)
                            if (!nameIndices.has(index)) {
                                // Apply sentence devaluation proportionally
                                wordData.finalValue = wordData.finalValue * sentenceDevaluationFactor;
                                wordData.totalScore = wordData.finalValue;
                            }
                        }
                    });
                    console.log(`[SENTENCE DEVALUATION] Applied devaluation factor ${sentenceDevaluationFactor.toFixed(4)} to all words except ${nameIndices.size} names`);
                }
            } else {
                console.log(`[SENTENCE DEVALUATION] No devaluation applied (${sentenceCount} sentences, threshold is >2 for -20%, or >5 sentences AND >100 words for -40%)`);
            }
            
            // ========== QUESTION DEVALUATION ==========
            console.log('=== Checking for question devaluation ===');
            
            // Check if any words are marked as questions (from OpenAI analysis)
            let questionWordCount = 0;
            const questionWordIndices = new Set();
            
            analyzedWords.forEach((wordData, index) => {
                // Check if word is in a question sentence
                const isQuestion = wordData.analysis && wordData.analysis.isQuestion === true;
                if (isQuestion) {
                    questionWordIndices.add(index);
                    questionWordCount++;
                }
            });
            
            // Also check text for question marks as fallback
            if (questionWordCount === 0 && originalText) {
                const hasQuestionMark = /[?Â¿]/.test(originalText);
                if (hasQuestionMark) {
                    // If text has question mark but OpenAI didn't mark words, mark all words as questions
                    analyzedWords.forEach((wordData, index) => {
                        questionWordIndices.add(index);
                        questionWordCount++;
                    });
                    console.log(`[QUESTION DETECTION] Text has question mark but OpenAI didn't mark words - treating all words as questions`);
                }
            }
            
            console.log(`[QUESTION DETECTION] Found ${questionWordCount} words in question sentences`);
            
            // Apply 30% devaluation to question words
            if (questionWordCount > 0) {
                const questionDevaluationFactor = 0.70; // -30% devaluation
                const valueBeforeQuestionDevaluation = totalValue;
                
                // Calculate total value of question words
                let questionWordsTotalValue = 0;
                questionWordIndices.forEach(index => {
                    if (analyzedWords[index] && analyzedWords[index].finalValue) {
                        questionWordsTotalValue += analyzedWords[index].finalValue;
                    }
                });
                
                // Apply devaluation only to question words
                questionWordIndices.forEach(index => {
                    if (analyzedWords[index] && analyzedWords[index].finalValue !== undefined && analyzedWords[index].finalValue !== null) {
                        const oldValue = analyzedWords[index].finalValue;
                        analyzedWords[index].finalValue = oldValue * questionDevaluationFactor;
                        analyzedWords[index].totalScore = analyzedWords[index].finalValue;
                    }
                });
                
                // Recalculate total value
                totalValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
                
                console.log(`[QUESTION DEVALUATION] Applied -30% devaluation to ${questionWordCount} question words. Total value before: ${valueBeforeQuestionDevaluation.toFixed(2)}, after: ${totalValue.toFixed(2)}`);
            } else {
                console.log(`[QUESTION DEVALUATION] No questions detected - no devaluation applied`);
            }
            
            // ========== TENSE-BASED DEVALUATION/MULTIPLICATION (for texts >100 words) ==========
            console.log('=== Checking for tense-based devaluation/multiplication ===');
            
            // Detect overall text tense from OpenAI analysis
            let detectedTextTense = null;
            const tenseCounts = { PRESENT: 0, PAST: 0, FUTURE: 0 };
            
            analyzedWords.forEach((wordData) => {
                // Check if word has textTense field from OpenAI
                if (wordData.analysis && wordData.analysis.textTense) {
                    const tense = wordData.analysis.textTense.toUpperCase();
                    if (tense === 'PRESENT' || tense === 'PAST' || tense === 'FUTURE') {
                        tenseCounts[tense] = (tenseCounts[tense] || 0) + 1;
                    }
                }
                
                // Also check individual verb tenses as fallback
                if (wordData.analysis && wordData.analysis.tense) {
                    const tense = wordData.analysis.tense.toUpperCase();
                    if (tense === 'PRESENT') tenseCounts.PRESENT++;
                    else if (tense === 'PAST') tenseCounts.PAST++;
                    else if (tense === 'FUTURE') tenseCounts.FUTURE++;
                }
            });
            
            // Determine overall tense (majority rule)
            const totalTenseCount = tenseCounts.PRESENT + tenseCounts.PAST + tenseCounts.FUTURE;
            if (totalTenseCount > 0) {
                if (tenseCounts.PAST > tenseCounts.PRESENT && tenseCounts.PAST > tenseCounts.FUTURE) {
                    detectedTextTense = 'PAST';
                } else if (tenseCounts.FUTURE > tenseCounts.PRESENT && tenseCounts.FUTURE > tenseCounts.PAST) {
                    detectedTextTense = 'FUTURE';
                } else {
                    detectedTextTense = 'PRESENT'; // Default to present
                }
            } else {
                // Fallback: check text for tense indicators
                if (originalText) {
                    const pastIndicators = /\b(was|were|had|did|went|said|told|thought|felt|saw|knew|got|made|took|gave|came|became)\b/i;
                    const futureIndicators = /\b(will|shall|going to|gonna|would|might|may)\b/i;
                    
                    if (pastIndicators.test(originalText) && !futureIndicators.test(originalText)) {
                        detectedTextTense = 'PAST';
                    } else if (futureIndicators.test(originalText)) {
                        detectedTextTense = 'FUTURE';
                    } else {
                        detectedTextTense = 'PRESENT';
                    }
                } else {
                    detectedTextTense = 'PRESENT'; // Default
                }
            }
            
            console.log(`[TENSE DETECTION] Detected text tense: ${detectedTextTense} (PRESENT: ${tenseCounts.PRESENT}, PAST: ${tenseCounts.PAST}, FUTURE: ${tenseCounts.FUTURE})`);
            
            // Apply tense-based devaluation/multiplication only if text >100 words
            if (totalWordsCount > 100) {
                let tenseMultiplier = 1.0;
                
                if (detectedTextTense === 'FUTURE') {
                    tenseMultiplier = 0.90; // -10% devaluation for future tense
                    console.log(`[TENSE DEVALUATION] Text is in FUTURE tense and has ${totalWordsCount} words (>100) - applying -10% devaluation`);
                } else if (detectedTextTense === 'PAST') {
                    tenseMultiplier = 1.5; // Ã—1.5 multiplication for past tense
                    console.log(`[TENSE MULTIPLICATION] Text is in PAST tense and has ${totalWordsCount} words (>100) - applying Ã—1.5 multiplication`);
                } else {
                    // PRESENT tense - no change
                    console.log(`[TENSE] Text is in PRESENT tense - no devaluation/multiplication applied`);
                }
                
                if (tenseMultiplier !== 1.0) {
                    const valueBeforeTenseAdjustment = totalValue;
                    totalValue = totalValue * tenseMultiplier;
                    
                    console.log(`[TENSE ADJUSTMENT] Total value before: ${valueBeforeTenseAdjustment.toFixed(2)}, after: ${totalValue.toFixed(2)} (multiplier: ${tenseMultiplier})`);
                    
                    // Distribute adjustment proportionally to all words EXCEPT names
                    if (valueBeforeTenseAdjustment > 0) {
                        const tenseAdjustmentFactor = totalValue / valueBeforeTenseAdjustment;
                        analyzedWords.forEach((wordData, index) => {
                            if (wordData.finalValue !== undefined && wordData.finalValue !== null) {
                                // Skip adjustment if this is a name (including names in context)
                                if (!nameIndices.has(index)) {
                                    // Apply tense adjustment proportionally
                                    wordData.finalValue = wordData.finalValue * tenseAdjustmentFactor;
                                    wordData.totalScore = wordData.finalValue;
                                }
                            }
                        });
                        console.log(`[TENSE ADJUSTMENT] Applied adjustment factor ${tenseAdjustmentFactor.toFixed(4)} to all words except ${nameIndices.size} names`);
                    }
                }
            } else {
                console.log(`[TENSE] Text has ${totalWordsCount} words (â‰¤100) - tense-based adjustment only applies to texts >100 words`);
            }
            
            // ========== ISOLATED WORD BOOST: Ã—10 FOR SINGLE WORDS (EXCEPT NAMES) ==========
            console.log('=== Checking for isolated word boost ===');
            
            // Check if text has only one word (isolated word)
            if (totalWordsCount === 1 && analyzedWords.length === 1) {
                const isolatedWord = analyzedWords[0];
                if (isolatedWord) {
                    // Check if it's a name or part of compound name (exclude from boost)
                    const isName = isolatedWord.isName === true || isolatedWord.isPartOfCompoundName === true;
                    
                    if (!isName) {
                        // Check word type
                        const uposType = isolatedWord.uposType || '';
                        const pos = isolatedWord.pos || '';
                        const isNoun = (uposType === 'NOUN' || pos === 'noun') && !isName;
                        const isAdjective = uposType === 'ADJ' || uposType === 'ADJECTIVE' || pos === 'adjective';
                        const isAdverb = uposType === 'ADV' || uposType === 'ADVERB' || pos === 'adverb';
                        const isVerb = uposType === 'VERB' || pos === 'verb' || isolatedWord.isSerEstar;
                        
                        // If word is NOT a name, noun, adjective, adverb, or verb (classified as "other")
                        if (!isNoun && !isAdjective && !isAdverb && !isVerb) {
                            // Apply 70% reduction (value becomes 30% of normal value)
                            const valueBeforeReduction = isolatedWord.finalValue || 0;
                            const reducedValue = valueBeforeReduction * 0.3; // 70% reduction = 30% of original
                            isolatedWord.finalValue = reducedValue;
                            isolatedWord.totalScore = reducedValue;
                            
                            // Recalculate total value
                            totalValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
                            
                            console.log(`[ISOLATED WORD] Isolated word "${isolatedWord.text}" is classified as "other" - applying 70% reduction. Value before: ${valueBeforeReduction.toFixed(2)}, after: ${reducedValue.toFixed(2)}`);
                        } else {
                            // Apply boost for valid word types (noun, adjective, adverb, verb)
                            const valueBeforeIsolatedBoost = isolatedWord.finalValue || 0;
                            let isolatedBoostFactor = 10.0; // Ã—10 base boost for isolated words
                            
                            // Apply additional boosts based on word type
                            if (isNoun) {
                                // Noun: Ã—10 additional boost (total Ã—100: Ã—10 base Ã— Ã—10 noun = Ã—100)
                                isolatedBoostFactor *= 10.0;
                                console.log(`[ISOLATED WORD BOOST] Isolated noun detected - applying Ã—10 additional boost (total Ã—100)`);
                            } else if (isAdjective) {
                                // Adjective: Ã—5 additional boost (total Ã—50: Ã—10 base Ã— Ã—5 adjective = Ã—50)
                                isolatedBoostFactor *= 5.0;
                                console.log(`[ISOLATED WORD BOOST] Isolated adjective detected - applying Ã—5 additional boost (total Ã—50)`);
                            } else if (isAdverb) {
                                // Adverb: Ã—3 additional boost (total Ã—30: Ã—10 base Ã— Ã—3 adverb = Ã—30)
                                isolatedBoostFactor *= 3.0;
                                console.log(`[ISOLATED WORD BOOST] Isolated adverb detected - applying Ã—3 additional boost (total Ã—30)`);
                            } else if (isVerb) {
                                // Verb: Ã—5 additional boost (total Ã—50: Ã—10 base Ã— Ã—5 verb = Ã—50)
                                isolatedBoostFactor *= 5.0;
                                console.log(`[ISOLATED WORD BOOST] Isolated verb detected - applying Ã—5 additional boost (total Ã—50)`);
                            }
                            
                            // Apply boost to isolated word
                            isolatedWord.finalValue = valueBeforeIsolatedBoost * isolatedBoostFactor;
                            isolatedWord.totalScore = isolatedWord.finalValue;
                            
                            // Recalculate total value
                            totalValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
                            
                            console.log(`[ISOLATED WORD BOOST] Applied Ã—${isolatedBoostFactor.toFixed(1)} boost to isolated word "${isolatedWord.text}" (${isNoun ? 'noun' : isAdjective ? 'adjective' : isAdverb ? 'adverb' : isVerb ? 'verb' : 'other'}). Value before: ${valueBeforeIsolatedBoost.toFixed(2)}, after: ${isolatedWord.finalValue.toFixed(2)}`);
                        }
                    } else {
                        console.log(`[ISOLATED WORD BOOST] Skipped isolated word "${isolatedWord.text}" - it's a name/compound name (already has high value when isolated)`);
                    }
                }
            } else {
                console.log(`[ISOLATED WORD BOOST] Text has ${totalWordsCount} words - not isolated (boost only applies to single words)`);
            }
            
            // ========== GALLERY WORD REPETITION COST INCREASE (5% for names/compound names, 2% for others) - APPLIED BEFORE GENERAL REDUCTION FOR NAMES ==========
            // This operates ABOVE the existing value system - adds cost for words that appear in gallery
            // CRITICAL: Applied BEFORE general reduction for names/compound names to ensure increase is proportional to high value
            // For other words, applied after general reduction
            // RADICAL CHANGE: Names/compound names get 5% increase per repetition (instead of 2%)
            console.log('=== Applying gallery word repetition cost increase ===');
            const wordRepetitions = getWordRepetitionCounts();
            let galleryIncreaseTotal = 0;
            const wordsWithIncrease = new Map();
            
            // Identify names and compound name parts in current text
            const nameIndicesForGallery = new Set();
            analyzedWords.forEach((wordData, index) => {
                if (wordData.isName === true || wordData.isPartOfCompoundName === true) {
                    nameIndicesForGallery.add(index);
                }
            });
            
            // Apply increase BEFORE general reduction for names/compound names
            analyzedWords.forEach((wordData, index) => {
                const wordText = (wordData.text || '').toLowerCase().trim();
                const repetitionData = wordRepetitions.get(wordText);
                const repetitions = repetitionData ? repetitionData.count : 0;
                const isNameOrCompound = nameIndicesForGallery.has(index);
                
                // Check if word is marked as name/compound in gallery (from previous purchases)
                const isNameInGallery = repetitionData && (repetitionData.isName === true || repetitionData.isCompoundName === true);
                
                if (repetitions > 0 && isNameOrCompound) {
                    // For names/compound names: apply BEFORE general reduction
                    // If word appears in more than 3 purchases, it becomes common and loses value instead of gaining
                    if (repetitions > 3) {
                        // Word appears in more than 3 purchases - it's common, reduce value by 5% for each purchase after the 3rd
                        const purchasesOver3 = repetitions - 3; // Number of purchases beyond the first 3
                        const decreasePercentPerPurchase = 0.05; // 5% reduction per additional purchase
                        // Apply compound reduction: (1 - 0.05) ^ purchasesOver3
                        const totalDecreaseFactor = Math.pow(1 - decreasePercentPerPurchase, purchasesOver3);
                        
                        const valueBeforeDecrease = wordData.finalValue || 0;
                        const valueAfterDecrease = valueBeforeDecrease * totalDecreaseFactor;
                        const decreaseAmount = valueBeforeDecrease - valueAfterDecrease;
                        
                        wordData.finalValue = valueAfterDecrease;
                        wordData.totalScore = wordData.finalValue;
                        
                        galleryIncreaseTotal -= decreaseAmount; // Negative for decrease
                        const totalDecreasePercent = (1 - totalDecreaseFactor) * 100;
                        wordsWithIncrease.set(wordText, {
                            repetitions: repetitions,
                            increasePercent: -totalDecreasePercent, // Negative to indicate decrease
                            increaseAmount: -decreaseAmount,
                            appliedBefore: true,
                            isName: true,
                            isCommon: true,
                            purchasesOver3: purchasesOver3
                        });
                    } else {
                        // Word appears in 3 or fewer purchases - still rare, increase value
                        // RADICAL: Use 10% increase for names/compound names (instead of 2%)
                        const increasePercent = repetitions * 0.10; // 10% per repetition for names/compound names
                        const increaseFactor = 1 + increasePercent;
                        
                        const valueBeforeIncrease = wordData.finalValue || 0;
                        const increaseAmount = valueBeforeIncrease * increasePercent;
                        
                        wordData.finalValue = valueBeforeIncrease * increaseFactor;
                        wordData.totalScore = wordData.finalValue;
                        
                        galleryIncreaseTotal += increaseAmount;
                        wordsWithIncrease.set(wordText, {
                            repetitions: repetitions,
                            increasePercent: increasePercent * 100,
                            increaseAmount: increaseAmount,
                            appliedBefore: true,
                            isName: true,
                            isCommon: false
                        });
                    }
                }
            });
            
            // Recalculate total after name increases/decreases
            if (wordsWithIncrease.size > 0) {
                totalValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
                const increases = Array.from(wordsWithIncrease.values()).filter(d => !d.isCommon).length;
                const decreases = Array.from(wordsWithIncrease.values()).filter(d => d.isCommon).length;
                if (galleryIncreaseTotal > 0) {
                    console.log(`[GALLERY REPETITION] Applied increases to ${increases} names/compound names and decreases to ${decreases} common words BEFORE general reduction. Total change: ${galleryIncreaseTotal > 0 ? '+' : ''}${galleryIncreaseTotal.toFixed(2)}`);
                } else {
                    console.log(`[GALLERY REPETITION] Applied increases to ${increases} names/compound names and decreases to ${decreases} common words BEFORE general reduction. Total change: ${galleryIncreaseTotal.toFixed(2)}`);
                }
                wordsWithIncrease.forEach((data, word) => {
                    if (data.isCommon) {
                        console.log(`[GALLERY REPETITION] "${word}": ${data.repetitions} purchases (COMMON) â†’ ${data.increasePercent.toFixed(1)}% (${data.increaseAmount.toFixed(2)}) [BEFORE reduction, NAME/COMPOUND]`);
                    } else {
                        console.log(`[GALLERY REPETITION] "${word}": ${data.repetitions} purchases â†’ +${data.increasePercent.toFixed(1)}% (+${data.increaseAmount.toFixed(2)}) [BEFORE reduction, NAME/COMPOUND]`);
                    }
                });
            }
            
            // ========== GENERAL VALUE REDUCTION: 40% REDUCTION (Ã—0.6) - NO EXCEPTIONS ==========
            console.log('=== Applying general 40% reduction to ALL values (no exceptions) ===');
            const valueBeforeGeneralReduction = totalValue;
            const generalReductionFactor = 0.6; // -40% reduction (Ã—0.6)
            totalValue = totalValue * generalReductionFactor;
            
            console.log(`[GENERAL REDUCTION] Total value before: ${valueBeforeGeneralReduction.toFixed(2)}, after: ${totalValue.toFixed(2)} (40% reduction)`);
            
            // Apply reduction proportionally to ALL words (no exceptions)
            if (valueBeforeGeneralReduction > 0) {
                const reductionFactor = totalValue / valueBeforeGeneralReduction;
                analyzedWords.forEach((wordData, index) => {
                    if (wordData.finalValue !== undefined && wordData.finalValue !== null) {
                        // Apply reduction to ALL words (no exceptions)
                        wordData.finalValue = wordData.finalValue * reductionFactor;
                        wordData.totalScore = wordData.finalValue;
                    }
                });
                console.log(`[GENERAL REDUCTION] Applied 40% reduction (factor: ${reductionFactor.toFixed(4)}) to ALL ${analyzedWords.length} words`);
            }
            
            // ========== TEXT LENGTH DEVALUATION (excludes Gallery increases) ==========
            // Apply devaluation to base values (excluding Gallery increases)
            // Gallery increases for names were already applied, so we need to calculate base values without them
            console.log('=== Applying text length devaluation (excluding Gallery increases) ===');
            const textLengthForDevaluation = analyzedWords.length;
            
            // Calculate length devaluation multiplier
            let lengthDevaluationFactor = 1.0;
            if (textLengthForDevaluation > 80) {
                lengthDevaluationFactor = 0.4; // -60% devaluation
                console.log(`[LENGTH DEVAL] Text has ${textLengthForDevaluation} words (>80) - applying 60% devaluation (Ã—0.4)`);
            } else if (textLengthForDevaluation > 60) {
                lengthDevaluationFactor = 0.5; // -50% devaluation
                console.log(`[LENGTH DEVAL] Text has ${textLengthForDevaluation} words (>60) - applying 50% devaluation (Ã—0.5)`);
            } else if (textLengthForDevaluation > 30) {
                lengthDevaluationFactor = 0.6; // -40% devaluation
                console.log(`[LENGTH DEVAL] Text has ${textLengthForDevaluation} words (>30) - applying 40% devaluation (Ã—0.6)`);
            } else if (textLengthForDevaluation > 10) {
                lengthDevaluationFactor = 0.8; // -20% devaluation
                console.log(`[LENGTH DEVAL] Text has ${textLengthForDevaluation} words (>10) - applying 20% devaluation (Ã—0.8)`);
            } else {
                console.log(`[LENGTH DEVAL] Text has ${textLengthForDevaluation} words (â‰¤10) - no length devaluation applied`);
            }
            
            // Apply length devaluation to base values (excluding Gallery increases)
            if (lengthDevaluationFactor !== 1.0) {
                // Store Gallery increases per word before applying devaluation
                const galleryIncreasesPerWord = new Map();
                let totalBaseValueWithoutGallery = 0;
                
                analyzedWords.forEach((wordData, index) => {
                    const wordText = (wordData.text || '').toLowerCase().trim();
                    const repetitionData = wordRepetitions.get(wordText);
                    const repetitions = repetitionData ? repetitionData.count : 0;
                    const isNameOrCompound = nameIndicesForGallery.has(index);
                    
                    const currentValue = wordData.finalValue || 0;
                    
                    if (repetitions > 0 && isNameOrCompound) {
                        // This word has Gallery increase applied before general reduction
                        // Calculate base value without Gallery increase
                        // Formula: value_with_gallery = (value_without_gallery * (1 + increasePercent)) * 0.6
                        // So: value_without_gallery = value_with_gallery / (0.6 * (1 + increasePercent))
                        const increasePercent = repetitions * 0.10;
                        const valueWithoutGallery = currentValue / (generalReductionFactor * (1 + increasePercent));
                        const galleryIncreaseAmount = currentValue - (valueWithoutGallery * generalReductionFactor);
                        galleryIncreasesPerWord.set(index, galleryIncreaseAmount);
                        totalBaseValueWithoutGallery += valueWithoutGallery * generalReductionFactor;
                    } else {
                        // No Gallery increase, current value is the base value
                        totalBaseValueWithoutGallery += currentValue;
                    }
                });
                
                // Apply devaluation to base values (without Gallery increases)
                analyzedWords.forEach((wordData, index) => {
                    if (wordData.finalValue !== undefined && wordData.finalValue !== null) {
                        const galleryIncrease = galleryIncreasesPerWord.get(index) || 0;
                        const currentValue = wordData.finalValue || 0;
                        
                        let valueWithoutGallery;
                        if (galleryIncrease > 0) {
                            // Calculate base value without Gallery increase
                            const wordText = (wordData.text || '').toLowerCase().trim();
                            const repetitionData = wordRepetitions.get(wordText);
                            const repetitions = repetitionData ? repetitionData.count : 0;
                            const increasePercent = repetitions * 0.10;
                            valueWithoutGallery = currentValue / (generalReductionFactor * (1 + increasePercent));
                        } else {
                            // No Gallery increase, current value is the base value
                            valueWithoutGallery = currentValue;
                        }
                        
                        // Apply devaluation to base value
                        const devaluedBase = valueWithoutGallery * lengthDevaluationFactor;
                        
                        // Add back Gallery increase (if any)
                        wordData.finalValue = devaluedBase + galleryIncrease;
                        wordData.totalScore = wordData.finalValue;
                    }
                });
                
                // Recalculate total value
                totalValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
                
                const devaluedBaseTotal = totalBaseValueWithoutGallery * lengthDevaluationFactor;
                const totalWithGallery = devaluedBaseTotal + (galleryIncreaseTotal * generalReductionFactor);
                
                console.log(`[LENGTH DEVAL] Applied ${((1 - lengthDevaluationFactor) * 100).toFixed(0)}% devaluation to base values (excluding Gallery increases). Base before: ${totalBaseValueWithoutGallery.toFixed(2)}, after: ${devaluedBaseTotal.toFixed(2)}, total with Gallery: ${totalValue.toFixed(2)}`);
            }
            
            // ========== GALLERY WORD REPETITION COST INCREASE FOR NON-NAMES (2% per repetition) - APPLIED AFTER GENERAL REDUCTION ==========
            // Apply increase AFTER general reduction for non-names
            const nonNameWordsWithIncrease = new Map();
            let nonNameGalleryIncreaseTotal = 0;
            
            analyzedWords.forEach((wordData, index) => {
                const wordText = (wordData.text || '').toLowerCase().trim();
                const repetitionData = wordRepetitions.get(wordText);
                const repetitions = repetitionData ? repetitionData.count : 0;
                const isNameOrCompound = nameIndicesForGallery.has(index);
                
                if (repetitions > 0 && !isNameOrCompound) {
                    // For non-names: apply AFTER general reduction
                    // If word appears in more than 3 purchases, it becomes common and loses value instead of gaining
                    if (repetitions > 3) {
                        // Word appears in more than 3 purchases - it's common, reduce value by 5% for each purchase after the 3rd
                        const purchasesOver3 = repetitions - 3; // Number of purchases beyond the first 3
                        const decreasePercentPerPurchase = 0.05; // 5% reduction per additional purchase
                        // Apply compound reduction: (1 - 0.05) ^ purchasesOver3
                        const totalDecreaseFactor = Math.pow(1 - decreasePercentPerPurchase, purchasesOver3);
                        
                        const valueBeforeDecrease = wordData.finalValue || 0;
                        const valueAfterDecrease = valueBeforeDecrease * totalDecreaseFactor;
                        const decreaseAmount = valueBeforeDecrease - valueAfterDecrease;
                        
                        wordData.finalValue = valueAfterDecrease;
                        wordData.totalScore = wordData.finalValue;
                        
                        nonNameGalleryIncreaseTotal -= decreaseAmount; // Negative for decrease
                        const totalDecreasePercent = (1 - totalDecreaseFactor) * 100;
                        nonNameWordsWithIncrease.set(wordText, {
                            repetitions: repetitions,
                            increasePercent: -totalDecreasePercent, // Negative to indicate decrease
                            increaseAmount: -decreaseAmount,
                            appliedBefore: false,
                            isCommon: true,
                            purchasesOver3: purchasesOver3
                        });
                    } else {
                        // Word appears in 3 or fewer purchases - still rare, increase value
                        const increasePercent = repetitions * 0.02; // 2% per repetition
                        const increaseFactor = 1 + increasePercent;
                        
                        const valueBeforeIncrease = wordData.finalValue || 0;
                        const increaseAmount = valueBeforeIncrease * increasePercent;
                        
                        wordData.finalValue = valueBeforeIncrease * increaseFactor;
                        wordData.totalScore = wordData.finalValue;
                        
                        nonNameGalleryIncreaseTotal += increaseAmount;
                        nonNameWordsWithIncrease.set(wordText, {
                            repetitions: repetitions,
                            increasePercent: increasePercent * 100,
                            increaseAmount: increaseAmount,
                            appliedBefore: false,
                            isCommon: false
                        });
                    }
                }
            });
            
            if (nonNameWordsWithIncrease.size > 0) {
                totalValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
                const increases = Array.from(nonNameWordsWithIncrease.values()).filter(d => !d.isCommon).length;
                const decreases = Array.from(nonNameWordsWithIncrease.values()).filter(d => d.isCommon).length;
                if (nonNameGalleryIncreaseTotal > 0) {
                    console.log(`[GALLERY REPETITION] Applied increases to ${increases} non-name words and decreases to ${decreases} common words AFTER general reduction. Total change: +${nonNameGalleryIncreaseTotal.toFixed(2)}`);
                } else {
                    console.log(`[GALLERY REPETITION] Applied increases to ${increases} non-name words and decreases to ${decreases} common words AFTER general reduction. Total change: ${nonNameGalleryIncreaseTotal.toFixed(2)}`);
                }
                nonNameWordsWithIncrease.forEach((data, word) => {
                    if (data.isCommon) {
                        console.log(`[GALLERY REPETITION] "${word}": ${data.repetitions} purchases (COMMON) â†’ ${data.increasePercent.toFixed(1)}% (${data.increaseAmount.toFixed(2)}) [AFTER reduction]`);
                    } else {
                        console.log(`[GALLERY REPETITION] "${word}": ${data.repetitions} purchases â†’ +${data.increasePercent.toFixed(1)}% (+${data.increaseAmount.toFixed(2)}) [AFTER reduction]`);
                    }
                });
            }
            
            // ========== TOP WORDS GALLERY INCREASE (Top 6-20 add 1.3% each) - APPLIED AFTER ALL OTHER CALCULATIONS ==========
            // Get top 20 words by final value
            const top20Words = [...analyzedWords]
                .filter(w => w && w.text)
                .sort((a, b) => (b.finalValue || b.totalScore || 0) - (a.finalValue || a.totalScore || 0))
                .slice(0, 20);
            
            let topWordsIncreaseTotal = 0;
            const topWordsWithIncrease = new Map();
            
            // Top 5 words keep their existing Gallery increase (already applied above)
            // Top 6-20 words add 1.3% each to the total value
            top20Words.forEach((wordData, rank) => {
                if (rank >= 5) { // Top 6-20 (0-indexed, so rank 5-19)
                    const wordText = (wordData.text || '').toLowerCase().trim();
                    const increasePercent = 0.013; // 1.3% per word
                    const increaseAmount = totalValue * increasePercent;
                    
                    topWordsIncreaseTotal += increaseAmount;
                    topWordsWithIncrease.set(wordText, {
                        rank: rank + 1,
                        increasePercent: increasePercent * 100,
                        increaseAmount: increaseAmount
                    });
                }
            });
            
            // Apply the increase to total value
            if (topWordsWithIncrease.size > 0) {
                totalValue += topWordsIncreaseTotal;
                console.log(`[TOP WORDS GALLERY] Applied 1.3% increase to top 6-20 words. Total increase: ${topWordsIncreaseTotal.toFixed(2)}`);
                topWordsWithIncrease.forEach((data, word) => {
                    console.log(`[TOP WORDS GALLERY] Rank ${data.rank} "${word}": +${data.increasePercent.toFixed(1)}% (+${data.increaseAmount.toFixed(2)})`);
                });
            }
            
            if (wordsWithIncrease.size === 0 && nonNameWordsWithIncrease.size === 0 && topWordsWithIncrease.size === 0) {
                console.log(`[GALLERY REPETITION] No words found in gallery - no cost increase applied`);
            }
            
            // ========== SHORT TEXT BOOST (x10 for <10 words, x5 for <20 words) - APPLIED AFTER ALL GALLERY CALCULATIONS ==========
            // This boost applies ONLY to non-name words and does NOT interfere with Gallery increases
            const totalWordCount = analyzedWords.length;
            let shortTextBoostFactor = 1.0;
            
            if (totalWordCount < 10) {
                shortTextBoostFactor = 10.0; // x10 boost for less than 10 words
            } else if (totalWordCount < 20) {
                shortTextBoostFactor = 5.0; // x5 boost for less than 20 words
            }
            
            if (shortTextBoostFactor > 1.0) {
                console.log(`=== Applying short text boost (${shortTextBoostFactor}x) for ${totalWordCount} words ===`);
                
                // Calculate total value of non-name words (excluding names and compound names)
                let nonNameWordsTotalValue = 0;
                const nameIndices = new Set();
                
                // Identify names and compound names
                analyzedWords.forEach((wordData, index) => {
                    if (wordData.isName === true || wordData.isPartOfCompoundName === true) {
                        nameIndices.add(index);
                    }
                });
                
                // Sum values of non-name words
                analyzedWords.forEach((wordData, index) => {
                    if (!nameIndices.has(index)) {
                        nonNameWordsTotalValue += wordData.finalValue || 0;
                    }
                });
                
                // Calculate boost amount (only applies to non-name words)
                const boostAmount = nonNameWordsTotalValue * (shortTextBoostFactor - 1.0);
                
                // Apply boost to non-name words only
                analyzedWords.forEach((wordData, index) => {
                    if (!nameIndices.has(index)) {
                        const valueBeforeBoost = wordData.finalValue || 0;
                        wordData.finalValue = valueBeforeBoost * shortTextBoostFactor;
                        wordData.totalScore = wordData.finalValue;
                    }
                });
                
                // Update total value
                totalValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
                
                console.log(`[SHORT TEXT BOOST] Applied ${shortTextBoostFactor}x boost to ${analyzedWords.length - nameIndices.size} non-name words. Boost amount: ${boostAmount.toFixed(2)}, Total value after boost: ${totalValue.toFixed(2)}`);
            }
            
            // ========== FINAL VALUE REDUCTION (20% for ALL words) - APPLIED AFTER ALL CALCULATIONS ==========
            console.log('=== Applying 20% reduction to ALL words (including Gallery words) ===');
            const valueBeforeFinalReduction = totalValue;
            const finalReductionFactor = 0.80; // 20% reduction (Ã—0.8)
            
            // Apply 20% reduction to ALL words (including those with Gallery increases)
            analyzedWords.forEach((wordData, index) => {
                if (wordData.finalValue !== undefined && wordData.finalValue !== null) {
                    const valueBeforeReduction = wordData.finalValue || 0;
                    wordData.finalValue = valueBeforeReduction * finalReductionFactor;
                    wordData.totalScore = wordData.finalValue;
                }
            });
            
            // Recalculate total value
            totalValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
            
            const finalReductionAmount = valueBeforeFinalReduction - totalValue;
            console.log(`[FINAL VALUE REDUCTION] Applied 20% reduction to ALL ${analyzedWords.length} words. Total before: ${valueBeforeFinalReduction.toFixed(2)}, after: ${totalValue.toFixed(2)}, reduction: ${finalReductionAmount.toFixed(2)}`);
            
            // ========== ADDITIONAL REDUCTION FOR TEXTS WITH MORE THAN 25 WORDS (25% reduction) ==========
            const wordCount = analyzedWords.length;
            if (wordCount > 25) {
                console.log(`=== Applying additional 25% reduction for texts with more than 25 words (current: ${wordCount} words) ===`);
                const valueBeforeLongTextReduction = totalValue;
                const longTextReductionFactor = 0.75; // 25% reduction (Ã—0.75)
                
                // Apply 25% reduction to ALL words
                analyzedWords.forEach((wordData, index) => {
                    if (wordData.finalValue !== undefined && wordData.finalValue !== null) {
                        const valueBeforeReduction = wordData.finalValue || 0;
                        wordData.finalValue = valueBeforeReduction * longTextReductionFactor;
                        wordData.totalScore = wordData.finalValue;
                    }
                });
                
                // Recalculate total value
                totalValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
                
                const longTextReductionAmount = valueBeforeLongTextReduction - totalValue;
                console.log(`[LONG TEXT REDUCTION] Applied 25% reduction to ALL ${analyzedWords.length} words (text has ${wordCount} words). Total before: ${valueBeforeLongTextReduction.toFixed(2)}, after: ${totalValue.toFixed(2)}, reduction: ${longTextReductionAmount.toFixed(2)}`);
            } else {
                console.log(`[LONG TEXT REDUCTION] Text has ${wordCount} words (â‰¤25 words) - no additional reduction applied`);
            }
            
            // ========== FINAL BOOST: 50% MORE VALUE FOR ISOLATED WORDS AND COMPOUND NAMES ==========
            console.log('=== Applying 50% boost to isolated words and compound names ===');
            
            // Check if text has only one word (isolated word)
            const isSingleWordText = totalWordsCount === 1 && analyzedWords.length === 1;
            
            // Get name groups to check for compound names
            const finalNameGroups = nameGroups || window.nameGroups || [];
            const finalCompoundNameIndices = new Set();
            finalNameGroups.forEach(group => {
                if (group.indices && group.indices.length > 1) {
                    // This is a compound name group
                    group.indices.forEach(idx => {
                        if (idx >= 0 && idx < analyzedWords.length) {
                            finalCompoundNameIndices.add(idx);
                        }
                    });
                }
            });
            
            // Apply 50% boost (Ã—1.5) to isolated words and compound names
            analyzedWords.forEach((wordData, index) => {
                const isIsolatedWord = isSingleWordText && index === 0;
                const isCompoundNamePart = finalCompoundNameIndices.has(index);
                
                if (isIsolatedWord || isCompoundNamePart) {
                    const valueBeforeBoost = wordData.finalValue || 0;
                    const boostedValue = valueBeforeBoost * 1.5; // 50% more = Ã—1.5
                    wordData.finalValue = boostedValue;
                    wordData.totalScore = boostedValue;
                    
                    const reason = isIsolatedWord ? 'isolated word' : 'compound name';
                    console.log(`[FINAL BOOST] Applied 50% boost (Ã—1.5) to "${wordData.text}" (${reason}). Value before: ${valueBeforeBoost.toFixed(2)}, after: ${boostedValue.toFixed(2)}`);
                }
            });
            
            // Recalculate total value after boost
            totalValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
            
            console.log(`Total text value: ${totalValue.toFixed(2)} points`);
            
            // Store total value for display update
            // Reset convergence total value when recalculating scores
            // Convergence values will be added AFTER all devaluations, so they don't affect devaluation calculations
            window.convergenceTotalValue = 0;
            window.totalTextScore = totalValue;
            
            // Calculate normalized scores for visualization (0 to 1)
            const maxValue = Math.max(...analyzedWords.map(w => w.finalValue || 0), 1);
            analyzedWords.forEach(wordData => {
                wordData.normalizedScore = maxValue > 0 ? (wordData.finalValue || 0) / maxValue : 0.5;
                // Ensure normalizedScore is a valid number
                if (isNaN(wordData.normalizedScore) || !isFinite(wordData.normalizedScore)) {
                    wordData.normalizedScore = 0.5;
                }
            });
            
            console.log(`Calculated scores for ${analyzedWords.length} words. Max value: ${maxValue.toFixed(2)}, Total: ${totalValue.toFixed(2)}`);
            
            // Update total value display (convert points directly to ETH)
            if (typeof convertToEthereum === 'function') {
                convertToEthereum(totalValue);
            } else {
                // Fallback: just log the value
                console.log(`Total value: ${totalValue.toFixed(2)} points (ETH conversion function not available)`);
            }
        }
        
        // OLD CALCULATION FUNCTION (keeping for reference, but should not be used)
        function calculateScores_OLD() {
            console.log('calculateScores_OLD called (should not be used)');
            
            if (!analyzedWords || analyzedWords.length === 0) {
                console.error('calculateScores: No analyzed words to process!');
                return;
            }
            
            // Identify compound names first (legacy function)
            identifyCompoundNames();
            
            // Count only non-extra words for context calculations
            // Extra names (3rd+ in compounds) don't count for any contextual calculations
            const effectiveWords = analyzedWords.filter(w => !w.isExtraName);
            const totalWords = effectiveWords.length; // Use effective word count, not total
            const lengthMultiplier = getLengthMultiplier(totalWords);
            console.log(`Length multiplier for ${totalWords} effective words (${analyzedWords.length} total, ${analyzedWords.length - totalWords} extra names ignored)`);
            
            // Calculate final value for each word
            analyzedWords.forEach((wordData, index) => {
                try {
                    // Check if this name is part of a compound with 3+ names
                    // If so, and it's the 3rd name or later, set value to 0
                    let isExtraName = false;
                    if (wordData.isName && wordData.isPartOfCompoundName && wordData.compoundNameGroup) {
                        const nameGroup = wordData.compoundNameGroup;
                        if (nameGroup.indices.length > 2) {
                            // This is a compound with 3+ names
                            const positionInGroup = nameGroup.indices.indexOf(index);
                            if (positionInGroup >= 2) {
                                // This is the 3rd name or later - set value to 0
                                isExtraName = true;
                            }
                        }
                    }
                    
                    // If this is an extra name (3rd+ in a compound), set all values to 0
                    if (isExtraName) {
                        wordData.baseValue = 0;
                        wordData.finalValue = 0;
                        wordData.totalScore = 0;
                        wordData.lengthMultiplier = 1.0;
                        wordData.ontologicalMultiplier = 1.0;
                        wordData.nameWithToBeMultiplier = 1.0;
                        wordData.semanticMultiplier = 1.0;
                        wordData.repetitionMultiplier = 1.0;
                        wordData.tenseMultiplier = 1.0;
                        wordData.narrativePenalty = 1.0;
                        return; // Skip rest of calculation for this word
                    }
                    
                    // ========== CRITICAL: Skip calculation for compound names - handled in post-pass ==========
                    // ALL compound names (name+name, name+other, other+name, other+other) get EXACTLY the same value
                    // We skip the individual calculation here and set a fixed value in post-pass
                    if (wordData.isPartOfCompoundName && wordData.compoundNameGroup) {
                        const nameGroup = wordData.compoundNameGroup;
                        if (nameGroup.indices.length >= 2) {
                            // Skip calculation - will be set to fixed value in post-pass
                            // Set temporary values (will be overwritten)
                            wordData.baseValue = 12.5; // Reduced 50% from 25.0
                            wordData.finalValue = 0; // Temporary, will be set in post-pass
                            wordData.totalScore = 0; // Temporary, will be set in post-pass
                            return; // Skip rest of calculation for compound names
                        }
                    }
                    
                    // Normal calculation for non-compound words
                    // CRITICAL: Pronouns can NEVER be converted to names
                    // CRITICAL: Final safety check - ensure pronouns NEVER have isName = true
                    if (wordData.pos === 'pronoun') {
                        wordData.isName = false;
                    }
                    // CRITICAL: If wordData.pos is "other", it should already be converted to "noun" in analyzeText
                    // But as a safety check, if it's still "other" (and NOT a pronoun), convert it here
                    if (wordData.pos === 'other') {
                        wordData.pos = 'noun';
                        wordData.isName = true;
                        wordData.wasOriginallyOther = true; // Mark that this was originally "other"
                    }
                    
                    let baseValue = getBaseValue(wordData.text, wordData.pos);
                    
                    // CRITICAL: Words that were originally "other" (now converted to noun with isName = true)
                    // must have EXACTLY the same baseValue as simple names (4.0 default for nouns)
                    // This ensures that an isolated "other" word has the same value as an isolated simple name
                    if (wordData.isName && wordData.wasOriginallyOther) {
                        // Override baseValue to match default noun value (4.0)
                        // This ensures that "other" words converted to names have EXACTLY the same value as simple names
                        const defaultNounValue = 4.0; // Default value for concrete specific nouns
                        baseValue = defaultNounValue;
                    }
                    
                    // Apply minimum value constraint
                    baseValue = Math.max(baseValue, 1.0);
                    
                    // Apply multipliers
                    // CRITICAL: For isolated single names (including words originally "other"), we want a uniform HIGH value
                    const isIsolatedSingleName = isIsolatedNames && !hasCompoundNames;
                    
                    if (isIsolatedSingleName) {
                        // For isolated single names, use a FIXED uniform value (HIGH value, same for all)
                        // This ensures "ian", "dagie", "o000j" all have EXACTLY the same HIGH value
                        // We calculate using standard multipliers but ensure uniformity by using fixed base value
                        // Base value: 4.0 (standard for all isolated names), length multiplier: 3.0 (single word)
                        // Isolation multiplier: 10.0x (applied in post-processing)
                        // Formula: 4.0 * 3.0 * 10.0 * 1.0 = ~120.0 (but we'll increase this to match previous high values)
                        // To get a higher value similar to what "ian" had before (~0.4 ETH equivalent), we need a higher base
                        // CRITICAL: Use a MUCH HIGHER base value for isolated names to ensure they have VERY HIGH value
                        // All isolated names use the same base value to ensure uniformity
                        // User reports names cost only 0.10 dollars - needs to be MUCH higher
                        // Formula: 800.0 * 3.0 * 10.0 * 1.0 = ~24000.0 (VERY HIGH value for isolated names - 50x higher)
                        const baseForIsolated = 800.0; // MUCH MUCH higher base value for ALL isolated names (ENSURES UNIFORMITY + VERY HIGH VALUE)
                        const lengthMult = 3.0; // Single word multiplier
                        // Base calculation (will be multiplied by 10.0x isolation multiplier in post-processing)
                        const baseCalculation = baseForIsolated * lengthMult * 1.0; // ~2400.0
                        wordData.baseValue = baseForIsolated;
                        // Store base calculation - will be multiplied by 10.0x in post-processing section below
                        wordData.finalValue = baseCalculation;
                        wordData.totalScore = baseCalculation;
                        
                        // Store multipliers for debugging (fixed values for isolated names)
                        wordData.lengthMultiplier = lengthMult;
                        wordData.ontologicalMultiplier = 1.0;
                        wordData.nameWithToBeMultiplier = 1.0;
                        wordData.semanticMultiplier = 1.0;
                        wordData.repetitionMultiplier = 1.0;
                        wordData.tenseMultiplier = 1.0;
                        wordData.narrativePenalty = 1.0;
                    } else {
                        // Normal calculation for non-isolated names
                        let ontologicalMultiplier = isOntologicalAssertion(index, analyzedWords) ? 1.8 : 1.0;
                        let nameWithToBeMultiplier = getNameWithToBeMultiplier(index, analyzedWords);
                        let semanticMultiplier = getSemanticClosureMultiplier(index, analyzedWords, totalWords);
                        // Use the pre-calculated repetition multiplier from the Map (ensures all instances get same multiplier)
                        const wordTextForRep = (wordData.text || '').toLowerCase().replace(/[^\w]/g, '');
                        let repetitionMultiplier = repetitionMultipliers ? (repetitionMultipliers.get(wordTextForRep) || 1.0) : 1.0;
                        // Fallback to function if Map not available (shouldn't happen in new code)
                        if (!repetitionMultipliers || repetitionMultiplier === 1.0) {
                            repetitionMultiplier = getRepetitionMultiplier(index, analyzedWords, wordData.text, totalWords);
                        }
                        let tenseMultiplier = getTenseMultiplier(index, analyzedWords, totalWords);
                        let narrativePenalty = getNarrativePenalty(index, analyzedWords, totalWords);
                        
                        // Calculate final word value (LEDGER-BASED: no normalization, no averaging, accumulation only)
                        wordData.baseValue = baseValue;
                        wordData.finalValue = (baseValue * lengthMultiplier * ontologicalMultiplier * nameWithToBeMultiplier * semanticMultiplier * repetitionMultiplier * tenseMultiplier * narrativePenalty) * 1.0;
                        wordData.finalValue = Math.max(wordData.finalValue, 1.0);
                        wordData.totalScore = wordData.finalValue;
                        
                        // Store multipliers for debugging/info
                        wordData.lengthMultiplier = lengthMultiplier;
                        wordData.ontologicalMultiplier = ontologicalMultiplier;
                        wordData.nameWithToBeMultiplier = nameWithToBeMultiplier;
                        wordData.semanticMultiplier = semanticMultiplier;
                        wordData.repetitionMultiplier = repetitionMultiplier;
                        wordData.tenseMultiplier = tenseMultiplier;
                        wordData.narrativePenalty = narrativePenalty;
                    }
                    
                    // Log first few words for debugging
                    if (index < 5) {
                        console.log(`Word ${index} "${wordData.text}": base=${baseValue.toFixed(2)}, final=${wordData.finalValue.toFixed(2)}, pos=${wordData.pos}`);
                    }
                } catch (error) {
                    console.error(`Error calculating score for word ${index} (${wordData.text}):`, error);
                    // Set default values to prevent crash
                    wordData.baseValue = 1.0;
                    wordData.finalValue = 1.0;
                    wordData.totalScore = 1.0;
                }
            });

            // ========== CRITICAL: ALL compound names get EXACTLY the same value ==========
            // This ensures name+name, name+other, other+name, and other+other all have the SAME value
            // We use a SINGLE, FIXED calculation for ALL compound names - no variations
            const nameGroups = window.nameGroups || [];
            
            // Check if text ONLY contains names (isolated names) - no verbs, adjectives, or other significant words
            let hasNonNameWords = false;
            analyzedWords.forEach((w, idx) => {
                // Skip extra names (3rd+ in compounds)
                if (w && w.isExtraName) return;
                
                // Check if word is NOT a name
                if (!w || !w.isName || w.pos !== 'noun') {
                    // Allow very common function words (articles, prepositions, conjunctions)
                    const commonWords = ['the', 'a', 'an', 'el', 'la', 'los', 'las', 'un', 'una', 
                                        'and', 'or', 'but', 'y', 'o', 'pero',
                                        'of', 'in', 'on', 'at', 'to', 'for', 'with', 'de', 'en', 'con', 'por', 'para'];
                    const cleanW = w ? w.text.toLowerCase().replace(/[^\w]/g, '') : '';
                    
                    // If it's not a common word and not a name, text is not isolated
                    if (!commonWords.includes(cleanW) && cleanW.length > 0) {
                        hasNonNameWords = true;
                    }
                }
            });
            
            const isIsolatedNames = !hasNonNameWords && nameGroups.length > 0;
            
            // Fixed multipliers for ALL compound names (same for everyone)
            const compoundLengthMultiplier = getLengthMultiplier(totalWords);
            const compoundOntologicalMultiplier = 1.0; // No ontological bonus
            const compoundNameWithToBeMultiplier = 1.0; // No "to be" bonus
            const compoundSemanticMultiplier = 1.0; // Standard semantic
            // Repetition multiplier based on total number of compound name groups (same for all)
            const compoundRepetitionMultiplier = nameGroups.length === 1 ? 10.0 : (nameGroups.length === 2 ? 8.0 : 3.0);
            const compoundTenseMultiplier = 1.0;
            const compoundNarrativePenalty = 1.0;
            
            // ISOLATED NAMES MULTIPLIER: If text only contains names, apply bonus multiplier
            // Compound names get 5.0x, single names get 10.0x when isolated (MUCH higher for single names)
            let isolatedMultiplier = 1.0;
            let hasCompoundNames = nameGroups.some(group => group.indices.length >= 2);
            if (isIsolatedNames) {
                if (hasCompoundNames) {
                    isolatedMultiplier = 5.0; // Compound names isolated: 5.0x multiplier
                } else {
                    isolatedMultiplier = 10.0; // Single names isolated: 10.0x multiplier (MUCH higher)
                }
            }
            
            // Context-size multiplier: if the text has more words than the compound, reduce value
            // Extra words beyond the compound diminish its relative weight
            function getContextCompoundMultiplier(groupSize) {
                const extraWords = Math.max(0, totalWords - groupSize);
                if (extraWords === 0) return 1.0;
                // Decay as extra words grow; floor at 0.35 to avoid zeroing
                return Math.max(0.35, 1 / (1 + (extraWords / 4)));
            }
            
            const globalReduction = 1.0;
            
            // FIXED value per part: ALL compound names use this EXACT same value (with isolation and context bonuses/penalties)
            // Reduced 50% from 25.0 to 12.5
            const BASE_COMPOUND_VALUE_PER_PART = 12.5 * compoundLengthMultiplier * compoundOntologicalMultiplier * 
                                                 compoundNameWithToBeMultiplier * compoundSemanticMultiplier * 
                                                 compoundRepetitionMultiplier * compoundTenseMultiplier * 
                                                 compoundNarrativePenalty * isolatedMultiplier * globalReduction;
            
            // Apply this EXACT same value to ALL compound name groups - NO EXCEPTIONS
            nameGroups.forEach(group => {
                if (group.indices.length >= 2) {
                    const groupId = group.startIndex;
                    
                    // Compute context-size reduction for this specific compound
                    const contextCompoundMultiplier = getContextCompoundMultiplier(group.indices.length);
                    
                    group.indices.forEach((idx, position) => {
                        const w = analyzedWords[idx];
                        if (!w) return;
                        w.compoundGroupId = groupId;
                        
                        if (position < 2) {
                            // First 2 parts: EXACT same fixed value for ALL compounds (reduced 50% from 25.0 to 12.5)
                            w.baseValue = 12.5;
                            const finalVal = BASE_COMPOUND_VALUE_PER_PART * contextCompoundMultiplier;
                            w.finalValue = finalVal;
                            w.totalScore = finalVal;
                            // Store fixed multipliers (same for all)
                            w.lengthMultiplier = compoundLengthMultiplier;
                            w.ontologicalMultiplier = compoundOntologicalMultiplier;
                            w.nameWithToBeMultiplier = compoundNameWithToBeMultiplier;
                            w.semanticMultiplier = compoundSemanticMultiplier;
                            w.repetitionMultiplier = compoundRepetitionMultiplier;
                            w.tenseMultiplier = compoundTenseMultiplier;
                            w.narrativePenalty = compoundNarrativePenalty;
                            w.isolatedMultiplier = isolatedMultiplier; // Store isolation multiplier
                            w.contextCompoundMultiplier = contextCompoundMultiplier; // Store context-size multiplier
                        } else {
                            // 3rd+ parts: set to 0
                            w.baseValue = 0;
                            w.finalValue = 0;
                            w.totalScore = 0;
                        }
                    });
                }
            });
            
            // Apply isolation / context multipliers to single names (not part of compounds)
            analyzedWords.forEach((w, idx) => {
                if (!w || !w.isName || w.pos !== 'noun') return;
                
                // Skip if part of compound
                let isPartOfCompound = false;
                nameGroups.forEach(group => {
                    if (group.indices.length >= 2 && group.indices.includes(idx)) {
                        isPartOfCompound = true;
                    }
                });
                if (isPartOfCompound) return;
                
                // CRITICAL: For isolated single names, apply the isolation multiplier uniformly (10.0x)
                // This ensures all isolated names (ian, dagie, o000j, etc.) get EXACTLY the same HIGH final value
                // The base calculation was done above, now we apply the uniform isolation multiplier
                if (isIsolatedNames && !hasCompoundNames) {
                    // Apply uniform isolation multiplier (10.0x) to ALL isolated single names
                    const singleIsolationMultiplier = 10.0; // Uniform multiplier for all isolated names
                    const contextSingleMultiplier = 1.0; // No context reduction for isolated names
                    
                    // Multiply the base calculation by the isolation multiplier to get the final high value
                    // This ensures ALL isolated names have the same value: baseCalculation * 10.0 = ~25.0
                    w.finalValue = w.finalValue * singleIsolationMultiplier;
                    w.totalScore = w.totalScore * singleIsolationMultiplier;
                    w.isolatedMultiplier = singleIsolationMultiplier;
                    w.contextSingleMultiplier = contextSingleMultiplier;
                    return; // Done - all isolated names now have the same high value
                }
                
                // For non-isolated single names, apply context multipliers
                // Context-size reduction: if there are many extra words, reduce value
                // For a single name, extra words are totalWords - 1
                const extraWordsSingle = Math.max(0, totalWords - 1);
                const contextSingleMultiplier = extraWordsSingle === 0 ? 1.0 : Math.max(0.4, 1 / (1 + (extraWordsSingle / 4)));
                
                // No isolation multiplier for non-isolated names
                w.finalValue = w.finalValue * contextSingleMultiplier;
                w.totalScore = w.totalScore * contextSingleMultiplier;
                w.isolatedMultiplier = 1.0;
                w.contextSingleMultiplier = contextSingleMultiplier;
            });
            
            // Note: Compound names with 3+ names now have the 3rd+ names set to value 0
            // This ensures that all compounds (2, 3, 4, 5... names) have the same total value
            // (only the first 2 names contribute to the value)
            
            // No normalization needed anymore since extra names are set to 0
            if (false && window.nameGroups && window.nameGroups.length > 0) {
                // Calculate reference value: what a 2-name compound should be worth
                // We need to recalculate values as if they were a 2-name compound, not using current values
                let referenceTotalValue = null;
                
                // Find first compound with 2+ names to calculate reference
                for (let i = 0; i < window.nameGroups.length; i++) {
                    const nameGroup = window.nameGroups[i];
                    if (nameGroup.indices.length >= 2) {
                        // Calculate what the first 2 names would be worth as a 2-name compound
                        // We need to recalculate removing the compound multiplier effect and reapplying for 2 names
                        const firstTwoIndices = nameGroup.indices.slice(0, 2);
                        let twoNameTotal = 0;
                        
                        firstTwoIndices.forEach(idx => {
                            const wordData = analyzedWords[idx];
                            if (wordData) {
                                // Current finalValue includes compound multiplier (1.8) for the actual compound size
                                // We need to calculate what it would be for a 2-name compound
                                // Since all names in compound get same multipliers, we can calculate:
                                // value_without_compound = finalValue / 1.8
                                // value_for_2name = value_without_compound * 1.8 = finalValue
                                // But wait, that's the same... 
                                // Actually, the issue is that the repetition multiplier includes compound info
                                // Let's recalculate properly: get base value and all multipliers except compound
                                const baseVal = wordData.baseValue || 0.1;
                                const lengthMult = wordData.lengthMultiplier || 1.0;
                                const ontologicalMult = wordData.ontologicalMultiplier || 1.0;
                                const nameToBeMult = wordData.nameWithToBeMultiplier || 1.0;
                                const semanticMult = wordData.semanticMultiplier || 1.0;
                                const tenseMult = wordData.tenseMultiplier || 1.0;
                                const narrativePen = wordData.narrativePenalty || 1.0;
                                
                                // Get repetition multiplier: we need to extract the compound multiplier part
                                // The repetition multiplier returned from getRepetitionMultiplier includes:
                                // scarcity * repetition * compound (1.8 for compounds)
                                // For a 2-name compound, we want the same scarcity and repetition, but compound is still 1.8
                                // So actually the repetition multiplier should be the same!
                                // The issue is that we're already using the right multiplier, so let's just use current value
                                // But wait - if this is a 3-name compound, the current value has compound 1.8 applied
                                // which is correct, but we want to know what 2 names would be worth
                                // Since each name gets the same multiplier, 2 names = 2 * (value_per_name)
                                // So we can just take the average value per name and multiply by 2
                                
                                // Actually simpler: use current finalValue directly since it already has all multipliers
                                if (wordData.finalValue) {
                                    twoNameTotal += wordData.finalValue;
                                }
                            }
                        });
                        
                        if (twoNameTotal > 0) {
                            referenceTotalValue = twoNameTotal;
                            console.log(`Reference value calculated from first 2 names: ${referenceTotalValue.toFixed(6)}`);
                            break;
                        }
                    }
                }
                
                // Now normalize ALL compounds to have this exact reference value
                if (referenceTotalValue !== null && referenceTotalValue > 0) {
                    console.log(`=== NORMALIZING ALL COMPOUNDS TO: ${referenceTotalValue.toFixed(6)} ===`);
                    window.nameGroups.forEach((nameGroup, groupIdx) => {
                        const nameCount = nameGroup.indices.length;
                        if (nameCount >= 2) {
                            // Calculate current total
                            let currentTotal = 0;
                            nameGroup.indices.forEach(idx => {
                                if (analyzedWords[idx] && analyzedWords[idx].finalValue) {
                                    currentTotal += analyzedWords[idx].finalValue;
                                }
                            });
                            
                            if (currentTotal > 0) {
                                const normalizationFactor = referenceTotalValue / currentTotal;
                                
                                // Apply normalization to ALL names in compound
                                nameGroup.indices.forEach(idx => {
                                    if (analyzedWords[idx] && analyzedWords[idx].finalValue) {
                                        const oldValue = analyzedWords[idx].finalValue;
                                        analyzedWords[idx].finalValue = oldValue * normalizationFactor;
                                        analyzedWords[idx].totalScore = analyzedWords[idx].finalValue;
                                    }
                                });
                                
                                // Verify
                                let newTotal = 0;
                                nameGroup.indices.forEach(idx => {
                                    if (analyzedWords[idx] && analyzedWords[idx].finalValue) {
                                        newTotal += analyzedWords[idx].finalValue;
                                    }
                                });
                                
                                console.log(`Compound ${groupIdx} (${nameCount} names): ${currentTotal.toFixed(6)} â†’ ${newTotal.toFixed(6)} (factor: ${normalizationFactor.toFixed(6)})`);
                                
                                // Double-check: ensure the total is exactly the reference value
                                if (Math.abs(newTotal - referenceTotalValue) > 0.000001) {
                                    console.warn(`WARNING: Normalization mismatch! Expected ${referenceTotalValue.toFixed(6)}, got ${newTotal.toFixed(6)}`);
                                    // Force exact match by adjusting the last name
                                    if (nameGroup.indices.length > 0) {
                                        const lastIdx = nameGroup.indices[nameGroup.indices.length - 1];
                                        if (analyzedWords[lastIdx]) {
                                            const adjustment = referenceTotalValue - newTotal;
                                            analyzedWords[lastIdx].finalValue += adjustment;
                                            analyzedWords[lastIdx].totalScore = analyzedWords[lastIdx].finalValue;
                                            console.log(`Adjusted last name by ${adjustment.toFixed(6)} to fix total`);
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    // Final verification: check all compound totals
                    console.log(`=== FINAL VERIFICATION ===`);
                    const verificationResults = [];
                    window.nameGroups.forEach((nameGroup, groupIdx) => {
                        if (nameGroup.indices.length >= 2) {
                            let total = 0;
                            const names = [];
                            nameGroup.indices.forEach(idx => {
                                if (analyzedWords[idx] && analyzedWords[idx].finalValue) {
                                    total += analyzedWords[idx].finalValue;
                                    names.push(analyzedWords[idx].text);
                                }
                            });
                            const namesText = names.join(' + ');
                            const totalETH = ethPriceUSD ? (total / ethPriceUSD).toFixed(6) : total.toFixed(6);
                            console.log(`Compound ${groupIdx} (${nameGroup.indices.length} names) "${namesText}": ${total.toFixed(6)} points = ${totalETH} ETH`);
                            verificationResults.push({ count: nameGroup.indices.length, total: total, names: namesText });
                        }
                    });
                    
                    // Verify all compounds have the same total
                    if (verificationResults.length > 1) {
                        const firstTotal = verificationResults[0].total;
                        const allMatch = verificationResults.every(r => Math.abs(r.total - firstTotal) < 0.0001);
                        if (allMatch) {
                            console.log(`âœ“ SUCCESS: All ${verificationResults.length} compounds have the same total: ${firstTotal.toFixed(6)}`);
                        } else {
                            console.error(`âœ— ERROR: Compounds have different totals!`);
                            verificationResults.forEach(r => {
                                console.error(`  ${r.count} names "${r.names}": ${r.total.toFixed(6)}`);
                            });
                        }
                    }
                    console.log(`=== NORMALIZATION COMPLETE ===`);
                }
            }
            
            // NOTE: Ontological equalization moved to AFTER repetition devaluation in calculateScores() (line ~7355)
            // This ensures it runs last and overwrites any previous values
            
            // Calculate total text value (LEDGER-BASED: sum of all word values - no averages, no normalization)
            // Total Text Value = Sum of all Final Word Values (ledger entry, not a symbolic number)
            let totalTextValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
            
            // CRITICAL: No text can be worth more than an isolated compound name
            // Maximum isolated compound name value: base 75.0 Ã— boost 20.0 Ã— length 1.5 (1-10 tokens) = 2250.0
            const maxIsolatedCompoundNameValue = 75.0 * 20.0 * 1.5; // = 2250.0
            if (totalTextValue > maxIsolatedCompoundNameValue) {
                console.log(`Total text value ${totalTextValue.toFixed(2)} exceeds max isolated compound name value ${maxIsolatedCompoundNameValue.toFixed(2)}, capping...`);
                totalTextValue = maxIsolatedCompoundNameValue;
            }
            
            // Store total text value
            window.totalTextScore = totalTextValue;
            
            // For visualization, we still need normalized scores (0 to 1) but keep original values
            const maxValue = Math.max(...analyzedWords.map(w => w.finalValue || 0), 1);
            analyzedWords.forEach(wordData => {
                wordData.normalizedScore = maxValue > 0 ? (wordData.finalValue || 0) / maxValue : 0.5;
                // Ensure normalizedScore is a valid number
                if (isNaN(wordData.normalizedScore) || !isFinite(wordData.normalizedScore)) {
                    wordData.normalizedScore = 0.5;
                }
            });
            
            console.log(`Calculated scores for ${analyzedWords.length} words. Max value: ${maxValue}, Total: ${totalTextValue}`);
        }
        
        function isToDoVerb(word) {
            const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
            const toDoVerbs = ['hacer', 'hace', 'hacen', 'hizo', 'hicieron', 'haciendo', 'hecho',
                              'do', 'does', 'did', 'doing', 'done', 'make', 'makes', 'made', 'making'];
            return toDoVerbs.includes(cleanWord);
        }
        
        function isToHaveVerb(word) {
            const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
            const toHaveVerbs = ['tener', 'tiene', 'tienen', 'tuvo', 'tuvieron', 'teniendo', 'tenido',
                                'haber', 'ha', 'han', 'habÃ­a', 'habÃ­an', 'habiendo', 'habido',
                                'have', 'has', 'had', 'having'];
            return toHaveVerbs.includes(cleanWord);
        }
        
        function isSubject(wordData, index) {
            // Check if word is likely a subject (pronoun or noun at start of sentence/clause)
            if (wordData.pos === 'pronoun') return true;
            if (wordData.pos === 'noun' && index < 5) return true; // Early nouns often subjects
            return false;
        }
        
        function isIdentityWord(word) {
            const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
            const identityWords = ['yo', 'i', 'me', 'mi', 'mÃ­o', 'mÃ­a', 'myself',
                                  'tÃº', 'you', 'tu', 'tuyo', 'tuya', 'yourself',
                                  'Ã©l', 'ella', 'he', 'she', 'him', 'her', 'his', 'hers', 'himself', 'herself',
                                  'nosotros', 'nosotras', 'we', 'us', 'our', 'ourselves',
                                  'vosotros', 'vosotras', 'you', 'yourselves',
                                  'ellos', 'ellas', 'they', 'them', 'their', 'themselves',
                                  'persona', 'person', 'gente', 'people', 'ser', 'being', 'identidad', 'identity'];
            return identityWords.includes(cleanWord);
        }
        
        // Database of known proper nouns (names, cities, countries, etc.)
        // Comprehensive database of first names and surnames (case-insensitive matching)
        const KNOWN_PROPER_NOUNS = new Set([
            // Common first names (English - Male)
            'John', 'James', 'Robert', 'Michael', 'William', 'David', 'Richard', 'Joseph', 'Thomas', 'Charles',
            'Christopher', 'Daniel', 'Matthew', 'Anthony', 'Mark', 'Donald', 'Steven', 'Paul', 'Andrew', 'Joshua',
            'Kenneth', 'Kevin', 'Brian', 'George', 'Edward', 'Ronald', 'Timothy', 'Jason', 'Jeffrey', 'Ryan',
            'Jacob', 'Gary', 'Nicholas', 'Eric', 'Jonathan', 'Stephen', 'Larry', 'Justin', 'Scott', 'Brandon',
            'Benjamin', 'Samuel', 'Frank', 'Gregory', 'Raymond', 'Alexander', 'Patrick', 'Jack', 'Dennis', 'Jerry',
            'Tyler', 'Aaron', 'Jose', 'Henry', 'Adam', 'Douglas', 'Nathan', 'Zachary', 'Kyle', 'Noah',
            'Ethan', 'Jeremy', 'Walter', 'Christian', 'Keith', 'Roger', 'Terry', 'Austin', 'Sean', 'Gerald',
            'Carl', 'Harold', 'Dylan', 'Jesse', 'Jordan', 'Bryan', 'Billy', 'Joe', 'Bruce', 'Gabriel',
            'Logan', 'Alan', 'Juan', 'Wayne', 'Roy', 'Ralph', 'Randy', 'Eugene', 'Vincent', 'Louis',
            'Philip', 'Bobby', 'Johnny', 'Russell', 'Lawrence', 'Ivan', 'Mason', 'Willie', 'Albert', 'Arthur',
            'Fred', 'Howard', 'Peter', 'Harry', 'Ian', 'Connor', 'Caleb', 'Lucas', 'Mason', 'Owen',
            'Aiden', 'Liam', 'Mason', 'Ethan', 'Noah', 'Lucas', 'Oliver', 'Aiden', 'Elijah', 'James',
            'Benjamin', 'Mason', 'Ethan', 'Alexander', 'Henry', 'Jackson', 'Sebastian', 'Aiden', 'Matthew', 'Samuel',
            'David', 'Joseph', 'Carter', 'Owen', 'Wyatt', 'John', 'Jack', 'Luke', 'Jayden', 'Dylan',
            'Grayson', 'Levi', 'Isaac', 'Julian', 'Mateo', 'Anthony', 'Jaxon', 'Lincoln', 'Joshua', 'Christopher',
            'Andrew', 'Theodore', 'Caleb', 'Ryan', 'Asher', 'Nathan', 'Thomas', 'Leo', 'Isaiah', 'Charles',
            'Josiah', 'Hudson', 'Christian', 'Hunter', 'Connor', 'Eli', 'Ezra', 'Aaron', 'Landon', 'Adrian',
            'Jonathan', 'Santiago', 'Jordan', 'Colton', 'Angel', 'Cooper', 'Ian', 'Carson', 'Easton', 'Nolan',
            'Parker', 'Roman', 'Connor', 'Tristan', 'Jeremy', 'Preston', 'Jaxson', 'Jose', 'Brayden', 'Bryce',
            'Weston', 'Axel', 'Carlos', 'Brody', 'Ashton', 'Ryder', 'Jesus', 'Silas', 'Sean', 'Nicolas',
            'Ivan', 'Miles', 'Maxwell', 'Kaiden', 'Vincent', 'Justin', 'Max', 'Cole', 'Damian', 'Steven',
            'Richard', 'Timothy', 'Jesse', 'Miguel', 'Diego', 'Luis', 'Antonio', 'Jorge', 'Alejandro', 'Fernando',
            'Rafael', 'Mario', 'Sergio', 'Roberto', 'Alberto', 'Ricardo', 'Eduardo', 'Andres', 'Oscar', 'Raul',
            'Ruben', 'Adrian', 'Alvaro', 'Victor', 'Hector', 'Gonzalo', 'Ignacio', 'Joaquin', 'Marcos', 'Nicolas',
            'Rodrigo', 'Sebastian', 'Tomas', 'Vicente', 'Alfonso', 'Arturo', 'Cesar', 'Emilio', 'Felipe', 'Gabriel',
            'Guillermo', 'Hugo', 'Julian', 'Leandro', 'Martin', 'Nestor', 'Octavio', 'Patricio', 'Ramon', 'Salvador',
            'Simon', 'Tadeo', 'Ulises', 'Valentin', 'Xavier', 'Yago', 'Zacarias', 'Abel', 'Bruno', 'Ciro',
            'Damian', 'Elias', 'Fabian', 'Gael', 'Hernan', 'Iker', 'Jairo', 'Kai', 'Lautaro', 'Mateo',
            // Common first names (English - Female)
            'Mary', 'Sarah', 'Jennifer', 'Emily', 'Jessica', 'Amanda', 'Melissa', 'Deborah', 'Michelle', 'Carol',
            'Lisa', 'Nancy', 'Karen', 'Betty', 'Helen', 'Sandra', 'Donna', 'Carolyn', 'Ruth', 'Sharon',
            'Laura', 'Anna', 'Emma', 'Olivia', 'Sophia', 'Isabella', 'Charlotte', 'Mia', 'Amelia', 'Harper',
            'Evelyn', 'Abigail', 'Emily', 'Elizabeth', 'Mila', 'Ella', 'Avery', 'Sofia', 'Camila', 'Aria',
            'Scarlett', 'Victoria', 'Madison', 'Luna', 'Grace', 'Chloe', 'Penelope', 'Layla', 'Riley', 'Zoey',
            'Nora', 'Lily', 'Eleanor', 'Hannah', 'Lillian', 'Addison', 'Aubrey', 'Ellie', 'Stella', 'Natalie',
            'Zoe', 'Leah', 'Hazel', 'Violet', 'Aurora', 'Savannah', 'Audrey', 'Brooklyn', 'Bella', 'Claire',
            'Skylar', 'Lucy', 'Paisley', 'Everly', 'Anna', 'Caroline', 'Nova', 'Genesis', 'Aaliyah', 'Kennedy',
            'Kinsley', 'Allison', 'Maya', 'Sarah', 'Madelyn', 'Adeline', 'Alexa', 'Ariana', 'Elena', 'Gabriella',
            // Common first names (Spanish - Male)
            'JosÃ©', 'Juan', 'Francisco', 'Antonio', 'Manuel', 'Pedro', 'Carlos', 'Luis', 'Miguel', 'JesÃºs',
            'Javier', 'Fernando', 'Pablo', 'Ãngel', 'Alejandro', 'Rafael', 'Mario', 'Enrique', 'Ricardo', 'Sergio',
            'Alberto', 'Roberto', 'Daniel', 'Jorge', 'Eduardo', 'AndrÃ©s', 'Diego', 'Ã“scar', 'RaÃºl', 'RubÃ©n',
            'AdriÃ¡n', 'Ãlvaro', 'IvÃ¡n', 'VÃ­ctor', 'HÃ©ctor', 'Gonzalo', 'Ignacio', 'JoaquÃ­n', 'Marcos', 'NicolÃ¡s',
            'Rodrigo', 'SebastiÃ¡n', 'TomÃ¡s', 'Vicente', 'Alfonso', 'Arturo', 'CÃ©sar', 'Emilio', 'Felipe', 'Gabriel',
            'Guillermo', 'Hugo', 'JuliÃ¡n', 'Leandro', 'MartÃ­n', 'NÃ©stor', 'Octavio', 'Patricio', 'RamÃ³n', 'Salvador',
            'SimÃ³n', 'Tadeo', 'Ulises', 'ValentÃ­n', 'Xavier', 'Yago', 'ZacarÃ­as', 'Abel', 'Bruno', 'Ciro',
            'DamiÃ¡n', 'ElÃ­as', 'FabiÃ¡n', 'Gael', 'HernÃ¡n', 'Iker', 'Jairo', 'Kai', 'Lautaro', 'Mateo',
            // Common first names (Spanish - Female)
            'MarÃ­a', 'Carmen', 'Ana', 'Laura', 'Patricia', 'Guadalupe', 'Rosa', 'Martha', 'Gloria', 'Andrea',
            'Monica', 'LucÃ­a', 'SofÃ­a', 'Martina', 'Isabella', 'Valentina', 'Emma', 'Olivia', 'Sara', 'Julia',
            'Paula', 'Daniela', 'Victoria', 'Elena', 'Beatriz', 'Dolores', 'Pilar', 'ConcepciÃ³n', 'Mercedes', 'Josefa',
            'Francisca', 'Teresa', 'Isabel', 'Catalina', 'Adriana', 'Alejandra', 'BÃ¡rbara', 'Cecilia', 'Claudia', 'Diana',
            'Esther', 'Gabriela', 'InÃ©s', 'Jimena', 'Karina', 'Lorena', 'Mariana', 'Natalia', 'Rebeca', 'Silvia',
            'VerÃ³nica', 'Yolanda', 'Alicia', 'Amparo', 'Angela', 'Antonia', 'Blanca', 'Cristina', 'Dolores', 'Esperanza',
            'Francisca', 'Gloria', 'Isabel', 'Josefa', 'Juana', 'Lourdes', 'Margarita', 'Milagros', 'Nuria', 'Paloma',
            'Pilar', 'Remedios', 'Rosario', 'Soledad', 'Teresa', 'Trinidad', 'Vanesa', 'Yolanda', 'Zoraida', 'Aurora',
            'Belen', 'Carmen', 'Consuelo', 'Dolores', 'Esperanza', 'Felisa', 'Gracia', 'Herminia', 'Inmaculada', 'Josefa',
            // Additional English Female Names
            'Charlotte', 'Harper', 'Evelyn', 'Abigail', 'Emily', 'Elizabeth', 'Mila', 'Ella', 'Avery', 'Sofia',
            'Camila', 'Aria', 'Scarlett', 'Victoria', 'Madison', 'Luna', 'Grace', 'Chloe', 'Penelope', 'Layla',
            'Riley', 'Zoey', 'Nora', 'Lily', 'Eleanor', 'Hannah', 'Lillian', 'Addison', 'Aubrey', 'Ellie',
            'Stella', 'Natalie', 'Zoe', 'Leah', 'Hazel', 'Violet', 'Aurora', 'Savannah', 'Audrey', 'Brooklyn',
            'Bella', 'Claire', 'Skylar', 'Lucy', 'Paisley', 'Everly', 'Caroline', 'Nova', 'Genesis', 'Aaliyah',
            'Kennedy', 'Kinsley', 'Allison', 'Maya', 'Madelyn', 'Adeline', 'Alexa', 'Ariana', 'Elena', 'Gabriella',
            'Naomi', 'Alice', 'Samantha', 'Hailey', 'Eva', 'Emilia', 'Autumn', 'Quinn', 'Nevaeh', 'Piper',
            'Willow', 'Lydia', 'Peyton', 'Brielle', 'Annabelle', 'Katherine', 'Liliana', 'Faith', 'Alexis', 'Rose',
            'Isabelle', 'Julia', 'Arianna', 'Allison', 'Savannah', 'Valentina', 'Claire', 'Samantha', 'Stella', 'Violet',
            'Aria', 'Lucy', 'Paisley', 'Everly', 'Caroline', 'Nova', 'Genesis', 'Aaliyah', 'Kennedy', 'Kinsley',
            // Additional English Male Names
            'Ian', 'Connor', 'Caleb', 'Lucas', 'Owen', 'Aiden', 'Liam', 'Oliver', 'Elijah', 'Sebastian',
            'Carter', 'Wyatt', 'Jayden', 'Grayson', 'Levi', 'Isaac', 'Julian', 'Jaxon', 'Lincoln', 'Theodore',
            'Asher', 'Leo', 'Isaiah', 'Josiah', 'Hudson', 'Hunter', 'Eli', 'Ezra', 'Landon', 'Santiago',
            'Colton', 'Angel', 'Cooper', 'Carson', 'Easton', 'Nolan', 'Parker', 'Roman', 'Tristan', 'Preston',
            'Brayden', 'Bryce', 'Weston', 'Axel', 'Brody', 'Ashton', 'Ryder', 'Silas', 'Miles', 'Maxwell',
            'Kaiden', 'Max', 'Cole', 'Damian', 'Zachary', 'Luke', 'Grayson', 'Jackson', 'Levi', 'Mateo',
            'Asher', 'Leo', 'Isaiah', 'Josiah', 'Hudson', 'Hunter', 'Eli', 'Ezra', 'Landon', 'Santiago',
            'Colton', 'Angel', 'Cooper', 'Carson', 'Easton', 'Nolan', 'Parker', 'Roman', 'Tristan', 'Preston',
            'Brayden', 'Bryce', 'Weston', 'Axel', 'Brody', 'Ashton', 'Ryder', 'Silas', 'Miles', 'Maxwell',
            'Kaiden', 'Max', 'Cole', 'Damian', 'Zachary', 'Luke', 'Grayson', 'Jackson', 'Levi', 'Mateo',
            // Italian Male Names
            'Marco', 'Luca', 'Andrea', 'Matteo', 'Alessandro', 'Leonardo', 'Francesco', 'Antonio', 'Giuseppe', 'Giovanni',
            'Stefano', 'Roberto', 'Alessio', 'Davide', 'Federico', 'Simone', 'Riccardo', 'Gabriele', 'Lorenzo', 'Mattia',
            'Emanuele', 'Nicola', 'Fabio', 'Daniele', 'Michele', 'Giacomo', 'Paolo', 'Enrico', 'Salvatore', 'Vincenzo',
            'Angelo', 'Raffaele', 'Massimo', 'Claudio', 'Gianluca', 'Alessandro', 'Domenico', 'Gianni', 'Pietro', 'Sergio',
            // Italian Female Names
            'Sofia', 'Giulia', 'Aurora', 'Alice', 'Ginevra', 'Emma', 'Giorgia', 'Greta', 'Beatrice', 'Anna',
            'Francesca', 'Matilde', 'Vittoria', 'Noemi', 'Bianca', 'Elisa', 'Ludovica', 'Elena', 'Alessia', 'Martina',
            'Chiara', 'Sara', 'Valentina', 'Camilla', 'Rebecca', 'Caterina', 'Arianna', 'Nicole', 'Gaia', 'Isabella',
            // French Male Names
            'Lucas', 'Louis', 'Hugo', 'Gabriel', 'Raphael', 'LÃ©o', 'Arthur', 'Adam', 'Paul', 'Nathan',
            'Noah', 'Ethan', 'Liam', 'Mael', 'Jules', 'Gabin', 'Sacha', 'Nolan', 'Aaron', 'Eden',
            'NaÃ«l', 'Marius', 'Mohamed', 'Tom', 'TimÃ©o', 'LÃ©on', 'Axel', 'MaÃ«l', 'NoÃ©', 'ThÃ©o',
            'Antoine', 'Pierre', 'Jean', 'FranÃ§ois', 'Philippe', 'Michel', 'Bernard', 'Claude', 'Daniel', 'Alain',
            // French Female Names
            'Emma', 'Jade', 'Louise', 'Alice', 'ChloÃ©', 'Lina', 'Mila', 'LÃ©a', 'Rose', 'Anna',
            'AmÃ©lie', 'InÃ¨s', 'Julia', 'LÃ©na', 'Manon', 'ZoÃ©', 'Lola', 'Lucie', 'Jeanne', 'Lilou',
            'Ã‰lise', 'Camille', 'Sarah', 'Ã‰va', 'MaÃ«lys', 'Romane', 'Agathe', 'Lou', 'Louna', 'Mia',
            // German Male Names
            'Maximilian', 'Alexander', 'Paul', 'Leon', 'Luka', 'Ben', 'Jonas', 'Noah', 'Finn', 'Henry',
            'Emil', 'Anton', 'Theo', 'Felix', 'Matteo', 'Liam', 'Milan', 'Elias', 'Luis', 'Jakob',
            'Julian', 'Moritz', 'Carl', 'Oskar', 'Philipp', 'Lukas', 'Max', 'Tim', 'Tom', 'David',
            // German Female Names
            'Emma', 'Hannah', 'Mia', 'Sophia', 'Emilia', 'Lina', 'Ella', 'Leni', 'Clara', 'Frieda',
            'Mila', 'Marie', 'Ida', 'Luise', 'Mathilda', 'Anna', 'Lea', 'Amelie', 'Lia', 'Charlotte',
            'Greta', 'Lilly', 'Nora', 'Helena', 'Elisa', 'Lara', 'Marlene', 'Thea', 'Paula', 'Lotta',
            // Russian Male Names
            'Alexander', 'Dmitri', 'Ivan', 'Sergei', 'Andrei', 'Aleksei', 'Mikhail', 'Vladimir', 'Nikolai', 'Pavel',
            'Maxim', 'Artem', 'Daniil', 'Kirill', 'Ilya', 'Roman', 'Yaroslav', 'Timofei', 'Artyom', 'Matvey',
            'Fyodor', 'Viktor', 'Oleg', 'Boris', 'Yuri', 'Grigory', 'Konstantin', 'Anatoly', 'Vadim', 'Denis',
            // Russian Female Names
            'Anna', 'Maria', 'Ekaterina', 'Anastasia', 'Daria', 'Elizaveta', 'Sofia', 'Viktoria', 'Polina', 'Arina',
            'Alina', 'Yulia', 'Kristina', 'Veronika', 'Valeria', 'Milana', 'Varvara', 'Aleksandra', 'Ksenia', 'Margarita',
            'Natalia', 'Tatiana', 'Olga', 'Irina', 'Elena', 'Svetlana', 'Ludmila', 'Galina', 'Nina', 'Larisa',
            // Arabic Male Names
            'Mohammed', 'Ahmed', 'Ali', 'Hassan', 'Hussein', 'Omar', 'Ibrahim', 'Yusuf', 'Khalid', 'Abdullah',
            'Mahmoud', 'Said', 'Tariq', 'Rashid', 'Malik', 'Amir', 'Karim', 'Jamal', 'Nasser', 'Faisal',
            'Salim', 'Zaid', 'Hamza', 'Bilal', 'Yasin', 'Taha', 'Anwar', 'Farid', 'Samir', 'Walid',
            // Arabic Female Names
            'Fatima', 'Aisha', 'Zainab', 'Mariam', 'Khadija', 'Safiya', 'Layla', 'Noor', 'Hana', 'Salma',
            'Yasmin', 'Amira', 'Leila', 'Nadia', 'Rania', 'Dina', 'Sara', 'Lina', 'Nour', 'Rana',
            'Hala', 'Mona', 'Dalia', 'Rania', 'Samira', 'Nadia', 'Laila', 'Soraya', 'Zara', 'Amina',
            // Hebrew/Jewish Names
            'David', 'Daniel', 'Michael', 'Benjamin', 'Jacob', 'Samuel', 'Joseph', 'Joshua', 'Aaron', 'Isaac',
            'Noah', 'Ethan', 'Levi', 'Adam', 'Jonathan', 'Nathan', 'Gabriel', 'Raphael', 'Eli', 'Zachary',
            'Sarah', 'Rachel', 'Rebecca', 'Leah', 'Esther', 'Miriam', 'Hannah', 'Deborah', 'Ruth', 'Naomi',
            'Judith', 'Tamar', 'Aviva', 'Shira', 'Talia', 'Maya', 'Eliana', 'Adina', 'Yael', 'Shoshana',
            // Indian/South Asian Names
            'Arjun', 'Aryan', 'Rohan', 'Vihaan', 'Advik', 'Krishna', 'Dev', 'Aarav', 'Ishaan', 'Reyansh',
            'Ananya', 'Diya', 'Aadhya', 'Anika', 'Ishani', 'Kavya', 'Mira', 'Pooja', 'Priya', 'Riya',
            'Saanvi', 'Sara', 'Shreya', 'Tara', 'Veda', 'Zara', 'Aarushi', 'Avani', 'Isha', 'Jiya',
            'Raj', 'Kumar', 'Singh', 'Patel', 'Sharma', 'Gupta', 'Khan', 'Ahmed', 'Ali', 'Hassan',
            // Additional Spanish Male Names
            'Diego', 'Antonio', 'Jorge', 'Alejandro', 'Fernando', 'Rafael', 'Mario', 'Sergio', 'Roberto', 'Alberto',
            'Ricardo', 'Eduardo', 'Andres', 'Oscar', 'Raul', 'Ruben', 'Adrian', 'Alvaro', 'Victor', 'Hector',
            'Gonzalo', 'Ignacio', 'Joaquin', 'Marcos', 'Nicolas', 'Rodrigo', 'Sebastian', 'Tomas', 'Vicente', 'Alfonso',
            'Arturo', 'Cesar', 'Emilio', 'Felipe', 'Gabriel', 'Guillermo', 'Hugo', 'Julian', 'Leandro', 'Martin',
            'Nestor', 'Octavio', 'Patricio', 'Ramon', 'Salvador', 'Simon', 'Tadeo', 'Ulises', 'Valentin', 'Xavier',
            'Yago', 'Zacarias', 'Abel', 'Bruno', 'Ciro', 'Damian', 'Elias', 'Fabian', 'Gael', 'Hernan',
            'Iker', 'Jairo', 'Kai', 'Lautaro', 'Mateo', 'Nicolas',
            'Catalina', 'Adriana', 'Alejandra', 'BÃ¡rbara', 'Cecilia', 'Claudia', 'Diana', 'Esther', 'Gabriela', 'InÃ©s',
            'Jimena', 'Karina', 'Lorena', 'Mariana', 'Natalia', 'Patricia', 'Rebeca', 'Silvia', 'VerÃ³nica', 'Yolanda',
            // Common surnames (English)
            'Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 'Rodriguez', 'Martinez',
            'Hernandez', 'Lopez', 'Wilson', 'Anderson', 'Thomas', 'Taylor', 'Moore', 'Jackson', 'Martin', 'Lee',
            'Thompson', 'White', 'Harris', 'Sanchez', 'Clark', 'Ramirez', 'Lewis', 'Robinson', 'Walker', 'Young',
            'Allen', 'King', 'Wright', 'Scott', 'Torres', 'Nguyen', 'Hill', 'Flores', 'Green', 'Adams',
            'Nelson', 'Baker', 'Hall', 'Rivera', 'Campbell', 'Mitchell', 'Carter', 'Roberts', 'Gomez', 'Phillips',
            'Evans', 'Turner', 'Diaz', 'Parker', 'Cruz', 'Edwards', 'Collins', 'Reyes', 'Stewart', 'Morris',
            'Morales', 'Murphy', 'Cook', 'Rogers', 'Gutierrez', 'Ortiz', 'Morgan', 'Cooper', 'Peterson', 'Bailey',
            'Reed', 'Kelly', 'Howard', 'Ramos', 'Kim', 'Cox', 'Ward', 'Richardson', 'Watson', 'Brooks',
            'Chavez', 'Wood', 'James', 'Bennett', 'Gray', 'Mendoza', 'Ruiz', 'Hughes', 'Price', 'Alvarez',
            'Castillo', 'Sanders', 'Patel', 'Myers', 'Long', 'Ross', 'Foster', 'Jimenez', 'Powell', 'Jenkins',
            'Perry', 'Patterson', 'Hughes', 'Flores', 'Washington', 'Butler', 'Simmons', 'Foster', 'Gonzales', 'Bryant',
            'Alexander', 'Russell', 'Griffin', 'Diaz', 'Hayes', 'Myers', 'Ford', 'Hamilton', 'Graham', 'Sullivan',
            'Wallace', 'Woods', 'Cole', 'West', 'Jordan', 'Owens', 'Reynolds', 'Fisher', 'Ellis', 'Harrison',
            'Gibson', 'Mcdonald', 'Cruz', 'Marshall', 'Ortiz', 'Gomez', 'Murray', 'Freeman', 'Wells', 'Webb',
            'Simpson', 'Stevens', 'Tucker', 'Porter', 'Hunter', 'Hicks', 'Crawford', 'Henry', 'Boyd', 'Mason',
            'Morales', 'Kennedy', 'Warren', 'Dixon', 'Ramos', 'Reyes', 'Burns', 'Gordon', 'Shaw', 'Holmes',
            'Rice', 'Robertson', 'Hunt', 'Black', 'Daniels', 'Palmer', 'Mills', 'Nichols', 'Grant', 'Knight',
            'Ferguson', 'Rose', 'Stone', 'Hawkins', 'Dunn', 'Perkins', 'Hudson', 'Spencer', 'Gardner', 'Stephens',
            'Payne', 'Pierce', 'Berry', 'Matthews', 'Arnold', 'Wagner', 'Willis', 'Ray', 'Watkins', 'Olson',
            'Carroll', 'Duncan', 'Snyder', 'Hart', 'Cunningham', 'Bradley', 'Lane', 'Andrews', 'Ruiz', 'Harper',
            'Fox', 'Riley', 'Armstrong', 'Carpenter', 'Weaver', 'Greene', 'Lawrence', 'Elliott', 'Chavez', 'Sims',
            'Austin', 'Peters', 'Kelley', 'Franklin', 'Lawson', 'Fields', 'Gutierrez', 'Ryan', 'Schmidt', 'Carr',
            'Vasquez', 'Castillo', 'Wheeler', 'Chapman', 'Oliver', 'Montgomery', 'Richards', 'Williamson', 'Johnston', 'Banks',
            'Meyer', 'Bishop', 'Mccoy', 'Howell', 'Alvarez', 'Morrison', 'Hansen', 'Fernandez', 'Garza', 'Harvey',
            'Little', 'Burton', 'Stanley', 'Nguyen', 'George', 'Jacobs', 'Reid', 'Kim', 'Fuller', 'Lynch',
            'Dean', 'Gilbert', 'Garrett', 'Romero', 'Welch', 'Larson', 'Frazier', 'Burke', 'Hanson', 'Day',
            'Mendoza', 'Moreno', 'Bowman', 'Medina', 'Fowler', 'Brewer', 'Hoffman', 'Carlson', 'Silva', 'Pearson',
            'Holland', 'Douglas', 'Fleming', 'Jensen', 'Vargas', 'Byrd', 'Davidson', 'Hopkins', 'May', 'Terry',
            'Herrera', 'Wade', 'Soto', 'Walters', 'Curtis', 'Neal', 'Caldwell', 'Lowe', 'Jennings', 'Barnett',
            'Graves', 'Jimenez', 'Horton', 'Shelton', 'Barrett', 'Obrien', 'Castro', 'Sutton', 'Gregory', 'Mckinney',
            'Lucas', 'Miles', 'Craig', 'Rodriquez', 'Chambers', 'Holt', 'Lambert', 'Fletcher', 'Watts', 'Bates',
            'Hale', 'Rhodes', 'Pena', 'Beck', 'Newman', 'Haynes', 'Mcdaniel', 'Mendez', 'Bush', 'Vaughn',
            'Parks', 'Dawson', 'Santiago', 'Norris', 'Hardy', 'Love', 'Steele', 'Curry', 'Powers', 'Schultz',
            'Barker', 'Guzman', 'Page', 'Munoz', 'Ball', 'Keller', 'Chandler', 'Weber', 'Leonard', 'Walsh',
            'Lyons', 'Ramsey', 'Wolfe', 'Schneider', 'Mullins', 'Benson', 'Sharp', 'Bowen', 'Daniel', 'Barber',
            'Cummings', 'Hines', 'Baldwin', 'Griffith', 'Valdez', 'Hubbard', 'Salazar', 'Reeves', 'Warner', 'Stevenson',
            'Burgess', 'Santos', 'Tate', 'Cross', 'Garner', 'Mann', 'Mack', 'Moss', 'Thornton', 'Dennis',
            'Mcgee', 'Farmer', 'Delgado', 'Aguilar', 'Vega', 'Glover', 'Manning', 'Cohen', 'Harmon', 'Rodgers',
            'Robbins', 'Newton', 'Todd', 'Blair', 'Higgins', 'Ingram', 'Reese', 'Cannon', 'Strickland', 'Townsend',
            'Potter', 'Goodwin', 'Walton', 'Rowe', 'Hampton', 'Ortega', 'Patton', 'Swanson', 'Joseph', 'Francis',
            'Goodman', 'Maldonado', 'Yates', 'Becker', 'Erickson', 'Hodges', 'Rios', 'Conner', 'Adkins', 'Webster',
            'Norman', 'Malone', 'Hammond', 'Flowers', 'Cobb', 'Moody', 'Quinn', 'Blake', 'Maxwell', 'Pope',
            'Floyd', 'Osborne', 'Paul', 'Mccarthy', 'Guerrero', 'Lindsey', 'Estrada', 'Sandoval', 'Gibbs', 'Tyler',
            'Gross', 'Fitzgerald', 'Stokes', 'Doyle', 'Sherman', 'Saunders', 'Wise', 'Colon', 'Gill', 'Alvarado',
            'Greer', 'Padilla', 'Simon', 'Waters', 'Nunez', 'Ballard', 'Schwartz', 'Mcbride', 'Houston', 'Christensen',
            'Klein', 'Pratt', 'Briggs', 'Parsons', 'Mclaughlin', 'Zimmerman', 'French', 'Buchanan', 'Nash', 'Dickerson',
            'Zamora', 'Escobar', 'Valencia', 'Maddox', 'Mccall', 'Morton', 'Stokes', 'Espinoza', 'Cisneros', 'Velazquez',
            // Common surnames (Spanish)
            'GarcÃ­a', 'RodrÃ­guez', 'GonzÃ¡lez', 'FernÃ¡ndez', 'LÃ³pez', 'MartÃ­nez', 'SÃ¡nchez', 'PÃ©rez', 'GÃ³mez', 'MartÃ­n',
            'JimÃ©nez', 'Ruiz', 'HernÃ¡ndez', 'DÃ­az', 'Moreno', 'MuÃ±oz', 'Ãlvarez', 'Romero', 'Alonso', 'GutiÃ©rrez',
            'Navarro', 'Torres', 'DomÃ­nguez', 'VÃ¡zquez', 'Ramos', 'Gil', 'RamÃ­rez', 'Serrano', 'Blanco', 'SuÃ¡rez',
            'Molina', 'Morales', 'Ortega', 'Delgado', 'Castro', 'Ortiz', 'Rubio', 'MarÃ­n', 'Sanz', 'Iglesias',
            'NuÃ±ez', 'Medina', 'Garrido', 'CortÃ©s', 'Castillo', 'Lozano', 'Guerrero', 'Cano', 'Prieto', 'MÃ©ndez',
            'Cruz', 'Calvo', 'Gallego', 'Vidal', 'LeÃ³n', 'MÃ¡rquez', 'Herrera', 'PeÃ±a', 'Flores', 'Campos',
            'Vega', 'Fuentes', 'Carrasco', 'Diez', 'Cabrera', 'Reyes', 'Caballero', 'Nieto', 'Aguilar', 'Santana',
            'Pascual', 'Herrero', 'Lorenzo', 'Montero', 'Hidalgo', 'GimÃ©nez', 'IbÃ¡Ã±ez', 'Ferrer', 'DurÃ¡n', 'Santiago',
            'BenÃ­tez', 'Vargas', 'Mora', 'Vicente', 'Arias', 'Carmona', 'Crespo', 'Soto', 'Ramos', 'Romero',
            'Soler', 'Bravo', 'Gallardo', 'Rojas', 'Parra', 'Pacheco', 'Lara', 'Contreras', 'Miranda', 'Salazar',
            'Cordero', 'RoldÃ¡n', 'Quintana', 'Merino', 'SÃ¡ez', 'Burgos', 'Rey', 'Luna', 'Segura', 'Camacho',
            'Villa', 'Mesa', 'Paredes', 'Rivera', 'Esteban', 'Sierra', 'Carrillo', 'GuzmÃ¡n', 'Villar', 'Espinosa',
            'Carbajal', 'Ponce', 'Palacios', 'Vera', 'Aparicio', 'Sarmiento', 'Rocha', 'Valle', 'Acosta', 'Montes',
            'Aguirre', 'Alvarado', 'Arias', 'Bautista', 'Benitez', 'Blanco', 'Bravo', 'Cabrera', 'Calderon', 'Campos',
            'Cano', 'Carrasco', 'Castillo', 'Castro', 'Cervantes', 'Contreras', 'Cordero', 'Corona', 'Cortes', 'Cruz',
            'Delgado', 'Diaz', 'Dominguez', 'Duarte', 'Escobar', 'Espinoza', 'Estrada', 'Fernandez', 'Flores', 'Franco',
            'Fuentes', 'Gallegos', 'Galvan', 'Garcia', 'Garza', 'Gil', 'Gomez', 'Gonzalez', 'Guerrero', 'Gutierrez',
            'Guzman', 'Hernandez', 'Herrera', 'Huerta', 'Ibarra', 'Iglesias', 'Jimenez', 'Juarez', 'Lara', 'Leon',
            'Lopez', 'Lozano', 'Luna', 'Madrid', 'Marin', 'Marquez', 'Martinez', 'Mata', 'Medina', 'Mejia',
            'Mendez', 'Mendoza', 'Molina', 'Montero', 'Morales', 'Moreno', 'Munoz', 'Navarro', 'Nieto', 'Nunez',
            'Ochoa', 'Olvera', 'Ortega', 'Ortiz', 'Padilla', 'Palacios', 'Paredes', 'Pena', 'Perez', 'Pineda',
            'Ponce', 'Quintero', 'Ramirez', 'Ramos', 'Reyes', 'Rios', 'Rivera', 'Robles', 'Rodriguez', 'Rojas',
            'Romero', 'Rosales', 'Rubio', 'Ruiz', 'Salazar', 'Salinas', 'Sanchez', 'Sandoval', 'Santana', 'Santiago',
            'Santos', 'Sierra', 'Silva', 'Solis', 'Soto', 'Suarez', 'Tapia', 'Torres', 'Trevino', 'Valdez',
            'Valencia', 'Vargas', 'Vasquez', 'Vega', 'Velazquez', 'Vera', 'Villa', 'Villanueva', 'Villarreal', 'Villegas',
            'Yanez', 'Zamora', 'Zavala', 'Zuniga', 'Acevedo', 'Acuna', 'Aguilar', 'Alarcon', 'Alfaro', 'Alonso',
            'Altamirano', 'Amaro', 'Andrade', 'Anguiano', 'Aparicio', 'Aragon', 'Aranda', 'Arce', 'Arguello', 'Arredondo',
            'Arreola', 'Arroyo', 'Arteaga', 'Avila', 'Ayala', 'Baca', 'Badillo', 'Baez', 'Bahena', 'Ballesteros',
            'Banuelos', 'Barajas', 'Barbosa', 'Barela', 'Barragan', 'Barrientos', 'Barrios', 'Bautista', 'Becerra', 'Belmonte',
            'Beltran', 'Benavides', 'Benavidez', 'Benitez', 'Bermudez', 'Bernal', 'Betancourt', 'Blanco', 'Bonilla', 'Borrego',
            'Botello', 'Bravo', 'Briceno', 'Brito', 'Bueno', 'Burgos', 'Bustamante', 'Bustos', 'Caballero', 'Cabrera',
            'Caceres', 'Cadena', 'Calderon', 'Calero', 'Calvillo', 'Camacho', 'Camarena', 'Campos', 'Canales', 'Canas',
            'Candelaria', 'Cano', 'Cantrell', 'Cantu', 'Caraballo', 'Carbajal', 'Cardona', 'Cardoso', 'Cardozo', 'Cardenas',
            'Cardiel', 'Careaga', 'Carillo', 'Carranza', 'Carrasco', 'Carrera', 'Carrillo', 'Carrizales', 'Carruthers', 'Carson',
            'Carter', 'Cartwright', 'Caruso', 'Carvalho', 'Carvajal', 'Casa', 'Casado', 'Casares', 'Casas', 'Casillas',
            'CastaÃ±eda', 'Castaneda', 'Castellanos', 'Castillo', 'Castro', 'Cavazos', 'Cazares', 'Ceballos', 'Cedillo', 'Cepeda',
            'Cerda', 'Cervantes', 'Cespedes', 'Chacon', 'Chapa', 'Chavez', 'Chavira', 'Chico', 'Chinchilla', 'Cid',
            'Cisneros', 'Clemente', 'Cobos', 'Coca', 'Colin', 'Collado', 'Collazo', 'Colon', 'Colunga', 'Compean',
            'Conde', 'Contreras', 'Cordero', 'Cordoba', 'Cordova', 'Cornejo', 'Corona', 'Coronado', 'Coronel', 'Corral',
            'Corrales', 'Correa', 'Cortes', 'Cortez', 'Cortina', 'Cota', 'Coto', 'Covarrubias', 'Crespo', 'Cruz',
            'Cuadrado', 'Cuellar', 'Cuenca', 'Cuevas', 'Cummings', 'Curiel', 'Davalos', 'Davila', 'De la Cruz', 'De la Fuente',
            'De la Garza', 'De la O', 'De la Rosa', 'De la Torre', 'De Leon', 'De los Santos', 'Del Angel', 'Del Campo', 'Del Castillo', 'Delgado',
            'Del Rio', 'Del Valle', 'Diaz', 'Diez', 'Dominguez', 'Donato', 'Dones', 'Doval', 'Duarte', 'Duenas',
            'Duran', 'Echeverria', 'Elias', 'Enriquez', 'Escalante', 'Escamilla', 'Escobar', 'Escobedo', 'Escudero', 'Esparza',
            'Espejo', 'Espinal', 'Espinosa', 'Espinoza', 'Esquivel', 'Esteban', 'Estrada', 'Fajardo', 'Falcon', 'Farias',
            'Favela', 'Felix', 'Fernandez', 'Ferrer', 'Fierro', 'Figueroa', 'Flores', 'Fonseca', 'Font', 'Franco',
            'Frias', 'Fuentes', 'Fuentes', 'Gaitan', 'Galindo', 'Gallegos', 'Galvan', 'Gama', 'Gamboa', 'Gamez',
            'Gandara', 'Garcia', 'Garibay', 'Garrido', 'Garza', 'Gasca', 'Gastelum', 'Gaytan', 'Gil', 'Giron',
            'Godinez', 'Gomez', 'Gonzales', 'Gonzalez', 'Grajeda', 'Granados', 'Grijalva', 'Guajardo', 'Guardado', 'Guerra',
            'Guerrero', 'Guevara', 'Guillen', 'Gutierrez', 'Guzman', 'Haro', 'Hernandez', 'Herrera', 'Hidalgo', 'Hinojosa',
            'Holguin', 'Huerta', 'Huizar', 'Ibarra', 'Iglesias', 'Infante', 'Iniguez', 'Irizarry', 'Islas', 'Jaime',
            'Jaimes', 'Jauregui', 'Jimenez', 'Juarez', 'Jurado', 'Labrador', 'Lara', 'Larios', 'Lazaro', 'Leal',
            'Lebron', 'Ledesma', 'Lemus', 'Leon', 'Lerma', 'Leyva', 'Linares', 'Lira', 'Lizama', 'Llamas',
            'Llanos', 'Lobato', 'Lobo', 'Lomeli', 'Lona', 'Longoria', 'Lopez', 'Lorenzo', 'Lozano', 'Lucero',
            'Luevano', 'Lugo', 'Luna', 'Macias', 'Madera', 'Madrid', 'Madrigal', 'MagaÃ±a', 'Magana', 'Maldonado',
            'Manriquez', 'Manzano', 'Marin', 'Mariscal', 'Marquez', 'Marroquin', 'Martinez', 'Mascarenas', 'Mata', 'Mateo',
            'Matos', 'Maya', 'Mayorga', 'Medina', 'Medrano', 'Mejia', 'Melendez', 'Mena', 'Mendez', 'Mendoza',
            'Menendez', 'Meraz', 'Merino', 'Mesa', 'Meza', 'Mier', 'Mijares', 'Millan', 'Mireles', 'Miranda',
            'Mireles', 'Mojica', 'Molina', 'Moncada', 'Monreal', 'Monsivais', 'Montano', 'Montero', 'Montes', 'Montoya',
            'Mora', 'Morales', 'Moreno', 'Morin', 'Mota', 'Moya', 'Munguia', 'Muniz', 'Munoz', 'Murillo',
            'Najar', 'Najera', 'Naranjo', 'Navarrete', 'Navarro', 'Nazario', 'Negrete', 'Neri', 'Nieto', 'Nino',
            'Noriega', 'Nunez', 'Ocampo', 'Ocasio', 'Ochoa', 'Ojeda', 'Olguin', 'Olivares', 'Olivas', 'Oliveira',
            'Olmos', 'Olvera', 'Ontiveros', 'Oquendo', 'Ordaz', 'Ordonez', 'Orellana', 'Ornelas', 'Oropeza', 'Ortega',
            'Ortiz', 'Osorio', 'Osuna', 'Otero', 'Pacheco', 'Padilla', 'Padron', 'Paez', 'Palacios', 'Palma',
            'Palomino', 'Palomo', 'Paniagua', 'Pantoja', 'Paredes', 'Parra', 'Partida', 'Pascual', 'Pastor', 'Patino',
            'Paz', 'Pedraza', 'Pedroza', 'Pena', 'Penaloza', 'Perales', 'Peralta', 'Perea', 'Pereira', 'Perez',
            'Pichardo', 'Piedra', 'Pina', 'Pineda', 'Pinero', 'Pinto', 'Pizarro', 'Plascencia', 'Plaza', 'Polanco',
            'Ponce', 'Porras', 'Portillo', 'Posada', 'Prado', 'Prieto', 'Puente', 'Puerta', 'Puga', 'Pulido',
            'Quesada', 'Quezada', 'Quinones', 'Quinonez', 'Quintero', 'Quiroz', 'Quiroga', 'Rael', 'Ramos', 'Ramirez',
            'Rangel', 'Raya', 'Recio', 'Regalado', 'Rendon', 'Renteria', 'Resendez', 'Reyes', 'Reyna', 'Reynoso',
            'Rico', 'Rincon', 'Riojas', 'Rios', 'Rivas', 'Rivera', 'Rizo', 'Robledo', 'Robles', 'Rocha',
            'Rodarte', 'Rodela', 'Rodriguez', 'Rojas', 'Rojo', 'Roldan', 'Rolon', 'Roman', 'Romero', 'Romo',
            'Roque', 'Rosado', 'Rosales', 'Rosario', 'Rosas', 'Rosenberg', 'Rovira', 'Rubalcava', 'Rubio', 'Ruiz',
            'Saavedra', 'Saenz', 'Salas', 'Salazar', 'Salcedo', 'Salcido', 'Saldivar', 'Salgado', 'Salinas', 'Salvador',
            'Samaniego', 'Sanabria', 'Sanchez', 'Sandoval', 'Sang', 'Sanjuan', 'Santacruz', 'Santana', 'Santiago', 'Santillan',
            'Santos', 'Sarabia', 'Sauceda', 'Saucedo', 'Segovia', 'Segura', 'Sena', 'Sepulveda', 'Serrano', 'Serrato',
            'Sifuentes', 'Silva', 'Silveira', 'Simo', 'Sisneros', 'Solis', 'Solorio', 'Solorzano', 'Soria', 'Sosa',
            'Sotelo', 'Soto', 'Suarez', 'Subia', 'Tafoya', 'Tamayo', 'Tamez', 'Tapia', 'Tarango', 'Tarin',
            'Taveras', 'Tejada', 'Tejeda', 'Tellez', 'Tello', 'Teran', 'Terrazas', 'Tijerina', 'Tirado', 'Toledo',
            'Tomas', 'Toro', 'Torralba', 'Torre', 'Torres', 'Tovar', 'Trevino', 'Trujillo', 'Truong', 'Ugalde',
            'Ulloa', 'Umana', 'Urena', 'Urbina', 'Urbino', 'Uribe', 'Urrutia', 'Uvalle', 'Vaca', 'Vadillo',
            'Valadez', 'Valdes', 'Valdez', 'Valdivia', 'Valencia', 'Valentin', 'Valenzuela', 'Valera', 'Valle', 'Vallejo',
            'Valles', 'Vallin', 'Valverde', 'Vanegas', 'Varela', 'Vargas', 'Vasquez', 'Vazquez', 'Vega', 'Velarde',
            'Velasquez', 'Velazquez', 'Velez', 'Vela', 'Vera', 'Verdugo', 'Vergara', 'Vicente', 'Vidal', 'Viera',
            'Vigil', 'Villa', 'Villagomez', 'Villagran', 'Villalobos', 'Villalon', 'Villalpando', 'Villanueva', 'Villar', 'Villareal',
            'Villarreal', 'Villasenor', 'Villegas', 'Vina', 'Vinales', 'Viramontes', 'Viveros', 'Vizcarra', 'Yanez', 'Ybarra',
            'Yepez', 'Yepes', 'Yglesias', 'Ynoa', 'Yordan', 'Yost', 'Young', 'Yturralde', 'Zabaleta', 'Zabala',
            'Zacarias', 'Zamarripa', 'Zambrano', 'Zamora', 'Zamudio', 'Zapata', 'Zapien', 'Zaragoza', 'Zarate', 'Zarco',
            'Zavala', 'Zayas', 'Zea', 'Zelaya', 'Zendejas', 'Zepeda', 'Zermeno', 'Zertuche', 'Zetina', 'Zorrilla',
            'Zubia', 'Zubieta', 'Zubizarreta', 'Zuluaga', 'Zuniga', 'Zurita', 'Zuvia', 'Zuzunaga', 'Zwanziger', 'Zwillinger',
            // Common surnames (Other languages)
            'Schmidt', 'Schneider', 'Fischer', 'Weber', 'Meyer', 'Wagner', 'Becker', 'Schulz', 'Hoffmann', 'Koch',
            'Bauer', 'Richter', 'Klein', 'Wolf', 'SchrÃ¶der', 'Neumann', 'Schwarz', 'Zimmermann', 'Braun', 'KrÃ¼ger',
            'Hofmann', 'Hartmann', 'Lange', 'Schmitt', 'Werner', 'Schmitz', 'Krause', 'Meier', 'Lehmann', 'Schmid',
            'Schulze', 'Maier', 'KÃ¶hler', 'Herrmann', 'KÃ¶nig', 'Walter', 'Mayer', 'Huber', 'Kaiser', 'Fuchs',
            'Peters', 'Lang', 'Scholz', 'MÃ¶ller', 'WeiÃŸ', 'Jung', 'Hahn', 'Schubert', 'Vogel', 'Friedrich',
            'Martin', 'Keller', 'GÃ¼nther', 'Frank', 'Winkler', 'Roth', 'Beck', 'Lorenz', 'Baumann', 'Franke',
            'Almeida', 'Silva', 'Santos', 'Oliveira', 'Souza', 'Rodrigues', 'Ferreira', 'Alves', 'Pereira', 'Lima',
            'Ribeiro', 'Carvalho', 'Gomes', 'Costa', 'Martins', 'Rocha', 'Ramos', 'Reis', 'Morais', 'Mendes',
            'Freitas', 'Fernandes', 'Monteiro', 'AraÃºjo', 'Correia', 'Teixeira', 'Moreira', 'GonÃ§alves', 'Mendes', 'Nunes',
            'Machado', 'Dias', 'Castro', 'Cardoso', 'Barros', 'Campos', 'Azevedo', 'Cunha', 'Pinto', 'Lopes',
            'Rossi', 'Russo', 'Ferrari', 'Esposito', 'Bianchi', 'Romano', 'Colombo', 'Ricci', 'Marino', 'Greco',
            'Bruno', 'Gallo', 'Conti', 'De Luca', 'Costa', 'Fontana', 'Caruso', 'Mario', 'Rizzo', 'Lombardi',
            'Moretti', 'Barbieri', 'Fontana', 'Mancini', 'Rizzo', 'Lombardi', 'Moretti', 'Barbieri', 'Fontana', 'Mancini',
            'Bernard', 'Dubois', 'Thomas', 'Robert', 'Richard', 'Petit', 'Durand', 'Leroy', 'Moreau', 'Simon',
            'Laurent', 'Lefebvre', 'Michel', 'Garcia', 'David', 'Bertrand', 'Roux', 'Vincent', 'Fournier', 'Morel',
            'Girard', 'AndrÃ©', 'Lefevre', 'Mercier', 'Dupont', 'Lambert', 'Bonnet', 'FranÃ§ois', 'Martinez', 'Legrand',
            'Garnier', 'Faure', 'Rousseau', 'Blanc', 'Guerin', 'Muller', 'Henry', 'Roussel', 'Nicolas', 'Perrin',
            'Morin', 'Mathieu', 'Clement', 'Gauthier', 'Dumont', 'Lopez', 'Fabre', 'Blanchard', 'Marie', 'Lopez',
            'Wang', 'Li', 'Zhang', 'Liu', 'Chen', 'Yang', 'Huang', 'Zhao', 'Wu', 'Zhou',
            'Xu', 'Sun', 'Ma', 'Zhu', 'Hu', 'Guo', 'He', 'Gao', 'Lin', 'Luo',
            'Song', 'Zheng', 'Tang', 'Han', 'Cao', 'Deng', 'Yuan', 'Jiang', 'Fan', 'Cai',
            'Tanaka', 'Sato', 'Suzuki', 'Takahashi', 'Watanabe', 'Ito', 'Yamamoto', 'Nakamura', 'Kobayashi', 'Kato',
            'Yoshida', 'Yamada', 'Sasaki', 'Yamaguchi', 'Saito', 'Matsumoto', 'Inoue', 'Kimura', 'Hayashi', 'Shimizu',
            'Yamazaki', 'Mori', 'Abe', 'Ikeda', 'Hashimoto', 'Yamashita', 'Ishikawa', 'Nakajima', 'Maeda', 'Fujita',
            'Ogawa', 'Goto', 'Okada', 'Hasegawa', 'Murakami', 'Kondo', 'Ishii', 'Saito', 'Sakamoto', 'Endo',
            // Major cities (English)
            'Paris', 'London', 'New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix', 'Philadelphia', 'San Antonio', 'San Diego',
            'Dallas', 'San Jose', 'Austin', 'Jacksonville', 'San Francisco', 'Indianapolis', 'Columbus', 'Fort Worth', 'Charlotte', 'Seattle',
            'Denver', 'Washington', 'Boston', 'El Paso', 'Detroit', 'Nashville', 'Portland', 'Memphis', 'Oklahoma City', 'Las Vegas',
            'Louisville', 'Baltimore', 'Milwaukee', 'Albuquerque', 'Tucson', 'Fresno', 'Sacramento', 'Kansas City', 'Mesa', 'Atlanta',
            'Miami', 'Omaha', 'Raleigh', 'Minneapolis', 'New Orleans', 'Cleveland', 'Tulsa', 'Wichita', 'Arlington', 'Tampa',
            'Tokyo', 'Delhi', 'Shanghai', 'SÃ£o Paulo', 'Mumbai', 'Beijing', 'Osaka', 'Cairo', 'Dhaka', 'Mexico City',
            'Buenos Aires', 'Kolkata', 'Bangkok', 'Istanbul', 'Lagos', 'Manila', 'Rio de Janeiro', 'Kinshasa', 'Lima', 'BogotÃ¡',
            // Major cities (Spanish)
            'Madrid', 'Barcelona', 'Valencia', 'Sevilla', 'Zaragoza', 'MÃ¡laga', 'Murcia', 'Palma', 'Las Palmas', 'Bilbao',
            'Alicante', 'CÃ³rdoba', 'Valladolid', 'Vigo', 'GijÃ³n', 'Hospitalet', 'Granada', 'Vitoria', 'A CoruÃ±a', 'Elche',
            'Buenos Aires', 'CÃ³rdoba', 'Rosario', 'Mendoza', 'La Plata', 'TucumÃ¡n', 'Mar del Plata', 'Salta', 'Santa Fe', 'San Juan',
            'Ciudad de MÃ©xico', 'Guadalajara', 'Monterrey', 'Puebla', 'Tijuana', 'LeÃ³n', 'JuÃ¡rez', 'TorreÃ³n', 'QuerÃ©taro', 'San Luis PotosÃ­',
            // Countries
            'Spain', 'France', 'Italy', 'Germany', 'United Kingdom', 'Portugal', 'Greece', 'Netherlands', 'Belgium', 'Switzerland',
            'Austria', 'Sweden', 'Norway', 'Denmark', 'Finland', 'Poland', 'Czech Republic', 'Hungary', 'Romania', 'Bulgaria',
            'Russia', 'China', 'Japan', 'India', 'Brazil', 'Argentina', 'Chile', 'Colombia', 'Peru', 'Venezuela',
            'Mexico', 'Canada', 'Australia', 'New Zealand', 'South Africa', 'Egypt', 'Turkey', 'Saudi Arabia', 'Iran', 'Iraq',
            'EspaÃ±a', 'Francia', 'Italia', 'Alemania', 'Reino Unido', 'Portugal', 'Grecia', 'PaÃ­ses Bajos', 'BÃ©lgica', 'Suiza',
            'MÃ©xico', 'Argentina', 'Chile', 'Colombia', 'PerÃº', 'Venezuela', 'Ecuador', 'Bolivia', 'Paraguay', 'Uruguay',
            // Other proper nouns
            'Amazon', 'Google', 'Microsoft', 'Apple', 'Facebook', 'Tesla', 'Nike', 'Coca-Cola', 'McDonald\'s', 'Starbucks',
            'Nintendo', 'Sony', 'Samsung', 'Volkswagen', 'Toyota', 'Honda', 'Ford', 'BMW', 'Mercedes', 'Audi',
            'Einstein', 'Shakespeare', 'Picasso', 'Mozart', 'Beethoven', 'Da Vinci', 'Galileo', 'Newton', 'Darwin', 'Freud',
            'Jesus', 'Buddha', 'Muhammad', 'Moses', 'Abraham', 'Noah', 'Adam', 'Eve', 'Mary', 'Joseph',
            // Extended English Names Database (Top 1000+)
            'Aaliyah', 'Aaron', 'Abby', 'Abigail', 'Adam', 'Addison', 'Adeline', 'Adrian', 'Adriana', 'Aiden',
            'Ainsley', 'Alaina', 'Alan', 'Alana', 'Alanna', 'Alayna', 'Albert', 'Alberto', 'Alden', 'Alec',
            'Alejandro', 'Alessandra', 'Alessandro', 'Alex', 'Alexa', 'Alexander', 'Alexandra', 'Alexandria', 'Alexis', 'Alfred',
            'Ali', 'Alice', 'Alicia', 'Alina', 'Alison', 'Alivia', 'Allan', 'Allen', 'Allison', 'Allyson',
            'Alondra', 'Alvin', 'Alyssa', 'Amanda', 'Amani', 'Amara', 'Amari', 'Amaya', 'Amber', 'Amelia',
            'Amir', 'Amiyah', 'Amy', 'Ana', 'Anahi', 'Anastasia', 'Andre', 'Andres', 'Andrew', 'Andy',
            'Angel', 'Angela', 'Angelica', 'Angelina', 'Angelo', 'Angie', 'Anika', 'Aniyah', 'Ann', 'Anna',
            'Annabelle', 'Anne', 'Annie', 'Annika', 'Ansley', 'Anthony', 'Antonio', 'Anton', 'Antonia', 'Antonio',
            'Anya', 'April', 'Arabella', 'Archer', 'Aria', 'Ariana', 'Arianna', 'Ariel', 'Ariella', 'Arielle',
            'Arjun', 'Arlo', 'Armando', 'Armani', 'Arnav', 'Arthur', 'Arturo', 'Arya', 'Asher', 'Ashley',
            'Ashlyn', 'Ashton', 'Aspen', 'Athena', 'Atlas', 'Atticus', 'Aubree', 'Aubrey', 'Audrey', 'August',
            'Augustus', 'Aurora', 'Austin', 'Autumn', 'Ava', 'Avery', 'Axel', 'Ayaan', 'Ayden', 'Ayla',
            'Aylin', 'Bailey', 'Barrett', 'Beau', 'Beckett', 'Beckham', 'Bella', 'Benjamin', 'Bennett', 'Bentley',
            'Berkley', 'Bethany', 'Blake', 'Blakely', 'Blake', 'Bodhi', 'Braden', 'Bradley', 'Brady', 'Brandon',
            'Brantley', 'Braxton', 'Brayden', 'Braylen', 'Braylon', 'Breanna', 'Brendan', 'Brennan', 'Brent', 'Brett',
            'Brian', 'Brianna', 'Brielle', 'Briggs', 'Brinley', 'Bristol', 'Brittany', 'Brody', 'Brooke', 'Brooklyn',
            'Brooks', 'Bruce', 'Bruno', 'Bryan', 'Bryce', 'Brynn', 'Bryson', 'Cade', 'Caden', 'Cael',
            'Caiden', 'Caitlin', 'Caitlyn', 'Caleb', 'Callie', 'Callum', 'Calvin', 'Camden', 'Cameron', 'Camila',
            'Camille', 'Camryn', 'Cannon', 'Cara', 'Carina', 'Carl', 'Carla', 'Carlo', 'Carlos', 'Carlton',
            'Carly', 'Carmen', 'Carol', 'Carolina', 'Caroline', 'Carolyn', 'Carson', 'Carter', 'Casey', 'Cash',
            'Cassandra', 'Cassidy', 'Cassius', 'Catalina', 'Catherine', 'Cayden', 'Cecilia', 'Cedric', 'Celeste', 'Cesar',
            'Chance', 'Chandler', 'Chanel', 'Charlee', 'Charleigh', 'Charles', 'Charlie', 'Charlotte', 'Chase', 'Chaya',
            'Chelsea', 'Cheyenne', 'Chloe', 'Chris', 'Christian', 'Christina', 'Christine', 'Christopher', 'Claire', 'Clara',
            'Clare', 'Clarissa', 'Clark', 'Clarke', 'Claudia', 'Clay', 'Clayton', 'Clementine', 'Cleo', 'Clifford',
            'Clinton', 'Clyde', 'Cody', 'Cohen', 'Colby', 'Cole', 'Coleman', 'Colin', 'Collin', 'Colt',
            'Colton', 'Conner', 'Connor', 'Conor', 'Conrad', 'Cooper', 'Cora', 'Coraline', 'Corbin', 'Corey',
            'Cory', 'Courtney', 'Craig', 'Crew', 'Cristian', 'Cristina', 'Cruz', 'Crystal', 'Cullen', 'Curtis',
            'Cynthia', 'Cyrus', 'Daisy', 'Dakota', 'Dale', 'Dallas', 'Dalton', 'Damian', 'Damien', 'Damon',
            'Dana', 'Daniel', 'Daniela', 'Daniella', 'Danielle', 'Danny', 'Dante', 'Daphne', 'Darcy', 'Darian',
            'Darius', 'Darren', 'Darryl', 'Darwin', 'Dash', 'Dashiell', 'Dave', 'David', 'Davin', 'Davis',
            'Dawson', 'Dax', 'Daxton', 'Dayton', 'Deacon', 'Dean', 'Deandre', 'Declan', 'Delaney', 'Delilah',
            'Della', 'Demetrius', 'Demi', 'Dennis', 'Derek', 'Derrick', 'Desmond', 'Destiny', 'Devin', 'Devon',
            'Dexter', 'Diana', 'Diego', 'Dillon', 'Dimitri', 'Dixie', 'Dolores', 'Dominic', 'Dominick', 'Dominik',
            'Dominique', 'Donald', 'Donovan', 'Dorian', 'Doris', 'Dorothy', 'Douglas', 'Drew', 'Duke', 'Dulce',
            'Duncan', 'Dustin', 'Dwayne', 'Dylan', 'Easton', 'Eddie', 'Eden', 'Edgar', 'Edison', 'Edmund',
            'Eduardo', 'Edward', 'Edwin', 'Eileen', 'Elaine', 'Eleanor', 'Elena', 'Eli', 'Eliana', 'Elianna',
            'Elias', 'Elijah', 'Elise', 'Eliza', 'Elizabeth', 'Ella', 'Elle', 'Ellen', 'Elliana', 'Ellie',
            'Elliot', 'Elliott', 'Ellis', 'Ellison', 'Eloise', 'Elsa', 'Elsie', 'Elvis', 'Elyse', 'Ember',
            'Emberly', 'Emelia', 'Emely', 'Emerson', 'Emery', 'Emilia', 'Emiliano', 'Emily', 'Emma', 'Emmanuel',
            'Emmett', 'Emmie', 'Emmy', 'Emory', 'Enrique', 'Enzo', 'Eric', 'Erica', 'Erick', 'Erik',
            'Erika', 'Erin', 'Ernest', 'Ernesto', 'Esme', 'Esmeralda', 'Esteban', 'Esther', 'Ethan', 'Eugene',
            'Eva', 'Evalyn', 'Evan', 'Evangeline', 'Eve', 'Evelyn', 'Everett', 'Everleigh', 'Everly', 'Ezekiel',
            'Ezra', 'Fabian', 'Faith', 'Farrah', 'Fatima', 'Felix', 'Felicity', 'Fernando', 'Finley', 'Finn',
            'Fiona', 'Flora', 'Florence', 'Ford', 'Forest', 'Forrest', 'Foster', 'Fox', 'Frances', 'Francesca',
            'Francis', 'Francisco', 'Franco', 'Frank', 'Frankie', 'Franklin', 'Fred', 'Freddie', 'Frederick', 'Freya',
            'Frida', 'Gabriel', 'Gabriela', 'Gabriella', 'Gabrielle', 'Gael', 'Gage', 'Gail', 'Gannon', 'Garrett',
            'Garrison', 'Gary', 'Gavin', 'Gayle', 'Gemma', 'Genesis', 'Genevieve', 'George', 'Georgia', 'Georgiana',
            'Gerald', 'Geraldine', 'Gerardo', 'Gia', 'Gianna', 'Gianni', 'Gibson', 'Gideon', 'Gilbert', 'Gillian',
            'Gina', 'Gino', 'Giovanni', 'Giselle', 'Gloria', 'Goldie', 'Grace', 'Gracelyn', 'Gracie', 'Grady',
            'Graham', 'Grant', 'Grayson', 'Greyson', 'Gregory', 'Greta', 'Grey', 'Greyson', 'Griffin', 'Guadalupe',
            'Guillermo', 'Gunnar', 'Gunner', 'Gus', 'Gustavo', 'Guy', 'Gwen', 'Gwendolyn', 'Hadley', 'Hailey',
            'Haisley', 'Haley', 'Hallie', 'Hamza', 'Hana', 'Hank', 'Hanna', 'Hannah', 'Harley', 'Harmony',
            'Harold', 'Harper', 'Harriet', 'Harris', 'Harrison', 'Harry', 'Harvey', 'Hassan', 'Hattie', 'Haven',
            'Hayden', 'Hayes', 'Hayley', 'Hazel', 'Heath', 'Heather', 'Heaven', 'Hector', 'Heidi', 'Helen',
            'Helena', 'Helene', 'Hendrix', 'Henley', 'Henri', 'Henry', 'Hensley', 'Herbert', 'Herman', 'Hernan',
            'Heston', 'Holden', 'Holland', 'Hollis', 'Holly', 'Hope', 'Howard', 'Hudson', 'Hugh', 'Hugo',
            'Hunter', 'Ian', 'Ibrahim', 'Iker', 'Imani', 'Imogen', 'India', 'Indie', 'Indigo', 'Ira',
            'Irene', 'Iris', 'Irving', 'Isaac', 'Isabel', 'Isabela', 'Isabella', 'Isabelle', 'Isaias', 'Ishaan',
            'Isla', 'Ismael', 'Israel', 'Issac', 'Itzel', 'Ivan', 'Ivana', 'Ivy', 'Iyla', 'Jace',
            'Jack', 'Jackson', 'Jacob', 'Jacqueline', 'Jada', 'Jade', 'Jaden', 'Jadiel', 'Jadon', 'Jagger',
            'Jaiden', 'Jaime', 'Jake', 'Jakob', 'Jalen', 'Jamal', 'Jamar', 'James', 'Jameson', 'Jamie',
            'Jamil', 'Jamison', 'Jana', 'Jane', 'Janelle', 'Janet', 'Janice', 'Janiyah', 'Jared', 'Jase',
            'Jasiah', 'Jasmine', 'Jason', 'Jasper', 'Javier', 'Jax', 'Jaxon', 'Jaxson', 'Jaxxon', 'Jay',
            'Jayce', 'Jayceon', 'Jayda', 'Jayden', 'Jayla', 'Jaylah', 'Jaylee', 'Jaylen', 'Jaylin', 'Jaylon',
            'Jayson', 'Jaziel', 'Jazlyn', 'Jazmin', 'Jazmine', 'Jean', 'Jefferson', 'Jeffrey', 'Jemma', 'Jenesis',
            'Jenna', 'Jennifer', 'Jenny', 'Jeremiah', 'Jeremy', 'Jericho', 'Jerry', 'Jesse', 'Jessica', 'Jessie',
            'Jesus', 'Jett', 'Jewel', 'Jillian', 'Jim', 'Jimena', 'Jimmy', 'Joan', 'Joaquin', 'Jocelyn',
            'Jody', 'Joe', 'Joel', 'Joey', 'Johan', 'Johanna', 'John', 'Johnathan', 'Johnny', 'Jolene',
            'Jon', 'Jonah', 'Jonas', 'Jonathan', 'Jones', 'Jordan', 'Jordyn', 'Jorge', 'Jose', 'Josef',
            'Joseph', 'Josephine', 'Josh', 'Joshua', 'Josiah', 'Josie', 'Josue', 'Journey', 'Jovan', 'Joy',
            'Joyce', 'Juan', 'Judah', 'Jude', 'Judith', 'Judy', 'Julia', 'Julian', 'Juliana', 'Julianna',
            'Julianne', 'Julie', 'Julien', 'Juliet', 'Juliette', 'Julio', 'Julius', 'June', 'Juniper', 'Juno',
            'Justice', 'Justin', 'Justus', 'Kade', 'Kaden', 'Kai', 'Kaia', 'Kaiden', 'Kailani', 'Kairo',
            'Kaiser', 'Kaitlyn', 'Kaiya', 'Kaleb', 'Kali', 'Kaliyah', 'Kallie', 'Kamari', 'Kamden', 'Kameron',
            'Kamila', 'Kamilah', 'Kamryn', 'Kane', 'Kara', 'Karen', 'Karina', 'Karla', 'Karlee', 'Karly',
            'Karson', 'Karter', 'Kasey', 'Kash', 'Kason', 'Kassidy', 'Kate', 'Katelyn', 'Katherine', 'Kathleen',
            'Kathryn', 'Kathy', 'Katie', 'Katrina', 'Kaya', 'Kayden', 'Kaydence', 'Kayla', 'Kaylee', 'Kayleigh',
            'Kaylie', 'Kaylin', 'Kayson', 'Keanu', 'Keaton', 'Keegan', 'Kehlani', 'Keira', 'Keith', 'Kellan',
            'Kellen', 'Kelly', 'Kelsey', 'Kelvin', 'Kendall', 'Kendra', 'Kendrick', 'Kennedy', 'Kenneth', 'Kenny',
            'Kensley', 'Kent', 'Kenzie', 'Kevin', 'Khalil', 'Khari', 'Khloe', 'Kian', 'Kiana', 'Kiara',
            'Kiera', 'Kieran', 'Kierra', 'Kiley', 'Killian', 'Kim', 'Kimber', 'Kimberly', 'Kingsley', 'Kingston',
            'Kinsley', 'Kira', 'Kira', 'Kirk', 'Kirsten', 'Kit', 'Kobe', 'Koda', 'Kody', 'Kohen',
            'Kole', 'Kolton', 'Konner', 'Kora', 'Korbin', 'Kori', 'Kourtney', 'Kris', 'Kristen', 'Kristin',
            'Kristina', 'Kristine', 'Kristopher', 'Krystal', 'Kurt', 'Kyla', 'Kylan', 'Kyle', 'Kylee', 'Kyleigh',
            'Kyler', 'Kylie', 'Kyra', 'Kyrie', 'Lacey', 'Laila', 'Lainey', 'Lakelyn', 'Lana', 'Lance',
            'Landen', 'Landon', 'Landry', 'Lane', 'Langston', 'Lara', 'Larry', 'Lars', 'Larissa', 'Laura',
            'Laurel', 'Lauren', 'Lauryn', 'Lautaro', 'Lawrence', 'Lawson', 'Layla', 'Laylah', 'Layne', 'Layton',
            'Lea', 'Leah', 'Leander', 'Leandro', 'Leanna', 'Leanne', 'Ledger', 'Lee', 'Leela', 'Leia',
            'Leif', 'Leigh', 'Leila', 'Leilani', 'Leland', 'Lena', 'Lennon', 'Lennox', 'Leo', 'Leon',
            'Leona', 'Leonard', 'Leonardo', 'Leonel', 'Leonidas', 'Leopold', 'Leroy', 'Leslie', 'Lester', 'Levi',
            'Lewis', 'Lexi', 'Lexie', 'Leyla', 'Lia', 'Liam', 'Liana', 'Lianna', 'Libby', 'Lila',
            'Lilah', 'Liliana', 'Lilianna', 'Lilith', 'Lillian', 'Lilliana', 'Lillie', 'Lilly', 'Lily', 'Lilyana',
            'Lina', 'Lincoln', 'Linda', 'Lindsay', 'Lindsey', 'Linus', 'Lionel', 'Lisa', 'Livia', 'Livvy',
            'Lizbeth', 'Lizzie', 'Logan', 'Lola', 'London', 'Londyn', 'Lorelai', 'Lorelei', 'Loren', 'Lorena',
            'Lorenzo', 'Lori', 'Lorna', 'Lorraine', 'Louie', 'Louis', 'Louisa', 'Louise', 'Lourdes', 'Luca',
            'Lucas', 'Lucian', 'Luciana', 'Luciano', 'Lucille', 'Lucy', 'Luella', 'Luisa', 'Luka', 'Lukas',
            'Luke', 'Lula', 'Luna', 'Lydia', 'Lyla', 'Lylah', 'Lynn', 'Lynnette', 'Lyra', 'Lyric',
            'Mabel', 'Maci', 'Macie', 'Mack', 'Mackenzie', 'Macy', 'Madalyn', 'Maddison', 'Maddox', 'Madeleine',
            'Madeline', 'Madelyn', 'Madelynn', 'Madilyn', 'Madilynn', 'Madison', 'Madisyn', 'Mae', 'Maeve', 'Maggie',
            'Magnolia', 'Magnus', 'Maia', 'Maite', 'Makayla', 'Makenna', 'Makenzie', 'Malachi', 'Malakai', 'Malaya',
            'Malcolm', 'Maleah', 'Malia', 'Malik', 'Mallory', 'Mallory', 'Mara', 'Marc', 'Marcel', 'Marcela',
            'Marcella', 'Marcelo', 'Marco', 'Marcos', 'Marcus', 'Margaret', 'Margarita', 'Margot', 'Maria', 'Mariah',
            'Mariam', 'Marian', 'Mariana', 'Marianna', 'Marie', 'Mariela', 'Marilyn', 'Marina', 'Mario', 'Marion',
            'Marisa', 'Marisol', 'Marissa', 'Maritza', 'Marjorie', 'Mark', 'Marlene', 'Marley', 'Marlon', 'Marshall',
            'Martha', 'Martin', 'Martina', 'Marvin', 'Mary', 'Maryam', 'Mason', 'Mateo', 'Mathew', 'Mathias',
            'Matias', 'Matilda', 'Matteo', 'Matthew', 'Matthias', 'Maurice', 'Mauricio', 'Maverick', 'Max', 'Maxim',
            'Maximilian', 'Maximus', 'Maxine', 'Maxwell', 'Maya', 'Mayra', 'Mckenna', 'Mckenzie', 'Mckinley', 'Meadow',
            'Megan', 'Meghan', 'Meilani', 'Melanie', 'Melany', 'Melina', 'Melinda', 'Melissa', 'Melody', 'Melvin',
            'Memphis', 'Meredith', 'Merrick', 'Messiah', 'Mia', 'Micah', 'Michael', 'Michaela', 'Michelle', 'Miguel',
            'Mikaela', 'Mikayla', 'Mike', 'Mila', 'Milana', 'Milani', 'Milena', 'Miles', 'Millie', 'Milo',
            'Milton', 'Mina', 'Mira', 'Miracle', 'Miranda', 'Miriam', 'Misael', 'Mitchell', 'Mitt', 'Miya',
            'Moises', 'Molly', 'Monica', 'Monroe', 'Monserrat', 'Montana', 'Monte', 'Montgomery', 'Morgan', 'Moriah',
            'Moses', 'Moshe', 'Muhammad', 'Mya', 'Myah', 'Myla', 'Mylah', 'Myles', 'Myra', 'Nadia',
            'Nala', 'Nalani', 'Nancy', 'Naomi', 'Nash', 'Nasir', 'Natalia', 'Natalie', 'Nataly', 'Natasha',
            'Nathalie', 'Nathan', 'Nathanael', 'Nathaniel', 'Naya', 'Nayeli', 'Nehemiah', 'Neil', 'Nelson', 'Nevaeh',
            'Nia', 'Nicholas', 'Nick', 'Nickolas', 'Nico', 'Nicole', 'Nicolette', 'Nicolas', 'Nigel', 'Niko',
            'Nikolai', 'Nikolas', 'Nila', 'Nina', 'Nixon', 'Noah', 'Noe', 'Noel', 'Noelle', 'Noemi',
            'Nola', 'Nolan', 'Nora', 'Norah', 'Norman', 'Nova', 'Novah', 'Nyla', 'Nylah', 'Oakley',
            'Oaklyn', 'Oaklynn', 'Ocean', 'Octavia', 'Odin', 'Olive', 'Oliver', 'Olivia', 'Omar', 'Omari',
            'Onyx', 'Opal', 'Ophelia', 'Ora', 'Orion', 'Orlando', 'Oscar', 'Oswald', 'Otis', 'Otto',
            'Owen', 'Pablo', 'Paislee', 'Paisley', 'Paityn', 'Palmer', 'Paloma', 'Pamela', 'Paola', 'Paris',
            'Parker', 'Pascal', 'Patricia', 'Patrick', 'Paul', 'Paula', 'Paulina', 'Pauline', 'Paxton', 'Payton',
            'Pearl', 'Pedro', 'Penelope', 'Penny', 'Percival', 'Percy', 'Perla', 'Peyton', 'Philip', 'Philippa',
            'Phillip', 'Phoebe', 'Phoenix', 'Pierce', 'Pierre', 'Piper', 'Pippa', 'Poppy', 'Porter', 'Poseidon',
            'Presley', 'Preston', 'Prince', 'Princess', 'Princeton', 'Priscilla', 'Quentin', 'Quincy', 'Quinn', 'Quinton',
            'Rachel', 'Rafael', 'Raiden', 'Raina', 'Ramiro', 'Ramon', 'Ramona', 'Randy', 'Raquel', 'Rashad',
            'Raul', 'Raven', 'Rayan', 'Rayden', 'Raylan', 'Raymond', 'Reagan', 'Rebecca', 'Rebekah', 'Reece',
            'Reed', 'Reese', 'Reese', 'Regan', 'Regina', 'Reid', 'Reign', 'Reina', 'Remi', 'Remington',
            'Remy', 'Renata', 'Rene', 'Renee', 'Rex', 'Rey', 'Reyansh', 'Reyna', 'Reynaldo', 'Rhea',
            'Rhett', 'Rhiannon', 'Rhys', 'Ricardo', 'Richard', 'Richie', 'Ricky', 'Ridge', 'Riley', 'Rio',
            'Rita', 'River', 'Rivka', 'Riya', 'Roan', 'Robert', 'Roberto', 'Robin', 'Robyn', 'Rocco',
            'Rocky', 'Rodney', 'Rodrigo', 'Rogelio', 'Roger', 'Rohan', 'Roland', 'Rolando', 'Roman', 'Rome',
            'Romeo', 'Romina', 'Ronald', 'Ronan', 'Ronin', 'Rory', 'Rosa', 'Rosalee', 'Rosalia', 'Rosalie',
            'Rosalind', 'Rosalinda', 'Rosalyn', 'Rosario', 'Rose', 'Roselyn', 'Rosemary', 'Rosie', 'Ross', 'Rowan',
            'Rowen', 'Roxana', 'Roxanne', 'Roy', 'Royal', 'Royalty', 'Royce', 'Ruby', 'Rudy', 'Rue',
            'Rufus', 'Rupert', 'Russell', 'Ruth', 'Ryan', 'Ryann', 'Ryder', 'Ryker', 'Rylan', 'Ryland',
            'Rylee', 'Ryleigh', 'Rylie', 'Rylen', 'Ryley', 'Sabrina', 'Sadie', 'Sage', 'Sahil', 'Saige',
            'Salma', 'Salvador', 'Salvatore', 'Sam', 'Samantha', 'Samara', 'Samir', 'Samson', 'Samuel', 'Sanaa',
            'Sandra', 'Sandy', 'Sanjay', 'Santiago', 'Santino', 'Santos', 'Saoirse', 'Sara', 'Sarah', 'Sarai',
            'Sariah', 'Sariyah', 'Sasha', 'Savanna', 'Savannah', 'Sawyer', 'Scarlet', 'Scarlett', 'Scout', 'Sebastian',
            'Selena', 'Selina', 'Serena', 'Serenity', 'Sergio', 'Seth', 'Shane', 'Shania', 'Shannon', 'Sharon',
            'Shaun', 'Shawn', 'Shay', 'Shea', 'Sheila', 'Shelby', 'Shelton', 'Sheridan', 'Sherman', 'Shiloh',
            'Shirley', 'Shiv', 'Shmuel', 'Shreya', 'Sidney', 'Sienna', 'Sierra', 'Silas', 'Silvia', 'Simone',
            'Simon', 'Sincere', 'Sky', 'Skye', 'Skyla', 'Skylar', 'Skyler', 'Sloane', 'Sofia', 'Sofie',
            'Sofiya', 'Sol', 'Solomon', 'Sonia', 'Sonny', 'Sonya', 'Sophia', 'Sophie', 'Soren', 'Spencer',
            'Stella', 'Stephanie', 'Stephen', 'Sterling', 'Steve', 'Steven', 'Stevie', 'Stewart', 'Stone', 'Storm',
            'Stuart', 'Sue', 'Sullivan', 'Summer', 'Sunny', 'Susan', 'Susanna', 'Susannah', 'Sutton', 'Suzanne',
            'Sven', 'Sylvia', 'Sylvie', 'Tadeo', 'Tahlia', 'Talia', 'Taliyah', 'Talon', 'Tamara', 'Tamia',
            'Tanner', 'Tara', 'Taryn', 'Tate', 'Tatiana', 'Tatum', 'Tatyana', 'Taya', 'Taylor', 'Teagan',
            'Tegan', 'Temperance', 'Teresa', 'Terrance', 'Terrence', 'Terry', 'Tessa', 'Thaddeus', 'Thalia', 'Thatcher',
            'Thea', 'Theo', 'Theodore', 'Theresa', 'Thomas', 'Thora', 'Tiana', 'Tianna', 'Tiago', 'Tiana',
            'Tiffany', 'Timothy', 'Tinsley', 'Titan', 'Titus', 'Tobias', 'Toby', 'Todd', 'Tom', 'Tomas',
            'Tommy', 'Toni', 'Tony', 'Tonya', 'Torin', 'Tori', 'Trace', 'Traci', 'Tracy', 'Travis',
            'Trent', 'Trenton', 'Trevor', 'Trey', 'Tristan', 'Tristen', 'Tristian', 'Triston', 'Troy', 'Tru',
            'Tucker', 'Turner', 'Ty', 'Tyler', 'Tylor', 'Tyree', 'Tyrell', 'Tyrone', 'Tyson', 'Ulises',
            'Ulrich', 'Uma', 'Uriel', 'Uriah', 'Urijah', 'Ursula', 'Valentin', 'Valentina', 'Valentine', 'Valeria',
            'Valerie', 'Valery', 'Van', 'Vance', 'Vanessa', 'Vaughn', 'Veda', 'Vera', 'Veronica', 'Vicente',
            'Vickie', 'Vicky', 'Victor', 'Victoria', 'Vida', 'Vienna', 'Vihaan', 'Viktor', 'Vince', 'Vincent',
            'Vincenzo', 'Violet', 'Violeta', 'Violetta', 'Virginia', 'Vito', 'Vivaan', 'Vivian', 'Viviana', 'Vivienne',
            'Vladimir', 'Wade', 'Walker', 'Wallace', 'Walter', 'Warren', 'Watson', 'Wayne', 'Wells', 'Wendy',
            'Wesley', 'Westin', 'Weston', 'Wheeler', 'Whitney', 'Wilder', 'Will', 'Willa', 'William', 'Willie',
            'Willow', 'Wilson', 'Winston', 'Winter', 'Wren', 'Wyatt', 'Wynter', 'Xander', 'Xavier', 'Ximena',
            'Xiomara', 'Xzavier', 'Yadiel', 'Yahir', 'Yamileth', 'Yara', 'Yareli', 'Yaretzi', 'Yasmin', 'Yasmine',
            'Yehuda', 'Yisroel', 'Yolanda', 'Yosef', 'Yousef', 'Yusuf', 'Yvette', 'Yvonne', 'Zachariah', 'Zachary',
            'Zack', 'Zackary', 'Zackery', 'Zahra', 'Zaid', 'Zain', 'Zaire', 'Zander', 'Zane', 'Zaniyah',
            'Zara', 'Zaria', 'Zariah', 'Zariyah', 'Zavier', 'Zayden', 'Zaylee', 'Zayn', 'Zayne', 'Zechariah',
            'Zeke', 'Zelda', 'Zendaya', 'Zephyr', 'Zeppelin', 'Zev', 'Zia', 'Ziggy', 'Zion', 'Zoe',
            'Zoey', 'Zoie', 'Zola', 'Zora', 'Zoya', 'Zula', 'Zuri', 'Zuriel', 'Zyaire', 'Zyla',
            'Zylah', 'Zyon'
        ]);

        // Create a lowercase version of the database for case-insensitive matching
        const KNOWN_PROPER_NOUNS_LOWER = new Set();
        KNOWN_PROPER_NOUNS.forEach(name => {
            KNOWN_PROPER_NOUNS_LOWER.add(name.toLowerCase());
            // Also add with first letter lowercase (common in text)
            if (name.length > 0) {
                KNOWN_PROPER_NOUNS_LOWER.add(name.charAt(0).toLowerCase() + name.slice(1));
            }
        });

        function isName(word, index) {
            const cleanWord = word.replace(/[^\w\u4e00-\u9fff]/g, '');
            const cleanWordLower = cleanWord.toLowerCase();

            // First check against known proper nouns database (case-insensitive)
            // IMPORTANT: Capitalization is NOT used as a signal - all checks are case-insensitive
            // Check both original case and lowercase versions (case-insensitive database lookup)
            if (KNOWN_PROPER_NOUNS.has(cleanWord) || KNOWN_PROPER_NOUNS_LOWER.has(cleanWordLower)) {
                return true;
            }
            
            // Check if this word appears after a name (likely a surname like "Carbajal")
            // This works regardless of capitalization
            if (index > 0 && analyzedWords && analyzedWords.length > 0) {
                const previousWord = analyzedWords[index - 1];
                if (previousWord && previousWord.isName && previousWord.pos === 'noun') {
                    // Previous word is a name, so this word is likely a surname (works with any case)
                    if (cleanWord.length >= 2) {
                        // Check if it's in our database (case-insensitive)
                        if (KNOWN_PROPER_NOUNS_LOWER.has(cleanWordLower)) {
                            return true;
                        }
                        // If after a name and classified as noun, might be a surname
                        const context = { prevWord: previousWord.text, nextWord: '', index: index, allWords: analyzedWords || [] };
                        const pos = getPOS(word, context);
                        if (pos === 'noun' && cleanWord.length >= 3) {
                            return true; // Likely a surname
                        }
                    }
                }
            }
            
            // Additional check: if word is in database (case-insensitive) and length suggests it's a name
            // This catches names written in any case
            if (KNOWN_PROPER_NOUNS_LOWER.has(cleanWordLower) && cleanWord.length >= 2) {
                // Verify it's not a common word by checking POS
                const prevWord = index > 0 && analyzedWords ? analyzedWords[index - 1]?.text || '' : '';
                const nextWord = analyzedWords && index < analyzedWords.length - 1 ? analyzedWords[index + 1]?.text || '' : '';
                const context = { prevWord: prevWord, nextWord: nextWord, index: index, allWords: analyzedWords || [] };
                const pos = getPOS(word, context);
                // If it's classified as a noun and in our name database, it's likely a name
                if (pos === 'noun') {
                    return true;
                }
            }

            return false;
        }
        
        function findMoralStructures() {
            const structures = [];
            const windowSize = 5; // Look at 5-word windows
            
            for (let i = 0; i < analyzedWords.length - 2; i++) {
                const window = analyzedWords.slice(i, Math.min(i + windowSize, analyzedWords.length));
                const windowIndices = window.map((_, idx) => i + idx);
                
                // Structure 1: Subject + "to be" + Complement (identity/existence)
                const subjectIndex = window.findIndex((w, idx) => isSubject(w, i + idx));
                const toBeIndex = window.findIndex(w => w.isSerEstar);
                const complementIndex = window.findIndex((w, idx) => 
                    idx > Math.max(subjectIndex, toBeIndex) && 
                    (w.pos === 'noun' || w.pos === 'adjective' || isIdentityWord(w.text))
                );
                
                if (subjectIndex >= 0 && toBeIndex >= 0 && complementIndex >= 0 && 
                    subjectIndex < toBeIndex && toBeIndex < complementIndex) {
                    // Check if complement is adjective or personal name (more valuable)
                    const complementWord = window[complementIndex];
                    const isPersonalComplement = complementWord.pos === 'adjective' || 
                                                 (complementWord.pos === 'noun' && isName(complementWord.text, windowIndices[complementIndex])) ||
                                                 isIdentityWord(complementWord.text);
                    const isSituation = complementWord.pos === 'noun' && !isName(complementWord.text, windowIndices[complementIndex]) && 
                                       !isIdentityWord(complementWord.text);
                    
                    const structureType = isPersonalComplement ? 'subject_to_be_personal' : 
                                         isSituation ? 'subject_to_be_situation' : 
                                         'subject_to_be_complement';
                    
                    const score = calculateStructureScore(structureType, window, windowIndices);
                    structures.push({
                        type: structureType,
                        indices: [windowIndices[subjectIndex], windowIndices[toBeIndex], windowIndices[complementIndex]],
                        score: score
                    });
                }
                
                // Structure 2: Subject + "to do" + Object (action)
                const toDoIndex = window.findIndex(w => isToDoVerb(w.text));
                const objectIndex = window.findIndex((w, idx) => 
                    idx > Math.max(subjectIndex, toDoIndex) && w.pos === 'noun'
                );
                
                if (subjectIndex >= 0 && toDoIndex >= 0 && objectIndex >= 0 &&
                    subjectIndex < toDoIndex && toDoIndex < objectIndex) {
                    const score = calculateStructureScore('subject_to_do_object', window, windowIndices);
                    structures.push({
                        type: 'subject_to_do_object',
                        indices: [windowIndices[subjectIndex], windowIndices[toDoIndex], windowIndices[objectIndex]],
                        score: score
                    });
                }
                
                // Structure 3: Subject + "to have" + Object (possession/existence)
                const toHaveIndex = window.findIndex(w => isToHaveVerb(w.text));
                const haveObjectIndex = window.findIndex((w, idx) => 
                    idx > Math.max(subjectIndex, toHaveIndex) && w.pos === 'noun'
                );
                
                if (subjectIndex >= 0 && toHaveIndex >= 0 && haveObjectIndex >= 0 &&
                    subjectIndex < toHaveIndex && toHaveIndex < haveObjectIndex) {
                    const score = calculateStructureScore('subject_to_have_object', window, windowIndices);
                    structures.push({
                        type: 'subject_to_have_object',
                        indices: [windowIndices[subjectIndex], windowIndices[toHaveIndex], windowIndices[haveObjectIndex]],
                        score: score
                    });
                }
                
                // Structure 4: Identity structure (pronoun + "to be" + identity)
                const pronounIndex = window.findIndex(w => w.pos === 'pronoun' || isIdentityWord(w.text));
                const identityToBeIndex = window.findIndex((w, idx) => idx > pronounIndex && w.isSerEstar);
                const identityComplementIndex = window.findIndex((w, idx) => 
                    idx > identityToBeIndex && (isIdentityWord(w.text) || w.pos === 'noun' || w.pos === 'adjective')
                );
                
                if (pronounIndex >= 0 && identityToBeIndex >= 0 && identityComplementIndex >= 0) {
                    const score = calculateStructureScore('identity_structure', window, windowIndices);
                    structures.push({
                        type: 'identity_structure',
                        indices: [windowIndices[pronounIndex], windowIndices[identityToBeIndex], windowIndices[identityComplementIndex]],
                        score: score
                    });
                }
            }
            
            return structures;
        }
        
        function calculateStructureScore(structureType, window, indices) {
            let baseScore = 0;
            
            switch(structureType) {
                case 'subject_to_be_personal':
                    baseScore = 10; // Very high value - to be + adjective/personal name
                    break;
                case 'subject_to_be_situation':
                    baseScore = 6; // Lower value - to be + situation/noun
                    break;
                case 'subject_to_be_complement':
                    baseScore = 8; // High moral value - existence/identity (fallback)
                    break;
                case 'subject_to_do_object':
                    baseScore = 7; // High value - action/purpose
                    break;
                case 'subject_to_have_object':
                    baseScore = 6; // Medium-high value - possession/existence
                    break;
                case 'identity_structure':
                    baseScore = 9; // Very high moral value - identity
                    break;
                default:
                    baseScore = 5;
            }
            
            // Add complexity bonus based on modifiers/adjectives
            const modifiers = window.filter(w => w.pos === 'adjective' || w.pos === 'adverb').length;
            baseScore += modifiers * 0.5;
            
            // Ensure score is between 1-10 for structure complexity/morality
            return Math.min(10, Math.max(1, Math.round(baseScore * 10) / 10));
        }

        // ==================== VISUALIZACIÃ“N 3D ====================
        // Detect text structure type
        let textStructureType = 'unknown';
        
        function detectTextStructure(text) {
            const lines = text.split(/\n+/).filter(line => line.trim().length > 0);
            
            if (lines.length === 0) return 'unknown';
            
            // Check if it's a list (bullet points or numbered)
            const listPatterns = {
                bullet: /^[\s]*[-â€¢*\+]\s+/,
                numbered: /^[\s]*\d+[\.\)]\s+/,
                lettered: /^[\s]*[a-zA-Z][\.\)]\s+/
            };
            
            let listItemCount = 0;
            lines.forEach(line => {
                if (listPatterns.bullet.test(line) || listPatterns.numbered.test(line) || listPatterns.lettered.test(line)) {
                    listItemCount++;
                }
            });
            
            // If more than 50% of lines are list items, it's a list
            if (listItemCount / lines.length > 0.5) {
                return 'list';
            }
            
            // Check average sentence length (rough estimate)
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(/\s+/).length, 0) / sentences.length;
            
            // Check if it's very short (single sentence or phrase)
            const wordCount = text.split(/\s+/).filter(w => w.length > 0).length;
            if (wordCount <= 10) {
                return 'short_phrase';
            }
            
            // Check if sentences are very short (aphorisms, definitions)
            if (avgSentenceLength <= 8 && sentences.length > 3) {
                return 'short_sentences';
            }
            
            // Check if it's paragraph-based (multiple paragraphs)
            if (lines.length > 3 && lines.some(line => line.length > 100)) {
                return 'paragraphs';
            }
            
            // Default to narrative flow
            return 'narrative';
        }
        
        function getClusterPosition(wordData, index) {
            // Original positioning based on POS clusters
            return getNarrativePosition(wordData, index);
        }
        
        function getSemanticCorePosition(wordData, index) {
            // Initialize if not available
            if (!window.semanticCores) {
                window.semanticCores = [];
            }
            if (!window.coreWords) {
                window.coreWords = new Map();
            }
            
            // Check if semantic cores are available
            if (!window.semanticCores || window.semanticCores.length === 0) {
                // Fallback to narrative positioning if no cores detected
                return getNarrativePosition(wordData, index);
            }
            
            const cores = window.semanticCores;
            const coreWords = window.coreWords || new Map();
            
            // Use structure-specific cluster distribution
            const distributionType = getClusterDistributionType();
            
            // Check if this word is a semantic core
            const coreIndex = coreWords.get(index);
            
            if (coreIndex !== undefined) {
                // This word IS a semantic core - position at center of its cluster
                const core = cores[coreIndex];
                const coreIndexInCores = core.index;
                
                // Get core position based on distribution type
                const corePos = getCorePosition(coreIndexInCores, cores.length, distributionType, wordData);
                
                return corePos;
            } else {
                // This word belongs to a core - position around its core
                const assignedCoreIndex = coreWords.get(index);
                
                if (assignedCoreIndex !== undefined) {
                    const core = cores[assignedCoreIndex];
                    const coreIndexInCores = core.index;
                    const distributionType = getClusterDistributionType();
                    
                    // Calculate core position using distribution type
                    const corePos = getCorePosition(coreIndexInCores, cores.length, distributionType, core.wordData);
                    
                    // Position around the core - different arrangements for different text types
                    const clusterArrangement = getClusterArrangement(distributionType);
                    
                    const relatedIndex = core.relatedWords.indexOf(index);
                    const totalRelated = core.relatedWords.length;
                    
                    let offsetX, offsetY, offsetZ;
                    
                    if (clusterArrangement === 'sphere') {
                        // 3D sphere around core - closer
                        const angle = (relatedIndex / Math.max(1, totalRelated)) * Math.PI * 2;
                        const verticalAngle = (relatedIndex / Math.max(1, totalRelated)) * Math.PI;
                        const radius = 0.5 + (wordData.normalizedScore * 0.8); // Reduced
                        offsetX = Math.cos(angle) * Math.sin(verticalAngle) * radius;
                        offsetY = Math.cos(verticalAngle) * radius * 0.6; // Reduced
                        offsetZ = Math.sin(angle) * Math.sin(verticalAngle) * radius;
                    } else if (clusterArrangement === 'flat_circle') {
                        // Flat circle around core - closer
                        const angle = (relatedIndex / Math.max(1, totalRelated)) * Math.PI * 2;
                        const radius = 0.6 + (wordData.normalizedScore * 0.7); // Reduced
                        offsetX = Math.cos(angle) * radius;
                        offsetY = (wordData.normalizedScore - 0.5) * 0.5; // Reduced
                        offsetZ = Math.sin(angle) * radius;
                    } else if (clusterArrangement === 'vertical_stack') {
                        // Vertical stack - closer
                        const verticalPos = (relatedIndex / Math.max(1, totalRelated) - 0.5) * 1.5; // Reduced
                        const angle = (relatedIndex / Math.max(1, totalRelated)) * Math.PI * 2;
                        const radius = 0.4 + (wordData.normalizedScore * 0.4); // Reduced
                        offsetX = Math.cos(angle) * radius;
                        offsetY = verticalPos;
                        offsetZ = Math.sin(angle) * radius;
                    } else {
                        // Default: loose sphere - closer
                        const angle = (relatedIndex / Math.max(1, totalRelated)) * Math.PI * 2;
                        const radius = 0.7 + (wordData.normalizedScore * 1.0); // Reduced
                        offsetX = Math.cos(angle) * radius;
                        offsetY = (wordData.normalizedScore - 0.5) * 1.0; // Reduced
                        offsetZ = Math.sin(angle) * radius;
                    }
                    
                    return {
                        x: corePos.x + offsetX,
                        y: corePos.y + offsetY,
                        z: corePos.z + offsetZ
                    };
                } else {
                    // Word not assigned to any core - use fallback
                    return getFallbackPosition(wordData, index);
                }
            }
        }
        
        // Determine cluster distribution type based on text structure
        function getClusterDistributionType() {
            // Use the detected text structure to determine how to distribute clusters
            if (textStructureType === 'list') {
                return 'vertical_columns'; // Lists: vertical columns
            } else if (textStructureType === 'short_phrase') {
                return 'centered_tight'; // Short phrases: tight, centered clusters
            } else if (textStructureType === 'short_sentences') {
                return 'scattered_medium'; // Short sentences: medium-sized scattered clusters
            } else if (textStructureType === 'paragraphs') {
                return 'horizontal_bands'; // Paragraphs: horizontal bands
            } else {
                return 'sphere_distributed'; // Narrative: distributed in sphere
            }
        }
        
        // Get core position based on distribution type
        function getCorePosition(coreIndex, totalCores, distributionType, wordData) {
            const normalizedIndex = coreIndex / Math.max(1, totalCores);
            
            switch(distributionType) {
                case 'vertical_columns':
                    // Vertical columns (for lists) - closer together
                    const columns = Math.ceil(Math.sqrt(totalCores));
                    const column = coreIndex % columns;
                    const row = Math.floor(coreIndex / columns);
                    return {
                        x: (column - (columns - 1) / 2) * 2.0, // Reduced from 3
                        y: -row * 1.8, // Reduced from 2.5
                        z: (wordData.normalizedScore - 0.5) * 1.5 // Reduced from 2
                    };
                    
                case 'centered_tight':
                    // Tight, centered clusters (for short phrases) - very close
                    const angle = normalizedIndex * Math.PI * 2;
                    const radius = 0.8 + normalizedIndex * 0.3; // Reduced from 1.5
                    return {
                        x: Math.cos(angle) * radius,
                        y: (wordData.normalizedScore - 0.5) * 0.8, // Reduced
                        z: Math.sin(angle) * radius
                    };
                    
                case 'scattered_medium':
                    // Medium-sized scattered clusters (for short sentences) - closer
                    const scatterAngle = normalizedIndex * Math.PI * 2.5;
                    const scatterRadius = 1.5 + coreIndex * 0.5; // Reduced from 2
                    return {
                        x: Math.cos(scatterAngle) * scatterRadius,
                        y: (normalizedIndex - 0.5) * 2 + (wordData.normalizedScore - 0.5) * 0.8, // Reduced
                        z: Math.sin(scatterAngle) * scatterRadius
                    };
                    
                case 'horizontal_bands':
                    // Horizontal bands (for paragraphs) - closer
                    const bandWidth = Math.ceil(Math.sqrt(totalCores));
                    const band = Math.floor(coreIndex / bandWidth);
                    const posInBand = coreIndex % bandWidth;
                    return {
                        x: (posInBand - (bandWidth - 1) / 2) * 2.0, // Reduced from 2.5
                        y: -band * 1.5, // Reduced from 2
                        z: (wordData.normalizedScore - 0.5) * 2.0 // Reduced from 3
                    };
                    
                case 'sphere_distributed':
                default:
                    // Distributed in sphere (for narrative) - closer
                    const sphereAngle = normalizedIndex * Math.PI * 2;
                    const sphereVerticalAngle = normalizedIndex * Math.PI;
                    const sphereRadius = 2.0 + coreIndex * 0.5; // Reduced from 3
                    return {
                        x: Math.cos(sphereAngle) * Math.sin(sphereVerticalAngle) * sphereRadius,
                        y: Math.cos(sphereVerticalAngle) * sphereRadius * 0.8 + (wordData.normalizedScore - 0.5) * 0.8, // Reduced
                        z: Math.sin(sphereAngle) * Math.sin(sphereVerticalAngle) * sphereRadius
                    };
            }
        }
        
        // Get cluster arrangement (how words are arranged around cores)
        function getClusterArrangement(distributionType) {
            switch(distributionType) {
                case 'centered_tight':
                    return 'flat_circle'; // Tight clusters: flat circles
                case 'vertical_columns':
                    return 'vertical_stack'; // Lists: vertical stacks
                case 'scattered_medium':
                    return 'sphere'; // Scattered: 3D spheres
                case 'horizontal_bands':
                    return 'flat_circle'; // Bands: flat circles
                default:
                    return 'sphere'; // Default: 3D spheres
            }
        }
        
        function createFallbackConnections() {
            // Simple fallback: connect adjacent high-value words
            for (let i = 0; i < nodes.length; i++) {
                const currentNode = nodes[i];
                const currentWord = currentNode.userData.wordData;
                
                if (currentWord.normalizedScore > 0.5) {
                    // Connect to other high-value words of same POS
                    for (let j = i + 1; j < nodes.length; j++) {
                        const otherNode = nodes[j];
                        const otherWord = otherNode.userData.wordData;
                        
                        if (otherWord.normalizedScore > 0.5 && 
                            otherWord.pos === currentWord.pos) {
                            createConnection(currentNode, otherNode);
                            break; // Connect to first match only
                        }
                    }
                }
            }
        }
        
        function getFallbackPosition(wordData, index) {
            // Position unassigned words based on POS and value
            const posGroups = {
                'noun': { x: 0, y: 2, z: 0 },
                'verb': { x: 0, y: -2, z: 0 },
                'adjective': { x: 2, y: 0, z: 0 },
                'pronoun': { x: -2, y: 0, z: 0 },
                'other': { x: 0, y: 0, z: 0 }
            };
            
            const basePos = posGroups[wordData.pos] || posGroups['other'];
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords;
            
            // Spread based on value
            const valueSpread = wordData.normalizedScore * 3;
            const angle = normalizedIndex * Math.PI * 2;
            
            return {
                x: basePos.x + Math.cos(angle) * valueSpread,
                y: basePos.y + (wordData.normalizedScore - 0.5) * 2,
                z: basePos.z + Math.sin(angle) * valueSpread
            };
        }
        
        // Position for lists: vertical or circular groups by list item
        function getListPosition(wordData, index) {
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords;
            
            // Find which "list item" this word belongs to by looking for list markers
            // This is a simplified approach - in practice you'd want to track list boundaries better
            const wordsPerItem = Math.max(3, Math.ceil(totalWords / 10)); // Assume ~10 list items
            const itemIndex = Math.floor(index / wordsPerItem);
            const itemPosition = (index % wordsPerItem) / wordsPerItem; // Position within item
            
            // Create vertical stack of items, with words spreading horizontally within each
            const itemY = -itemIndex * 1.5; // Stack items vertically
            const itemAngle = itemIndex * (Math.PI * 2 / 10); // Circular arrangement per item
            
            // Within each item, words spread in a line/arc
            const withinItemSpread = (itemPosition - 0.5) * 2; // -1 to 1
            const radius = 2 + itemIndex * 0.3; // Growing radius for outer items
            
            // Value-based depth
            const depthZ = wordData.normalizedScore * 3 - 1.5;
            
            return {
                x: Math.cos(itemAngle) * radius + withinItemSpread * 0.8,
                y: itemY + (wordData.normalizedScore - 0.5) * 0.5,
                z: Math.sin(itemAngle) * radius + depthZ
            };
        }
        
        // Position for short phrases: compact, centered, high value words prominent
        function getShortPhrasePosition(wordData, index) {
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords;
            
            // Compact circular arrangement centered on origin
            const angle = (normalizedIndex * Math.PI * 2) + (wordData.normalizedScore * Math.PI);
            const radius = 0.5 + wordData.normalizedScore * 2; // Value determines distance from center
            
            // Vertical stacking based on value (high value higher)
            const heightY = wordData.normalizedScore * 2 - 1;
            
            return {
                x: Math.cos(angle) * radius,
                y: heightY,
                z: Math.sin(angle) * radius + (normalizedIndex - 0.5) * 0.5
            };
        }
        
        // Position for short sentences: each sentence forms a small cluster
        function getShortSentencesPosition(wordData, index) {
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords;
            
            // Group words into sentences (approximate: assume 5-8 words per sentence)
            const wordsPerSentence = 6;
            const sentenceIndex = Math.floor(index / wordsPerSentence);
            const wordInSentence = index % wordsPerSentence;
            
            // Each sentence is a small cluster
            const sentenceAngle = sentenceIndex * (Math.PI * 2 / 15); // Arrange sentences in a large circle
            const sentenceRadius = 3 + sentenceIndex * 0.2;
            
            // Words within sentence form a small arc
            const wordAngle = (wordInSentence / wordsPerSentence) * Math.PI * 0.6; // Small arc
            const wordRadius = 0.3 + wordData.normalizedScore * 0.5;
            
            return {
                x: Math.cos(sentenceAngle) * sentenceRadius + Math.cos(sentenceAngle + wordAngle) * wordRadius,
                y: (wordData.normalizedScore - 0.5) * 1.5 + (sentenceIndex % 3 - 1) * 0.3,
                z: Math.sin(sentenceAngle) * sentenceRadius + Math.sin(sentenceAngle + wordAngle) * wordRadius
            };
        }
        
        // Position for paragraphs: linear flow with paragraph breaks
        function getParagraphsPosition(wordData, index) {
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords;
            
            // Estimate paragraph breaks (assume ~50-100 words per paragraph)
            const wordsPerParagraph = 75;
            const paragraphIndex = Math.floor(index / wordsPerParagraph);
            const wordInParagraph = index % wordsPerParagraph;
            
            // Paragraphs form vertical columns with horizontal flow within
            const columnX = (paragraphIndex % 3 - 1) * 3; // 3 columns
            const paragraphY = -paragraphIndex * 2; // Stack paragraphs vertically
            
            // Words flow horizontally within paragraph
            const wordX = (wordInParagraph / wordsPerParagraph - 0.5) * 4;
            const wordY = (wordData.normalizedScore - 0.5) * 1;
            const wordZ = (normalizedIndex - 0.5) * 3;
            
            return {
                x: columnX + wordX * 0.5,
                y: paragraphY + wordY,
                z: wordZ
            };
        }
        
        // Position for narrative: traditional flow with POS clusters
        function getNarrativePosition(wordData, index) {
            // Base cluster centers based on syntax (POS) - more spread out
            const posGroups = {
                'noun': { x: -4, y: 0, z: -2 },
                'verb': { x: 4, y: 0, z: 2 },
                'adjective': { x: 0, y: 4, z: -1 },
                'adverb': { x: 0, y: -4, z: 1 },
                'pronoun': { x: -2, y: 2, z: 4 },
                'preposition': { x: 2, y: -2, z: -4 },
                'conjunction': { x: -3, y: -3, z: -3 },
                'determiner': { x: 3, y: -3, z: 3 },
                'other': { x: 0, y: 0, z: 0 }
            };
            
            const basePos = posGroups[wordData.pos] || posGroups['other'];
            
            // Use text order/index to create organic flow following syntax
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords; // 0 to 1
            
            // Create organic distribution based on syntax order
            // Each POS cluster spreads organically following text sequence
            const sequenceAngle = normalizedIndex * Math.PI * 4; // Multiple rotations
            const sequenceRadius = 0.5 + (normalizedIndex * 2.5); // Growing radius
            
            // INVERTED: More valuable nodes closer to exterior, less valuable closer to interior
            const minDistance = 0.8;
            const maxDistance = 5.0;
            const distanceFromClusterCenter = minDistance + (wordData.normalizedScore * (maxDistance - minDistance));
            
            // Add significant vertical variation (less flat)
            const verticalSpread = 3.5;
            const verticalOffset = (normalizedIndex - 0.5) * verticalSpread * 2; // Spread based on order
            const verticalRandom = (Math.random() - 0.5) * verticalSpread;
            
            // Organic positioning following syntax order
            const angle1 = sequenceAngle;
            const angle2 = normalizedIndex * Math.PI * 2;
            
            // Less organized, more chaotic distribution
            const chaosFactor = 1.2;
            const randomX = (Math.random() - 0.5) * chaosFactor;
            const randomY = (Math.random() - 0.5) * chaosFactor;
            const randomZ = (Math.random() - 0.5) * chaosFactor;
            
            return {
                x: basePos.x + Math.cos(angle1) * distanceFromClusterCenter * Math.cos(angle2) + randomX,
                y: basePos.y + verticalOffset + Math.sin(angle1) * distanceFromClusterCenter + verticalRandom + randomY,
                z: basePos.z + Math.sin(angle2) * distanceFromClusterCenter + (normalizedIndex - 0.5) * 2 + randomZ
            };
        }
        
        function getValueBasedColor(wordData, index, allWords) {
            // CRITICAL: Always return a number (hex color value)
            if (!allWords || allWords.length === 0) {
                return 0x808080; // Default grey
            }
            
            // Sort all words by finalValue
            const sortedWords = [...allWords].sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0));
            const currentValue = wordData.finalValue || 0;
            
            // Filter words with at least 40 points
            const wordsWith40PlusPoints = sortedWords.filter(w => (w.finalValue || 0) >= 40);
            
            // Get top 5 from words with 40+ points (or fewer if less than 5 exist)
            const top5YellowNodes = wordsWith40PlusPoints.slice(0, 5);
            
            // Check if this word is in the top 5 yellow nodes
            const isTop5Yellow = top5YellowNodes.some(w => 
                (w === wordData) || 
                (w.text === wordData.text && w.index === wordData.index)
            );
            
            // Also check that current value is at least 40 points
            const hasMinimumPoints = currentValue >= 40;
            
            let color;
            if (isTop5Yellow && hasMinimumPoints) {
                color = 0xffff00; // Yellow for top 5 with minimum 40 points
            } else {
                // Find index of current word in sorted array for percentile calculation
                const sortedIndex = sortedWords.findIndex(w => w === wordData || 
                    (w.text === wordData.text && w.index === wordData.index));
                
                // Calculate percentile (0 to 1)
                const percentile = sortedIndex >= 0 ? sortedIndex / sortedWords.length : 0.5;
                
                if (percentile < 0.2) {
                    color = 0x4a8fa5; // Azul-verdoso-grisÃ¡ceo (medio-alto)
                } else if (percentile < 0.4) {
                    color = 0x5a7fa5; // Azul grisÃ¡ceo (medio)
                } else if (percentile < 0.6) {
                    color = 0x6a8fb5; // Azul grisÃ¡ceo claro (medio-bajo)
                } else {
                    color = 0x999999; // Gris mÃ¡s oscuro (bajo) - changed from 0x808080 to be less white
                }
            }
            
            // Ensure we always return a number
            return typeof color === 'number' ? color : parseInt(color, 16);
        }
        
        // Helper: Get word type classification for shape determination
        function getWordTypeForShape(wordData, index) {
            const pos = wordData.pos || '';
            const uposType = wordData.uposType || wordData.upos || '';
            const upos = wordData.upos || wordData.uposType || '';
            const isName = wordData.isName || false;
            const isSerEstar = wordData.isSerEstar || false;
            const isPartOfCompoundName = wordData.isPartOfCompoundName || false;
            const tense = wordData.tense || null;
            const text = (wordData.text || '').toLowerCase();
            
            // NOUNS - Check both legacy pos and UPOS tags
            if (pos === 'noun' || upos === 'NOUN' || upos === 'PROPN' || uposType === 'NOUN' || uposType === 'NAME' || uposType === 'PROPN') {
                if (isPartOfCompoundName) {
                    return 'compound_noun';
                }
                if (isName) {
                    return 'proper_noun';
                }
                // Check for gerundial nouns (verbs functioning as nouns) - words ending in -ing used as nouns
                if (text.endsWith('ing') && (upos === 'NOUN' || uposType === 'NOUN' || pos === 'noun')) {
                    return 'gerundial_noun';
                }
                // Default to common noun
                return 'common_noun';
            }
            
            // PRONOUNS - Check both legacy pos and UPOS tags
            if (pos === 'pronoun' || upos === 'PRON' || uposType === 'PRON' || uposType === 'PRONOUN') {
                // Check for specific pronoun types based on text or context
                const pronounText = text.trim();
                // Subject pronouns: I, you, he, she, it, we, they
                if (['i', 'you', 'he', 'she', 'it', 'we', 'they'].includes(pronounText)) {
                    return 'subject_pronoun';
                }
                // Object pronouns: me, him, her, us, them
                if (['me', 'him', 'her', 'us', 'them'].includes(pronounText)) {
                    return 'object_pronoun';
                }
                // Possessive pronouns: mine, yours, his, hers, ours, theirs
                if (['mine', 'yours', 'his', 'hers', 'ours', 'theirs'].includes(pronounText)) {
                    return 'possessive_pronoun';
                }
                // Reflexive pronouns: myself, yourself, himself, herself, itself, ourselves, yourselves, themselves
                if (pronounText.endsWith('self') || pronounText.endsWith('selves')) {
                    return 'reflexive_pronoun';
                }
                // Demonstrative pronouns: this, that, these, those
                if (['this', 'that', 'these', 'those'].includes(pronounText)) {
                    return 'demonstrative_pronoun';
                }
                // Relative pronouns: who, whom, whose, which, that (when used as relative)
                if (['who', 'whom', 'whose', 'which'].includes(pronounText)) {
                    return 'relative_pronoun';
                }
                // Interrogative pronouns: who, whom, whose, which, what
                if (['what'].includes(pronounText)) {
                    return 'interrogative_pronoun';
                }
                // Indefinite pronouns: some, any, all, each, every, etc.
                if (['some', 'any', 'all', 'each', 'every', 'none', 'both', 'few', 'many', 'most', 'several'].includes(pronounText)) {
                    return 'indefinite_pronoun';
                }
                // Reciprocal pronouns: each other, one another
                if (pronounText.includes('other') || pronounText.includes('another')) {
                    return 'reciprocal_pronoun';
                }
                // Default to subject pronoun
                return 'subject_pronoun';
            }
            
            // VERBS - Check both legacy pos and UPOS tags
            if (pos === 'verb' || upos === 'VERB' || upos === 'AUX' || uposType === 'VERB' || uposType === 'AUX' || uposType === 'VERB_AUXILIARY') {
                if (isSerEstar || upos === 'AUX' || uposType === 'VERB_AUXILIARY') {
                    return 'auxiliary_verb';
                } else if (uposType === 'VERB_MODAL' || uposType === 'MODAL' || (upos === 'AUX' && ['can', 'could', 'may', 'might', 'must', 'shall', 'should', 'will', 'would'].includes(text))) {
                    return 'modal_verb';
                } else if (text.endsWith('ing') && tense === 'PRESENT_PARTICIPLE') {
                    // Present participle
                    return 'present_participle';
                } else if (tense === 'PAST_PARTICIPLE' || (text.endsWith('ed') && tense !== 'PAST')) {
                    // Past participle
                    return 'past_participle';
                } else if (text === 'be' || text === 'to be' || (text.startsWith('to ') && text.includes('be'))) {
                    // Infinitive
                    return 'infinitive';
                } else if (text === 'be' || text === 'am' || text === 'is' || text === 'are' || text === 'was' || text === 'were') {
                    // Base form or linking verb
                    return 'linking_verb';
                } else {
                    return 'lexical_verb';
                }
            }
            
            // ADJECTIVES - Check both legacy pos and UPOS tags
            if (pos === 'adjective' || upos === 'ADJ' || uposType === 'ADJ' || uposType === 'ADJECTIVE') {
                // Comparative adjectives: ending in -er or more + adj
                if (text.endsWith('er') || text.startsWith('more ')) {
                    return 'comparative_adjective';
                }
                // Superlative adjectives: ending in -est or most + adj
                if (text.endsWith('est') || text.startsWith('most ')) {
                    return 'superlative_adjective';
                }
                // Default to descriptive adjective
                return 'descriptive_adjective';
            }
            
            // ADVERBS - Check both legacy pos and UPOS tags
            if (pos === 'adverb' || upos === 'ADV' || uposType === 'ADV' || uposType === 'ADVERB') {
                return 'adverb';
            }
            
            // PREPOSITIONS - Check both legacy pos and UPOS tags
            if (pos === 'preposition' || upos === 'ADP' || uposType === 'ADP' || uposType === 'PREPOSITION') {
                // Compound prepositions: multiple words or specific patterns
                if (text.includes(' ') || ['according to', 'because of', 'in front of', 'in spite of', 'instead of'].some(comp => text.includes(comp))) {
                    return 'compound_preposition';
                }
                // Prepositional particles: part of phrasal verbs
                if (['up', 'down', 'in', 'out', 'on', 'off', 'over', 'under', 'away', 'back'].includes(text)) {
                    return 'prepositional_particle';
                }
                return 'simple_preposition';
            }
            
            // CONJUNCTIONS - Check both legacy pos and UPOS tags
            if (pos === 'conjunction' || upos === 'CCONJ' || upos === 'SCONJ' || uposType === 'CCONJ' || uposType === 'SCONJ' || uposType === 'CONJUNCTION') {
                // Coordinating: and, but, or, nor, for, so, yet
                if (['and', 'but', 'or', 'nor', 'for', 'so', 'yet'].includes(text)) {
                    return 'coordinating_conjunction';
                }
                // Correlative: both...and, either...or, neither...nor, not only...but also
                if (['both', 'either', 'neither', 'not only', 'but also'].includes(text)) {
                    return 'correlative_conjunction';
                }
                // Subordinating: because, although, if, when, while, etc.
                return 'subordinating_conjunction';
            }
            
            // DETERMINERS - Check both legacy pos and UPOS tags
            if (pos === 'determiner' || upos === 'DET' || uposType === 'DET' || uposType === 'DETERMINER') {
                // Definite article
                if (text === 'the') {
                    return 'definite_article';
                }
                // Indefinite article
                if (text === 'a' || text === 'an') {
                    return 'indefinite_article';
                }
                // Demonstrative determiners
                if (['this', 'that', 'these', 'those'].includes(text)) {
                    return 'demonstrative_determiner';
                }
                // Possessive determiners
                if (['my', 'your', 'his', 'her', 'its', 'our', 'their'].includes(text)) {
                    return 'possessive_determiner';
                }
                // Quantifiers
                if (['some', 'any', 'all', 'each', 'every', 'many', 'much', 'few', 'little', 'several', 'most'].includes(text)) {
                    return 'quantifier';
                }
                // Interrogative determiners
                if (['which', 'what', 'whose'].includes(text)) {
                    return 'interrogative_determiner';
                }
                // Default to definite article
                return 'definite_article';
            }
            
            // NUMERALS - Check both legacy pos and UPOS tags
            if (pos === 'numeral' || pos === 'number' || upos === 'NUM' || uposType === 'NUM' || uposType === 'NUMERAL') {
                // Ordinal: first, second, third, etc.
                if (text.endsWith('st') || text.endsWith('nd') || text.endsWith('rd') || text.endsWith('th') || 
                    ['first', 'second', 'third', 'fourth', 'fifth'].includes(text)) {
                    return 'ordinal_numeral';
                }
                // Multiplicative: once, twice, thrice
                if (['once', 'twice', 'thrice'].includes(text)) {
                    return 'multiplicative_numeral';
                }
                // Fractional: half, third, quarter, etc.
                if (['half', 'third', 'quarter', 'fifth'].includes(text) || text.endsWith('th') && text !== 'fourth' && text !== 'fifth') {
                    return 'fractional_numeral';
                }
                // Default to cardinal
                return 'cardinal_numeral';
            }
            
            // Default: common noun
            return 'common_noun';
        }
        
        // Helper: Create geometry based on word type
        // CRITICAL: Accept color as NUMBER and opacity as NUMBER to avoid ANY material sharing
        function createWordTypeGeometry(wordType, baseSize, colorHex, baseOpacity) {
            const group = new THREE.Group();
            const pixelSize = baseSize * 0.1; // 1 pixel = 0.1 * baseSize
            
            // Helper function to create mesh with material - ALWAYS create NEW material for EACH mesh
            // This is CRITICAL to prevent material sharing between nodes
            const createMesh = (geometry, customOpacity = null) => {
                // Create a COMPLETELY NEW material for this specific mesh
                const meshMaterial = new THREE.MeshStandardMaterial({
                    color: colorHex, // Use hex number directly - NO references
                    transparent: true,
                    opacity: customOpacity !== null ? customOpacity : baseOpacity,
                    metalness: 0.1,
                    roughness: 0.7
                });
                const mesh = new THREE.Mesh(geometry, meshMaterial);
                return mesh;
            };
            
            // Helper to get semi-transparent opacity (for outer parts)
            const getSemiTransparentOpacity = () => 0.76; // 24% transparent for semi-transparent parts (20% less transparent)
            
            switch (wordType) {
                // NOUNS
                case 'common_noun': {
                    // Esfera con una superficie cuadrada dos pÃ­xeles mÃ¡s abajo, del mismo diÃ¡metro
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const square = new THREE.BoxGeometry(baseSize, pixelSize * 0.1, baseSize, 1, 1, 1);
                    group.add(createMesh(sphere));
                    const squareMesh = createMesh(square);
                    squareMesh.position.y = -baseSize * 2.5; // Reduced from 3.0 - surfaces that are too far should be closer
                    group.add(squareMesh);
                    break;
                }
                case 'proper_noun': {
                    // Esfera semi transparente con una esfera dentro y con una superficie cuadrada del mismo diÃ¡metro, dos pÃ­xeles mÃ¡s abajo
                    const outerSphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const innerSphere = new THREE.SphereGeometry(baseSize * 0.6, 6, 6);
                    const square = new THREE.BoxGeometry(baseSize, pixelSize * 0.1, baseSize, 1, 1, 1);
                    
                    const outerMesh = createMesh(outerSphere, getSemiTransparentOpacity());
                    const innerMesh = createMesh(innerSphere);
                    const squareMesh = createMesh(square);
                    squareMesh.position.y = -baseSize * 2.0; // Two pixels below (2 * pixelSize = 2 * 0.1 * baseSize)
                    
                    group.add(outerMesh);
                    group.add(innerMesh);
                    group.add(squareMesh);
                    break;
                }
                case 'concrete_noun': {
                    // Esfera semi transparente con una esfera dentro y con una superficie cuadrada mÃ¡s pequeÃ±a 1 pÃ­xel mÃ¡s abajo
                    const outerSphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const innerSphere = new THREE.SphereGeometry(baseSize * 0.6, 6, 6);
                    const square = new THREE.BoxGeometry(baseSize * 0.8, pixelSize * 0.1, baseSize * 0.8, 1, 1, 1);
                    const outerMesh = createMesh(outerSphere, getSemiTransparentOpacity());
                    const innerMesh = createMesh(innerSphere);
                    const squareMesh = createMesh(square);
                    squareMesh.position.y = -baseSize * 1.0; // One pixel below (1 * pixelSize = 0.1 * baseSize)
                    group.add(outerMesh);
                    group.add(innerMesh);
                    group.add(squareMesh);
                    break;
                }
                case 'abstract_noun': {
                    // Esfera
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    group.add(createMesh(sphere));
                    break;
                }
                case 'countable_noun': {
                    // Esfera con un espacio abierto en su parte superior
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const sphereMesh = createMesh(sphere);
                    // Create a hole by adding a small sphere at top (visual representation)
                    const hole = new THREE.SphereGeometry(baseSize * 0.3, 6, 6);
                    const holeMesh = createMesh(hole);
                    holeMesh.position.y = baseSize * 1.0; // Increased separation
                    group.add(sphereMesh);
                    group.add(holeMesh);
                    break;
                }
                case 'uncountable_noun': {
                    // Esfera
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    group.add(createMesh(sphere));
                    break;
                }
                case 'collective_noun': {
                    // Esfera con un cubo dentro
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const cube = new THREE.BoxGeometry(baseSize * 0.5, baseSize * 0.5, baseSize * 0.5, 1, 1, 1);
                    group.add(createMesh(sphere));
                    group.add(createMesh(cube));
                    break;
                }
                case 'compound_noun': {
                    // Esfera atravesada por un cuadrado
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const square = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 1.2, 1, 1, 1);
                    group.add(createMesh(sphere));
                    const squareMesh = createMesh(square);
                    squareMesh.rotation.z = Math.PI / 4;
                    group.add(squareMesh);
                    break;
                }
                case 'possessive_noun': {
                    // Esfera con una base rectangular plana en su parte inferior
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const rect = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 0.8, 1, 1, 1);
                    group.add(createMesh(sphere));
                    const rectMesh = createMesh(rect);
                    rectMesh.position.y = -baseSize * 1.0; // Increased separation
                    group.add(rectMesh);
                    break;
                }
                case 'gerundial_noun': {
                    // RectÃ¡ngulo semi transparente con una esfera dentro
                    const rect = new THREE.BoxGeometry(baseSize * 1.2, baseSize, baseSize * 0.8, 1, 1, 1);
                    const sphere = new THREE.SphereGeometry(baseSize * 0.6, 6, 6);
                    group.add(createMesh(rect, getSemiTransparentOpacity()));
                    group.add(createMesh(sphere));
                    break;
                }
                
                // PRONOUNS
                case 'subject_pronoun': {
                    // Dos superficies cuadradas a 3 pÃ­xeles de distancia con una esfera en medio
                    const square1 = new THREE.BoxGeometry(baseSize * 0.8, pixelSize * 0.1, baseSize * 0.8, 1, 1, 1);
                    const square2 = new THREE.BoxGeometry(baseSize * 0.8, pixelSize * 0.1, baseSize * 0.8, 1, 1, 1);
                    const sphere = new THREE.SphereGeometry(baseSize * 0.4, 6, 6);
                    const sq1Mesh = createMesh(square1);
                    sq1Mesh.position.y = baseSize * 0.5; // Increased separation
                    const sq2Mesh = createMesh(square2);
                    sq2Mesh.position.y = -baseSize * 0.5; // Increased separation
                    group.add(sq1Mesh);
                    group.add(sq2Mesh);
                    group.add(createMesh(sphere));
                    break;
                }
                case 'object_pronoun': {
                    // Esfera semi transparente con una esfera dentro
                    const outerSphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const innerSphere = new THREE.SphereGeometry(baseSize * 0.6, 6, 6);
                    group.add(createMesh(outerSphere, getSemiTransparentOpacity()));
                    group.add(createMesh(innerSphere));
                    break;
                }
                case 'possessive_pronoun': {
                    // Esfera atravesada por una superficie cuadrada vertical del mismo diÃ¡metro
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const square = new THREE.BoxGeometry(baseSize, baseSize, pixelSize * 0.1, 1, 1, 1);
                    group.add(createMesh(sphere));
                    const squareMesh = createMesh(square);
                    squareMesh.rotation.y = Math.PI / 4;
                    group.add(squareMesh);
                    break;
                }
                case 'reflexive_pronoun': {
                    // Dos superficies cuadradas a 2 pÃ­xeles de distancia entre ellas
                    const square1 = new THREE.BoxGeometry(baseSize * 0.8, pixelSize * 0.1, baseSize * 0.8, 1, 1, 1);
                    const square2 = new THREE.BoxGeometry(baseSize * 0.8, pixelSize * 0.1, baseSize * 0.8, 1, 1, 1);
                    const sq1Mesh = createMesh(square1);
                    sq1Mesh.position.y = baseSize * 0.4; // Increased separation
                    const sq2Mesh = createMesh(square2);
                    sq2Mesh.position.y = -baseSize * 0.4; // Increased separation
                    group.add(sq1Mesh);
                    group.add(sq2Mesh);
                    break;
                }
                case 'intensive_pronoun': {
                    // Esfera semi transparente con una esfera ovalada dentro
                    const outerSphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const innerSphere = new THREE.SphereGeometry(baseSize * 0.6, 6, 6);
                    const outerMesh = createMesh(outerSphere, getSemiTransparentOpacity());
                    const innerMesh = createMesh(innerSphere);
                    innerMesh.scale.y = 1.3;
                    group.add(outerMesh);
                    group.add(innerMesh);
                    break;
                }
                case 'demonstrative_pronoun': {
                    // Cubo rectangular abierto con una esfera sobre la parte abierta
                    const cube = new THREE.BoxGeometry(baseSize * 1.2, baseSize * 0.8, baseSize * 0.8, 1, 1, 1);
                    const sphere = new THREE.SphereGeometry(baseSize * 0.4, 6, 6);
                    group.add(createMesh(cube));
                    const sphereMesh = createMesh(sphere);
                    sphereMesh.position.y = baseSize * 0.9; // Increased separation
                    group.add(sphereMesh);
                    break;
                }
                case 'relative_pronoun': {
                    // Esfera con una lÃ­nea atravesada verticalmente
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const line = new THREE.BoxGeometry(pixelSize * 0.1, baseSize * 1.2, pixelSize * 0.1, 1, 1, 1);
                    group.add(createMesh(sphere));
                    group.add(createMesh(line));
                    break;
                }
                case 'interrogative_pronoun': {
                    // Esfera semi transparente con dos espacios abiertos arriba y abajo
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const hole1 = new THREE.SphereGeometry(baseSize * 0.2, 4, 4);
                    const hole2 = new THREE.SphereGeometry(baseSize * 0.2, 4, 4);
                    group.add(createMesh(sphere, getSemiTransparentOpacity()));
                    const h1Mesh = createMesh(hole1);
                    h1Mesh.position.y = baseSize * 1.0; // Increased separation
                    const h2Mesh = createMesh(hole2);
                    h2Mesh.position.y = -baseSize * 1.0; // Increased separation
                    group.add(h1Mesh);
                    group.add(h2Mesh);
                    break;
                }
                case 'indefinite_pronoun': {
                    // Dos semi esferas una encima de la otra
                    // Use two hemispheres (half spheres)
                    const sphere1 = new THREE.SphereGeometry(baseSize, 8, 4);
                    const sphere2 = new THREE.SphereGeometry(baseSize, 8, 4);
                    const s1Mesh = createMesh(sphere1);
                    s1Mesh.position.y = baseSize * 0.5; // Increased separation
                    const s2Mesh = createMesh(sphere2);
                    s2Mesh.position.y = -baseSize * 0.5; // Increased separation
                    s2Mesh.rotation.x = Math.PI;
                    group.add(s1Mesh);
                    group.add(s2Mesh);
                    break;
                }
                case 'reciprocal_pronoun': {
                    // Cubo hexagonal (approximate with octahedron)
                    const octahedron = new THREE.OctahedronGeometry(baseSize, 0);
                    group.add(createMesh(octahedron));
                    break;
                }
                
                // DETERMINERS
                case 'definite_article': {
                    // Cubo rectangular
                    const cube = new THREE.BoxGeometry(baseSize * 1.2, baseSize * 0.8, baseSize * 0.8, 1, 1, 1);
                    group.add(createMesh(cube));
                    break;
                }
                case 'indefinite_article': {
                    // Cubo rectangular con una superficie cuadrada en su base a 2 pÃ­xeles de distancia
                    const cube = new THREE.BoxGeometry(baseSize * 1.2, baseSize * 0.8, baseSize * 0.8, 1, 1, 1);
                    const square = new THREE.BoxGeometry(baseSize * 0.8, pixelSize * 0.1, baseSize * 0.8, 1, 1, 1);
                    group.add(createMesh(cube));
                    const squareMesh = createMesh(square);
                    squareMesh.position.y = -baseSize * 0.8; // Increased separation
                    group.add(squareMesh);
                    break;
                }
                case 'quantifier': {
                    // HexÃ¡gono abierto por la mitad (use octahedron)
                    const octahedron = new THREE.OctahedronGeometry(baseSize, 0);
                    group.add(createMesh(octahedron));
                    break;
                }
                case 'demonstrative_determiner': {
                    // Cubo rectangular con una superficie rectangular en su base a 2 pÃ­xeles de distancia
                    const cube = new THREE.BoxGeometry(baseSize * 1.2, baseSize * 0.8, baseSize * 0.8, 1, 1, 1);
                    const rect = new THREE.BoxGeometry(baseSize * 1.0, pixelSize * 0.1, baseSize * 0.6, 1, 1, 1);
                    group.add(createMesh(cube));
                    const rectMesh = createMesh(rect);
                    rectMesh.position.y = -baseSize * 0.8; // Increased separation
                    group.add(rectMesh);
                    break;
                }
                case 'possessive_determiner': {
                    // Cubo rectangular con una superficie cuadrada atravesada verticalmente
                    const cube = new THREE.BoxGeometry(baseSize * 1.2, baseSize * 0.8, baseSize * 0.8, 1, 1, 1);
                    const square = new THREE.BoxGeometry(baseSize * 0.8, baseSize * 0.8, pixelSize * 0.1, 1, 1, 1);
                    group.add(createMesh(cube));
                    const squareMesh = createMesh(square);
                    squareMesh.rotation.y = Math.PI / 4;
                    group.add(squareMesh);
                    break;
                }
                case 'distributive_determiner': {
                    // Cubo con agujeros en cada uno de sus lados
                    const cube = new THREE.BoxGeometry(baseSize, baseSize, baseSize, 1, 1, 1);
                    group.add(createMesh(cube));
                    // Add small holes (represented as small spheres) on each side
                    const holeSize = baseSize * 0.15;
                    const positions = [
                        [baseSize * 0.6, 0, 0], [-baseSize * 0.6, 0, 0],
                        [0, baseSize * 0.6, 0], [0, -baseSize * 0.6, 0],
                        [0, 0, baseSize * 0.6], [0, 0, -baseSize * 0.6]
                    ];
                    positions.forEach(pos => {
                        const hole = new THREE.SphereGeometry(holeSize, 4, 4);
                        const holeMesh = createMesh(hole);
                        holeMesh.position.set(pos[0], pos[1], pos[2]);
                        group.add(holeMesh);
                    });
                    break;
                }
                case 'interrogative_determiner': {
                    // Cubo semi transparente con una esfera dentro y un hueco en uno de sus lados
                    const cube = new THREE.BoxGeometry(baseSize, baseSize, baseSize, 1, 1, 1);
                    const sphere = new THREE.SphereGeometry(baseSize * 0.5, 6, 6);
                    const hole = new THREE.SphereGeometry(baseSize * 0.2, 4, 4);
                    group.add(createMesh(cube, getSemiTransparentOpacity()));
                    group.add(createMesh(sphere));
                    const holeMesh = createMesh(hole);
                    holeMesh.position.x = baseSize * 0.9; // Increased separation
                    group.add(holeMesh);
                    break;
                }
                case 'predeterminer': {
                    // Base cuadrada
                    const square = new THREE.BoxGeometry(baseSize, pixelSize * 0.1, baseSize, 1, 1, 1);
                    group.add(createMesh(square));
                    break;
                }
                
                // VERBS
                case 'lexical_verb': {
                    // Cubo con una base cuadrada arriba y abajo
                    const cube = new THREE.BoxGeometry(baseSize, baseSize, baseSize, 1, 1, 1);
                    const square1 = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 1.2, 1, 1, 1);
                    const square2 = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 1.2, 1, 1, 1);
                    group.add(createMesh(cube));
                    const sq1Mesh = createMesh(square1);
                    sq1Mesh.position.y = baseSize * 0.6;
                    const sq2Mesh = createMesh(square2);
                    sq2Mesh.position.y = -baseSize * 0.6;
                    group.add(sq1Mesh);
                    group.add(sq2Mesh);
                    break;
                }
                case 'auxiliary_verb': {
                    // Ã“valo con una lÃ­nea atravesada
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const sphereMesh = createMesh(sphere);
                    sphereMesh.scale.set(1.3, 1, 1); // Make it oval
                    const line = new THREE.BoxGeometry(baseSize * 1.5, pixelSize * 0.1, pixelSize * 0.1, 1, 1, 1);
                    group.add(sphereMesh);
                    const lineMesh = createMesh(line);
                    lineMesh.rotation.z = Math.PI / 4;
                    group.add(lineMesh);
                    break;
                }
                case 'semi_modal_verb': {
                    // Esfera atravesada por un cubo con una base de superficie cuadrada separada a dos pÃ­xeles
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const cube = new THREE.BoxGeometry(baseSize * 0.6, baseSize * 0.6, baseSize * 0.6, 1, 1, 1);
                    const square = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 1.2, 1, 1, 1);
                    group.add(createMesh(sphere));
                    const cubeMesh = createMesh(cube);
                    cubeMesh.rotation.y = Math.PI / 4;
                    group.add(cubeMesh);
                    const squareMesh = createMesh(square);
                    squareMesh.position.y = -baseSize * 2.5; // Reduced from 3.0 - surfaces that are too far should be closer
                    group.add(squareMesh);
                    break;
                }
                case 'phrasal_verb': {
                    // LÃ­nea que fuga desde un cubo rectangular
                    const cube = new THREE.BoxGeometry(baseSize * 1.2, baseSize * 0.8, baseSize * 0.8, 1, 1, 1);
                    const line = new THREE.BoxGeometry(baseSize * 1.5, pixelSize * 0.1, pixelSize * 0.1, 1, 1, 1);
                    group.add(createMesh(cube));
                    const lineMesh = createMesh(line);
                    lineMesh.position.x = baseSize * 1.2; // Increased separation
                    lineMesh.rotation.z = Math.PI / 6;
                    group.add(lineMesh);
                    break;
                }
                case 'transitive_verb': {
                    // Dos cubos unidos por una lÃ­nea
                    const cube1 = new THREE.BoxGeometry(baseSize * 0.6, baseSize * 0.6, baseSize * 0.6, 1, 1, 1);
                    const cube2 = new THREE.BoxGeometry(baseSize * 0.6, baseSize * 0.6, baseSize * 0.6, 1, 1, 1);
                    const line = new THREE.BoxGeometry(baseSize * 0.8, pixelSize * 0.1, pixelSize * 0.1, 1, 1, 1);
                    group.add(createMesh(cube1));
                    const cube2Mesh = createMesh(cube2);
                    cube2Mesh.position.x = baseSize * 1.2; // Increased separation
                    group.add(cube2Mesh);
                    const lineMesh = createMesh(line);
                    lineMesh.position.x = baseSize * 0.7; // Increased separation
                    group.add(lineMesh);
                    break;
                }
                case 'ditransitive_verb': {
                    // Cubo con una parte triangular
                    const cube = new THREE.BoxGeometry(baseSize, baseSize, baseSize, 1, 1, 1);
                    const tetrahedron = new THREE.TetrahedronGeometry(baseSize * 0.5, 0);
                    group.add(createMesh(cube));
                    const tetMesh = createMesh(tetrahedron);
                    tetMesh.position.y = baseSize * 0.7; // Increased separation
                    group.add(tetMesh);
                    break;
                }
                case 'base_form_verb': {
                    // Esfera con una base circular
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const cylinder = new THREE.CylinderGeometry(baseSize * 0.8, baseSize * 0.8, pixelSize * 0.1, 8);
                    group.add(createMesh(sphere));
                    const cylMesh = createMesh(cylinder);
                    cylMesh.position.y = -baseSize * 1.0; // Increased separation
                    group.add(cylMesh);
                    break;
                }
                case 'infinitive': {
                    // Esfera con dos bases circulares a dos pÃ­xeles cada una
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const cylinder1 = new THREE.CylinderGeometry(baseSize * 0.8, baseSize * 0.8, pixelSize * 0.1, 8);
                    const cylinder2 = new THREE.CylinderGeometry(baseSize * 0.8, baseSize * 0.8, pixelSize * 0.1, 8);
                    group.add(createMesh(sphere));
                    const cyl1Mesh = createMesh(cylinder1);
                    cyl1Mesh.position.y = baseSize * 2.5; // Reduced from 3.0 - surfaces that are too far should be closer
                    const cyl2Mesh = createMesh(cylinder2);
                    cyl2Mesh.position.y = -baseSize * 2.5; // Reduced from 3.0 - surfaces that are too far should be closer
                    group.add(cyl1Mesh);
                    group.add(cyl2Mesh);
                    break;
                }
                case 'present_participle': {
                    // Esfera con una base rectangular
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const rect = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 0.8, 1, 1, 1);
                    group.add(createMesh(sphere));
                    const rectMesh = createMesh(rect);
                    rectMesh.position.y = -baseSize * 1.0; // Increased separation
                    group.add(rectMesh);
                    break;
                }
                case 'past_participle': {
                    // Esfera con una superficie cuadrada y otra circular, una de ellas arriba y la otra abajo
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const square = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 1.2, 1, 1, 1);
                    const cylinder = new THREE.CylinderGeometry(baseSize * 0.8, baseSize * 0.8, pixelSize * 0.1, 8);
                    group.add(createMesh(sphere));
                    const squareMesh = createMesh(square);
                    squareMesh.position.y = baseSize * 0.9; // Increased separation
                    const cylMesh = createMesh(cylinder);
                    cylMesh.position.y = -baseSize * 1.0; // Increased separation
                    group.add(squareMesh);
                    group.add(cylMesh);
                    break;
                }
                case 'gerund': {
                    // Esfera atravesada por un cÃ­rculo
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const cylinder = new THREE.CylinderGeometry(baseSize * 0.8, baseSize * 0.8, pixelSize * 0.1, 8);
                    group.add(createMesh(sphere));
                    const cylMesh = createMesh(cylinder);
                    cylMesh.rotation.x = Math.PI / 2;
                    group.add(cylMesh);
                    break;
                }
                case 'modal_verb': {
                    // Tres esferas, cada una mÃ¡s transparente, unas dentro de otras
                    const sphere1 = new THREE.SphereGeometry(baseSize, 8, 8);
                    const sphere2 = new THREE.SphereGeometry(baseSize * 0.7, 6, 6);
                    const sphere3 = new THREE.SphereGeometry(baseSize * 0.4, 4, 4);
                    // Create meshes with different opacities
                    group.add(createMesh(sphere1, 0.9));
                    group.add(createMesh(sphere2, 0.7));
                    group.add(createMesh(sphere3, 0.5));
                    break;
                }
                case 'linking_verb': {
                    // LÃ­nea
                    const line = new THREE.BoxGeometry(baseSize * 1.5, pixelSize * 0.1, pixelSize * 0.1, 1, 1, 1);
                    group.add(createMesh(line));
                    break;
                }
                case 'intransitive_verb': {
                    // TriÃ¡ngulo (use tetrahedron)
                    const tetrahedron = new THREE.TetrahedronGeometry(baseSize, 0);
                    group.add(createMesh(tetrahedron));
                    break;
                }
                case 'stative_verb': {
                    // Rombo (use octahedron)
                    const octahedron = new THREE.OctahedronGeometry(baseSize, 0);
                    group.add(createMesh(octahedron));
                    break;
                }
                case 'dynamic_verb': {
                    // Rombo con el doble de vÃ©rtices (use icosahedron)
                    const icosahedron = new THREE.IcosahedronGeometry(baseSize, 0);
                    group.add(createMesh(icosahedron));
                    break;
                }
                
                // ADJECTIVES
                case 'descriptive_adjective': {
                    // Un triÃ¡ngulo abierto (use tetrahedron)
                    const tetrahedron = new THREE.TetrahedronGeometry(baseSize, 0);
                    group.add(createMesh(tetrahedron));
                    break;
                }
                case 'attributive_adjective': {
                    // Un tetraedro
                    const tetrahedron = new THREE.TetrahedronGeometry(baseSize, 0);
                    group.add(createMesh(tetrahedron));
                    break;
                }
                case 'predicative_adjective': {
                    // Un rombo con una esfera atravesada
                    const octahedron = new THREE.OctahedronGeometry(baseSize, 0);
                    const sphere = new THREE.SphereGeometry(baseSize * 0.5, 6, 6);
                    group.add(createMesh(octahedron));
                    const sphereMesh = createMesh(sphere);
                    group.add(sphereMesh);
                    break;
                }
                case 'comparative_adjective': {
                    // Un hexÃ¡gono con una base rectangular
                    const octahedron = new THREE.OctahedronGeometry(baseSize, 0);
                    const rect = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 0.8, 1, 1, 1);
                    group.add(createMesh(octahedron));
                    const rectMesh = createMesh(rect);
                    rectMesh.position.y = -baseSize * 1.0; // Increased separation
                    group.add(rectMesh);
                    break;
                }
                case 'superlative_adjective': {
                    // Un hexÃ¡gono semi transparente con otro hexÃ¡gono dentro
                    const outerOcta = new THREE.OctahedronGeometry(baseSize, 0);
                    const innerOcta = new THREE.OctahedronGeometry(baseSize * 0.6, 0);
                    group.add(createMesh(outerOcta, getSemiTransparentOpacity()));
                    group.add(createMesh(innerOcta));
                    break;
                }
                case 'coordinate_adjective': {
                    // Dos hexÃ¡gonos uno al lado del otro
                    const octa1 = new THREE.OctahedronGeometry(baseSize * 0.7, 0);
                    const octa2 = new THREE.OctahedronGeometry(baseSize * 0.7, 0);
                    group.add(createMesh(octa1));
                    const octa2Mesh = createMesh(octa2);
                    octa2Mesh.position.x = baseSize * 1.2; // Increased separation
                    group.add(octa2Mesh);
                    break;
                }
                case 'compound_adjective': {
                    // Un hexÃ¡gono al lado de una esfera
                    const octa = new THREE.OctahedronGeometry(baseSize * 0.7, 0);
                    const sphere = new THREE.SphereGeometry(baseSize * 0.6, 6, 6);
                    group.add(createMesh(octa));
                    const sphereMesh = createMesh(sphere);
                    sphereMesh.position.x = baseSize * 1.2; // Increased separation
                    group.add(sphereMesh);
                    break;
                }
                case 'participial_adjective': {
                    // Un hexÃ¡gono con dos esferas a cada lado
                    const octa = new THREE.OctahedronGeometry(baseSize, 0);
                    const sphere1 = new THREE.SphereGeometry(baseSize * 0.4, 4, 4);
                    const sphere2 = new THREE.SphereGeometry(baseSize * 0.4, 4, 4);
                    const sphere3 = new THREE.SphereGeometry(baseSize * 0.4, 4, 4);
                    const sphere4 = new THREE.SphereGeometry(baseSize * 0.4, 4, 4);
                    group.add(createMesh(octa));
                    const s1Mesh = createMesh(sphere1);
                    s1Mesh.position.x = baseSize * 1.2; // Increased separation
                    const s2Mesh = createMesh(sphere2);
                    s2Mesh.position.x = -baseSize * 1.2; // Increased separation
                    const s3Mesh = createMesh(sphere3);
                    s3Mesh.position.z = baseSize * 1.2; // Increased separation
                    const s4Mesh = createMesh(sphere4);
                    s4Mesh.position.z = -baseSize * 1.2; // Increased separation
                    group.add(s1Mesh);
                    group.add(s2Mesh);
                    group.add(s3Mesh);
                    group.add(s4Mesh);
                    break;
                }
                
                // ADVERBS
                case 'adverb': {
                    // Un rectÃ¡ngulo con dos lÃ­neas atravesadas
                    const rect = new THREE.BoxGeometry(baseSize * 1.2, baseSize * 0.8, baseSize * 0.6, 1, 1, 1);
                    const line1 = new THREE.BoxGeometry(baseSize * 1.5, pixelSize * 0.1, pixelSize * 0.1, 1, 1, 1);
                    const line2 = new THREE.BoxGeometry(baseSize * 1.5, pixelSize * 0.1, pixelSize * 0.1, 1, 1, 1);
                    group.add(createMesh(rect));
                    const l1Mesh = createMesh(line1);
                    l1Mesh.rotation.z = Math.PI / 4;
                    const l2Mesh = createMesh(line2);
                    l2Mesh.rotation.z = -Math.PI / 4;
                    group.add(l1Mesh);
                    group.add(l2Mesh);
                    break;
                }
                
                // PREPOSITIONS
                case 'simple_preposition': {
                    // Una base cuadrada con un triÃ¡ngulo arriba
                    const square = new THREE.BoxGeometry(baseSize, pixelSize * 0.1, baseSize, 1, 1, 1);
                    const tetrahedron = new THREE.TetrahedronGeometry(baseSize * 0.6, 0);
                    group.add(createMesh(square));
                    const tetMesh = createMesh(tetrahedron);
                    tetMesh.position.y = baseSize * 0.7; // Increased separation
                    group.add(tetMesh);
                    break;
                }
                case 'compound_preposition': {
                    // Una base circular (use cylinder)
                    const cylinder = new THREE.CylinderGeometry(baseSize, baseSize, pixelSize * 0.1, 8);
                    group.add(createMesh(cylinder));
                    break;
                }
                case 'prepositional_particle': {
                    // Una base circular y otra base circular
                    const cylinder1 = new THREE.CylinderGeometry(baseSize, baseSize, pixelSize * 0.1, 8);
                    const cylinder2 = new THREE.CylinderGeometry(baseSize, baseSize, pixelSize * 0.1, 8);
                    group.add(createMesh(cylinder1));
                    const cyl2Mesh = createMesh(cylinder2);
                    cyl2Mesh.position.y = -baseSize * 0.4; // Increased separation
                    group.add(cyl2Mesh);
                    break;
                }
                
                // CONJUNCTIONS
                case 'coordinating_conjunction': {
                    // Una lÃ­nea unida a un cubo
                    const line = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, pixelSize * 0.1, 1, 1, 1);
                    const cube = new THREE.BoxGeometry(baseSize * 0.6, baseSize * 0.6, baseSize * 0.6, 1, 1, 1);
                    group.add(createMesh(line));
                    const cubeMesh = createMesh(cube);
                    cubeMesh.position.x = baseSize * 1.0; // Increased separation
                    group.add(cubeMesh);
                    break;
                }
                case 'subordinating_conjunction': {
                    // Una lÃ­nea unida a un cubo por su parte de arriba
                    const line = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, pixelSize * 0.1, 1, 1, 1);
                    const cube = new THREE.BoxGeometry(baseSize * 0.6, baseSize * 0.6, baseSize * 0.6, 1, 1, 1);
                    group.add(createMesh(line));
                    const cubeMesh = createMesh(cube);
                    cubeMesh.position.x = baseSize * 1.0; // Increased separation
                    cubeMesh.position.y = baseSize * 0.5; // Increased separation
                    group.add(cubeMesh);
                    break;
                }
                case 'correlative_conjunction': {
                    // Tres cubos unidos por tres lÃ­neas
                    const cube1 = new THREE.BoxGeometry(baseSize * 0.4, baseSize * 0.4, baseSize * 0.4, 1, 1, 1);
                    const cube2 = new THREE.BoxGeometry(baseSize * 0.4, baseSize * 0.4, baseSize * 0.4, 1, 1, 1);
                    const cube3 = new THREE.BoxGeometry(baseSize * 0.4, baseSize * 0.4, baseSize * 0.4, 1, 1, 1);
                    const line1 = new THREE.BoxGeometry(baseSize * 0.6, pixelSize * 0.1, pixelSize * 0.1, 1, 1, 1);
                    const line2 = new THREE.BoxGeometry(baseSize * 0.6, pixelSize * 0.1, pixelSize * 0.1, 1, 1, 1);
                    const line3 = new THREE.BoxGeometry(baseSize * 0.6, pixelSize * 0.1, pixelSize * 0.1, 1, 1, 1);
                    group.add(createMesh(cube1));
                    const c2Mesh = createMesh(cube2);
                    c2Mesh.position.x = baseSize * 0.8; // Increased separation
                    const c3Mesh = createMesh(cube3);
                    c3Mesh.position.x = -baseSize * 0.8; // Increased separation
                    group.add(c2Mesh);
                    group.add(c3Mesh);
                    const l1Mesh = createMesh(line1);
                    l1Mesh.position.x = baseSize * 0.4; // Increased separation
                    l1Mesh.rotation.z = Math.PI / 6;
                    const l2Mesh = createMesh(line2);
                    l2Mesh.position.x = -baseSize * 0.4; // Increased separation
                    l2Mesh.rotation.z = -Math.PI / 6;
                    const l3Mesh = createMesh(line3);
                    l3Mesh.position.y = baseSize * 0.5; // Increased separation
                    group.add(l1Mesh);
                    group.add(l2Mesh);
                    group.add(l3Mesh);
                    break;
                }
                
                // NUMERALS
                case 'cardinal_numeral': {
                    // Un cubo con una base cuadrada
                    const cube = new THREE.BoxGeometry(baseSize, baseSize, baseSize, 1, 1, 1);
                    const square = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 1.2, 1, 1, 1);
                    group.add(createMesh(cube));
                    const squareMesh = createMesh(square);
                    squareMesh.position.y = -baseSize * 1.0; // Increased separation
                    group.add(squareMesh);
                    break;
                }
                case 'ordinal_numeral': {
                    // Una esfera con dos bases cuadradas
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const square1 = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 1.2, 1, 1, 1);
                    const square2 = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 1.2, 1, 1, 1);
                    group.add(createMesh(sphere));
                    const sq1Mesh = createMesh(square1);
                    sq1Mesh.position.y = baseSize * 0.6;
                    const sq2Mesh = createMesh(square2);
                    sq2Mesh.position.y = -baseSize * 0.6;
                    group.add(sq1Mesh);
                    group.add(sq2Mesh);
                    break;
                }
                case 'multiplicative_numeral': {
                    // Una esfera con tres bases cuadradas separadas
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const square1 = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 1.2, 1, 1, 1);
                    const square2 = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 1.2, 1, 1, 1);
                    const square3 = new THREE.BoxGeometry(baseSize * 1.2, pixelSize * 0.1, baseSize * 1.2, 1, 1, 1);
                    group.add(createMesh(sphere));
                    const sq1Mesh = createMesh(square1);
                    sq1Mesh.position.y = baseSize * 1.2; // Increased separation
                    const sq2Mesh = createMesh(square2);
                    sq2Mesh.position.y = 0;
                    const sq3Mesh = createMesh(square3);
                    sq3Mesh.position.y = -baseSize * 1.2; // Increased separation
                    group.add(sq1Mesh);
                    group.add(sq2Mesh);
                    group.add(sq3Mesh);
                    break;
                }
                case 'fractional_numeral': {
                    // Una esfera partida en dos
                    const sphere1 = new THREE.SphereGeometry(baseSize, 8, 4);
                    const sphere2 = new THREE.SphereGeometry(baseSize, 8, 4);
                    const s1Mesh = createMesh(sphere1);
                    s1Mesh.position.y = baseSize * 0.4; // Increased separation
                    const s2Mesh = createMesh(sphere2);
                    s2Mesh.position.y = -baseSize * 0.4; // Increased separation
                    s2Mesh.rotation.x = Math.PI;
                    group.add(s1Mesh);
                    group.add(s2Mesh);
                    break;
                }
                
                default: {
                    // Default: common noun
                    const sphere = new THREE.SphereGeometry(baseSize, 8, 8);
                    const square = new THREE.BoxGeometry(baseSize, pixelSize * 0.1, baseSize, 1, 1, 1);
                    group.add(createMesh(sphere));
                    const squareMesh = createMesh(square);
                    squareMesh.position.y = -baseSize * 2.5; // Reduced from 3.0 - surfaces that are too far should be closer
                    group.add(squareMesh);
                    break;
                }
            }
            
            // CRITICAL: Final pass to ensure ALL meshes have correct material with correct color
            // This is a safety net to catch any meshes that might have been missed
            // FORCE update all materials to ensure colors are applied correctly
            let meshCount = 0;
            group.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    meshCount++;
                    // Preserve any custom opacity that was set (e.g., for semi-transparent parts)
                    const currentOpacity = child.material && child.material.opacity !== undefined ? child.material.opacity : baseOpacity;
                    
                    // Get old color for debug
                    const oldColor = child.material && child.material.color ? 
                                   (typeof child.material.color === 'number' ? child.material.color : child.material.color.getHex()) : 
                                   0xffffff;
                    
                    // ALWAYS create a COMPLETELY NEW material instance - never reuse
                    // This ensures NO material sharing between ANY nodes
                    const newMaterial = new THREE.MeshStandardMaterial({
                        color: colorHex, // Use hex number directly - NO references
                        transparent: true,
                        opacity: currentOpacity,
                        metalness: 0.1,
                        roughness: 0.7
                    });
                    
                    // CRITICAL: Always replace the material - don't check if it's correct
                    // This ensures every mesh gets a fresh material with the correct color
                    if (child.material) {
                        child.material.dispose(); // Dispose old material to free memory
                    }
                    child.material = newMaterial;
                    child.material.needsUpdate = true;
                    
                    // Verify color was set correctly
                    const finalColor = typeof newMaterial.color === 'number' ? newMaterial.color : newMaterial.color.getHex();
                    if (meshCount <= 2 && (oldColor === 0xffffff || oldColor !== colorHex)) {
                        console.log(`Fixed mesh ${meshCount} in ${wordType}: oldColor=0x${oldColor.toString(16)}, newColor=0x${finalColor.toString(16)}, expected=0x${colorHex.toString(16)}`);
                    }
                }
            });
            
            return group;
        }

        // Cache for min/max values to avoid recalculating for each node
        let cachedValueRange = null;
        
        function create3DNode(wordData, index) {
            const baseSize = 0.06; // All nodes have same base size
            
            // Store connection count (will be updated after connections are created)
            wordData.connectionCount = 0;
            
            // Get color based on value relative to text
            const color = getValueBasedColor(wordData, index, analyzedWords);
            
            // Get word type for shape
            const wordType = getWordTypeForShape(wordData, index);
            
            // Debug: log word type classification
            if (index < 5) { // Only log first 5 to avoid spam
                console.log(`Word "${wordData.text}": pos=${wordData.pos}, upos=${wordData.upos}, uposType=${wordData.uposType}, wordType=${wordType}`);
            }
            
            // Determine opacity based on word type
            // Default: 8% transparent (opacity: 0.92) for most nodes (20% less transparent)
            let nodeOpacity = 0.92; // 8% transparent (92% opaque) - 20% less transparent
            // Semi-transparent types (from specifications): should be more transparent
            // These types have parts that are semi-transparent according to the specifications
            const semiTransparentTypes = ['proper_noun', 'object_pronoun', 'intensive_pronoun', 
                                         'interrogative_pronoun', 'superlative_adjective', 'modal_verb',
                                         'concrete_noun', 'gerundial_noun', 'interrogative_determiner'];
            if (semiTransparentTypes.includes(wordType)) {
                nodeOpacity = 0.80; // 20% transparent for semi-transparent types (20% less transparent)
            }
            
            // CRITICAL: Convert color to hex number to avoid any reference sharing
            const colorHex = typeof color === 'number' ? color : (color && color.getHex ? color.getHex() : 0xffffff);
            
            // Debug: verify color is set correctly
            if (index < 5) {
                console.log(`Node ${index} "${wordData.text}": colorHex=0x${colorHex.toString(16)}, wordType=${wordType}, opacity=${nodeOpacity}`);
            }
            
            // Create geometry based on word type - PASS COLOR AS NUMBER, NOT MATERIAL
            // This ensures NO material sharing between nodes
            const geometryGroup = createWordTypeGeometry(wordType, baseSize, colorHex, nodeOpacity);
            
            // Enable shadows for all meshes in the group
            geometryGroup.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            // Calculate sphere size based on word value
            // Get word value (finalValue or totalScore)
            const wordValue = wordData.finalValue || wordData.totalScore || 0;
            
            // Calculate min and max values from all analyzed words (cache for efficiency)
            if (cachedValueRange === null && analyzedWords && analyzedWords.length > 0) {
                const allValues = analyzedWords.map(w => w.finalValue || w.totalScore || 0).filter(v => v > 0);
                if (allValues.length > 0) {
                    cachedValueRange = {
                        min: Math.min(...allValues),
                        max: Math.max(...allValues)
                    };
                } else {
                    cachedValueRange = { min: 0, max: 0 };
                }
            }
            
            let sphereSizeMultiplier = 2.25; // Default to minimum (50% larger than 1.5x = 2.25x, increased overall)
            
            if (cachedValueRange && cachedValueRange.max > cachedValueRange.min && wordValue > 0) {
                // Normalize value between 0 and 1
                const normalizedValue = (wordValue - cachedValueRange.min) / (cachedValueRange.max - cachedValueRange.min);
                
                // Use progressive interpolation for scaling (increased sizes for more convergence zones):
                // - Value 0 (min): 2.25x (50% larger than 1.5x)
                // - Value 0.5 (medium): ~3.0x (50% larger than 2.0x)
                // - Value 1.0 (max): 10.5x (50% larger than 7.0x)
                // Using a combination of linear and exponential for smooth progression
                // For low-medium values: more linear, for high values: more exponential
                if (normalizedValue <= 0.5) {
                    // Linear interpolation for lower half: 2.25x to 3.0x
                    sphereSizeMultiplier = 2.25 + (normalizedValue * 0.75); // 0->2.25, 0.5->3.0
                } else {
                    // Exponential interpolation for upper half: 3.0x to 10.5x
                    const upperNormalized = (normalizedValue - 0.5) / 0.5; // 0 to 1 for upper half
                    const exponentialValue = Math.pow(upperNormalized, 1.5); // Power curve
                    sphereSizeMultiplier = 3.0 + (exponentialValue * 7.5); // 3.0 to 10.5
                }
                
                // Ensure it doesn't exceed 10.5x
                sphereSizeMultiplier = Math.min(sphereSizeMultiplier, 10.5);
            } else if (wordValue > 0 && cachedValueRange && cachedValueRange.max > 0) {
                // All values are the same, use medium size (around 3.0x, 50% larger than 2.0x)
                sphereSizeMultiplier = 3.0;
            }
            
            const sphereSize = baseSize * sphereSizeMultiplier;
            
            // Create gray semi-transparent sphere around the node
            const sphereGeometry = new THREE.SphereGeometry(sphereSize, 16, 16);
            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: 0x808080, // Gray color
                transparent: true,
                opacity: 0.21, // 30% mÃ¡s transparente (era 0.3, ahora 0.21)
                metalness: 0.1,
                roughness: 0.8,
                side: THREE.DoubleSide
            });
            const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphereMesh.castShadow = false; // Don't cast shadow from the sphere
            sphereMesh.receiveShadow = false; // Don't receive shadow on the sphere
            
            // Make sphere not detectable by raycaster (so it doesn't intercept hover/click events)
            // This allows access to nodes (including violet convergence nodes) inside the sphere
            sphereMesh.raycast = function() { return []; }; // Return empty array = not detectable
            
            // Add sphere to the group (it will be positioned at the same place as the node)
            geometryGroup.add(sphereMesh);
            
            // Position the group
            const pos = getClusterPosition(wordData, index);
            geometryGroup.position.set(pos.x, pos.y, pos.z);
            
            // Store user data
            geometryGroup.userData = {
                wordData: wordData,
                index: index,
                connectionCount: 0,
                isGroup: true,
                wordType: wordType,
                sphereSize: sphereSize, // Store sphere size for convergence detection
                sphereMesh: sphereMesh // Store reference to sphere mesh
            };
            
            scene.add(geometryGroup);
            nodes.push(geometryGroup);
            
            return geometryGroup;
        }
        
        // DISABLED: Update node shapes after connections are created
        // This function was overwriting the shapes based on word type
        // Now shapes are determined by word type from the start, so this is no longer needed
        function updateNodeShapes() {
            // DISABLED - Shapes are now determined by word type, not connections
            // Do nothing - keep the shapes that were created based on word type
            return;
        }

        // Identify semantic, morphological, and syntactic cores (key concepts) in the text
        function identifySemanticCores() {
            const cores = [];
            const coreWords = new Map(); // word -> core index
            
            // Calculate word importance scores (semantic + morphological + syntactic)
            const wordImportance = analyzedWords.map((wordData, index) => {
                let importance = 0;
                
                // Semantic importance
                importance += wordData.normalizedScore * 3;
                
                // Morphological importance (word structure, length, complexity)
                const wordLength = wordData.text.length;
                importance += Math.min(wordLength / 10, 1) * 0.5;
                
                // Syntactic importance (POS-based)
                const posWeights = {
                    'pronoun': 2.0,
                    'verb': 1.8,
                    'noun': 1.5,
                    'adjective': 1.2,
                    'adverb': 1.0,
                    'other': 0.5
                };
                importance += (posWeights[wordData.pos] || 0.5) * 0.5;
                
                // Frequency importance (repeated words are more important)
                importance += wordData.normalizedFrequency * 1.0;
                
                // Ontological assertion bonus
                if (isOntologicalAssertion(index, analyzedWords)) {
                    importance += 2.0;
                }
                
                return { index, importance, wordData };
            });
            
            // Sort by importance and select top words as cores
            wordImportance.sort((a, b) => b.importance - a.importance);
            
            // Determine number of cores based on text length and structure
            const totalWords = analyzedWords.length;
            let numCores;
            if (totalWords <= 10) {
                numCores = Math.min(3, totalWords);
            } else if (totalWords <= 50) {
                numCores = Math.min(5, Math.ceil(totalWords / 10));
            } else if (totalWords <= 200) {
                numCores = Math.min(8, Math.ceil(totalWords / 25));
            } else {
                numCores = Math.min(12, Math.ceil(totalWords / 50));
            }
            
            // Create cores from top important words
            const selectedCores = wordImportance.slice(0, numCores);
            
            selectedCores.forEach((item, coreIndex) => {
                const wordData = item.wordData;
                const index = item.index;
                const cleanWord = wordData.text.toLowerCase().replace(/[^\w]/g, '');
                
                // Determine core type
                let coreType = 'semantic';
                if (wordData.pos === 'pronoun' && (cleanWord === 'i' || cleanWord === 'we' || cleanWord === 'you' || 
                    cleanWord === 'yo' || cleanWord === 'nosotros' || cleanWord === 'tÃº')) {
                    coreType = 'ontological_subject';
                } else if (wordData.isSerEstar) {
                    coreType = 'existence';
                } else if (isName(wordData.text, index) && wordData.pos === 'noun') {
                    coreType = 'identity';
                } else if (wordData.pos === 'noun') {
                    coreType = 'morphological_noun';
                } else if (wordData.pos === 'verb') {
                    coreType = 'syntactic_verb';
                } else if (wordData.pos === 'adjective') {
                    coreType = 'descriptive';
                }
                
                cores.push({
                    index: coreIndex,
                    wordIndex: index,
                    wordData: wordData,
                    type: coreType,
                    relatedWords: [],
                    importance: item.importance
                });
                coreWords.set(index, coreIndex);
            });
            
            // 2. Group ALL words around cores based on multiple criteria
            analyzedWords.forEach((wordData, index) => {
                if (coreWords.has(index)) return; // Skip cores themselves
                
                let bestCore = null;
                let bestScore = 0;
                
                cores.forEach(core => {
                    let score = 0;
                    
                    // 1. Morphological similarity (same POS)
                    if (wordData.pos === core.wordData.pos) {
                        score += 2.5;
                    }
                    
                    // 2. Semantic proximity (text position)
                    const textDistance = Math.abs(index - core.wordIndex);
                    const maxDistance = Math.min(20, Math.ceil(totalWords / 5));
                    if (textDistance <= maxDistance) {
                        score += (maxDistance - textDistance) / maxDistance * 2.0;
                    }
                    
                    // 3. Syntactic relationships (check for grammatical patterns)
                    const window = 8;
                    if (textDistance <= window) {
                        const start = Math.max(0, Math.min(index, core.wordIndex) - 3);
                        const end = Math.min(analyzedWords.length, Math.max(index, core.wordIndex) + 3);
                        const windowWords = analyzedWords.slice(start, end);
                        
                        // Pattern: subject + verb + object
                        for (let i = 0; i < windowWords.length - 2; i++) {
                            const w1 = windowWords[i];
                            const w2 = windowWords[i + 1];
                            const w3 = windowWords[i + 2];
                            
                            // Core + "to be" + word OR word + "to be" + core
                            if ((w1 === core.wordData || w1 === wordData) && 
                                (w2.isSerEstar) &&
                                (w3 === core.wordData || w3 === wordData)) {
                                score += 6.0; // Very strong syntactic relationship
                            }
                            
                            // Noun + verb + noun pattern
                            if (w1.pos === 'noun' && w2.pos === 'verb' && w3.pos === 'noun' &&
                                (w1 === core.wordData || w3 === core.wordData) &&
                                (w1 === wordData || w3 === wordData)) {
                                score += 3.0;
                            }
                        }
                    }
                    
                    // 4. Semantic similarity (same word = same concept)
                    const coreWord = core.wordData.text.toLowerCase().replace(/[^\w]/g, '');
                    const word = wordData.text.toLowerCase().replace(/[^\w]/g, '');
                    if (coreWord === word) {
                        score += 5.0; // Same word = same concept
                    }
                    
                    // 5. Value similarity (high-value words cluster together)
                    const valueDiff = Math.abs(wordData.normalizedScore - core.wordData.normalizedScore);
                    if (valueDiff < 0.3) {
                        score += 1.5;
                    }
                    if (wordData.normalizedScore > 0.6 && core.wordData.normalizedScore > 0.6) {
                        score += 1.0;
                    }
                    
                    // 6. Frequency similarity (repeated words cluster together)
                    const freqDiff = Math.abs(wordData.normalizedFrequency - core.wordData.normalizedFrequency);
                    if (freqDiff < 0.2) {
                        score += 1.0;
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestCore = core;
                    }
                });
                
                // Assign to best core (lower threshold to ensure all words are assigned)
                if (bestCore && bestScore >= 0.5) {
                    bestCore.relatedWords.push(index);
                    coreWords.set(index, bestCore.index);
                } else if (cores.length > 0) {
                    // Fallback: assign to nearest core by text position
                    const nearestCore = cores.reduce((nearest, core) => {
                        const dist1 = Math.abs(index - nearest.wordIndex);
                        const dist2 = Math.abs(index - core.wordIndex);
                        return dist2 < dist1 ? core : nearest;
                    });
                    nearestCore.relatedWords.push(index);
                    coreWords.set(index, nearestCore.index);
                }
            });
            
            return { cores, coreWords };
        }
        
        function createConnections() {
            // Clear existing connections
            connections.forEach(conn => {
                if (conn.geometry) conn.geometry.dispose();
                if (conn.material) conn.material.dispose();
                scene.remove(conn);
            });
            connections = [];
            
            // Reset connection counts
            nodes.forEach(node => {
                if (node.userData) {
                    node.userData.connectionCount = 0;
                    if (node.userData.wordData) {
                        node.userData.wordData.connectionCount = 0;
                    }
                }
            });
            
            if (nodes.length < 2) {
                console.log('Not enough nodes to create connections');
                return;
            }
            
            // CRITICAL: Validate all nodes are properly initialized before creating connections
            // Also try to fix nodes with invalid positions
            const validNodes = nodes.filter(node => {
                if (!node) return false;
                if (!node.userData) return false;
                
                // Check if position is valid
                if (!node.position || 
                    !isFinite(node.position.x) || 
                    !isFinite(node.position.y) || 
                    !isFinite(node.position.z)) {
                    
                    // Try to fix the position
                    if (node.userData.index !== undefined) {
                        const index = node.userData.index;
                        const angle = (index / Math.max(nodes.length, 1)) * Math.PI * 2;
                        const radius = 5;
                        if (!node.position) {
                            node.position = new THREE.Vector3();
                        }
                        node.position.set(
                            Math.cos(angle) * radius,
                            Math.sin(angle) * radius * 0.5,
                            Math.sin(angle * 2) * radius * 0.3
                        );
                        console.log(`Fixed invalid position for node ${index}`);
                        return true; // Now it's valid
                    }
                    
                    console.warn('Node has invalid position and cannot be fixed:', node);
                    return false;
                }
                return true;
            });
            
            if (validNodes.length < 2) {
                console.error(`Only ${validNodes.length} valid nodes found (out of ${nodes.length} total), cannot create connections`);
                // Last resort: try to create connections with any nodes that exist
                if (nodes.length >= 2) {
                    console.warn('Attempting to create connections with all nodes regardless of position validity...');
                    // Force create connections even if positions might be invalid
                    for (let i = 0; i < nodes.length - 1; i++) {
                        const currentNode = nodes[i];
                        const nextNode = nodes[i + 1];
                        if (currentNode && currentNode.userData && nextNode && nextNode.userData) {
                            // Ensure positions exist
                            if (!currentNode.position) {
                                currentNode.position = new THREE.Vector3(i * 2, 0, 0);
                            }
                            if (!nextNode.position) {
                                nextNode.position = new THREE.Vector3((i + 1) * 2, 0, 0);
                            }
                            createConnection(currentNode, nextNode);
                        }
                    }
                    return;
                }
                return;
            }
            
            // Update nodes array to only include valid nodes (temporary for connection creation)
            const originalNodes = nodes;
            nodes = validNodes;
            
            const totalNodes = nodes.length;
            console.log(`Creating connections for ${totalNodes} valid nodes (${originalNodes.length} total nodes)`);
            
            // CRITICAL STEP 1: ALWAYS create adjacent connections FIRST (guaranteed)
            // This ensures every node has at least one connection before applying other strategies
            console.log(`Step 1: Creating guaranteed adjacent connections for ${totalNodes} nodes...`);
            let guaranteedConnections = 0;
            for (let i = 0; i < validNodes.length - 1; i++) {
                const currentNode = validNodes[i];
                const nextNode = validNodes[i + 1];
                
                if (!currentNode || !nextNode || !currentNode.userData || !nextNode.userData) {
                    continue;
                }
                
                // Check if connection already exists
                const connectionExists = connections.some(conn => 
                    conn && conn.userData && 
                    ((conn.userData.fromNode === currentNode && conn.userData.toNode === nextNode) ||
                     (conn.userData.fromNode === nextNode && conn.userData.toNode === currentNode))
                );
                
                if (!connectionExists) {
                    const result = createConnection(currentNode, nextNode);
                    if (result) {
                        guaranteedConnections++;
                    } else {
                        console.error(`CRITICAL: Failed to create guaranteed adjacent connection between nodes ${i} and ${i + 1}`);
                        // Try again with a delay
                        setTimeout(() => {
                            const retryResult = createConnection(currentNode, nextNode);
                            if (retryResult) {
                                console.log(`Successfully created retry connection between nodes ${i} and ${i + 1}`);
                            }
                        }, 10);
                    }
                }
            }
            console.log(`Step 1 complete: Created ${guaranteedConnections} guaranteed adjacent connections (total: ${connections.length})`);
            
            // STEP 2: Use different strategies based on text length for additional connections
            if (totalNodes <= 10) {
                // Short text: connect all adjacent words (already done, add more connections)
                createShortPhraseConnections();
            } else if (totalNodes <= 50) {
                // Medium text: connect adjacent and same POS
                createShortSentencesConnections();
            } else if (totalNodes <= 200) {
                // Long text: use paragraph-based connections
                createParagraphsConnections();
            } else {
                // Very long text: use narrative connections with limited range
                createNarrativeConnections();
            }
            
            console.log(`Step 2 complete: Created ${connections.length} total connections`);
            
            // CRITICAL: Ensure minimum connections are always created
            // For texts with more than 200 nodes, we need at least (totalNodes - 1) connections (adjacent chain)
            // For shorter texts, we need at least 50% of possible connections
            const minRequiredConnections = totalNodes > 200 
                ? Math.max(totalNodes - 1, Math.floor(totalNodes * 0.3)) // At least adjacent chain + 30% for long texts
                : Math.max(totalNodes - 1, Math.floor(totalNodes * 0.5)); // At least 50% for shorter texts
            
            if (connections.length === 0 || connections.length < minRequiredConnections) {
                console.warn(`Only ${connections.length} connections created (minimum required: ${minRequiredConnections}), creating fallback connections`);
                createFallbackConnections();
                console.log(`After fallback: ${connections.length} connections`);
                
                // If still not enough, force create adjacent connections
                if (connections.length < totalNodes - 1) {
                    console.warn(`Still insufficient connections (${connections.length}), forcing adjacent connections...`);
                    for (let i = 0; i < validNodes.length - 1; i++) {
                        const currentNode = validNodes[i];
                        const nextNode = validNodes[i + 1];
                        
                        if (!currentNode || !nextNode) continue;
                        
                        const connectionExists = connections.some(conn => 
                            conn.userData && 
                            ((conn.userData.fromNode === currentNode && conn.userData.toNode === nextNode) ||
                             (conn.userData.fromNode === nextNode && conn.userData.toNode === currentNode))
                        );
                        
                        if (!connectionExists) {
                            const result = createConnection(currentNode, nextNode);
                            if (!result) {
                                console.error(`CRITICAL: Failed to create forced adjacent connection between nodes ${i} and ${i + 1}`);
                            }
                        }
                    }
                    console.log(`After forcing adjacent connections: ${connections.length} connections`);
                }
            }
            
            // Restore original nodes array
            nodes = originalNodes;
            
            // CRITICAL: Verify ALL connections are in the scene and add any missing ones
            console.log(`Verifying ${connections.length} connections are in scene...`);
            let connectionsAddedToScene = 0;
            connections.forEach((conn, idx) => {
                if (!conn) {
                    console.warn(`Connection at index ${idx} is null or undefined`);
                    return;
                }
                
                if (!scene.children.includes(conn)) {
                    try {
                        scene.add(conn);
                        connectionsAddedToScene++;
                        console.log(`Added missing connection ${idx} to scene`);
                    } catch (error) {
                        console.error(`Error adding connection ${idx} to scene:`, error);
                        // Try to recreate the connection
                        if (conn.userData && conn.userData.fromNode && conn.userData.toNode) {
                            try {
                                const newConn = createConnection(conn.userData.fromNode, conn.userData.toNode);
                                if (newConn) {
                                    // Remove old connection from array
                                    connections[idx] = newConn;
                                    console.log(`Recreated connection ${idx}`);
                                }
                            } catch (recreateError) {
                                console.error(`Failed to recreate connection ${idx}:`, recreateError);
                            }
                        }
                    }
                }
            });
            
            if (connectionsAddedToScene > 0) {
                console.log(`Added ${connectionsAddedToScene} missing connections to scene`);
            }
            
            // Final verification: ensure we have at least some connections
            const finalConnectionCount = connections.filter(c => c !== null && c !== undefined).length;
            // Exclude reference sphere lines from the count
            const connectionsInScene = scene.children.filter(child => {
                if (!(child instanceof THREE.Line)) return false;
                // Exclude reference sphere lines (they are in referenceSphereLines array)
                return !referenceSphereLines.includes(child);
            }).length;
            
            console.log(`Final verification: ${finalConnectionCount} connections in array, ${connectionsInScene} lines in scene`);
            
            if (finalConnectionCount === 0) {
                console.error('CRITICAL: No connections were created! Attempting emergency fallback...');
                // Emergency fallback: create connections between ALL adjacent nodes
                for (let i = 0; i < validNodes.length - 1; i++) {
                    if (validNodes[i] && validNodes[i + 1]) {
                        const result = createConnection(validNodes[i], validNodes[i + 1]);
                        if (!result) {
                            console.error(`CRITICAL: Emergency fallback failed for nodes ${i} and ${i + 1}`);
                        }
                    }
                }
                console.log(`Emergency fallback created ${connections.length} connections`);
            }
            
            // CRITICAL: Force add any connections that are in array but not in scene
            if (finalConnectionCount > connectionsInScene) {
                console.warn(`Mismatch detected: ${finalConnectionCount} connections in array but only ${connectionsInScene} in scene. Forcing addition...`);
                connections.forEach((conn, idx) => {
                    if (conn && !scene.children.includes(conn)) {
                        try {
                            scene.add(conn);
                            console.log(`Force-added connection ${idx} to scene`);
                        } catch (e) {
                            console.error(`Failed to force-add connection ${idx}:`, e);
                            // Try recreating
                            if (conn.userData && conn.userData.fromNode && conn.userData.toNode) {
                                const newConn = createConnection(conn.userData.fromNode, conn.userData.toNode);
                                if (newConn) {
                                    connections[idx] = newConn;
                                }
                            }
                        }
                    }
                });
            }
            
            // Final count after all fixes
            const finalLinesInScene = scene.children.filter(child => child instanceof THREE.Line).length;
            console.log(`âœ“ Final state: ${connections.length} connections in array, ${finalLinesInScene} lines in scene`);
            
            if (finalLinesInScene === 0 && connections.length > 0) {
                console.error('CRITICAL ERROR: Connections exist in array but NO lines in scene!');
                console.error('This indicates a serious problem with scene.add() or line creation.');
            }
            
            // Final check: ensure every node has at least one connection
            const finalNodesWithoutConnections = [];
            validNodes.forEach((node, idx) => {
                if (!node || !node.userData) return;
                
                const hasConnection = connections.some(conn => 
                    conn && conn.userData && 
                    (conn.userData.fromNode === node || conn.userData.toNode === node)
                );
                
                if (!hasConnection) {
                    finalNodesWithoutConnections.push(idx);
                }
            });
            
            if (finalNodesWithoutConnections.length > 0) {
                console.error(`CRITICAL: ${finalNodesWithoutConnections.length} nodes still have no connections after all attempts!`);
                // Last resort: connect each node to its nearest neighbor
                finalNodesWithoutConnections.forEach(nodeIndex => {
                    const node = validNodes[nodeIndex];
                    if (!node) return;
                    
                    // Find nearest node by text position
                    let nearestNode = null;
                    let minDistance = Infinity;
                    
                    validNodes.forEach((otherNode, otherIdx) => {
                        if (otherIdx === nodeIndex || !otherNode || !otherNode.userData) return;
                        
                        const nodeIdx = node.userData.index !== undefined ? node.userData.index : nodeIndex;
                        const otherIdx2 = otherNode.userData.index !== undefined ? otherNode.userData.index : otherIdx;
                        const distance = Math.abs(nodeIdx - otherIdx2);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestNode = otherNode;
                        }
                    });
                    
                    if (nearestNode) {
                        const result = createConnection(node, nearestNode);
                        if (!result) {
                            console.error(`CRITICAL: Failed to create last-resort connection for node ${nodeIndex}`);
                        }
                    }
                });
            }
            
            // Final verification of connections in scene
            // Exclude reference sphere lines from the count
            const finalConnectionsInScene = scene.children.filter(child => {
                if (!(child instanceof THREE.Line)) return false;
                // Exclude reference sphere lines (they are in referenceSphereLines array)
                return !referenceSphereLines.includes(child);
            }).length;
            const finalConnectionsInArray = connections.filter(c => c !== null && c !== undefined).length;
            console.log(`Final verification: ${finalConnectionsInArray} connections in array, ${finalConnectionsInScene} connections in scene`);
            
            if (finalConnectionsInArray !== finalConnectionsInScene) {
                console.warn(`Mismatch detected: ${finalConnectionsInArray} in array vs ${finalConnectionsInScene} in scene. Re-syncing...`);
                // Remove all connection lines from scene (but keep reference sphere lines)
                scene.children.filter(child => {
                    if (!(child instanceof THREE.Line)) return false;
                    // Don't remove reference sphere lines
                    return !referenceSphereLines.includes(child);
                }).forEach(line => {
                    scene.remove(line);
                });
                
                // Re-add all valid connections
                connections.forEach(conn => {
                    if (conn && conn.userData) {
                        try {
                            scene.add(conn);
                        } catch (error) {
                            console.error('Error re-adding connection to scene:', error);
                        }
                    }
                });
                
                const afterSync = scene.children.filter(child => {
                    if (!(child instanceof THREE.Line)) return false;
                    // Exclude reference sphere lines
                    return !referenceSphereLines.includes(child);
                }).length;
                console.log(`After sync: ${afterSync} connections in scene`);
            }
            
            // Update node shapes based on connection count
            updateNodeShapes();
        }
        
        // Fallback function to ensure minimum connections are always created
        function createFallbackConnections() {
            if (nodes.length < 2) return;
            
            // Connect each node to at least its immediate neighbors
            for (let i = 0; i < nodes.length - 1; i++) {
                const currentNode = nodes[i];
                const nextNode = nodes[i + 1];
                
                if (!currentNode || !nextNode || !currentNode.userData || !nextNode.userData) {
                    continue;
                }
                
                // Check if connection already exists
                const connectionExists = connections.some(conn => 
                    conn.userData && 
                    ((conn.userData.fromNode === currentNode && conn.userData.toNode === nextNode) ||
                     (conn.userData.fromNode === nextNode && conn.userData.toNode === currentNode))
                );
                
                if (!connectionExists) {
                    const result = createConnection(currentNode, nextNode);
                    if (!result) {
                        console.warn(`Failed to create fallback connection between nodes ${i} and ${i + 1}`);
                    }
                }
            }
            
            // Also connect first and last node if there are only 2 nodes
            if (nodes.length === 2) {
                const connectionExists = connections.some(conn => 
                    conn.userData && 
                    ((conn.userData.fromNode === nodes[0] && conn.userData.toNode === nodes[1]) ||
                     (conn.userData.fromNode === nodes[1] && conn.userData.toNode === nodes[0]))
                );
                
                if (!connectionExists) {
                    createConnection(nodes[0], nodes[1]);
                }
            }
        }
        
        async function detectAndCreateConvergenceZones() {
            // Clear existing convergence zones and subtract their values from total
            let totalConvergenceValueToSubtract = 0;
            convergenceZones.forEach(zone => {
                if (zone.group) {
                    zone.group.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    scene.remove(zone.group);
                }
                // Subtract zone value from total
                if (zone.totalValue) {
                    totalConvergenceValueToSubtract += zone.totalValue;
                }
            });
            
            // Subtract convergence values from total before clearing
            if (window.totalTextScore !== undefined && totalConvergenceValueToSubtract > 0) {
                window.totalTextScore = Math.max(0, (window.totalTextScore || 0) - totalConvergenceValueToSubtract);
                if (window.convergenceTotalValue !== undefined) {
                    window.convergenceTotalValue = Math.max(0, (window.convergenceTotalValue || 0) - totalConvergenceValueToSubtract);
                }
                // Update display
                if (typeof convertToEthereum === 'function') {
                    convertToEthereum(window.totalTextScore);
                }
            }
            
            convergenceZones = [];
            
            // Remove convergence nodes from nodes array
            nodes = nodes.filter(n => !n.userData || !n.userData.isConvergenceNode);
            
            // Update button state initially (will be disabled if no zones)
            updateConvergenceZoneButton();
            
            if (nodes.length < 2) {
                console.log('Not enough nodes to detect convergences');
                return;
            }
            
            console.log('Detecting sphere convergences...');
            const convergencePairs = [];
            
            // Check all pairs of nodes for sphere convergence
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const node1 = nodes[i];
                    const node2 = nodes[j];
                    
                    if (!node1 || !node2 || !node1.userData || !node2.userData) continue;
                    if (!node1.userData.sphereSize || !node2.userData.sphereSize) continue;
                    
                    const pos1 = node1.position;
                    const pos2 = node2.position;
                    
                    // Calculate distance between node centers
                    const distance = pos1.distanceTo(pos2);
                    
                    // Get sphere sizes
                    const sphereSize1 = node1.userData.sphereSize;
                    const sphereSize2 = node2.userData.sphereSize;
                    
                    // Check if spheres overlap or are very close (within 10% of combined radius)
                    const combinedRadius = sphereSize1 + sphereSize2;
                    const convergenceThreshold = combinedRadius * 0.9; // 90% of combined radius
                    
                    if (distance < convergenceThreshold) {
                        // Calculate convergence point (midpoint between nodes)
                        const convergencePoint = new THREE.Vector3()
                            .addVectors(pos1, pos2)
                            .multiplyScalar(0.5);
                        
                        // Calculate convergence strength (0 to 1, where 1 is full overlap)
                        const convergenceStrength = 1 - (distance / combinedRadius);
                        
                        convergencePairs.push({
                            node1: node1,
                            node2: node2,
                            point: convergencePoint,
                            strength: convergenceStrength,
                            distance: distance
                        });
                    }
                }
            }
            
            console.log(`Found ${convergencePairs.length} convergence zones`);
            
            // Create convergence zones asynchronously
            const zonePromises = convergencePairs.map((pair, index) => 
                createConvergenceZone(pair, index)
            );
            
            await Promise.all(zonePromises);
            console.log(`Created ${convergencePairs.length} convergence zones`);
            
            // Update convergence zone button state
            updateConvergenceZoneButton();
        }
        
        // Function to update convergence zone button state
        function updateConvergenceZoneButton() {
            const btn = document.getElementById('convergenceZoneBtn');
            if (!btn) return;
            
            // Disable if no text has been analyzed or no convergence zones exist
            if (!analyzedWords || analyzedWords.length === 0 || convergenceZones.length === 0) {
                btn.disabled = true;
                btn.style.opacity = '0.4';
                btn.style.cursor = 'not-allowed';
            } else {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            }
        }
        
        // Function to show convergence zones modal
        function showConvergenceZonesModal() {
            if (!convergenceZones || convergenceZones.length === 0) {
                alert('No convergence zones found');
                return;
            }
            
            // Create modal if it doesn't exist
            let modal = document.getElementById('convergence-zones-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'convergence-zones-modal';
                modal.style.cssText = 'display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0); z-index: 10001; overflow-y: auto; pointer-events: none; scrollbar-width: none; -ms-overflow-style: none;';
                document.body.appendChild(modal);
                
                // Hide scrollbar for webkit browsers
                const style = document.createElement('style');
                style.textContent = '#convergence-zones-modal::-webkit-scrollbar { display: none; }';
                document.head.appendChild(style);
                
                const container = document.createElement('div');
                container.id = 'convergence-zones-modal-container';
                container.style.cssText = 'position: absolute; max-width: 550px; background: rgba(220, 220, 220, 0.76); padding: 4px 12px 12px 12px; border-radius: 0; color: #000000; font-family: Helvetica, Arial, sans-serif; pointer-events: auto;';
                modal.appendChild(container);
                
                const header = document.createElement('div');
                header.style.cssText = 'display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 3px; margin-top: 0; position: relative;';
                
                const closeBtn = document.createElement('button');
                closeBtn.id = 'close-convergence-zones-modal';
                closeBtn.innerHTML = '<span style="font-size: 12px;">Ã—</span><span>CLOSE</span>';
                closeBtn.style.cssText = 'background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; display: flex; align-items: center; gap: 2px; white-space: nowrap; border-radius: 0; margin: 0; min-height: 16px; height: 16px;';
                closeBtn.onclick = hideConvergenceZonesModal;
                header.appendChild(closeBtn);
                
                // Add color mode button (same style as TOTAL VALUE)
                const colorBtn = document.createElement('div');
                colorBtn.id = 'convergence-zones-color-btn';
                colorBtn.style.cssText = 'width: 16px; height: 16px; background: #808080; border: none; cursor: pointer; padding: 1px; display: flex; align-items: center; justify-content: center; border-radius: 0; margin: 0; position: absolute; top: 1px; right: 3px;';
                const colorIndicator = document.createElement('div');
                colorIndicator.id = 'convergence-zones-color-indicator';
                colorIndicator.style.cssText = 'width: 12px; height: 12px; background: #000000; border-radius: 0;';
                colorBtn.appendChild(colorIndicator);
                colorBtn.addEventListener('click', toggleConvergenceZonesColorMode);
                header.appendChild(colorBtn);
                
                container.appendChild(header);
                
                const content = document.createElement('div');
                content.id = 'convergence-zones-content';
                content.style.cssText = 'font-size: 11px; line-height: 1.1; color: #000000; margin-top: 5px;';
                container.appendChild(content);
                
                // Close modal when clicking outside (similar to TOTAL VALUE)
                const modalContainer = document.getElementById('convergence-zones-modal-container');
                if (modalContainer) {
                    document.addEventListener('click', (e) => {
                        const modal = document.getElementById('convergence-zones-modal');
                        if (modal && modal.style.display === 'block' && !modalContainer.contains(e.target) && e.target.id !== 'convergenceZoneBtn' && !e.target.closest('#convergenceZoneBtn')) {
                            hideConvergenceZonesModal();
                        }
                    });
                }
            }
            
            // Position modal below the button (or centered on mobile)
            const convergenceZoneBtn = document.getElementById('convergenceZoneBtn');
            const modalContainer = document.getElementById('convergence-zones-modal-container');
            if (convergenceZoneBtn && modalContainer) {
                // Check if mobile (screen width <= 768px)
                if (window.innerWidth <= 768) {
                    // Center modal on mobile
                    modalContainer.style.top = '50%';
                    modalContainer.style.left = '50%';
                    modalContainer.style.transform = 'translate(-50%, -50%)';
                    modalContainer.style.margin = '0';
                } else {
                    // Desktop positioning: below button
                    const btnRect = convergenceZoneBtn.getBoundingClientRect();
                    modalContainer.style.top = (btnRect.bottom + 5) + 'px'; // 5px gap below button
                    modalContainer.style.left = btnRect.left + 'px';
                    modalContainer.style.transform = 'none';
                    modalContainer.style.margin = '0'; // Remove auto margin
                }
            }
            
            // Update color indicator
            const colorIndicator = document.getElementById('convergence-zones-color-indicator');
            if (colorIndicator) {
                colorIndicator.style.background = convergenceZonesColorMode ? '#ffffff' : '#000000';
            }
            
            // Get colors based on mode
            const boxBg = convergenceZonesColorMode ? "#ffffff" : "#000000";
            const boxBorder = convergenceZonesColorMode ? "#000000" : "#333333";
            const textColor = convergenceZonesColorMode ? "#000000" : "#ffffff";
            
            // Populate content
            const content = document.getElementById('convergence-zones-content');
            content.innerHTML = '';
            
            convergenceZones.forEach((zone, index) => {
                const zoneDiv = document.createElement('div');
                zoneDiv.style.cssText = `margin-bottom: 8px; padding: 6px; background: ${boxBg}; color: ${textColor}; border: 1px solid ${boxBorder};`;
                
                // Header with ZONE in uppercase
                const zoneHeader = document.createElement('div');
                zoneHeader.style.cssText = `font-size: 11px; font-weight: bold; margin-bottom: 4px; color: ${textColor};`;
                const word1 = (zone.node1 && zone.node1.userData && zone.node1.userData.wordData && zone.node1.userData.wordData.text) || 'Unknown';
                const word2 = (zone.node2 && zone.node2.userData && zone.node2.userData.wordData && zone.node2.userData.wordData.text) || 'Unknown';
                zoneHeader.textContent = `ZONE ${index + 1}: "${word1}" + "${word2}"`;
                zoneDiv.appendChild(zoneHeader);
                
                // Summary information
                const summaryBg = convergenceZonesColorMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)";
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = `font-size: 9px; line-height: 1.2; color: ${textColor}; margin-bottom: 4px; padding: 4px; background: ${summaryBg};`;
                
                // Get zone data
                const position = zone.point || { x: 0, y: 0, z: 0 };
                const strength = zone.strength || 0;
                
                // Get node values
                const node1Value = (zone.node1 && zone.node1.userData && zone.node1.userData.wordData && (zone.node1.userData.wordData.finalValue || zone.node1.userData.wordData.totalScore || 0)) || 0;
                const node2Value = (zone.node2 && zone.node2.userData && zone.node2.userData.wordData && (zone.node2.userData.wordData.finalValue || zone.node2.userData.totalScore || 0)) || 0;
                const totalNodeValue = node1Value + node2Value;
                
                // Count convergence nodes (violet nodes) - count children of the group
                let convergenceNodeCount = 0;
                if (zone.group && zone.group.children) {
                    zone.group.children.forEach((child) => {
                        if (child.userData && child.userData.isConvergenceNode) {
                            convergenceNodeCount++;
                        }
                    });
                }
                
                // Calculate zone size (distance between nodes)
                let zoneSize = 0;
                if (zone.node1 && zone.node2) {
                    const pos1 = zone.node1.position;
                    const pos2 = zone.node2.position;
                    zoneSize = pos1.distanceTo(pos2);
                }
                
                // Get sphere sizes
                const sphereSize1 = (zone.node1 && zone.node1.userData && zone.node1.userData.sphereSize) || 0;
                const sphereSize2 = (zone.node2 && zone.node2.userData && zone.node2.userData.sphereSize) || 0;
                const avgSphereSize = (sphereSize1 + sphereSize2) / 2;
                
                // Convert values to ETH if available
                let totalNodeValueETH = 0;
                if (typeof ethPriceUSD !== 'undefined' && ethPriceUSD && ethPriceUSD > 0) {
                    totalNodeValueETH = totalNodeValue / ethPriceUSD;
                }
                
                // Get convergence zone total value
                const zoneTotalValue = zone.totalValue || 0;
                let zoneTotalValueETH = 0;
                if (typeof ethPriceUSD !== 'undefined' && ethPriceUSD && ethPriceUSD > 0) {
                    zoneTotalValueETH = zoneTotalValue / ethPriceUSD;
                }
                const zoneTotalValueETHDisplay = zoneTotalValueETH >= 0.01 ? 
                    `${zoneTotalValueETH.toFixed(6)} ETH` : 
                    `${zoneTotalValueETH.toFixed(10)} ETH`;
                
                summaryDiv.innerHTML = `
                    <div><strong>Location:</strong> (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})</div>
                    <div><strong>Nodes:</strong> ${convergenceNodeCount}</div>
                    <div><strong>Size:</strong> ${zoneSize.toFixed(3)}</div>
                    <div><strong>Weight:</strong> ${avgSphereSize.toFixed(4)}</div>
                    <div><strong>Value:</strong> ${zoneTotalValueETHDisplay}</div>
                    <div><strong>Node Values:</strong> ${totalNodeValueETH > 0 ? totalNodeValueETH.toFixed(6) + ' ETH' : totalNodeValue.toFixed(2)}</div>
                    <div><strong>Strength:</strong> ${(strength * 100).toFixed(1)}%</div>
                `;
                zoneDiv.appendChild(summaryDiv);
                
                // Generated text (invert colors based on mode: white mode = black bg/white text, black mode = white bg/black text)
                const textDiv = document.createElement('div');
                textDiv.style.cssText = 'font-size: 10px; line-height: 1.0; margin-top: 2px;';
                // Wrap text in span with same style as TOTAL VALUE numbers
                const textSpan = document.createElement('span');
                const textBg = convergenceZonesColorMode ? "#000000" : "#ffffff";
                const textFg = convergenceZonesColorMode ? "#ffffff" : "#000000";
                textSpan.style.cssText = `background: ${textBg}; color: ${textFg} !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;`;
                textSpan.textContent = zone.text || 'No text generated';
                textDiv.appendChild(textSpan);
                zoneDiv.appendChild(textDiv);
                
                content.appendChild(zoneDiv);
            });
            
            // Show modal
            modal.style.display = 'block';
            modal.style.visibility = 'visible';
            modal.style.opacity = '1';
            modal.style.pointerEvents = 'auto';
        }
        
        function hideConvergenceZonesModal() {
            const modal = document.getElementById('convergence-zones-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Function to generate semantically related text for convergence zones
        async function generateConvergenceText(word1, word2) {
            const apiKey = localStorage.getItem('openai_api_key');
            if (!apiKey) {
                console.warn('OpenAI API key not found. Using fallback text.');
                return `${word1} ${word2}`;
            }
            
            const prompt = `Generate a short phrase, sentence, or few words (maximum 8 words) that semantically relates to these two words: "${word1}" and "${word2}". The generated text should create a meaningful connection between these words, exploring their semantic relationship. Return ONLY the generated text, no explanations or additional text.`;
            
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        temperature: 0.7,
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a creative linguistic assistant. Generate concise, semantically rich text that connects concepts.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: 50
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('OpenAI API error for convergence text:', response.status, errorText);
                    return `${word1} ${word2}`;
                }
                
                const data = await response.json();
                if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                    console.error('Invalid OpenAI response structure for convergence text:', data);
                    return `${word1} ${word2}`;
                }
                
                const generatedText = data.choices[0].message.content.trim();
                // Remove quotes if present
                return generatedText.replace(/^["']|["']$/g, '');
            } catch (error) {
                console.error('Error generating convergence text:', error);
                return `${word1} ${word2}`;
            }
        }
        
        // Function to analyze convergence text and get word types
        async function analyzeConvergenceText(text) {
            const apiKey = localStorage.getItem('openai_api_key');
            if (!apiKey) {
                console.warn('OpenAI API key not found. Using fallback analysis.');
                // Return simple fallback analysis
                const words = text.split(/\s+/).filter(w => w.length > 0);
                return words.map(word => ({
                    word: word,
                    pos: 'MISC',
                    uposType: 'MISC',
                    isName: false
                }));
            }
            
            // Use the same analysis function as the main text
            // Extract words from text
            const words = text.split(/\s+/).filter(w => w.length > 0);
            if (words.length === 0) return [];
            
            const wordList = words.map((w, i) => `${i + 1}. "${w}"`).join('\n');
            
            const prompt = `You are a linguistic analysis expert. Analyze the following text and classify each word according to its grammatical function in context.

Complete text to analyze:
"${text}"

Words to classify (in order, extracted from text):
${wordList}

Return a JSON array with ONE entry per word listed above, in order. Use the EXACT word as it appears in the text.

Return format (JSON array only, no other text):
[
  {"word": "exact_word_as_in_text", "pos": "VERB", "uposType": "VERB", "isName": false},
  {"word": "exact_word_as_in_text", "pos": "NOUN", "uposType": "NOUN", "isName": false},
  {"word": "Mike", "pos": "NAME", "uposType": "NAME", "isName": true}
]`;
            
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        temperature: 0.0,
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a linguistic analysis expert. Return ONLY valid JSON arrays for POS tagging, no explanations or additional text.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: 500
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('OpenAI API error for convergence analysis:', response.status, errorText);
                    // Return fallback
                    return words.map(word => ({
                        word: word,
                        pos: 'MISC',
                        uposType: 'MISC',
                        isName: false
                    }));
                }
                
                const data = await response.json();
                if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                    console.error('Invalid OpenAI response structure for convergence analysis:', data);
                    return words.map(word => ({
                        word: word,
                        pos: 'MISC',
                        uposType: 'MISC',
                        isName: false
                    }));
                }
                
                const content = data.choices[0].message.content.trim();
                let jsonText = content;
                if (content.startsWith('```json')) {
                    jsonText = content.replace(/```json\n?/g, '').replace(/```\n?$/g, '');
                } else if (content.startsWith('```')) {
                    jsonText = content.replace(/```\n?/g, '').replace(/```$/g, '');
                }
                
                const analysis = JSON.parse(jsonText);
                if (!Array.isArray(analysis)) {
                    console.error('OpenAI response is not an array for convergence analysis:', typeof analysis);
                    return words.map(word => ({
                        word: word,
                        pos: 'MISC',
                        uposType: 'MISC',
                        isName: false
                    }));
                }
                
                return analysis;
            } catch (error) {
                console.error('Error analyzing convergence text:', error);
                return words.map(word => ({
                    word: word,
                    pos: 'MISC',
                    uposType: 'MISC',
                    isName: false
                }));
            }
        }
        
        async function createConvergenceZone(pair, index) {
            const { node1, node2, point, strength } = pair;
            
            // Get words from both nodes
            const word1 = node1.userData.wordData?.text || '';
            const word2 = node2.userData.wordData?.text || '';
            
            // Generate semantically related text using OpenAI
            const convergenceText = await generateConvergenceText(word1, word2);
            
            // Analyze the generated text to get word types
            const wordAnalysis = await analyzeConvergenceText(convergenceText);
            
            // Create a group for this convergence zone
            const convergenceGroup = new THREE.Group();
            convergenceGroup.position.copy(point);
            
            // Tokenize the convergence text into words
            const convergenceWords = convergenceText.split(/\s+/).filter(w => w.length > 0);
            
            if (convergenceWords.length === 0 || wordAnalysis.length === 0) return;
            
            // Calculate convergence zone radius (smaller of the two sphere sizes)
            const sphereSize1 = node1.userData.sphereSize || 0.06;
            const sphereSize2 = node2.userData.sphereSize || 0.06;
            const convergenceRadius = Math.min(sphereSize1, sphereSize2) * 0.3; // Use 30% of smaller sphere
            
            // Create small violet nodes for each word in the convergence text
            const convergenceNodes = [];
            const smallNodeSize = 0.008; // Very small nodes
            const violetColor = 0x8B00FF; // Violet color
            
            // Create analyzedWords array for value calculation
            const convergenceAnalyzedWords = [];
            convergenceWords.forEach((word, wordIndex) => {
                const analysis = wordAnalysis.find(a => 
                    a.word.toLowerCase() === word.toLowerCase() || 
                    a.word === word
                ) || wordAnalysis[wordIndex] || {
                    word: word,
                    pos: 'MISC',
                    uposType: 'MISC',
                    isName: false
                };
                
                convergenceAnalyzedWords.push({
                    text: word,
                    pos: analysis.pos || 'MISC',
                    uposType: analysis.uposType || analysis.pos || 'MISC',
                    upos: analysis.uposType || analysis.pos || 'MISC',
                    isName: analysis.isName || false
                });
            });
            
            // Create tokens array for value calculation
            const convergenceTokens = convergenceWords.map((word, wordIndex) => {
                const analysis = convergenceAnalyzedWords[wordIndex];
                return {
                    surface: word,
                    type: analysis.uposType || analysis.pos || 'MISC',
                    name_group: null,
                    features: {}
                };
            });
            
            // Calculate multipliers for convergence text (simplified, since it's a short phrase)
            // For convergence phrases, we'll use simplified multipliers
            const convergenceRepetitionMultipliers = new Map();
            convergenceWords.forEach((word, index) => {
                const wordText = word.toLowerCase().replace(/[^\w]/g, '');
                if (!convergenceRepetitionMultipliers.has(wordText)) {
                    // Count occurrences in convergence text
                    let count = 0;
                    convergenceWords.forEach(w => {
                        if (w.toLowerCase().replace(/[^\w]/g, '') === wordText) {
                            count++;
                        }
                    });
                    // Simple repetition multiplier
                    let mult = 1.0;
                    if (count === 1) mult = 1.5;
                    else if (count === 2) mult = 1.2;
                    else if (count >= 3) mult = 0.9;
                    convergenceRepetitionMultipliers.set(wordText, mult);
                }
            });
            
            // Simplified multipliers for convergence text
            const convergenceDiversityMult = 1.0; // No diversity devaluation for short phrases
            const convergenceNonNameDevaluation = 1.0; // No devaluation for short phrases
            const convergenceAdjectiveMult = 1.0; // No special handling
            const convergenceTextLengthDevaluation = 1.0; // No length devaluation for short phrases
            
            // Calculate values for each word in convergence text
            const convergenceWordValues = [];
            convergenceWords.forEach((word, wordIndex) => {
                const analysis = convergenceAnalyzedWords[wordIndex];
                const token = convergenceTokens[wordIndex];
                const wordText = word.toLowerCase().replace(/[^\w]/g, '');
                const repetitionMult = convergenceRepetitionMultipliers.get(wordText) || 1.0;
                
                // Calculate value using the same function as main text
                const valueInfo = calculateNewTokenValue(
                    token, 
                    wordIndex, 
                    convergenceTokens, 
                    [], // No name groups in convergence text
                    convergenceAnalyzedWords, 
                    repetitionMult, 
                    convergenceDiversityMult, 
                    convergenceNonNameDevaluation, 
                    convergenceAdjectiveMult, 
                    convergenceTextLengthDevaluation
                );
                
                // Apply 40% reduction to convergence zone values (multiply by 0.6)
                const reducedValue = valueInfo.final_value * 0.6;
                convergenceWordValues.push(reducedValue);
            });
            
            // Match words with their analysis and assign calculated values
            convergenceWords.forEach((word, wordIndex) => {
                // Find matching analysis entry (by word text)
                const analysis = wordAnalysis.find(a => 
                    a.word.toLowerCase() === word.toLowerCase() || 
                    a.word === word
                ) || wordAnalysis[wordIndex] || {
                    word: word,
                    pos: 'MISC',
                    uposType: 'MISC',
                    isName: false
                };
                
                // Get calculated value for this word
                const calculatedValue = convergenceWordValues[wordIndex] || 1.0;
                
                // Create word data object for getWordTypeForShape
                const wordData = {
                    text: word,
                    pos: analysis.pos || 'MISC',
                    uposType: analysis.uposType || analysis.pos || 'MISC',
                    upos: analysis.uposType || analysis.pos || 'MISC',
                    isName: analysis.isName || false
                };
                
                // Get word type for shape
                const wordType = getWordTypeForShape(wordData, wordIndex);
                
                // Create geometry based on word type
                const nodeGeometry = createWordTypeGeometry(wordType, smallNodeSize, violetColor, 0.9);
                
                // Create a group for this node
                const nodeGroup = new THREE.Group();
                
                // Add the geometry to the group
                nodeGroup.add(nodeGeometry);
                
                // Store userData for the convergence node (to make it interactive)
                nodeGroup.userData = {
                    wordData: {
                        text: word,
                        pos: analysis.pos || 'MISC',
                        uposType: analysis.uposType || analysis.pos || 'MISC',
                        upos: analysis.uposType || analysis.pos || 'MISC',
                        isName: analysis.isName || false,
                        finalValue: calculatedValue, // Valor calculado para el nodo violeta
                        totalScore: calculatedValue, // Valor calculado para el nodo violeta
                        isConvergenceNode: true
                    },
                    index: -1, // Ãndice especial para nodos de convergencia
                    connectionCount: 0,
                    isGroup: true,
                    wordType: wordType,
                    isConvergenceNode: true // Marca para identificar nodos de convergencia
                };
                
                // Distribute nodes organically within the convergence zone
                // Use spherical distribution for more organic placement
                const angle = (wordIndex / convergenceWords.length) * Math.PI * 2;
                const radius = convergenceRadius * (0.3 + Math.random() * 0.4); // Random radius within zone
                const height = (Math.random() - 0.5) * convergenceRadius * 0.5; // Random height variation
                
                nodeGroup.position.x = Math.cos(angle) * radius;
                nodeGroup.position.y = height;
                nodeGroup.position.z = Math.sin(angle) * radius;
                
                // Disable shadows for convergence nodes
                nodeGroup.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                    }
                });
                
                convergenceGroup.add(nodeGroup);
                convergenceNodes.push(nodeGroup);
            });
            
            // Create violet lines connecting the convergence nodes
            // Connect each node to its nearest neighbors for organic structure
            for (let i = 0; i < convergenceNodes.length; i++) {
                const nodeA = convergenceNodes[i];
                
                // Find nearest neighbors (connect to 2-3 nearest nodes)
                const neighbors = [];
                for (let j = 0; j < convergenceNodes.length; j++) {
                    if (i === j) continue;
                    const nodeB = convergenceNodes[j];
                    const distance = nodeA.position.distanceTo(nodeB.position);
                    neighbors.push({ node: nodeB, distance: distance });
                }
                
                // Sort by distance and take 2-3 nearest neighbors
                neighbors.sort((a, b) => a.distance - b.distance);
                const numConnections = Math.min(neighbors.length, convergenceWords.length <= 3 ? 2 : 3);
                
                for (let k = 0; k < numConnections; k++) {
                    const nodeB = neighbors[k].node;
                    
                    // Check if connection already exists (avoid duplicates)
                    const connectionExists = convergenceGroup.children.some(child => {
                        if (child.type === 'Line' && child.userData) {
                            return (child.userData.fromNode === nodeA && child.userData.toNode === nodeB) ||
                                   (child.userData.fromNode === nodeB && child.userData.toNode === nodeA);
                        }
                        return false;
                    });
                    
                    if (!connectionExists) {
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            nodeA.position.clone(),
                            nodeB.position.clone()
                        ]);
                        
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: 0x8B00FF, // Violet color
                            transparent: true,
                            opacity: 0.7,
                            linewidth: 1
                        });
                        
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        line.userData = { fromNode: nodeA, toNode: nodeB };
                        convergenceGroup.add(line);
                    }
                }
            }
            
            // Calculate total value for this convergence zone
            const zoneTotalValue = convergenceWordValues.reduce((sum, val) => sum + val, 0);
            
            // Store convergence zone value separately (will be added to total AFTER all devaluations)
            // Initialize convergence total value if it doesn't exist
            if (window.convergenceTotalValue === undefined) {
                window.convergenceTotalValue = 0;
            }
            window.convergenceTotalValue += zoneTotalValue;
            
            // Update global total value to include convergence zone values
            // These values are added AFTER all devaluations, so they don't affect devaluation calculations
            // The convergence values are pure additions - they are NOT subject to any devaluations
            if (window.totalTextScore !== undefined) {
                // Simply add the convergence zone value to the total
                // This happens AFTER all devaluations have been applied to the main text
                window.totalTextScore = (window.totalTextScore || 0) + zoneTotalValue;
                // Update display
                if (typeof convertToEthereum === 'function') {
                    convertToEthereum(window.totalTextScore);
                }
            }
            
            // Store convergence zone data
            const zoneData = {
                group: convergenceGroup,
                node1: node1,
                node2: node2,
                point: point,
                strength: strength,
                text: convergenceText,
                totalValue: zoneTotalValue, // Store total value for this zone
                wordValues: convergenceWordValues // Store individual word values
            };
            
            convergenceZones.push(zoneData);
            scene.add(convergenceGroup);
            
            // Agregar los nodos violetas al array nodes para que sean detectables por el raycaster
            convergenceNodes.forEach(violetNode => {
                nodes.push(violetNode);
            });
            
            console.log(`Created convergence zone ${index + 1}: "${convergenceText}" at (${point.x.toFixed(2)}, ${point.y.toFixed(2)}, ${point.z.toFixed(2)}) with total value: ${zoneTotalValue.toFixed(2)}`);
        }
        
        function createSemanticConnections(cores, coreWords) {
            // Track which nodes have connections
            const connectedNodes = new Set();
            
            // 1. Connect all words to their semantic core (hub-spoke pattern)
            coreWords.forEach((coreIndex, wordIndex) => {
                const core = cores[coreIndex];
                const coreNode = nodes.find(n => n.userData.index === core.wordIndex);
                const wordNode = nodes.find(n => n.userData.index === wordIndex);
                
                if (coreNode && wordNode && coreNode !== wordNode) {
                    createConnection(coreNode, wordNode);
                    connectedNodes.add(coreNode);
                    connectedNodes.add(wordNode);
                }
            });
            
            // 2. Connect words within the same semantic core (cluster connections)
            cores.forEach(core => {
                const coreNode = nodes.find(n => n.userData.index === core.wordIndex);
                if (!coreNode) return;
                
                // Connect related words to each other (within same core)
                for (let i = 0; i < core.relatedWords.length; i++) {
                    const wordIndex1 = core.relatedWords[i];
                    const wordNode1 = nodes.find(n => n.userData.index === wordIndex1);
                    
                    if (!wordNode1) continue;
                    
                    // Connect to core
                    if (coreNode !== wordNode1) {
                        // Already connected above, but ensure it exists
                        if (!connections.some(c => 
                            (c.userData.fromNode === coreNode && c.userData.toNode === wordNode1) ||
                            (c.userData.fromNode === wordNode1 && c.userData.toNode === coreNode)
                        )) {
                            createConnection(coreNode, wordNode1);
                        }
                    }
                    
                    // Connect to other words in same core (if they share semantic similarity)
                    for (let j = i + 1; j < core.relatedWords.length; j++) {
                        const wordIndex2 = core.relatedWords[j];
                        const wordNode2 = nodes.find(n => n.userData.index === wordIndex2);
                        
                        if (!wordNode2) continue;
                        
                        const word1 = analyzedWords[wordIndex1];
                        const word2 = analyzedWords[wordIndex2];
                        
                        // Connect if same POS or both high value
                        if (word1.pos === word2.pos || 
                            (word1.normalizedScore > 0.6 && word2.normalizedScore > 0.6)) {
                            createConnection(wordNode1, wordNode2);
                        }
                    }
                }
            });
            
            // 3. Connect cores to each other (inter-core connections)
            for (let i = 0; i < cores.length; i++) {
                for (let j = i + 1; j < cores.length; j++) {
                    const core1 = cores[i];
                    const core2 = cores[j];
                    
                    const coreNode1 = nodes.find(n => n.userData.index === core1.wordIndex);
                    const coreNode2 = nodes.find(n => n.userData.index === core2.wordIndex);
                    
                    if (!coreNode1 || !coreNode2) continue;
                    
                    // Connect cores if they share related words or have semantic relationship
                    const sharedRelated = core1.relatedWords.filter(idx => 
                        core2.relatedWords.includes(idx)
                    ).length;
                    
                    // Connect if cores are of complementary types or share concepts
                    const shouldConnect = 
                        sharedRelated > 0 || // Share related words
                        (core1.type === 'ontological_subject' && core2.type === 'existence') ||
                        (core1.type === 'existence' && core2.type === 'essential_concept') ||
                        (core1.type === 'identity' && core2.type === 'ontological_subject') ||
                        Math.abs(core1.wordIndex - core2.wordIndex) <= 5; // Close in text
                    
                    if (shouldConnect) {
                        createConnection(coreNode1, coreNode2);
                    }
                }
            }
            
            // 4. Ensure ALL nodes have at least one connection
            nodes.forEach(node => {
                if (!connectedNodes.has(node)) {
                    // Find nearest connected node
                    let nearestNode = null;
                    let minDistance = Infinity;
                    
                    connectedNodes.forEach(connectedNode => {
                        const dist = node.position.distanceTo(connectedNode.position);
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearestNode = connectedNode;
                        }
                    });
                    
                    if (nearestNode) {
                        createConnection(node, nearestNode);
                        connectedNodes.add(node);
                    } else {
                        // If no connected nodes, connect to nearest node by text position
                        const nodeIndex = node.userData.index;
                        let nearestByText = null;
                        let minTextDist = Infinity;
                        
                        nodes.forEach(otherNode => {
                            if (otherNode === node) return;
                            const textDist = Math.abs(nodeIndex - otherNode.userData.index);
                            if (textDist < minTextDist) {
                                minTextDist = textDist;
                                nearestByText = otherNode;
                            }
                        });
                        
                        if (nearestByText) {
                            createConnection(node, nearestByText);
                            connectedNodes.add(node);
                            connectedNodes.add(nearestByText);
                        }
                    }
                }
            });
            
            // 5. Add additional connections within clusters for better connectivity
            cores.forEach(core => {
                const coreNode = nodes.find(n => n.userData.index === core.wordIndex);
                if (!coreNode) return;
                
                // Connect words within same cluster if they're semantically similar
                for (let i = 0; i < core.relatedWords.length; i++) {
                    const wordIndex1 = core.relatedWords[i];
                    const wordNode1 = nodes.find(n => n.userData.index === wordIndex1);
                    if (!wordNode1) continue;
                    
                    const word1 = analyzedWords[wordIndex1];
                    
                    for (let j = i + 1; j < core.relatedWords.length; j++) {
                        const wordIndex2 = core.relatedWords[j];
                        const wordNode2 = nodes.find(n => n.userData.index === wordIndex2);
                        if (!wordNode2) continue;
                        
                        const word2 = analyzedWords[wordIndex2];
                        
                        // Connect if they share characteristics
                        if (word1.pos === word2.pos || 
                            Math.abs(word1.normalizedScore - word2.normalizedScore) < 0.3 ||
                            Math.abs(wordIndex1 - wordIndex2) <= 5) {
                            
                            // Check if already connected
                            if (!connections.some(c => 
                                (c.userData.fromNode === wordNode1 && c.userData.toNode === wordNode2) ||
                                (c.userData.fromNode === wordNode2 && c.userData.toNode === wordNode1)
                            )) {
                                createConnection(wordNode1, wordNode2);
                            }
                        }
                    }
                }
            });
        }
        
        function createListConnections() {
            // In lists, connect words within the same list item more strongly
            const wordsPerItem = Math.max(3, Math.ceil(analyzedWords.length / 10));
            
            for (let i = 0; i < nodes.length; i++) {
                const currentNode = nodes[i];
                const currentIndex = currentNode.userData.index;
                const itemIndex = Math.floor(currentIndex / wordsPerItem);
                
                // Connect to words in same list item (stronger connections)
                for (let j = 0; j < nodes.length; j++) {
                    if (i === j) continue;
                    const otherNode = nodes[j];
                    const otherIndex = otherNode.userData.index;
                    const otherItemIndex = Math.floor(otherIndex / wordsPerItem);
                    
                    const textDistance = Math.abs(currentIndex - otherIndex);
                    
                    if (itemIndex === otherItemIndex && textDistance <= 5) {
                        // Same item: connect closely spaced words
                        if (textDistance <= 3) {
                            createConnection(currentNode, otherNode);
                        }
                    } else if (Math.abs(itemIndex - otherItemIndex) === 1 && textDistance <= 2) {
                        // Adjacent items: connect only very close words (bridges)
                        if (textDistance <= 2) {
                            createConnection(currentNode, otherNode);
                        }
                    }
                }
            }
        }
        
        function createShortPhraseConnections() {
            // Short phrases: all words are closely connected (tight network)
            // CRITICAL: Always create connections, even if some fail
            
            // STEP 1: ALWAYS create adjacent connections FIRST (guaranteed)
            console.log(`createShortPhraseConnections: Creating adjacent connections for ${nodes.length} nodes...`);
            let adjacentConnectionsCreated = 0;
            for (let i = 0; i < nodes.length - 1; i++) {
                if (!nodes[i] || !nodes[i].userData || !nodes[i + 1] || !nodes[i + 1].userData) {
                    continue;
                }
                
                // Check if connection already exists
                const connectionExists = connections.some(conn => 
                    conn.userData && 
                    ((conn.userData.fromNode === nodes[i] && conn.userData.toNode === nodes[i + 1]) ||
                     (conn.userData.fromNode === nodes[i + 1] && conn.userData.toNode === nodes[i]))
                );
                
                if (!connectionExists) {
                    const result = createConnection(nodes[i], nodes[i + 1]);
                    if (result) {
                        adjacentConnectionsCreated++;
                    } else {
                        console.error(`Failed to create adjacent connection between nodes ${i} and ${i + 1}`);
                    }
                }
            }
            console.log(`Created ${adjacentConnectionsCreated} adjacent connections`);
            
            // STEP 2: Create additional connections for closely spaced words
            let additionalConnectionsCreated = 0;
            for (let i = 0; i < nodes.length; i++) {
                if (!nodes[i] || !nodes[i].userData) continue;
                
                for (let j = i + 1; j < nodes.length; j++) {
                    if (!nodes[j] || !nodes[j].userData) continue;
                    
                    const distance = Math.abs(i - j);
                    if (distance <= 3 && distance > 1) { // Skip adjacent (already connected)
                        // Check if connection already exists
                        const connectionExists = connections.some(conn => 
                            conn.userData && 
                            ((conn.userData.fromNode === nodes[i] && conn.userData.toNode === nodes[j]) ||
                             (conn.userData.fromNode === nodes[j] && conn.userData.toNode === nodes[i]))
                        );
                        
                        if (!connectionExists) {
                            const result = createConnection(nodes[i], nodes[j]);
                            if (result) additionalConnectionsCreated++;
                        }
                    }
                }
            }
            console.log(`Created ${additionalConnectionsCreated} additional connections`);
            
            // STEP 3: Final verification - ensure every node has at least one connection
            const nodesWithoutConnections = [];
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (!node || !node.userData) continue;
                
                const hasConnection = connections.some(conn => 
                    conn.userData && 
                    (conn.userData.fromNode === node || conn.userData.toNode === node)
                );
                
                if (!hasConnection) {
                    nodesWithoutConnections.push(i);
                }
            }
            
            if (nodesWithoutConnections.length > 0) {
                console.warn(`Found ${nodesWithoutConnections.length} nodes without connections in createShortPhraseConnections, fixing...`);
                nodesWithoutConnections.forEach(nodeIndex => {
                    const node = nodes[nodeIndex];
                    if (!node) return;
                    
                    // Connect to adjacent nodes
                    const candidates = [
                        nodes[nodeIndex - 1],
                        nodes[nodeIndex + 1]
                    ].filter(n => n && n.userData);
                    
                    for (const candidate of candidates) {
                        if (!candidate) continue;
                        
                        const connectionExists = connections.some(conn => 
                            conn.userData && 
                            ((conn.userData.fromNode === node && conn.userData.toNode === candidate) ||
                             (conn.userData.fromNode === candidate && conn.userData.toNode === node))
                        );
                        
                        if (!connectionExists) {
                            const result = createConnection(node, candidate);
                            if (result) break; // Found a connection, move to next node
                        }
                    }
                });
            }
            
            console.log(`createShortPhraseConnections: Final connection count: ${connections.length}`);
        }
        
        function createShortSentencesConnections() {
            // Connect words within sentences, less between sentences
            // CRITICAL: Always create adjacent connections FIRST
            
            // STEP 1: ALWAYS create adjacent connections FIRST (guaranteed)
            console.log(`createShortSentencesConnections: Creating adjacent connections for ${nodes.length} nodes...`);
            let adjacentConnectionsCreated = 0;
            for (let i = 0; i < nodes.length - 1; i++) {
                const currentNode = nodes[i];
                const nextNode = nodes[i + 1];
                
                if (!currentNode || !nextNode || !currentNode.userData || !nextNode.userData) {
                    continue;
                }
                
                // Check if connection already exists
                const connectionExists = connections.some(conn => 
                    conn.userData && 
                    ((conn.userData.fromNode === currentNode && conn.userData.toNode === nextNode) ||
                     (conn.userData.fromNode === nextNode && conn.userData.toNode === currentNode))
                );
                
                if (!connectionExists) {
                    const result = createConnection(currentNode, nextNode);
                    if (result) {
                        adjacentConnectionsCreated++;
                    } else {
                        console.error(`Failed to create adjacent connection between nodes ${i} and ${i + 1}`);
                    }
                }
            }
            console.log(`Created ${adjacentConnectionsCreated} adjacent connections`);
            
            // STEP 2: Create additional connections within sentences
            const wordsPerSentence = 6;
            let additionalConnectionsCreated = 0;
            
            for (let i = 0; i < nodes.length; i++) {
                const currentNode = nodes[i];
                if (!currentNode || !currentNode.userData || currentNode.userData.index === undefined) continue;
                
                const currentIndex = currentNode.userData.index;
                const sentenceIndex = Math.floor(currentIndex / wordsPerSentence);
                
                for (let j = 0; j < nodes.length; j++) {
                    if (i === j) continue;
                    const otherNode = nodes[j];
                    if (!otherNode || !otherNode.userData || otherNode.userData.index === undefined) continue;
                    
                    const otherIndex = otherNode.userData.index;
                    const otherSentenceIndex = Math.floor(otherIndex / wordsPerSentence);
                    
                    const textDistance = Math.abs(currentIndex - otherIndex);
                    
                    // Skip adjacent (already connected)
                    if (textDistance === 1) continue;
                    
                    // Check if connection already exists
                    const connectionExists = connections.some(conn => 
                        conn.userData && 
                        ((conn.userData.fromNode === currentNode && conn.userData.toNode === otherNode) ||
                         (conn.userData.fromNode === otherNode && conn.userData.toNode === currentNode))
                    );
                    
                    if (connectionExists) continue;
                    
                    if (sentenceIndex === otherSentenceIndex) {
                        // Same sentence: connect closely
                        if (textDistance <= 4) {
                            const result = createConnection(currentNode, otherNode);
                            if (result) additionalConnectionsCreated++;
                        }
                    } else if (Math.abs(sentenceIndex - otherSentenceIndex) === 1 && textDistance <= 2) {
                        // Adjacent sentences: minimal connections
                        if (textDistance <= 2 && Math.random() > 0.7) {
                            const result = createConnection(currentNode, otherNode);
                            if (result) additionalConnectionsCreated++;
                        }
                    }
                }
            }
            console.log(`Created ${additionalConnectionsCreated} additional connections`);
            
            // STEP 3: Final verification - ensure every node has at least one connection
            const nodesWithoutConnections = [];
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (!node || !node.userData) continue;
                
                const hasConnection = connections.some(conn => 
                    conn.userData && 
                    (conn.userData.fromNode === node || conn.userData.toNode === node)
                );
                
                if (!hasConnection) {
                    nodesWithoutConnections.push(i);
                }
            }
            
            if (nodesWithoutConnections.length > 0) {
                console.warn(`Found ${nodesWithoutConnections.length} nodes without connections in createShortSentencesConnections, fixing...`);
                nodesWithoutConnections.forEach(nodeIndex => {
                    const node = nodes[nodeIndex];
                    if (!node) return;
                    
                    // Connect to adjacent nodes
                    const candidates = [
                        nodes[nodeIndex - 1],
                        nodes[nodeIndex + 1]
                    ].filter(n => n && n.userData);
                    
                    for (const candidate of candidates) {
                        if (!candidate) continue;
                        
                        const connectionExists = connections.some(conn => 
                            conn.userData && 
                            ((conn.userData.fromNode === node && conn.userData.toNode === candidate) ||
                             (conn.userData.fromNode === candidate && conn.userData.toNode === node))
                        );
                        
                        if (!connectionExists) {
                            const result = createConnection(node, candidate);
                            if (result) break; // Found a connection, move to next node
                        }
                    }
                });
            }
            
            console.log(`createShortSentencesConnections: Final connection count: ${connections.length}`);
        }
        
        function createParagraphsConnections() {
            // Connect words within paragraphs, less between paragraphs
            // CRITICAL: Always create adjacent connections FIRST
            
            // STEP 1: ALWAYS create adjacent connections FIRST (guaranteed)
            console.log(`createParagraphsConnections: Creating adjacent connections for ${nodes.length} nodes...`);
            let adjacentConnectionsCreated = 0;
            for (let i = 0; i < nodes.length - 1; i++) {
                const currentNode = nodes[i];
                const nextNode = nodes[i + 1];
                
                if (!currentNode || !nextNode || !currentNode.userData || !nextNode.userData) {
                    continue;
                }
                
                // Check if connection already exists
                const connectionExists = connections.some(conn => 
                    conn.userData && 
                    ((conn.userData.fromNode === currentNode && conn.userData.toNode === nextNode) ||
                     (conn.userData.fromNode === nextNode && conn.userData.toNode === currentNode))
                );
                
                if (!connectionExists) {
                    const result = createConnection(currentNode, nextNode);
                    if (result) {
                        adjacentConnectionsCreated++;
                    } else {
                        console.error(`Failed to create adjacent connection between nodes ${i} and ${i + 1}`);
                    }
                }
            }
            console.log(`Created ${adjacentConnectionsCreated} adjacent connections`);
            
            // STEP 2: Create additional connections within paragraphs
            const wordsPerParagraph = 75;
            let additionalConnectionsCreated = 0;
            
            for (let i = 0; i < nodes.length; i++) {
                const currentNode = nodes[i];
                if (!currentNode || !currentNode.userData || currentNode.userData.index === undefined) continue;
                
                const currentIndex = currentNode.userData.index;
                const paragraphIndex = Math.floor(currentIndex / wordsPerParagraph);
                
                // Connect to adjacent words in the text (semantic proximity)
                const adjacentRange = 4; // Connect to words within 4 positions
                
                for (let j = Math.max(0, i - adjacentRange); j < Math.min(nodes.length, i + adjacentRange + 1); j++) {
                    if (i !== j) {
                        const otherNode = nodes[j];
                        if (!otherNode || !otherNode.userData) continue;
                        
                        // Handle both regular nodes and noun groups
                        const otherIndex = otherNode.userData.index !== undefined ? 
                            otherNode.userData.index : 
                            (otherNode.userData.wordData ? analyzedWords.findIndex(w => w === otherNode.userData.wordData) : j);
                        
                        if (otherIndex === undefined) continue;
                        
                        // Calculate semantic distance based on text position
                        const textDistance = Math.abs(currentIndex - otherIndex);
                        
                        // Skip adjacent (already connected)
                        if (textDistance === 1) continue;
                        
                        // Check if connection already exists
                        const connectionExists = connections.some(conn => 
                            conn.userData && 
                            ((conn.userData.fromNode === currentNode && conn.userData.toNode === otherNode) ||
                             (conn.userData.fromNode === otherNode && conn.userData.toNode === currentNode))
                        );
                        
                        if (connectionExists) continue;
                        
                        // Connect adjacent words (distance 2-3) with higher probability
                        if (textDistance === 2) {
                            // Always connect distance 2
                            const result = createConnection(currentNode, otherNode);
                            if (result) additionalConnectionsCreated++;
                        } else if (textDistance === 3 && Math.random() > 0.5) {
                            // 50% chance for distance 3
                            const result = createConnection(currentNode, otherNode);
                            if (result) additionalConnectionsCreated++;
                        }
                    }
                }
                
                // Connect words of the same POS that are close in text order and same paragraph
                if (currentNode.userData.wordData) {
                    const samePOSNodes = nodes.filter(n => {
                        if (!n || !n.userData || !n.userData.wordData) return false;
                        const nIndex = n.userData.index;
                        if (nIndex === undefined) return false;
                        const nParagraph = Math.floor(nIndex / wordsPerParagraph);
                        return n.userData.wordData.pos === currentNode.userData.wordData.pos &&
                               n !== currentNode &&
                               Math.abs(nIndex - currentIndex) <= 5 &&
                               nParagraph === paragraphIndex; // Only same paragraph
                    });
                    
                    // Connect to 1-2 same POS nodes that are nearby in text
                    const numSamePOS = Math.min(2, samePOSNodes.length);
                    for (let k = 0; k < numSamePOS; k++) {
                        const targetNode = samePOSNodes[Math.floor(Math.random() * samePOSNodes.length)];
                        if (targetNode && !connections.some(conn => 
                            conn.userData &&
                            ((conn.userData.fromNode === currentNode && conn.userData.toNode === targetNode) ||
                             (conn.userData.fromNode === targetNode && conn.userData.toNode === currentNode))
                        )) {
                            const result = createConnection(currentNode, targetNode);
                            if (result) additionalConnectionsCreated++;
                        }
                    }
                }
            }
            console.log(`Created ${additionalConnectionsCreated} additional connections`);
            
            // STEP 3: Final verification - ensure every node has at least one connection
            const nodesWithoutConnections = [];
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (!node || !node.userData) continue;
                
                const hasConnection = connections.some(conn => 
                    conn.userData && 
                    (conn.userData.fromNode === node || conn.userData.toNode === node)
                );
                
                if (!hasConnection) {
                    nodesWithoutConnections.push(i);
                }
            }
            
            if (nodesWithoutConnections.length > 0) {
                console.warn(`Found ${nodesWithoutConnections.length} nodes without connections in createParagraphsConnections, fixing...`);
                nodesWithoutConnections.forEach(nodeIndex => {
                    const node = nodes[nodeIndex];
                    if (!node) return;
                    
                    // Connect to adjacent nodes
                    const candidates = [
                        nodes[nodeIndex - 1],
                        nodes[nodeIndex + 1]
                    ].filter(n => n && n.userData);
                    
                    for (const candidate of candidates) {
                        if (!candidate) continue;
                        
                        const connectionExists = connections.some(conn => 
                            conn.userData && 
                            ((conn.userData.fromNode === node && conn.userData.toNode === candidate) ||
                             (conn.userData.fromNode === candidate && conn.userData.toNode === node))
                        );
                        
                        if (!connectionExists) {
                            const result = createConnection(node, candidate);
                            if (result) break; // Found a connection, move to next node
                        }
                    }
                });
            }
            
            console.log(`createParagraphsConnections: Final connection count: ${connections.length}`);
        }
        
        function createNarrativeConnections() {
            // Connection pattern for very long narrative text
            // CRITICAL: Always ensure connections are created, especially for very long texts
            const totalNodes = nodes.length;
            let totalConnectionsCreated = 0;
            
            // CRITICAL STEP 1: Always connect adjacent nodes FIRST (this should NEVER fail)
            // This ensures every node has at least one connection
            console.log(`Creating adjacent connections for ${totalNodes} nodes...`);
            for (let i = 0; i < nodes.length - 1; i++) {
                const currentNode = nodes[i];
                const nextNode = nodes[i + 1];
                
                if (!currentNode || !nextNode || !currentNode.userData || !nextNode.userData) {
                    continue;
                }
                
                // Check if connection already exists
                const connectionExists = connections.some(conn => 
                    conn.userData && 
                    ((conn.userData.fromNode === currentNode && conn.userData.toNode === nextNode) ||
                     (conn.userData.fromNode === nextNode && conn.userData.toNode === currentNode))
                );
                
                if (!connectionExists) {
                    const result = createConnection(currentNode, nextNode);
                    if (result) {
                        totalConnectionsCreated++;
                    } else {
                        console.warn(`Failed to create adjacent connection between nodes ${i} and ${i + 1}`);
                    }
                }
            }
            console.log(`Created ${totalConnectionsCreated} adjacent connections`);
            
            // CRITICAL STEP 2: Connect nodes within a reasonable range
            // For very long texts, use a larger range but ensure we don't create too many connections
            const maxConnectionsPerNode = Math.min(8, Math.floor(totalNodes / 10) + 3); // Adaptive limit
            const adjacentRange = Math.min(6, Math.floor(totalNodes / 50) + 3); // Adaptive range
            
            console.log(`Creating additional connections (max ${maxConnectionsPerNode} per node, range ${adjacentRange})...`);
            
            for (let i = 0; i < nodes.length; i++) {
                const currentNode = nodes[i];
                if (!currentNode || !currentNode.userData) continue;
                
                const currentIndex = currentNode.userData.index;
                if (currentIndex === undefined) {
                    // Fallback: use array index
                    const fallbackIndex = i;
                    // Try to connect to nearby nodes by array position
                    for (let j = Math.max(0, i - adjacentRange); j < Math.min(nodes.length, i + adjacentRange + 1); j++) {
                        if (i === j) continue;
                        const otherNode = nodes[j];
                        if (!otherNode || !otherNode.userData) continue;
                        
                        // Check current connection count for this node
                        const currentConnections = connections.filter(conn => 
                            conn.userData && 
                            (conn.userData.fromNode === currentNode || conn.userData.toNode === currentNode)
                        ).length;
                        
                        if (currentConnections >= maxConnectionsPerNode) break;
                        
                        const connectionExists = connections.some(conn => 
                            conn.userData && 
                            ((conn.userData.fromNode === currentNode && conn.userData.toNode === otherNode) ||
                             (conn.userData.fromNode === otherNode && conn.userData.toNode === currentNode))
                        );
                        
                        if (!connectionExists) {
                            const result = createConnection(currentNode, otherNode);
                            if (result) totalConnectionsCreated++;
                        }
                    }
                    continue;
                }
                
                let connectionCount = connections.filter(conn => 
                    conn.userData && 
                    (conn.userData.fromNode === currentNode || conn.userData.toNode === currentNode)
                ).length;
                
                // Connect to adjacent words in the text (semantic proximity)
                for (let j = Math.max(0, i - adjacentRange); j < Math.min(nodes.length, i + adjacentRange + 1) && connectionCount < maxConnectionsPerNode; j++) {
                    if (i === j) continue;
                    
                    const otherNode = nodes[j];
                    if (!otherNode || !otherNode.userData) continue;
                    
                    // Handle both regular nodes and noun groups
                    let otherIndex = otherNode.userData.index;
                    if (otherIndex === undefined) {
                        // Fallback: use array index
                        otherIndex = j;
                    }
                    
                    // Calculate semantic distance based on text position
                    const textDistance = Math.abs(currentIndex - otherIndex);
                    
                    // Connect adjacent words (distance 1-5) - always connect
                    if (textDistance <= 5) {
                        // Check if connection already exists
                        const connectionExists = connections.some(conn => 
                            conn.userData && 
                            ((conn.userData.fromNode === currentNode && conn.userData.toNode === otherNode) ||
                             (conn.userData.fromNode === otherNode && conn.userData.toNode === currentNode))
                        );
                        
                        if (!connectionExists) {
                            const result = createConnection(currentNode, otherNode);
                            if (result) {
                                connectionCount++;
                                totalConnectionsCreated++;
                            }
                        }
                    }
                }
                
                // Connect words of the same POS that are close in text order (limited to avoid performance issues)
                if (connectionCount < maxConnectionsPerNode && currentNode.userData.wordData) {
                    const samePOSNodes = nodes.filter(n => {
                        if (!n || !n.userData || !n.userData.wordData) return false;
                        const nIndex = n.userData.index !== undefined ? n.userData.index : nodes.indexOf(n);
                        const cIndex = currentIndex !== undefined ? currentIndex : i;
                        return n.userData.wordData.pos === currentNode.userData.wordData.pos &&
                               n !== currentNode &&
                               Math.abs(nIndex - cIndex) <= 15 && // Increased range for long texts
                               Math.abs(nIndex - cIndex) > 5; // But not too close (already connected above)
                    });
                    
                    // Connect to 1-3 same POS nodes that are nearby in text
                    const numSamePOS = Math.min(3, samePOSNodes.length, maxConnectionsPerNode - connectionCount);
                    for (let k = 0; k < numSamePOS; k++) {
                        const targetNode = samePOSNodes[Math.floor(Math.random() * samePOSNodes.length)];
                        if (targetNode && targetNode.userData) {
                            const connectionExists = connections.some(conn => 
                                conn.userData && 
                                ((conn.userData.fromNode === currentNode && conn.userData.toNode === targetNode) ||
                                 (conn.userData.fromNode === targetNode && conn.userData.toNode === currentNode))
                            );
                            
                            if (!connectionExists) {
                                const result = createConnection(currentNode, targetNode);
                                if (result) {
                                    connectionCount++;
                                    totalConnectionsCreated++;
                                }
                            }
                        }
                    }
                }
            }
            
            console.log(`Total connections created in createNarrativeConnections: ${totalConnectionsCreated}`);
            
            // CRITICAL STEP 3: Final verification - ensure every node has at least one connection
            const nodesWithoutConnections = [];
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (!node || !node.userData) continue;
                
                const hasConnection = connections.some(conn => 
                    conn.userData && 
                    (conn.userData.fromNode === node || conn.userData.toNode === node)
                );
                
                if (!hasConnection) {
                    nodesWithoutConnections.push(i);
                }
            }
            
            // Connect any nodes without connections to their nearest neighbors
            if (nodesWithoutConnections.length > 0) {
                console.warn(`Found ${nodesWithoutConnections.length} nodes without connections, fixing...`);
                nodesWithoutConnections.forEach(nodeIndex => {
                    const node = nodes[nodeIndex];
                    if (!node) return;
                    
                    // Try to connect to adjacent nodes
                    const candidates = [
                        nodes[nodeIndex - 1],
                        nodes[nodeIndex + 1],
                        nodes[nodeIndex - 2],
                        nodes[nodeIndex + 2]
                    ].filter(n => n && n.userData);
                    
                    for (const candidate of candidates) {
                        if (!candidate) continue;
                        
                        const connectionExists = connections.some(conn => 
                            conn.userData && 
                            ((conn.userData.fromNode === node && conn.userData.toNode === candidate) ||
                             (conn.userData.fromNode === candidate && conn.userData.toNode === node))
                        );
                        
                        if (!connectionExists) {
                            const result = createConnection(node, candidate);
                            if (result) {
                                totalConnectionsCreated++;
                                break; // Found a connection, move to next node
                            }
                        }
                    }
                });
            }
            
            console.log(`Final connection count: ${connections.length} (created ${totalConnectionsCreated} new connections)`);
        }

        function createConnection(fromNode, toNode) {
            // Validate nodes
            if (!fromNode || !toNode || !fromNode.userData || !toNode.userData) {
                console.warn('Invalid nodes for connection');
                return null;
            }
            
            // Get actual position (handle groups)
            const fromPos = fromNode.position.clone();
            const toPos = toNode.position.clone();
            
            // Validate positions
            if (!fromPos || !toPos || 
                !isFinite(fromPos.x) || !isFinite(fromPos.y) || !isFinite(fromPos.z) ||
                !isFinite(toPos.x) || !isFinite(toPos.y) || !isFinite(toPos.z)) {
                console.warn('Invalid positions for connection', fromPos, toPos);
                return null;
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints([
                fromPos,
                toPos
            ]);
            
            // Get actual colors from the nodes using getValueBasedColor
            const fromWordData = fromNode.userData.wordData;
            const toWordData = toNode.userData.wordData;
            const fromIndex = fromNode.userData.index !== undefined ? fromNode.userData.index : 0;
            const toIndex = toNode.userData.index !== undefined ? toNode.userData.index : 0;
            
            // Get colors from nodes
            const fromColor = fromWordData ? getValueBasedColor(fromWordData, fromIndex, analyzedWords) : 0x808080;
            const toColor = toWordData ? getValueBasedColor(toWordData, toIndex, analyzedWords) : 0x808080;
            
            // Check if both nodes are yellow (0xffff00) or white (0xffffff)
            const yellowColor = 0xffff00;
            const whiteColor = 0xffffff;
            const bothAreYellow = (fromColor === yellowColor && toColor === yellowColor);
            const bothAreWhite = (fromColor === whiteColor && toColor === whiteColor);
            
            // Get values to determine which node has higher value
            const fromValue = fromWordData && fromWordData.finalValue !== undefined 
                ? fromWordData.finalValue 
                : (fromWordData && fromWordData.normalizedScore !== undefined ? fromWordData.normalizedScore : 0);
            const toValue = toWordData && toWordData.finalValue !== undefined 
                ? toWordData.finalValue 
                : (toWordData && toWordData.normalizedScore !== undefined ? toWordData.normalizedScore : 0);
            
            let connectionColor;
            
            // If both nodes are white, use brighter white for the connection line
            if (bothAreWhite) {
                connectionColor = 0xffffff; // Bright white for connections between white nodes
            } else if (bothAreYellow) {
                connectionColor = 0xffffff; // White for connections between yellow nodes
            } else {
                // Determine which node has higher value (predominates)
                const higherValue = Math.max(fromValue, toValue);
                const lowerValue = Math.min(fromValue, toValue);
                const higherValueColor = fromValue >= toValue ? fromColor : toColor;
                const lowerValueColor = fromValue >= toValue ? toColor : fromColor;
                
                // Mix colors: 70% from higher value node, 30% from lower value node
                // This makes the higher value node's color predominate
                const mixRatio = 0.7; // 70% higher value color, 30% lower value color
                
                // Convert hex colors to RGB
                const getRGB = (hex) => {
                    return {
                        r: (hex >> 16) & 0xFF,
                        g: (hex >> 8) & 0xFF,
                        b: hex & 0xFF
                    };
                };
                
                const higherRGB = getRGB(higherValueColor);
                const lowerRGB = getRGB(lowerValueColor);
                
                // Mix colors
                let mixedR = Math.round(higherRGB.r * mixRatio + lowerRGB.r * (1 - mixRatio));
                let mixedG = Math.round(higherRGB.g * mixRatio + lowerRGB.g * (1 - mixRatio));
                let mixedB = Math.round(higherRGB.b * mixRatio + lowerRGB.b * (1 - mixRatio));
                
                // Increase brightness for better visibility against blue background
                // Apply a brightness boost to make lines more visible
                const brightnessBoost = 1.3; // Increase brightness by 30%
                mixedR = Math.min(255, Math.round(mixedR * brightnessBoost));
                mixedG = Math.min(255, Math.round(mixedG * brightnessBoost));
                mixedB = Math.min(255, Math.round(mixedB * brightnessBoost));
                
                // Convert back to hex
                connectionColor = (mixedR << 16) | (mixedG << 8) | mixedB;
            }
            
            // Calculate opacity based on average value
            const avgValue = (fromValue + toValue) / 2;
            const normalizedAvg = Math.min(1.0, Math.max(0.0, avgValue));
            
            // For white connections, use higher opacity for better visibility
            // For other connections, use slightly lower opacity to make them appear thinner
            let lineOpacity;
            if (bothAreWhite) {
                lineOpacity = 0.85 + (normalizedAvg * 0.1); // 0.85-0.95 for white connections (brighter)
            } else {
                lineOpacity = 0.6 + (normalizedAvg * 0.15); // 0.6-0.75 for other connections (thinner appearance)
            }
            
            const material = new THREE.LineBasicMaterial({
                color: connectionColor,
                transparent: true,
                opacity: lineOpacity
            });
            
            const line = new THREE.Line(geometry, material);
            line.userData = {
                fromNode: fromNode,
                toNode: toNode
            };
            
            // Update connection counts (handle both regular nodes and noun groups)
            if (fromNode.userData) {
                fromNode.userData.connectionCount = (fromNode.userData.connectionCount || 0) + 1;
                if (fromNode.userData.wordData) {
                    fromNode.userData.wordData.connectionCount = (fromNode.userData.wordData.connectionCount || 0) + 1;
                }
            }
            if (toNode.userData) {
                toNode.userData.connectionCount = (toNode.userData.connectionCount || 0) + 1;
                if (toNode.userData.wordData) {
                    toNode.userData.wordData.connectionCount = (toNode.userData.wordData.connectionCount || 0) + 1;
                }
            }
            
            // CRITICAL: Always add connection to scene - SIMPLIFIED AND FORCED
            // Check if connection already exists
            const connectionExists = connections.some(conn => 
                conn && conn.userData && 
                ((conn.userData.fromNode === fromNode && conn.userData.toNode === toNode) ||
                 (conn.userData.fromNode === toNode && conn.userData.toNode === fromNode))
            );
            
            if (connectionExists) {
                // Connection already exists, dispose resources and return existing
                geometry.dispose();
                material.dispose();
                const existingConn = connections.find(conn => 
                    conn && conn.userData && 
                    ((conn.userData.fromNode === fromNode && conn.userData.toNode === toNode) ||
                     (conn.userData.fromNode === toNode && conn.userData.toNode === fromNode))
                );
                return existingConn || line;
            }
            
            // Validate scene exists
            if (!scene) {
                console.error('CRITICAL: Scene is null when trying to add connection');
                geometry.dispose();
                material.dispose();
                return null;
            }
            
            // Validate geometry
            if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                console.error('CRITICAL: Invalid geometry when trying to add connection');
                if (geometry) geometry.dispose();
                if (material) material.dispose();
                return null;
            }
            
            // FORCE ADD TO SCENE - Multiple attempts with different strategies
            let addedToScene = false;
            
            // Strategy 1: Direct add
            try {
                scene.add(line);
                if (scene.children.includes(line)) {
                    addedToScene = true;
                }
            } catch (e) {
                console.warn('Direct add failed:', e);
            }
            
            // Strategy 2: If not added, try adding to scene.children directly
            if (!addedToScene) {
                try {
                    scene.children.push(line);
                    if (scene.children.includes(line)) {
                        addedToScene = true;
                        console.log('Added connection via direct push to scene.children');
                    }
                } catch (e) {
                    console.warn('Direct push failed:', e);
                }
            }
            
            // Strategy 3: Create new line and add
            if (!addedToScene) {
                try {
                    const newGeometry = new THREE.BufferGeometry().setFromPoints([fromPos, toPos]);
                    const newLine = new THREE.Line(newGeometry, material.clone());
                    newLine.userData = { fromNode: fromNode, toNode: toNode };
                    scene.add(newLine);
                    if (scene.children.includes(newLine)) {
                        geometry.dispose();
                        line = newLine;
                        addedToScene = true;
                        console.log('Created new line and added successfully');
                    }
                } catch (e) {
                    console.error('Failed to create new line:', e);
                }
            }
            
            // If still not added, this is a critical error
            if (!addedToScene) {
                console.error('CRITICAL: Failed to add connection to scene after all strategies');
                console.error('From node:', fromNode, 'To node:', toNode);
                console.error('From pos:', fromPos, 'To pos:', toPos);
                console.error('Scene children count:', scene.children.length);
                geometry.dispose();
                material.dispose();
                return null;
            }
            
            // Add to connections array
            connections.push(line);
            
            // Log first few connections for debugging
            if (connections.length <= 10) {
                console.log(`âœ“ Connection ${connections.length} created and added to scene`);
            }
            
            return line;
        }

        function updateConnections() {
            connections.forEach(connection => {
                const fromNode = connection.userData.fromNode;
                const toNode = connection.userData.toNode;
                
                // Get actual position (handle groups for nouns)
                const fromPos = fromNode.userData.isNoun ? fromNode.position : fromNode.position;
                const toPos = toNode.userData.isNoun ? toNode.position : toNode.position;
                
                const points = [fromPos, toPos];
                connection.geometry.setFromPoints(points);
            });
        }

        function clearScene() {
            // First, remove all convergence zones and their groups from scene
            convergenceZones.forEach(zone => {
                if (zone.group) {
                    // Dispose all children (violet nodes and lines) before removing group
                    zone.group.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    // Remove the entire group from scene
                    scene.remove(zone.group);
                }
            });
            
            // Remove all nodes from scene (including convergence nodes)
            // Make a copy of the array to avoid issues while iterating
            const nodesToRemove = [...nodes];
            nodesToRemove.forEach(node => {
                // Remove node from scene
                if (node.parent) {
                    node.parent.remove(node);
                } else {
                    scene.remove(node);
                }
                // Dispose geometry and materials
                if (node.isGroup) {
                    node.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                } else {
                    if (node.geometry) node.geometry.dispose();
                    if (node.material) node.material.dispose();
                }
            });
            
            // Remove all connections
            connections.forEach(conn => {
                if (conn.parent) {
                    conn.parent.remove(conn);
                } else {
                    scene.remove(conn);
                }
                if (conn.geometry) conn.geometry.dispose();
                if (conn.material) conn.material.dispose();
            });
            
            // Clear arrays
            convergenceZones = [];
            nodes = [];
            connections = [];
            
            // Reset convergence total value
            window.convergenceTotalValue = 0;
            
            removeNametags();
            nametagsVisible = false;
            const toggleBtn = document.getElementById('toggleNametagsBtn');
            if (toggleBtn) toggleBtn.textContent = 'SHOW NAMETAGS';
            
            // Update convergence zone button state
            updateConvergenceZoneButton();
            
            // Clear max-value-panel
            maxValueNode = null;
            if (maxValuePanelMesh) {
                if (maxValuePanelScene) {
                    maxValuePanelScene.remove(maxValuePanelMesh);
                }
                if (maxValuePanelMesh.geometry) maxValuePanelMesh.geometry.dispose();
                if (maxValuePanelMesh.material) maxValuePanelMesh.material.dispose();
                if (maxValuePanelMesh.children) {
                    maxValuePanelMesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
                maxValuePanelMesh = null;
            }
            if (maxValuePanelAnimationId) {
                cancelAnimationFrame(maxValuePanelAnimationId);
                maxValuePanelAnimationId = null;
            }
            
            // Clear max-value-panel fields (check if elements exist)
            const maxValuePanelWordEl = document.getElementById('max-value-panel-word');
            const maxValueWordEl = document.getElementById('max-value-word');
            const maxValueIndividualValueEl = document.getElementById('max-value-individual-value');
            const maxValuePositionEl = document.getElementById('max-value-position');
            const maxValueRelativeValueEl = document.getElementById('max-value-relative-value');
            const maxValueConnectionsEl = document.getElementById('max-value-connections');
            const maxValueSizeEl = document.getElementById('max-value-size');
            const maxValuePerformanceEl = document.getElementById('max-value-performance');
            const maxValue3DCoordsEl = document.getElementById('max-value-3d-coords');
            
            if (maxValuePanelWordEl) maxValuePanelWordEl.textContent = '-';
            if (maxValueWordEl) maxValueWordEl.textContent = '-';
            if (maxValueIndividualValueEl) maxValueIndividualValueEl.textContent = '-';
            if (maxValuePositionEl) maxValuePositionEl.textContent = '-';
            if (maxValueRelativeValueEl) maxValueRelativeValueEl.textContent = '-';
            if (maxValueConnectionsEl) maxValueConnectionsEl.textContent = '-';
            if (maxValueSizeEl) maxValueSizeEl.textContent = '-';
            if (maxValuePerformanceEl) maxValuePerformanceEl.textContent = '-';
            if (maxValue3DCoordsEl) maxValue3DCoordsEl.textContent = '-';
            
            // Clear node list
            if (nodeListVisible) {
                const container = document.getElementById('node-list-container');
                container.classList.remove('visible');
                clearNodeList();
                nodeListVisible = false;
                const nodeListBtn = document.getElementById('nodeListBtn');
                if (nodeListBtn) nodeListBtn.textContent = 'TOP NODES';
            }
        }

        // ==================== LOADING MODAL FUNCTIONS ====================
        let loadingDotsInterval = null;
        
        function showLoadingModal() {
            const modal = document.getElementById('api-loading-modal');
            const generateBtn = document.getElementById('generateBtn');
            
            if (modal) {
                modal.style.display = 'block';
                // Start dots animation
                startLoadingDotsAnimation();
                // Start progress bar animation
                startLoadingProgressBar();
            }
            
            // Disable Export Body button
            if (generateBtn) {
                generateBtn.disabled = true;
                generateBtn.style.opacity = '0.5';
                generateBtn.style.cursor = 'not-allowed';
            }
        }
        
        function hideLoadingModal() {
            const modal = document.getElementById('api-loading-modal');
            const generateBtn = document.getElementById('generateBtn');
            
            if (modal) {
                modal.style.display = 'none';
                // Stop dots animation
                stopLoadingDotsAnimation();
                // Stop and reset progress bar
                stopLoadingProgressBar();
            }
            
            // Enable Export Body button (will be updated by updateButtonStates based on text)
            updateButtonStates();
        }
        
        // Show purchase success message
        function showPurchaseSuccessMessage() {
            const modal = document.getElementById('purchase-success-modal');
            if (modal) {
                modal.style.display = 'block';
            }
        }
        
        // Hide purchase success message
        function hidePurchaseSuccessMessage() {
            const modal = document.getElementById('purchase-success-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function startLoadingDotsAnimation() {
            const dotsElement = document.getElementById('loading-dots');
            if (!dotsElement) return;
            
            let dotCount = 0;
            loadingDotsInterval = setInterval(() => {
                dotCount = (dotCount + 1) % 4; // 0, 1, 2, 3
                dotsElement.textContent = '.'.repeat(dotCount);
            }, 500); // Change every 500ms
        }
        
        function stopLoadingDotsAnimation() {
            if (loadingDotsInterval) {
                clearInterval(loadingDotsInterval);
                loadingDotsInterval = null;
            }
            const dotsElement = document.getElementById('loading-dots');
            if (dotsElement) {
                dotsElement.textContent = '...';
            }
        }
        
        let loadingProgressInterval = null;
        let loadingProgressAnimationId = null;
        let currentProgress = 0;
        let progressSimulatorInterval = null;
        let continuousProgressInterval = null; // Continuous progress that never stops
        let targetProgress = 100; // Target progress for continuous animation
        let progressSpeed = 0.1; // Speed of progress (percentage per 50ms)
        
        function getColorForProgress(progressPercent) {
            // Blue (0%) -> Violet (50%) -> Red (100%)
            // Blue: #0000ff (0, 0, 255)
            // Violet: #8000ff (128, 0, 255)
            // Red: #ff0000 (255, 0, 0)
            
            let r, g, b;
            if (progressPercent < 50) {
                // Blue to Violet: 0-50%
                const factor = progressPercent / 50;
                r = Math.round(0 + (128 - 0) * factor);
                g = Math.round(0 + (0 - 0) * factor);
                b = Math.round(255 + (255 - 255) * factor); // Stay at 255
            } else {
                // Violet to Red: 50-100%
                const factor = (progressPercent - 50) / 50;
                r = Math.round(128 + (255 - 128) * factor);
                g = Math.round(0 + (0 - 0) * factor);
                b = Math.round(255 + (0 - 255) * factor);
            }
            
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }
        
        function updateLoadingProgress(percent) {
            const progressBar = document.getElementById('loading-progress-bar');
            if (!progressBar) return;
            
            // Update current progress, but don't override if continuous progress is running
            // The continuous progress will handle the actual updates
            const newProgress = Math.max(0, Math.min(100, percent));
            if (newProgress > currentProgress || !continuousProgressInterval) {
                currentProgress = newProgress;
            }
            
            progressBar.style.width = currentProgress + '%';
            progressBar.style.background = getColorForProgress(currentProgress);
        }
        
        function startProgressSimulator(textLength, targetProgress, duration) {
            // Stop any existing simulator
            if (progressSimulatorInterval) {
                clearInterval(progressSimulatorInterval);
            }
            
            const startProgress = currentProgress;
            const progressDiff = targetProgress - startProgress;
            const startTime = Date.now();
            
            progressSimulatorInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(targetProgress, startProgress + (progressDiff * (elapsed / duration)));
                updateLoadingProgress(progress);
                
                if (progress >= targetProgress) {
                    clearInterval(progressSimulatorInterval);
                    progressSimulatorInterval = null;
                }
            }, 50); // Update every 50ms for smooth animation
        }
        
        function stopProgressSimulator() {
            if (progressSimulatorInterval) {
                clearInterval(progressSimulatorInterval);
                progressSimulatorInterval = null;
            }
        }
        
        function startLoadingProgressBar() {
            const progressBar = document.getElementById('loading-progress-bar');
            if (!progressBar) return;
            
            // Reset progress bar
            currentProgress = 0;
            targetProgress = 100;
            progressBar.style.width = '0%';
            progressBar.style.background = '#0000ff'; // Start with blue
            
            // Stop any existing progress simulators
            stopProgressSimulator();
            stopContinuousProgress();
            
            // Start continuous progress that never stops
            startContinuousProgress();
        }
        
        function startContinuousProgress() {
            // Stop any existing continuous progress
            if (continuousProgressInterval) {
                clearInterval(continuousProgressInterval);
            }
            
            // Start continuous progress animation that always advances
            continuousProgressInterval = setInterval(() => {
                // Always advance progress, but respect targetProgress
                if (currentProgress < targetProgress) {
                    // Calculate increment based on remaining progress and speed
                    const remaining = targetProgress - currentProgress;
                    const increment = Math.max(0.05, Math.min(progressSpeed, remaining * 0.1)); // At least 0.05% per update, max speed or 10% of remaining
                    currentProgress = Math.min(targetProgress, currentProgress + increment);
                    updateLoadingProgress(currentProgress);
                } else if (currentProgress < 100) {
                    // If we've reached target but not 100%, continue slowly
                    currentProgress = Math.min(100, currentProgress + 0.05);
                    updateLoadingProgress(currentProgress);
                }
                
                // Stop if we've reached 100%
                if (currentProgress >= 100) {
                    stopContinuousProgress();
                }
            }, 50); // Update every 50ms for smooth animation
        }
        
        function stopContinuousProgress() {
            if (continuousProgressInterval) {
                clearInterval(continuousProgressInterval);
                continuousProgressInterval = null;
            }
        }
        
        function setProgressSpeed(speed) {
            // Speed: percentage per 50ms
            // Higher speed = faster progress
            progressSpeed = Math.max(0.05, Math.min(2.0, speed)); // Clamp between 0.05% and 2% per 50ms
        }
        
        function setTargetProgress(target) {
            // Set target progress (the bar will advance towards this target)
            targetProgress = Math.max(currentProgress, Math.min(100, target));
        }
        
        function stopLoadingProgressBar() {
            if (loadingProgressAnimationId) {
                cancelAnimationFrame(loadingProgressAnimationId);
                loadingProgressAnimationId = null;
            }
            stopProgressSimulator();
            stopContinuousProgress();
            const progressBar = document.getElementById('loading-progress-bar');
            if (progressBar) {
                currentProgress = 0;
                targetProgress = 100;
                progressBar.style.width = '0%';
                progressBar.style.background = '#0000ff';
            }
        }
        
        // ==================== GENERACIÃ“N DE VISUALIZACIÃ“N ====================
        async function generateVisualization() {
            // If viewing a purchase, restore normal mode first
            if (isViewingPurchase) {
                returnToInputMode();
            }
            
            // Hide right panel if visible (since we're generating a new visualization)
            // Hide all right panels
            hideNodeDetails();
            
            const text = document.getElementById('textInput').value.trim();
            
            // Check if there's text before proceeding
            if (!text || text.length === 0) {
                return;
            }
            
            if (!text) {
                alert('Please enter some text');
                return;
            }
            
            // Limpiar escena anterior
            clearScene();
            
            // Si GALLERY estÃ¡ activo, ocultarlo
            if (galleryVisible) {
                const container = document.getElementById('node-list-container');
                if (container) {
                    container.classList.remove('visible');
                }
                if (typeof clearGallery === 'function') {
                    clearGallery();
                }
                galleryVisible = false;
                closeLeaderboardRightPanel();
            }
            
            // Store generation date/time
            visualizationGenerationDate = new Date();
            
            // Show loading modal
            showLoadingModal();
            
            try {
                const textLength = text.length;
                const tokenCount = text.trim().split(/\s+/).length;
                
                // Calculate duration and speed based on text length
                // MÃ¡s rÃ¡pido si < 10 palabras
                // RÃ¡pido si >= 10 y < 100 palabras
                // Medio si >= 100 y < 300 palabras
                // Lento si >= 300 y < 500 palabras
                let totalDuration;
                let baseSpeed;
                if (tokenCount < 10) {
                    totalDuration = 1000 + (tokenCount * 50); // 1-1.5 seconds (mÃ¡s rÃ¡pido)
                    baseSpeed = 1.5; // Fast speed: 1.5% per 50ms
                } else if (tokenCount < 100) {
                    totalDuration = 2000 + ((tokenCount - 10) * 30); // 2-4.7 seconds (rÃ¡pido)
                    baseSpeed = 1.0; // Fast speed: 1.0% per 50ms
                } else if (tokenCount < 300) {
                    totalDuration = 5000 + ((tokenCount - 100) * 25); // 5-10 seconds (medio)
                    baseSpeed = 0.5; // Medium speed: 0.5% per 50ms
                } else if (tokenCount < 500) {
                    totalDuration = 10000 + ((tokenCount - 300) * 30); // 10-16 seconds (lento)
                    baseSpeed = 0.3; // Slow speed: 0.3% per 50ms
                } else {
                    totalDuration = 16000; // MÃ¡ximo 16 segundos para textos muy largos
                    baseSpeed = 0.2; // Very slow speed: 0.2% per 50ms
                }
                
                // Set initial progress speed
                setProgressSpeed(baseSpeed);
                
                // Step 1: Tokenization (0% -> 10%)
                setTargetProgress(10);
                
                // Analizar texto (wait for API response)
                // The progress will advance continuously during analyzeText execution
                await analyzeText(text);
                setTargetProgress(40); // analyzeText completes at 40%
                
                // If analyzeText failed, analyzedWords might be empty
                if (!analyzedWords || analyzedWords.length === 0) {
                    console.error('Visualization generation aborted: No words analyzed.');
                    setTargetProgress(100); // Ensure progress reaches 100% before hiding
                    await new Promise(resolve => setTimeout(resolve, 500));
                    hideLoadingModal();
                    return;
                }
                
                // Step 2: Score calculation (40% -> 70%)
                setTargetProgress(70);
                calculateScores();
                setTargetProgress(70); // Ensure we're at 70%
                
                // Step 3: Create 3D nodes (70% -> 95%)
                setTargetProgress(95);
                const progressPerNode = 25 / Math.max(1, analyzedWords.length);
                let nodeProgress = 70;
                
                // Reset value range cache before creating nodes
                cachedValueRange = null;
                
                analyzedWords.forEach((wordData, index) => {
                    create3DNode(wordData, index);
                    nodeProgress += progressPerNode;
                    // Update target progress smoothly during node creation
                    setTargetProgress(Math.min(95, nodeProgress));
                });
                setTargetProgress(95);
                
                // Step 4: Finalize (95% -> 100%)
                setTargetProgress(100);
                // Wait a bit to ensure progress reaches 100%
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // CRITICAL: Ensure all nodes have valid positions before creating connections
                // Wait a frame to ensure all nodes are fully initialized
                await new Promise(resolve => {
                    requestAnimationFrame(() => {
                        // Verify all nodes have valid positions
                        const nodesWithInvalidPositions = nodes.filter(node => {
                            if (!node || !node.userData) return true;
                            if (!node.position || 
                                !isFinite(node.position.x) || 
                                !isFinite(node.position.y) || 
                                !isFinite(node.position.z)) {
                                return true;
                            }
                            return false;
                        });
                        
                        if (nodesWithInvalidPositions.length > 0) {
                            console.warn(`Found ${nodesWithInvalidPositions.length} nodes with invalid positions, attempting to fix...`);
                            // Try to fix nodes with invalid positions
                            nodesWithInvalidPositions.forEach(node => {
                                if (node && node.userData && node.userData.index !== undefined) {
                                    // Try to get position from wordData or set default
                                    const index = node.userData.index;
                                    if (!node.position || !isFinite(node.position.x)) {
                                        // Set a default position based on index
                                        const angle = (index / Math.max(analyzedWords.length, 1)) * Math.PI * 2;
                                        const radius = 5;
                                        node.position.set(
                                            Math.cos(angle) * radius,
                                            Math.sin(angle) * radius * 0.5,
                                            Math.sin(angle * 2) * radius * 0.3
                                        );
                                        console.log(`Fixed position for node ${index}`);
                                    }
                                }
                            });
                        }
                        
                        resolve();
                    });
                });
                
                // Crear conexiones
                createConnections();
                
                // Detectar convergencias entre esferas y crear zonas de convergencia
                await detectAndCreateConvergenceZones();
                
                // Actualizar estadÃ­sticas
                updateStats();
                
                // Update max value panel
                updateMaxValuePanel();
            } catch (error) {
                console.error('Error during visualization generation:', error);
            } finally {
                // CRITICAL: Ensure progress bar reaches 100% before hiding modal
                updateLoadingProgress(100);
                // Wait a moment to ensure the progress bar is fully updated
                await new Promise(resolve => setTimeout(resolve, 300));
                // Hide loading modal
                hideLoadingModal();
                // Enable Map Text and related buttons after body is exported
                enableMapTextButtons();
                
                // Auto-collapse text box after importing text (if not already collapsed)
                const leftPanel = document.getElementById('left-panel');
                const textContainer = document.getElementById('text-container');
                if (leftPanel && textContainer && !leftPanel.classList.contains('collapsed')) {
                    toggleTextBox();
                }
            }
        }
        
        // Function to disable Map Text and related buttons
        function disableMapTextButtons() {
            const mapTextBtn = document.getElementById('mapTextBtn');
            const nodeListBtn = document.getElementById('nodeListBtn');
            const toggleNametagsBtn = document.getElementById('toggleNametagsBtn');
            const resetCameraBtn = document.getElementById('resetCameraBtn');
            
            if (mapTextBtn) {
                mapTextBtn.disabled = true;
                mapTextBtn.style.opacity = '0.4';
                mapTextBtn.style.cursor = 'not-allowed';
            }
            if (nodeListBtn) {
                nodeListBtn.disabled = true;
                nodeListBtn.style.opacity = '0.4';
                nodeListBtn.style.cursor = 'not-allowed';
            }
            if (toggleNametagsBtn) {
                toggleNametagsBtn.disabled = true;
                toggleNametagsBtn.style.opacity = '0.4';
                toggleNametagsBtn.style.cursor = 'not-allowed';
            }
            if (resetCameraBtn) {
                resetCameraBtn.disabled = true;
                resetCameraBtn.style.opacity = '0.4';
                resetCameraBtn.style.cursor = 'not-allowed';
            }
        }
        
        // Function to enable Map Text and related buttons
        function enableMapTextButtons() {
            const mapTextBtn = document.getElementById('mapTextBtn');
            const nodeListBtn = document.getElementById('nodeListBtn');
            const toggleNametagsBtn = document.getElementById('toggleNametagsBtn');
            const resetCameraBtn = document.getElementById('resetCameraBtn');
            
            if (mapTextBtn) {
                mapTextBtn.disabled = false;
                mapTextBtn.style.opacity = '1';
                mapTextBtn.style.cursor = 'pointer';
            }
            if (nodeListBtn) {
                nodeListBtn.disabled = false;
                nodeListBtn.style.opacity = '1';
                nodeListBtn.style.cursor = 'pointer';
            }
            if (toggleNametagsBtn) {
                toggleNametagsBtn.disabled = false;
                toggleNametagsBtn.style.opacity = '1';
                toggleNametagsBtn.style.cursor = 'pointer';
            }
            if (resetCameraBtn) {
                resetCameraBtn.disabled = false;
                resetCameraBtn.style.opacity = '1';
                resetCameraBtn.style.cursor = 'pointer';
            }
        }

        // ==================== NAVEGACIÃ“N A CLAIM ====================
        // Variables para claim modal
        let claimScene = null;
        let claimCamera = null;
        let claimAnimationId = null;
        let sharedNodeListRenderer = null;
        let sharedNodeListScene = null;
        let sharedNodeListCamera = null;

        function navigateToClaim() {
            if (nodes.length === 0) {
                alert('No hay visualizaciÃ³n para reclamar. Genera una visualizaciÃ³n primero.');
                return;
            }
            
            const modal = document.getElementById('claim-modal');
            if (!modal) return;
            
            // Mostrar modal
            modal.style.display = 'block';
            modal.style.visibility = 'visible';
            modal.style.opacity = '1';
            
            // Inicializar contenido del modal
            initClaimModal();
        }

        function initClaimModal() {
            // Crear visualizaciÃ³n 3D
            initClaim3DScene();
            
            // Mostrar Total Value (idÃ©ntico al modal original)
            showClaimTotalValue();

            // Actualizar botÃ³n PURCHASE con el valor en ETH
            updateClaimPurchaseButton();

            // Resetear completamente la secciÃ³n expandida cuando se actualiza con nuevos datos
            const expandedSection = document.getElementById('claim-expanded-section');
            const expandBtn = document.getElementById('claim-expand-btn');
            const grid = document.getElementById('claim-top4-fractals-grid');
            const totalValueContainer = document.getElementById('claim-total-value-container');

            // Forzar ocultaciÃ³n de la secciÃ³n expandida
            if (expandedSection) {
                expandedSection.style.display = 'none';
                expandedSection.style.visibility = 'hidden';
            }
            if (expandBtn) {
                expandBtn.innerHTML = '<span>EXPAND</span><span style="font-size: 7px;">â†“</span>';
            }
            if (grid) {
                grid.innerHTML = '';
            }
            if (totalValueContainer) {
                totalValueContainer.style.height = '500px';
                totalValueContainer.style.minHeight = '500px';
            }
        }

        function initClaim3DScene() {
            const container = document.getElementById('claim-3d-container');
            if (!container) return;
            
            // Limpiar contenido previo
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // Limpiar escena anterior si existe
            if (claimScene) {
                claimScene.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
            if (claimAnimationId) {
                cancelAnimationFrame(claimAnimationId);
                claimAnimationId = null;
            }
            
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Usar el renderer principal en lugar de crear uno nuevo
            // Renderizar a una textura y luego mostrar en un canvas 2D
            claimScene = new THREE.Scene();
            claimScene.background = new THREE.Color(0x000000); // Fondo negro

            claimCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            
            // Calcular bounding box para ver todo el cuerpo
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            nodes.forEach(node => {
                const pos = node.position;
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y);
                minZ = Math.min(minZ, pos.z);
                maxZ = Math.max(maxZ, pos.z);
            });
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxSize = Math.max(sizeX, sizeY, sizeZ, 1);
            
            // Posicionar cÃ¡mara para ver todo el cuerpo (mÃ¡s cerca para que se vea mÃ¡s grande)
            const distance = maxSize * 1.8; // Reducido de 2.5 a 1.8 para hacer el cuerpo mÃ¡s grande
            claimCamera.position.set(centerX, centerY, centerZ + distance);
            claimCamera.lookAt(centerX, centerY, centerZ);

            // Luces
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            claimScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 5);
            claimScene.add(directionalLight);

            // Clonar nodos y conexiones
            nodes.forEach(node => {
                const clonedNode = node.isGroup ? node.clone(true) : node.clone();
                claimScene.add(clonedNode);
            });
            
            connections.forEach(connection => {
                const clonedConnection = connection.clone();
                claimScene.add(clonedConnection);
            });

            // Crear canvas 2D para mostrar la imagen renderizada
            const canvas2D = document.createElement('canvas');
            canvas2D.width = width;
            canvas2D.height = height;
            canvas2D.style.cssText = 'width: 100%; height: 100%; display: block;';
            container.appendChild(canvas2D);
            
            const ctx2D = canvas2D.getContext('2d');
            
            // Renderizar usando el renderer principal a una textura temporal
            const renderTarget = new THREE.WebGLRenderTarget(width, height);
            
            // Guardar estado del renderer principal
            const originalSize = renderer.getSize(new THREE.Vector2());
            const originalClearColor = renderer.getClearColor(new THREE.Color());
            
            // Renderizar una vez
            renderer.setRenderTarget(renderTarget);
            renderer.setClearColor(0x000000, 1); // Fondo negro
            renderer.render(claimScene, claimCamera);
            
            // Leer la textura y dibujarla en el canvas 2D
            const gl = renderer.getContext();
            const pixels = new Uint8Array(width * height * 4);
            renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, pixels);
            
            const imageData = ctx2D.createImageData(width, height);
            for (let i = 0; i < pixels.length; i += 4) {
                imageData.data[i] = pixels[i];     // R
                imageData.data[i + 1] = pixels[i + 1]; // G
                imageData.data[i + 2] = pixels[i + 2]; // B
                imageData.data[i + 3] = pixels[i + 3]; // A
            }
            ctx2D.putImageData(imageData, 0, 0);
            
            // Restaurar estado del renderer principal
            renderer.setRenderTarget(null);
            renderer.setSize(originalSize.x, originalSize.y);
            renderer.setClearColor(originalClearColor, 1);
            
            // Limpiar render target
            renderTarget.dispose();
            
            // Limpiar escena temporal
            claimScene.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
            claimScene = null;
        }

        function showClaimTotalValue() {
            const container = document.getElementById('claim-total-value-container');
            if (!container) return;
            
            // Limpiar contenido previo
            container.innerHTML = '';
            
            // Crear estructura idÃ©ntica al modal de Total Value
            const wrapper = document.createElement('div');
            wrapper.id = 'claim-total-value-wrapper';
            wrapper.style.cssText = 'position: relative; max-width: 100%; margin: 0;';
            
            // Get color mode from valueLogicColorMode
            const boxBg = valueLogicColorMode ? "#ffffff" : "#000000";
            const boxBorder = valueLogicColorMode ? "#000000" : "#ffffff";
            const textColor = valueLogicColorMode ? "#000000" : "#ffffff";
            const dividerColor = valueLogicColorMode ? "#cccccc" : "#333333";

            const content = document.createElement('div');
            content.id = 'claim-value-logic-content';
            content.style.cssText = `font-size: 11px; line-height: 1.1; color: ${textColor}; margin-top: 5px;`;
            
            const overviewContainer = document.createElement('div');
            overviewContainer.id = 'claim-value-logic-overview-container';
            overviewContainer.style.cssText = `width: 100%; max-width: 100%; height: 150px; background: ${boxBg}; border: 1px solid ${boxBorder}; margin-top: 5px; margin-bottom: 5px; border-radius: 0; position: relative; display: block; overflow: hidden; box-sizing: border-box;`;
            const overviewCanvas = document.createElement('canvas');
            overviewCanvas.id = 'claim-value-logic-overview-canvas';
            overviewCanvas.style.cssText = 'width: 100%; height: 100%; display: block;';
            overviewContainer.appendChild(overviewCanvas);
            
            const top5Grid = document.createElement('div');
            top5Grid.id = 'claim-value-logic-top5-grid';
            top5Grid.style.cssText = 'display: block; margin-top: 5px; margin-bottom: 5px;';
            
            const totalBox = document.createElement('div');
            totalBox.id = 'claim-value-logic-total-box';
            totalBox.style.cssText = `background: ${boxBg}; border: 1px solid ${boxBorder}; padding: 6px; margin-top: 5px; border-radius: 0; display: none;`;
            const totalDisplay = document.createElement('div');
            totalDisplay.style.cssText = `color: ${textColor}; font-size: 11px;`;
            totalDisplay.innerHTML = '<strong>Total Value:</strong> <span id="claim-value-logic-total-display">-</span>';
            totalBox.appendChild(totalDisplay);
            
            wrapper.appendChild(content);
            wrapper.appendChild(overviewContainer);
            wrapper.appendChild(top5Grid);
            wrapper.appendChild(totalBox);
            container.appendChild(wrapper);
            
            // Generar el contenido usando la misma lÃ³gica que showValueLogicSummary
            if (!analyzedWords || analyzedWords.length === 0) return;
            
            const totalWords = analyzedWords.length;
            const totalValuePoints = window.totalTextScore || analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
            const avgBaseValue = analyzedWords.reduce((sum, w) => sum + (w.baseValue || 0), 0) / totalWords;
            const avgFinalValuePoints = totalValuePoints / totalWords;
            
            let totalValueETH = 0;
            let avgFinalValueETH = 0;
            if (ethPriceUSD) {
                totalValueETH = totalValuePoints / ethPriceUSD;
                avgFinalValueETH = avgFinalValuePoints / ethPriceUSD;
            }
            
            const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                `${totalValueETH.toFixed(6)} ETH` : 
                `${totalValueETH.toFixed(10)} ETH`;
            const avgFinalValueETHDisplay = avgFinalValueETH >= 0.01 ? 
                `${avgFinalValueETH.toFixed(6)} ETH` : 
                `${avgFinalValueETH.toFixed(10)} ETH`;
                window.__totalValueEth = totalValueETH;
            window.__totalValueDisplay = totalValueETHDisplay;
            window.__createdAt = visualizationGenerationDate
            ? visualizationGenerationDate.toISOString()
            : new Date().toISOString();
            window.__rawText = (document.getElementById("textInput")?.value || "").trim();
            
            // Calcular multiplicadores promedio (reutilizar lÃ³gica existente)
            const avgLengthMultiplier = analyzedWords.reduce((sum, w) => sum + (w.lengthMultiplier || 1), 0) / totalWords;
            const avgOntologicalMultiplier = analyzedWords.reduce((sum, w) => sum + (w.ontologicalMultiplier || 1), 0) / totalWords;
            const avgNameWithToBeMultiplier = analyzedWords.reduce((sum, w) => sum + (w.nameWithToBeMultiplier || 1), 0) / totalWords;
            const avgSemanticMultiplier = analyzedWords.reduce((sum, w) => sum + (w.semanticMultiplier || 1), 0) / totalWords;
            const avgRepetitionMultiplier = analyzedWords.reduce((sum, w) => sum + (w.repetitionMultiplier || 1), 0) / totalWords;
            const avgTenseMultiplier = analyzedWords.reduce((sum, w) => sum + (w.tenseMultiplier || 1), 0) / totalWords;
            const avgNarrativePenalty = analyzedWords.reduce((sum, w) => sum + (w.narrativePenalty || 1), 0) / totalWords;
            
            // Contar tiempos verbales (reutilizar lÃ³gica existente)
            let presentCount = 0, pastCount = 0, futureCount = 0;
            analyzedWords.forEach((w) => {
                if (w.pos === 'verb') {
                    const cleanWord = w.text.toLowerCase().replace(/[^\w]/g, '');
                    const presentVerbs = ['is', 'am', 'are', 'be', 'being', 'exist', 'exists', 'remain', 'remains',
                                         'es', 'son', 'estar', 'ser', 'existe', 'existen', 'permanece', 'permanecen',
                                         'have', 'has', 'do', 'does', 'go', 'goes', 'come', 'comes', 'see', 'sees',
                                         'tengo', 'tiene', 'hago', 'hace', 'voy', 'va', 'vengo', 'viene', 'veo', 've'];
                    const pastVerbs = ['was', 'were', 'been', 'existed', 'remained', 'became', 'had', 'did', 'went',
                                      'came', 'saw', 'fue', 'fueron', 'estuvo', 'estuvieron', 'existiÃ³', 'existieron',
                                      'tuvo', 'hizo', 'fue', 'vino', 'vio', 'said', 'told', 'thought', 'knew',
                                      'dijo', 'contÃ³', 'pensÃ³', 'supo'];
                    const futureVerbs = ['will', 'shall', 'would', 'going', 'gonna',
                                        'serÃ¡', 'serÃ¡n', 'estarÃ¡', 'estarÃ¡n', 'tendrÃ¡', 'tendrÃ¡n', 'harÃ¡', 'harÃ¡n',
                                        'irÃ¡', 'irÃ¡n', 'vendrÃ¡', 'vendrÃ¡n', 'verÃ¡', 'verÃ¡n'];
                    const futureModal = ['will', 'shall', 'would', 'can', 'could', 'may', 'might',
                                        'podrÃ¡', 'podrÃ¡n', 'deberÃ¡', 'deberÃ¡n', 'puede', 'pueden'];
                    if (presentVerbs.includes(cleanWord) || cleanWord.endsWith('ing')) presentCount++;
                    else if (pastVerbs.includes(cleanWord) || cleanWord.endsWith('ed')) pastCount++;
                    else if (futureVerbs.includes(cleanWord) || futureModal.includes(cleanWord)) futureCount++;
                }
            });
            
            let predominantTense = 'none';
            const totalVerbs = presentCount + pastCount + futureCount;
            if (totalVerbs > 0) {
                if (presentCount > pastCount && presentCount > futureCount) predominantTense = 'present';
                else if (pastCount > presentCount && pastCount > futureCount) predominantTense = 'past';
                else if (futureCount > presentCount && futureCount > pastCount) predominantTense = 'future';
                else if (presentCount > 0 && (pastCount > 0 || futureCount > 0)) {
                    if (futureCount > 0) predominantTense = 'present_future';
                    else if (pastCount > 0) predominantTense = 'present_past';
                }
            }
            
            const tenseLabels = {
                'present': 'Present', 'past': 'Past', 'future': 'Future',
                'present_future': 'Present + Future', 'present_past': 'Present + Past',
                'none': 'No verbs detected'
            };
            
            // Contar por POS
            const posCounts = {}, posValuesETH = {};
            analyzedWords.forEach(w => {
                const pos = w.pos || 'other';
                posCounts[pos] = (posCounts[pos] || 0) + 1;
                const valuePoints = w.finalValue || 0;
                if (ethPriceUSD) {
                    posValuesETH[pos] = (posValuesETH[pos] || 0) + (valuePoints / ethPriceUSD);
                }
            });
            
            const toBeCount = analyzedWords.filter(w => w.isSerEstar).length;
            const nameGroups = window.nameGroups || [];
            const nameCount = nameGroups.length;
            const ontologicalValues = toBeCount + nameCount;
            const ontologicalAssertions = analyzedWords.filter(w => w.ontologicalMultiplier > 1).length;
            
            const top4Words = [...analyzedWords]
                .sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0))
                .slice(0, 4);
            
            const topWords = [...analyzedWords]
                .sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0))
                .slice(0, 20);
            
            function highlightNumber(num) {
                if (valueLogicColorMode) {
                    // White mode: black background, white text
                    return `<span style="background: #000000; color: #ffffff !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;">${num}</span>`;
                } else {
                    // Black mode: white background, black text
                    return `<span style="background: #ffffff; color: #000000 !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;">${num}</span>`;
                }
            }

            const borderColor = boxBorder;
            const boxStyle = `background: ${boxBg}; border: 1px solid ${boxBorder}; padding: 4px; margin-bottom: 3px; border-radius: 0;`;
            const itemStyle = "margin: 0.5px 0;";
            
            let generationDateStr = 'N/A';
            if (visualizationGenerationDate) {
                const date = visualizationGenerationDate;
                generationDateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}`;
            }
            
            let html = `
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">General Summary</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Total Words:</strong> ${highlightNumber(totalWords)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Average Value per Word:</strong> ${highlightNumber(avgFinalValueETHDisplay)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Average Base Value:</strong> ${highlightNumber(avgBaseValue.toFixed(2))}</div>
                </div>
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Date</h3>
                    <div style="${itemStyle} color: ${textColor};">${generationDateStr}</div>
                </div>
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Applied Multipliers (Average)</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Length Multiplier:</strong> Ã—${highlightNumber(avgLengthMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Multiplier:</strong> Ã—${highlightNumber(avgOntologicalMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Name + "to be" Multiplier:</strong> Ã—${highlightNumber(avgNameWithToBeMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Semantic Closure Multiplier:</strong> Ã—${highlightNumber(avgSemanticMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Repetition Multiplier:</strong> Ã—${highlightNumber(avgRepetitionMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Temporal Multiplier:</strong> Ã—${highlightNumber(avgTenseMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Predominant Tense:</strong> ${highlightNumber(tenseLabels[predominantTense])} (Present: ${presentCount}, Past: ${pastCount}, Future: ${futureCount})</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Narrative Penalty:</strong> Ã—${highlightNumber(avgNarrativePenalty.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Global Reduction:</strong> Ã—${highlightNumber('1.0')}</div>
                </div>
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Distribution by Value Range</h3>
            `;
            
            // Calculate value ranges
            const valueRanges = {
                'â‰¥ 1 ETH': { min: 1.0, count: 0, totalValue: 0 },
                '0.1 - 1 ETH': { min: 0.1, max: 1.0, count: 0, totalValue: 0 },
                '0.01 - 0.1 ETH': { min: 0.01, max: 0.1, count: 0, totalValue: 0 },
                '0.001 - 0.01 ETH': { min: 0.001, max: 0.01, count: 0, totalValue: 0 },
                '0.0001 - 0.001 ETH': { min: 0.0001, max: 0.001, count: 0, totalValue: 0 },
                '< 0.0001 ETH': { max: 0.0001, count: 0, totalValue: 0 }
            };
            
            // Count words in each range
            analyzedWords.forEach(w => {
                const valuePoints = w.finalValue || 0;
                const valueETH = ethPriceUSD ? valuePoints / ethPriceUSD : 0;
                
                if (valueETH >= 1.0) {
                    valueRanges['â‰¥ 1 ETH'].count++;
                    valueRanges['â‰¥ 1 ETH'].totalValue += valueETH;
                } else if (valueETH >= 0.1) {
                    valueRanges['0.1 - 1 ETH'].count++;
                    valueRanges['0.1 - 1 ETH'].totalValue += valueETH;
                } else if (valueETH >= 0.01) {
                    valueRanges['0.01 - 0.1 ETH'].count++;
                    valueRanges['0.01 - 0.1 ETH'].totalValue += valueETH;
                } else if (valueETH >= 0.001) {
                    valueRanges['0.001 - 0.01 ETH'].count++;
                    valueRanges['0.001 - 0.01 ETH'].totalValue += valueETH;
                } else if (valueETH >= 0.0001) {
                    valueRanges['0.0001 - 0.001 ETH'].count++;
                    valueRanges['0.0001 - 0.001 ETH'].totalValue += valueETH;
                } else {
                    valueRanges['< 0.0001 ETH'].count++;
                    valueRanges['< 0.0001 ETH'].totalValue += valueETH;
                }
            });
            
            // Sort ranges by total value (descending) and display
            const sortedRanges = Object.keys(valueRanges)
                .map(rangeName => ({
                    name: rangeName,
                    ...valueRanges[rangeName]
                }))
                .filter(range => range.count > 0) // Only show ranges with words
                .sort((a, b) => b.totalValue - a.totalValue); // Sort by total value descending
            
            sortedRanges.forEach(range => {
                const count = range.count;
                const rangeTotalValueETH = range.totalValue;
                const percentage = (count / totalWords * 100).toFixed(1);
                const valuePercentage = totalValueETH > 0 ? ((rangeTotalValueETH / totalValueETH) * 100).toFixed(1) : '0.0';
                const valueETHDisplay = rangeTotalValueETH >= 0.01 ? `${rangeTotalValueETH.toFixed(6)} ETH` : `${rangeTotalValueETH.toFixed(10)} ETH`;
                html += `<div style="${itemStyle} color: ${textColor};"><strong>${range.name}:</strong> ${highlightNumber(count)} words (${highlightNumber(percentage + '%')}) - Total Value: ${highlightNumber(valueETHDisplay)} (${highlightNumber(valuePercentage + '%')} of total)</div>`;
            });
            
            html += `
                </div>
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Special Elements</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Values:</strong> ${highlightNumber(ontologicalValues)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Names:</strong> ${highlightNumber(nameCount)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Assertions:</strong> ${highlightNumber(ontologicalAssertions)}</div>
                </div>
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Top 20 Words by Value</h3>
            `;
            
            topWords.forEach((w, idx) => {
                const wordValuePoints = w.finalValue || 0;
                const wordValueETH = ethPriceUSD ? wordValuePoints / ethPriceUSD : 0;
                const wordValueETHDisplay = wordValueETH >= 0.01 ? `${wordValueETH.toFixed(6)} ETH` : `${wordValueETH.toFixed(10)} ETH`;
                html += `
                    <div style="${itemStyle} color: ${textColor}; padding: 2px 0; border-top: 1px solid ${dividerColor};">
                        <strong>${idx + 1}. "${w.text}"</strong><br>
                        Value: ${highlightNumber(wordValueETHDisplay)}<br>
                        Base: ${highlightNumber((w.baseValue || 0).toFixed(2))} | 
                        Length: Ã—${highlightNumber((w.lengthMultiplier || 1).toFixed(2))} | 
                        Ontological: Ã—${highlightNumber((w.ontologicalMultiplier || 1).toFixed(2))} | 
                        Repetition: Ã—${highlightNumber((w.repetitionMultiplier || 1).toFixed(2))}
                    </div>
                `;
            });
            
            html += `</div>`;
            
            // Add input text block at the end
            const inputText = (document.getElementById('textInput')?.value || '').trim();
            if (inputText) {
                html += `
                    <div style="${boxStyle}">
                        <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Input Text</h3>
                        <div style="${itemStyle} color: ${textColor}; white-space: pre-wrap; word-wrap: break-word;">${inputText}</div>
                    </div>
                `;
            }
            
            content.innerHTML = html;
            
            // Crear overview 3D (reutilizar funciÃ³n existente pero adaptada)
            createClaimValueLogicOverview(overviewContainer, overviewCanvas);
            
            // Generar top 4 grid con fractales
            generateClaimTop5Grid(top5Grid, top4Words);
            
            // Actualizar total value box
            const claimTotalDisplay = document.getElementById('claim-value-logic-total-display');
            if (claimTotalDisplay) {
                claimTotalDisplay.textContent = totalValueETHDisplay;
            }

            // Actualizar botÃ³n PURCHASE con el valor en ETH
            updateClaimPurchaseButton();
            totalBox.style.display = 'block';
        }

        function createClaimValueLogicOverview(container, canvas) {
            if (!container || !canvas || !nodes || nodes.length === 0) return;
            
            // Asegurarse de que el contenedor estÃ© visible
            container.style.display = 'block';
            container.style.visibility = 'visible';
            container.style.opacity = '1';
            
            // Esperar a que el DOM se actualice para obtener las dimensiones correctas
            setTimeout(() => {
                const containerRect = container.getBoundingClientRect();
                let containerWidth = Math.floor(containerRect.width);
                const containerHeight = 150;
                
                // Si el ancho es 0 o muy pequeÃ±o, usar un valor por defecto
                if (containerWidth <= 0) {
                    containerWidth = 340;
                }
                
                // Asegurarse de que el canvas tenga dimensiones explÃ­citas
                canvas.width = containerWidth;
                canvas.height = containerHeight;
                
                // Limpiar renderer anterior si existe
                if (window.claimOverviewRenderer) {
                    try {
                        window.claimOverviewRenderer.dispose();
                    } catch (e) {
                        console.warn('Error disposing claim overview renderer:', e);
                    }
                    window.claimOverviewRenderer = null;
                }
                
                // Crear escena (similar al overview regular)
                const overviewScene = new THREE.Scene();
                overviewScene.background = new THREE.Color(0x000000);
                
                const overviewCamera = new THREE.PerspectiveCamera(50, containerWidth / containerHeight, 0.1, 1000);
                
                // Calcular bounding box
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                let minZ = Infinity, maxZ = -Infinity;
                
                nodes.forEach(node => {
                    const pos = node.position;
                    minX = Math.min(minX, pos.x);
                    maxX = Math.max(maxX, pos.x);
                    minY = Math.min(minY, pos.y);
                    maxY = Math.max(maxY, pos.y);
                    minZ = Math.min(minZ, pos.z);
                    maxZ = Math.max(maxZ, pos.z);
                });
                
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;
                
                const sizeX = maxX - minX;
                const sizeY = maxY - minY;
                const sizeZ = maxZ - minZ;
                const maxSize = Math.max(sizeX, sizeY, sizeZ, 1);
                
                const distance = maxSize * 2.5;
                overviewCamera.position.set(centerX, centerY, centerZ + distance);
                overviewCamera.lookAt(centerX, centerY, centerZ);
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
                overviewScene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(2, 2, 2);
                overviewScene.add(directionalLight);
                
                // Clone nodes at smaller scale
                const scaleFactor = 0.25;
                nodes.forEach(node => {
                    let clonedNode;
                    if (node.isGroup) {
                        clonedNode = node.clone(true);
                    } else {
                        clonedNode = node.clone();
                    }
                    clonedNode.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    overviewScene.add(clonedNode);
                });
                
                // Clone connections
                connections.forEach(conn => {
                    const clonedConn = conn.clone();
                    overviewScene.add(clonedConn);
                });
                
                // Create renderer directly with the canvas (igual que el overview regular)
                try {
                    window.claimOverviewRenderer = new THREE.WebGLRenderer({ 
                        canvas: canvas,
                        antialias: false,
                        powerPreference: "low-power"
                    });
                    window.claimOverviewRenderer.setSize(containerWidth, containerHeight);
                    window.claimOverviewRenderer.setPixelRatio(0.5);
                    
                    // Renderizar en el siguiente frame para asegurar que todo estÃ© listo
                    requestAnimationFrame(() => {
                        if (window.claimOverviewRenderer && overviewScene && overviewCamera) {
                            window.claimOverviewRenderer.render(overviewScene, overviewCamera);
                        }
                    });
                } catch (error) {
                    console.error('Error creating claim overview renderer:', error);
                    // Fallback: intentar copiar del overview regular si estÃ¡ disponible
                    const existingOverview = document.getElementById('value-logic-overview-canvas');
                    if (existingOverview && existingOverview.width > 0 && existingOverview.height > 0) {
                        try {
                            const ctx2D = canvas.getContext('2d');
                            canvas.width = containerWidth;
                            canvas.height = containerHeight;
                            ctx2D.drawImage(existingOverview, 0, 0, containerWidth, containerHeight);
                        } catch (e) {
                            console.error('Error copying existing overview:', e);
                        }
                    }
                }
            }, 300);
        }

        function generateClaimTop5Grid(container, top4Words) {
            if (!container || !top4Words || top4Words.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            // Get color mode from valueLogicColorMode
            const boxBorder = valueLogicColorMode ? "#000000" : "#ffffff";
            const boxBg = valueLogicColorMode ? "#ffffff" : "#000000";
            const textColor = valueLogicColorMode ? "#000000" : "#ffffff";
            
            let gridHTML = '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">';
            
            top4Words.forEach((w, idx) => {
                const wordIndex = analyzedWords.indexOf(w);
                if (wordIndex < 0) return;
                
                const fractalCanvasId = `claim-top5-grid-fractal-${idx}`;
                gridHTML += `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                        <div style="border: 1px solid ${boxBorder}; background: #000000; width: 100%; padding: 2px;">
                            <canvas id="${fractalCanvasId}" width="120" height="90" style="display: block; width: 100%; height: 90px;"></canvas>
                        </div>
                        <div style="border: 1px solid ${boxBorder}; background: ${boxBg}; padding: 4px; width: 100%;">
                            <div style="color: ${textColor}; font-size: 10px; text-align: center; font-family: Helvetica, Arial, sans-serif;">${w.text}</div>
                        </div>
                    </div>
                `;
            });
            
            gridHTML += '</div>';
            container.innerHTML = gridHTML;
            container.style.display = 'block';
            
            // Generar fractales
            setTimeout(() => {
                top4Words.forEach((w, idx) => {
                    const wordIndex = analyzedWords.indexOf(w);
                    if (wordIndex >= 0) {
                        const fractalCanvasId = `claim-top5-grid-fractal-${idx}`;
                        generateTop5Fractal(fractalCanvasId, wordIndex);
                    }
                });
            }, 150);
        }

        function createClaimTop12NodesList() {
            const grid = document.getElementById('claim-nodes-grid');
            if (!grid) return;
            
            // Limpiar contenido previo
            grid.innerHTML = '';
            
            const sortedNodes = [...nodes].sort((a, b) => {
                const scoreA = a.userData.wordData ? (a.userData.wordData.finalValue || 0) : 0;
                const scoreB = b.userData.wordData ? (b.userData.wordData.finalValue || 0) : 0;
                return scoreB - scoreA;
            });

            const top12 = sortedNodes.slice(0, 12);

            top12.forEach((node, index) => {
                const wordData = node.userData.wordData;
                if (!wordData) return;

                const item = document.createElement('div');
                item.className = 'node-list-item';
                item.style.cssText = 'width: 180px; height: auto; min-height: 250px; background: rgba(255, 255, 255, 0.95); border: none; padding: 5px; display: flex; flex-direction: column; overflow: visible; box-sizing: border-box; flex-shrink: 0;';

                const header = document.createElement('div');
                header.style.cssText = 'text-align: center; margin-bottom: 5px; padding: 2px;';
                const h3 = document.createElement('h3');
                h3.style.cssText = 'color: #000000; font-size: 11px; margin: 0; font-family: Helvetica, Arial, sans-serif;';
                h3.textContent = wordData.text;
                header.appendChild(h3);
                item.appendChild(header);

                const canvasContainer = document.createElement('div');
                canvasContainer.className = 'node-list-item-canvas-container';
                canvasContainer.style.cssText = 'width: 100%; height: 140px; background: #000000; margin-bottom: 5px; position: relative;';
                const canvas = document.createElement('canvas');
                canvas.className = 'node-list-item-canvas';
                canvas.width = 200;
                canvas.height = 140;
                canvasContainer.appendChild(canvas);
                item.appendChild(canvasContainer);

                // AÃ±adir fractal debajo del canvas 3D
                const fractalContainer = document.createElement('div');
                fractalContainer.style.cssText = 'width: 100%; margin-bottom: 5px; border: 1px solid #ffffff; background: #000000; padding: 1px; box-sizing: border-box; overflow: visible;';
                const fractalCanvas = document.createElement('canvas');
                fractalCanvas.id = `claim-node-list-fractal-${index}`;
                fractalCanvas.width = 178;
                fractalCanvas.height = 94;
                fractalCanvas.style.cssText = 'display: block; width: 100%; height: 94px; background: #000000; box-sizing: border-box;';
                fractalContainer.appendChild(fractalCanvas);
                item.appendChild(fractalContainer);

                grid.appendChild(item);

                // Crear escena 3D para este nodo
                createClaimNodeListItem3D(canvas, node, index);
                
                // Generar fractal para este nodo
                const wordIndex = node.userData.index;
                if (wordIndex >= 0 && analyzedWords && wordIndex < analyzedWords.length) {
                    setTimeout(() => {
                        generateTop5Fractal(`claim-node-list-fractal-${index}`, wordIndex);
                    }, 150 + (index * 50)); // Stagger generation to avoid blocking
                }
            });
        }

        function createClaimNodeListItem3D(canvas, node, index) {
            // Usar renderer compartido si no existe
            if (!sharedNodeListRenderer) {
                // Crear un canvas temporal para el renderer compartido
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 200;
                tempCanvas.height = 140;
                sharedNodeListRenderer = new THREE.WebGLRenderer({ canvas: tempCanvas, antialias: false });
                sharedNodeListRenderer.setSize(200, 140);
                
                sharedNodeListScene = new THREE.Scene();
                sharedNodeListScene.background = new THREE.Color(0x000000);
                
                sharedNodeListCamera = new THREE.PerspectiveCamera(75, 200 / 140, 0.1, 1000);
                sharedNodeListCamera.position.set(0, 0, 0.3);
                sharedNodeListCamera.lookAt(0, 0, 0);
                
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                sharedNodeListScene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(5, 5, 5);
                sharedNodeListScene.add(directionalLight);
            }
            
            // Limpiar escena anterior
            while (sharedNodeListScene.children.length > 2) { // Mantener las luces
                const child = sharedNodeListScene.children[2];
                sharedNodeListScene.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            }
            
            // Clonar el nodo y centrarlo
            const clone = node.isGroup ? node.clone(true) : node.clone();
            clone.position.set(0, 0, 0);
            sharedNodeListScene.add(clone);
            
            // Renderizar a una textura temporal
            const renderTarget = new THREE.WebGLRenderTarget(200, 140);
            
            // Guardar estado del renderer
            const originalSize = sharedNodeListRenderer.getSize(new THREE.Vector2());
            const originalClearColor = sharedNodeListRenderer.getClearColor(new THREE.Color());
            
            // Renderizar
            sharedNodeListRenderer.setRenderTarget(renderTarget);
            sharedNodeListRenderer.setClearColor(0x000000, 1);
            sharedNodeListRenderer.render(sharedNodeListScene, sharedNodeListCamera);
            
            // Leer la textura y dibujarla en el canvas 2D
            const ctx2D = canvas.getContext('2d');
            const pixels = new Uint8Array(200 * 140 * 4);
            sharedNodeListRenderer.readRenderTargetPixels(renderTarget, 0, 0, 200, 140, pixels);
            
            const imageData = ctx2D.createImageData(200, 140);
            for (let i = 0; i < pixels.length; i += 4) {
                imageData.data[i] = pixels[i];
                imageData.data[i + 1] = pixels[i + 1];
                imageData.data[i + 2] = pixels[i + 2];
                imageData.data[i + 3] = pixels[i + 3];
            }
            ctx2D.putImageData(imageData, 0, 0);
            
            // Restaurar estado del renderer
            sharedNodeListRenderer.setRenderTarget(null);
            sharedNodeListRenderer.setSize(originalSize.x, originalSize.y);
            sharedNodeListRenderer.setClearColor(originalClearColor, 1);
            
            // Limpiar render target
            renderTarget.dispose();
            
            // Remover el nodo clonado de la escena
            sharedNodeListScene.remove(clone);
            if (clone.geometry) clone.geometry.dispose();
            if (clone.material) {
                if (Array.isArray(clone.material)) {
                    clone.material.forEach(m => m.dispose());
                } else {
                    clone.material.dispose();
                }
            }
        }

        function updateClaimPurchaseButton() {
            const purchaseBtn = document.getElementById('claim-purchase-btn');
            if (!purchaseBtn) return;

            // Calcular valor total en ETH (convert points directly to ETH)
            const totalValuePoints = window.totalTextScore || (analyzedWords ? analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0) : 0);
            let totalValueETH = 0;
            if (ethPriceUSD && totalValuePoints > 0) {
                totalValueETH = totalValuePoints / ethPriceUSD;
            }

            const totalValueETHDisplay = totalValueETH >= 0.01 ?
                `${totalValueETH.toFixed(6)} ETH` :
                `${totalValueETH.toFixed(10)} ETH`;

            purchaseBtn.textContent = `PURCHASE FOR ${totalValueETHDisplay}`;
        }

        // Initialize max-value-panel to be hidden by default
        function initializeMaxValuePanel() {
            const maxValuePanel = document.getElementById('max-value-panel');
            
            if (maxValuePanel) {
                // Ensure panel is hidden by default
                maxValuePanel.style.display = 'none';
                maxValuePanel.style.visibility = 'hidden';
                maxValuePanel.style.position = 'fixed';
                maxValuePanel.style.bottom = '14px';
                maxValuePanel.style.right = '0';
            }
        }
        
        function toggleClaimExpanded() {
            const expandedSection = document.getElementById('claim-expanded-section');
            const expandBtn = document.getElementById('claim-expand-btn');
            const totalValueContainer = document.getElementById('claim-total-value-container');

            if (!expandedSection || !expandBtn) return;

            if (expandedSection.style.display === 'none' || expandedSection.style.display === '') {
                // Expandir
                expandedSection.style.display = 'block';
                expandedSection.style.visibility = 'visible'; // Asegurar que sea visible
                expandBtn.innerHTML = '<span>COLLAPSE</span><span style="font-size: 7px;">â†‘</span>';

                // Ampliar el recuadro de TOTAL VALUE verticalmente
                if (totalValueContainer) {
                    // Calcular altura adicional segÃºn el nÃºmero de nodos
                    const containerWidth = 350;
                    const padding = 5;
                    const gridWidth = containerWidth - (padding * 2);
                    const gap = 2;

                    // Obtener el nÃºmero de nodos para calcular la altura correcta
                    const top8Words = analyzedWords ? [...analyzedWords]
                        .sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0))
                        .slice(0, 8) : [];
                    const totalNodes = top8Words.length;

                    let squareSize;
                    let rows;

                    if (totalNodes === 2) {
                        // 1 fila de 2 columnas
                        squareSize = Math.floor((gridWidth - (gap * 1)) / 2);
                        rows = 1;
                    } else {
                        // 2 filas de 4 columnas
                        squareSize = Math.floor((gridWidth - (gap * 3)) / 4);
                        rows = 2;
                    }

                    const expandedHeight = (squareSize * rows) + (gap * (rows - 1)) + (padding * 2) + 5;
                    const newHeight = 500 + expandedHeight;
                    totalValueContainer.style.height = newHeight + 'px';
                    totalValueContainer.style.minHeight = newHeight + 'px';
                }

                // Siempre limpiar y regenerar para asegurar que se usen los datos actuales
                const grid = document.getElementById('claim-top4-fractals-grid');
                if (grid) {
                    grid.innerHTML = '';
                    // Esperar un momento para que el DOM se actualice y la secciÃ³n sea visible antes de generar
                    setTimeout(() => {
                        // Verificar que la secciÃ³n estÃ© visible antes de generar
                        if (expandedSection.style.display === 'block' && expandedSection.style.visibility !== 'hidden') {
                            generateClaimTop4Fractals();
                        }
                    }, 100);
                }
            } else {
                // Contraer
                expandedSection.style.display = 'none';
                // No establecer visibility: hidden aquÃ­ para que pueda expandirse de nuevo
                expandBtn.innerHTML = '<span>EXPAND</span><span style="font-size: 7px;">â†“</span>';

                // Restaurar altura original del recuadro de TOTAL VALUE
                if (totalValueContainer) {
                    totalValueContainer.style.height = '500px';
                    totalValueContainer.style.minHeight = '500px';
                }
            }
        }

        function generateClaimTop4Fractals() {
            if (!analyzedWords || analyzedWords.length === 0 || !nodes || nodes.length === 0) return;

            const grid = document.getElementById('claim-top4-fractals-grid');
            if (!grid) return;

            // Obtener top 8 palabras por valor (para 2 filas de 4)
            const top8Words = [...analyzedWords]
                .sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0))
                .slice(0, 8);

            if (top8Words.length === 0) return;

            // Limpiar grid
            grid.innerHTML = '';

            // Calcular tamaÃ±o de cada cuadrado
            const containerWidth = 350;
            const padding = 5;
            const gridWidth = containerWidth - (padding * 2);
            const gap = 2;

            // Si solo hay 2 nodos, hacerlos el doble de grandes
            const totalNodes = top8Words.length;
            let squareSize;
            let columns;
            let rows;

            if (totalNodes === 2) {
                // 1 fila de 2 columnas, cada cuadrado ocupa el doble de espacio
                columns = 2;
                rows = 1;
                squareSize = Math.floor((gridWidth - (gap * 1)) / 2); // 1 gap entre 2 elementos
                grid.style.gridTemplateColumns = 'repeat(2, 1fr)';
                grid.style.gridTemplateRows = 'repeat(1, 1fr)';
            } else {
                // Configurar grid para 2 filas de 4 columnas (comportamiento normal)
                columns = 4;
                rows = 2;
                squareSize = Math.floor((gridWidth - (gap * 3)) / 4); // 3 gaps entre 4 elementos
                grid.style.gridTemplateColumns = 'repeat(4, 1fr)';
                grid.style.gridTemplateRows = 'repeat(2, 1fr)';
            }

            top8Words.forEach((w, idx) => {
                const wordIndex = analyzedWords.indexOf(w);
                if (wordIndex < 0) return;

                // Encontrar el nodo correspondiente (usar los nodos actuales, no en cachÃ©)
                const node = nodes.find(n => n.userData && n.userData.index === wordIndex);
                if (!node) {
                    console.warn(`Node not found for word index ${wordIndex}`);
                    return;
                }

                const nodeSectionCanvasId = `claim-expanded-node-section-${idx}`;

                // Crear contenedor del cuadrado
                const squareDiv = document.createElement('div');
                squareDiv.style.cssText = `width: ${squareSize}px; height: ${squareSize}px; background: #000000; border: 1px solid #ffffff; padding: 1px; box-sizing: border-box; overflow: hidden;`;

                // Crear canvas
                const canvas = document.createElement('canvas');
                canvas.id = nodeSectionCanvasId;
                const canvasSize = squareSize - 2; // menos padding (1px cada lado)
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                canvas.style.cssText = 'display: block; width: 100%; height: 100%; background: #000000;';

                squareDiv.appendChild(canvas);
                grid.appendChild(squareDiv);
            });

            // Generar imÃ¡genes de secciones de nodos despuÃ©s de que los canvas estÃ©n en el DOM
            setTimeout(() => {
                top8Words.forEach((w, idx) => {
                    const wordIndex = analyzedWords.indexOf(w);
                    if (wordIndex >= 0) {
                        const node = nodes.find(n => n.userData && n.userData.index === wordIndex);
                        if (node) {
                            const nodeSectionCanvasId = `claim-expanded-node-section-${idx}`;
                            createClaimNodeSectionImage(nodeSectionCanvasId, node, squareSize - 2);
                        }
                    }
                });
            }, 100);
        }

        function createClaimNodeSectionImage(canvasId, centerNode, canvasSize) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !centerNode || !nodes || nodes.length === 0) return;

            try {
                // Crear renderer compartido si no existe
                if (!sharedTopNodesRenderer) {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvasSize;
                    tempCanvas.height = canvasSize;
                    sharedTopNodesRenderer = new THREE.WebGLRenderer({ canvas: tempCanvas, antialias: false });
                    sharedTopNodesRenderer.setSize(canvasSize, canvasSize);
                    sharedTopNodesRenderer.setPixelRatio(0.75);

                    sharedTopNodesScene = new THREE.Scene();
                    sharedTopNodesScene.background = new THREE.Color(0x000000);

                    sharedTopNodesCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);

                    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                    sharedTopNodesScene.add(ambientLight);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(2, 2, 2);
                    sharedTopNodesScene.add(directionalLight);
                }

                // Limpiar escena anterior (mantener solo las luces)
                while (sharedTopNodesScene.children.length > 2) {
                    const child = sharedTopNodesScene.children[2];
                    sharedTopNodesScene.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }

                // Encontrar nodos conectados al nodo central
                const connectedNodes = new Set([centerNode]);
                const centerPos = centerNode.position;

                // Buscar conexiones que incluyan este nodo usando userData
                connections.forEach(conn => {
                    if (conn.userData && conn.userData.fromNode && conn.userData.toNode) {
                        if (conn.userData.fromNode === centerNode) {
                            connectedNodes.add(conn.userData.toNode);
                        } else if (conn.userData.toNode === centerNode) {
                            connectedNodes.add(conn.userData.fromNode);
                        }
                    }
                });

                // TambiÃ©n incluir nodos cercanos en el espacio 3D (dentro de un radio)
                const radius = 0.4; // Radio para incluir nodos cercanos
                nodes.forEach(node => {
                    if (node !== centerNode && !connectedNodes.has(node)) {
                        const distance = centerPos.distanceTo(node.position);
                        if (distance < radius) {
                            connectedNodes.add(node);
                        }
                    }
                });

                // Clonar nodos y conexiones para la secciÃ³n
                const clonedNodes = [];
                const nodeMap = new Map();

                connectedNodes.forEach(node => {
                    const clonedNode = node.isGroup ? node.clone(true) : node.clone();
                    clonedNodes.push(clonedNode);
                    nodeMap.set(node, clonedNode);
                    sharedTopNodesScene.add(clonedNode);
                });

                // Clonar conexiones entre los nodos incluidos
                connections.forEach(conn => {
                    if (conn.userData && conn.userData.fromNode && conn.userData.toNode) {
                        const fromNode = conn.userData.fromNode;
                        const toNode = conn.userData.toNode;

                        // Solo clonar si ambos nodos estÃ¡n en la secciÃ³n
                        if (connectedNodes.has(fromNode) && connectedNodes.has(toNode) &&
                            nodeMap.has(fromNode) && nodeMap.has(toNode)) {
                            const clonedFrom = nodeMap.get(fromNode);
                            const clonedTo = nodeMap.get(toNode);

                            // Crear nueva conexiÃ³n entre los nodos clonados
                            const clonedFromPos = clonedFrom.position;
                            const clonedToPos = clonedTo.position;
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                clonedFromPos,
                                clonedToPos
                            ]);

                            const material = conn.material.clone();
                            const clonedConn = new THREE.Line(geometry, material);
                            sharedTopNodesScene.add(clonedConn);
                        }
                    }
                });

                // Calcular bounding box de la secciÃ³n
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                let minZ = Infinity, maxZ = -Infinity;

                clonedNodes.forEach(node => {
                    const pos = node.position;
                    minX = Math.min(minX, pos.x);
                    maxX = Math.max(maxX, pos.x);
                    minY = Math.min(minY, pos.y);
                    maxY = Math.max(maxY, pos.y);
                    minZ = Math.min(minZ, pos.z);
                    maxZ = Math.max(maxZ, pos.z);
                });

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;

                const sizeX = maxX - minX;
                const sizeY = maxY - minY;
                const sizeZ = maxZ - minZ;
                const maxSize = Math.max(sizeX, sizeY, sizeZ, 0.1);

                // Posicionar cÃ¡mara para ver toda la secciÃ³n
                const distance = maxSize * 2.5;
                sharedTopNodesCamera.position.set(centerX, centerY, centerZ + distance);
                sharedTopNodesCamera.lookAt(centerX, centerY, centerZ);

                // Renderizar a una textura temporal
                const renderTarget = new THREE.WebGLRenderTarget(canvasSize, canvasSize);

                // Guardar estado del renderer
                const originalSize = sharedTopNodesRenderer.getSize(new THREE.Vector2());
                const originalClearColor = sharedTopNodesRenderer.getClearColor(new THREE.Color());

                // Renderizar
                sharedTopNodesRenderer.setRenderTarget(renderTarget);
                sharedTopNodesRenderer.setClearColor(0x000000, 1);
                sharedTopNodesRenderer.render(sharedTopNodesScene, sharedTopNodesCamera);

                // Leer la textura y dibujarla en el canvas 2D
                const ctx2D = canvas.getContext('2d');
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                const pixels = new Uint8Array(canvasSize * canvasSize * 4);
                sharedTopNodesRenderer.readRenderTargetPixels(renderTarget, 0, 0, canvasSize, canvasSize, pixels);

                const imageData = ctx2D.createImageData(canvasSize, canvasSize);
                for (let i = 0; i < pixels.length; i += 4) {
                    imageData.data[i] = pixels[i];
                    imageData.data[i + 1] = pixels[i + 1];
                    imageData.data[i + 2] = pixels[i + 2];
                    imageData.data[i + 3] = pixels[i + 3];
                }
                ctx2D.putImageData(imageData, 0, 0);

                // Restaurar estado del renderer
                sharedTopNodesRenderer.setRenderTarget(null);
                sharedTopNodesRenderer.setSize(originalSize.x, originalSize.y);
                sharedTopNodesRenderer.setClearColor(originalClearColor, 1);

                // Limpiar render target
                renderTarget.dispose();

            } catch (e) {
                console.warn('Error generating node section image:', e);
            }
        }

        function hideClaimModal() {
            const modal = document.getElementById('claim-modal');
            if (modal) {
                modal.style.display = 'none';
                modal.style.visibility = 'hidden';
                modal.style.opacity = '0';
            }
            
            // Limpiar recursos 3D
            if (claimAnimationId) {
                cancelAnimationFrame(claimAnimationId);
                claimAnimationId = null;
            }
            
            if (claimScene) {
                claimScene.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                claimScene = null;
            }
            
            // Limpiar renderer compartido de nodos
            if (sharedNodeListRenderer) {
                if (sharedNodeListScene) {
                    sharedNodeListScene.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    sharedNodeListScene = null;
                }
                sharedNodeListRenderer.dispose();
                sharedNodeListRenderer = null;
                sharedNodeListCamera = null;
            }
        }

        async function downloadClaimPurchasePack() {
            try {
                // Verificar JSZip
                if (typeof JSZip === 'undefined') {
                    // Cargar JSZip dinÃ¡micamente
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                    await new Promise((resolve, reject) => {
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                }
                
                const zip = new JSZip();
                let imageReady = false;
                let nodeBodyImageReady = false;
                let glbReady = false;

                function checkAndDownload() {
                    if (imageReady && nodeBodyImageReady && glbReady) {
                        zip.generateAsync({ type: 'blob' }).then((content) => {
                            const link = document.createElement('a');
                            link.href = URL.createObjectURL(content);
                            link.download = `purchase-pack-${getTimestamp()}.zip`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            setTimeout(() => URL.revokeObjectURL(link.href), 100);
                            
                            // Save purchase to gallery
                            savePurchaseToGalleryAfterDownload();
                            
                            // Close claim modal and other open windows
                            hideClaimModal();
                            hideNodeDetails();
                            
                            // Close right panel if visible
                            const rightPanel = document.getElementById('right-panel');
                            if (rightPanel && rightPanel.classList.contains('visible')) {
                                rightPanel.classList.remove('visible');
                                rightPanel.style.display = 'none';
                            }
                            
                            // Close node info panel if visible
                            const nodeInfoPanel = document.getElementById('node-info-panel');
                            if (nodeInfoPanel && nodeInfoPanel.classList.contains('visible')) {
                                nodeInfoPanel.classList.remove('visible');
                                nodeInfoPanel.style.display = 'none';
                            }
                            
                            // Show success message
                            showPurchaseSuccessMessage();
                            
                            // After 2 seconds, hide success message and clear everything
                            setTimeout(() => {
                                hidePurchaseSuccessMessage();
                                clearTextBox();
                            }, 2000);
                        });
                    }
                }

                // 1. Capturar imagen del total value (capturar todo el contenido sin cortes)
                const totalValueContainer = document.getElementById('claim-total-value-container');
                if (totalValueContainer && typeof html2canvas !== 'undefined') {
                    // Clonar el contenedor fuera de la vista para evitar glitches visuales
                    const clonedContainer = totalValueContainer.cloneNode(true);
                    clonedContainer.id = 'claim-total-value-container-clone';
                    clonedContainer.style.position = 'fixed';
                    clonedContainer.style.left = '-9999px';
                    clonedContainer.style.top = '0';
                    clonedContainer.style.height = 'auto';
                    clonedContainer.style.maxHeight = 'none';
                    clonedContainer.style.overflow = 'visible';
                    clonedContainer.style.opacity = '1';
                    clonedContainer.style.visibility = 'visible';
                    clonedContainer.style.display = 'block';
                    clonedContainer.style.width = totalValueContainer.offsetWidth + 'px';
                    document.body.appendChild(clonedContainer);
                    
                    // Asegurarse de que los contenedores estÃ©n visibles en el clon
                    const clonedOverviewContainer = clonedContainer.querySelector('#claim-value-logic-overview-container');
                    const clonedTop5Grid = clonedContainer.querySelector('#claim-value-logic-top5-grid');
                    if (clonedOverviewContainer) {
                        clonedOverviewContainer.style.display = 'block';
                    }
                    if (clonedTop5Grid) {
                        clonedTop5Grid.style.display = 'block';
                    }
                    
                    // Copiar el contenido de los canvas al clon
                    const originalCanvases = totalValueContainer.querySelectorAll('canvas');
                    const clonedCanvases = clonedContainer.querySelectorAll('canvas');
                    
                    // Mapear canvas por ID para copiar correctamente
                    originalCanvases.forEach((originalCanvas) => {
                        const canvasId = originalCanvas.id;
                        if (!canvasId) return;
                        
                        const clonedCanvas = clonedContainer.querySelector('#' + canvasId);
                        if (clonedCanvas && originalCanvas.width > 0 && originalCanvas.height > 0) {
                            try {
                                const ctx = clonedCanvas.getContext('2d');
                                if (ctx) {
                                    clonedCanvas.width = originalCanvas.width;
                                    clonedCanvas.height = originalCanvas.height;
                                    // Copiar el contenido del canvas original
                                    ctx.drawImage(originalCanvas, 0, 0);
                                }
                            } catch (e) {
                                console.warn('Could not copy canvas ' + canvasId + ':', e);
                            }
                        }
                    });
                    
                    // Esperar a que el DOM se actualice y los canvas se rendericen
                    setTimeout(() => {
                        // Asegurarse de que todos los canvas estÃ©n listos
                        const allCanvasesReady = Array.from(clonedCanvases).every(canvas => {
                            return canvas.width > 0 && canvas.height > 0;
                        });
                        
                        if (!allCanvasesReady) {
                            // Reintentar copiar los canvas
                            originalCanvases.forEach((originalCanvas) => {
                                const canvasId = originalCanvas.id;
                                if (!canvasId) return;
                                
                                const clonedCanvas = clonedContainer.querySelector('#' + canvasId);
                                if (clonedCanvas && originalCanvas.width > 0 && originalCanvas.height > 0) {
                                    try {
                                        const ctx = clonedCanvas.getContext('2d');
                                        if (ctx) {
                                            clonedCanvas.width = originalCanvas.width;
                                            clonedCanvas.height = originalCanvas.height;
                                            ctx.drawImage(originalCanvas, 0, 0);
                                        }
                                    } catch (e) {
                                        console.warn('Could not copy canvas ' + canvasId + ':', e);
                                    }
                                }
                            });
                        }
                        
                        html2canvas(clonedContainer, {
                            backgroundColor: '#dcdcdc',
                            scale: 2,
                            height: clonedContainer.scrollHeight,
                            width: clonedContainer.scrollWidth,
                            useCORS: true,
                            allowTaint: true,
                            logging: false,
                            ignoreElements: (element) => {
                                // No ignorar nada, capturar todo
                                return false;
                            },
                            onclone: (clonedDoc) => {
                                // Asegurarse de que los contenedores estÃ©n visibles en el clon de html2canvas
                                const clonedOverview = clonedDoc.getElementById('claim-value-logic-overview-container');
                                const clonedTop5 = clonedDoc.getElementById('claim-value-logic-top5-grid');
                                if (clonedOverview) {
                                    clonedOverview.style.display = 'block';
                                }
                                if (clonedTop5) {
                                    clonedTop5.style.display = 'block';
                                }
                                
                                // Copiar canvas nuevamente en el clon de html2canvas
                                originalCanvases.forEach((originalCanvas) => {
                                    const canvasId = originalCanvas.id;
                                    if (!canvasId) return;
                                    
                                    const clonedCanvas = clonedDoc.getElementById(canvasId);
                                    if (clonedCanvas && originalCanvas.width > 0 && originalCanvas.height > 0) {
                                        try {
                                            const ctx = clonedCanvas.getContext('2d');
                                            if (ctx) {
                                                clonedCanvas.width = originalCanvas.width;
                                                clonedCanvas.height = originalCanvas.height;
                                                ctx.drawImage(originalCanvas, 0, 0);
                                            }
                                        } catch (e) {
                                            console.warn('Could not copy canvas in onclone ' + canvasId + ':', e);
                                        }
                                    }
                                });
                            }
                        }).then((canvas) => {
                            // Eliminar el clon
                            if (clonedContainer.parentNode) {
                                document.body.removeChild(clonedContainer);
                            }
                            
                            canvas.toBlob((blob) => {
                                zip.file('total-value-summary.jpg', blob);
                                imageReady = true;
                                checkAndDownload();
                            }, 'image/jpeg', 1.0);
                        }).catch((error) => {
                            console.error('Error capturing total value:', error);
                            // Eliminar el clon en caso de error
                            if (clonedContainer.parentNode) {
                                document.body.removeChild(clonedContainer);
                            }
                            imageReady = true;
                            checkAndDownload();
                        });
                    }, 300);
                } else {
                    imageReady = true;
                    checkAndDownload();
                }

                // 2. Capturar imagen del cuerpo de nodos (claim-3d-container)
                const claim3DContainer = document.getElementById('claim-3d-container');
                if (claim3DContainer) {
                    // Find the canvas 2D element inside the container
                    const canvas2D = claim3DContainer.querySelector('canvas');
                    
                    if (canvas2D) {
                        try {
                            // Capture directly from the canvas using toDataURL
                            const imageData = canvas2D.toDataURL('image/jpeg', 0.90);
                            
                            // Convert data URL to blob
                            fetch(imageData)
                                .then(res => res.blob())
                                .then(blob => {
                                    zip.file('node-body-image.jpg', blob);
                                    nodeBodyImageReady = true;
                                    console.log('âœ“ Node body image captured and added to ZIP');
                                    checkAndDownload();
                                })
                                .catch(error => {
                                    console.error('Error converting node body image to blob:', error);
                                    nodeBodyImageReady = true;
                                    checkAndDownload();
                                });
                        } catch (error) {
                            console.error('Error capturing node body image:', error);
                            nodeBodyImageReady = true;
                            checkAndDownload();
                        }
                    } else {
                        console.warn('Canvas not found inside claim-3d-container');
                        nodeBodyImageReady = true;
                        checkAndDownload();
                    }
                } else {
                    console.warn('claim-3d-container not found');
                    nodeBodyImageReady = true;
                    checkAndDownload();
                }

                // 3. Exportar GLB
                if (typeof THREE.GLTFExporter === 'undefined') {
                    alert('Error: GLTFExporter no estÃ¡ disponible.');
                    glbReady = true;
                    checkAndDownload();
                    return;
                }

                const exportScene = new THREE.Scene();
                nodes.forEach(node => {
                    const clonedNode = node.isGroup ? node.clone(true) : node.clone();
                    exportScene.add(clonedNode);
                });
                connections.forEach(connection => {
                    const clonedConnection = connection.clone();
                    exportScene.add(clonedConnection);
                });

                try {
                    const exporter = new THREE.GLTFExporter();
                    exporter.parse(exportScene, (result) => {
                        let blob;
                        if (result instanceof ArrayBuffer) {
                            blob = new Blob([result], { type: 'model/gltf-binary' });
                        } else {
                            const output = JSON.stringify(result, null, 2);
                            blob = new Blob([output], { type: 'application/json' });
                        }
                        window.__latestGlbBlob = blob;
                        window.__latestGlbFilename = "text-body.glb";
                        
                        // Convert blob to base64 for gallery storage
                        const reader = new FileReader();
                        reader.onloadend = () => {
                            window.__latestGlbBase64 = reader.result;
                        };
                        reader.readAsDataURL(blob);

                        zip.file('text-body.glb', blob);
                        glbReady = true;
                        checkAndDownload();
                    }, {
                        binary: true,
                        trs: false,
                        onlyVisible: true,
                        truncateDrawRange: true,
                        embedImages: true,
                        animations: [],
                        includeCustomExtensions: false
                    });
                } catch (error) {
                    console.error('Error exporting GLB:', error);
                    glbReady = true;
                    checkAndDownload();
                }
            } catch (e) {
                console.error('Error creating purchase pack:', e);
                alert('Error al crear el pack. Por favor, intenta de nuevo.');
            }
        }
        
        // ==================== GALLERY STORAGE SYSTEM ====================
        // Store gallery purchases in localStorage
        function savePurchaseToGallery(purchaseData) {
            try {
                let gallery = JSON.parse(localStorage.getItem('gallery_purchases') || '[]');
                gallery.push(purchaseData);
                // Sort by total value (descending)
                gallery.sort((a, b) => (b.totalValue || 0) - (a.totalValue || 0));
                
                // Check size before saving (localStorage limit is typically 5-10MB)
                const jsonString = JSON.stringify(gallery);
                const sizeInMB = new Blob([jsonString]).size / (1024 * 1024);
                
                if (sizeInMB > 8) {
                    console.warn(`Gallery data size (${sizeInMB.toFixed(2)}MB) approaching localStorage limit. Attempting to save anyway...`);
                }
                
                try {
                    localStorage.setItem('gallery_purchases', jsonString);
                    
                    // Verify the image was saved correctly
                    const savedData = JSON.parse(localStorage.getItem('gallery_purchases') || '[]');
                    const lastPurchase = savedData[savedData.length - 1];
                    if (lastPurchase && lastPurchase.id === purchaseData.id) {
                        if (lastPurchase.nodeBodyImage) {
                            const savedImgSizeKB = (lastPurchase.nodeBodyImage.length * 3) / 4 / 1024;
                            console.log(`âœ“ Purchase saved to gallery successfully. Gallery size: ${sizeInMB.toFixed(2)}MB, ${gallery.length} items`);
                            console.log(`âœ“ Image verified in saved data: ${savedImgSizeKB.toFixed(2)}KB`);
                            console.log(`âœ“ Saved image preview: ${lastPurchase.nodeBodyImage.substring(0, 50)}...`);
                            console.log(`âœ“ Saved image starts with: ${lastPurchase.nodeBodyImage.substring(0, 30)}...`);
                            
                            // Verify the saved image is still a valid data URL
                            if (!lastPurchase.nodeBodyImage.startsWith('data:image/')) {
                                console.error(`âŒ CRITICAL ERROR: Saved image is NOT a valid data URL!`);
                                console.error(`Saved image preview: ${lastPurchase.nodeBodyImage.substring(0, 100)}...`);
                            } else {
                                console.log(`âœ“ Saved image format is valid`);
                            }
                        } else {
                            console.error(`âŒ ERROR: Image was NOT saved! Purchase ID: ${purchaseData.id}`);
                            console.error(`Original had image: ${!!purchaseData.nodeBodyImage}`);
                            console.error(`Original image length: ${purchaseData.nodeBodyImage ? purchaseData.nodeBodyImage.length : 0}`);
                        }
                    }
                    
                    return true;
                } catch (storageError) {
                    // If storage fails due to size, try multiple strategies
                    if (storageError.name === 'QuotaExceededError' || storageError.code === 22) {
                        console.warn('localStorage quota exceeded. Attempting recovery strategies...');
                        
                        // Strategy 1: Remove oldest 50% of items (more aggressive)
                        let itemsToRemove = Math.max(1, Math.floor(gallery.length * 0.5));
                        gallery = gallery.slice(0, gallery.length - itemsToRemove);
                        
                        // Remove large data from remaining items to free up space (but keep smaller images)
                        gallery.forEach(item => {
                            if (item.nodeBodyImage && item.nodeBodyImage.length > 200000) {
                                // Only remove images larger than ~150KB (keep smaller compressed images)
                                console.log(`Removing large image from old purchase (${(item.nodeBodyImage.length * 3 / 4 / 1024).toFixed(2)}KB)`);
                                item.nodeBodyImage = null;
                            }
                            if (item.glbBase64 && item.glbBase64.length > 500000) {
                                // Remove GLB larger than ~375KB
                                item.glbBase64 = null;
                            }
                        });
                        
                        try {
                            const reducedJsonString = JSON.stringify(gallery);
                            const reducedSizeMB = new Blob([reducedJsonString]).size / (1024 * 1024);
                            console.log(`Removed ${itemsToRemove} oldest items and large data. Gallery size now: ${reducedSizeMB.toFixed(2)}MB`);
                            
                            localStorage.setItem('gallery_purchases', reducedJsonString);
                            
                            // CRITICAL: Try to save WITH image first (prioritize keeping the image)
                            const purchaseDataWithImage = {
                                ...purchaseData,
                                glbBase64: null // Remove GLB but keep image
                            };
                            gallery.push(purchaseDataWithImage);
                            gallery.sort((a, b) => (b.totalValue || 0) - (a.totalValue || 0));
                            
                            const testJsonString = JSON.stringify(gallery);
                            const testSizeMB = new Blob([testJsonString]).size / (1024 * 1024);
                            
                            if (testSizeMB < 8) {
                                localStorage.setItem('gallery_purchases', testJsonString);
                                console.log(`âœ“ Purchase saved to gallery WITH image (${testSizeMB.toFixed(2)}MB)`);
                                return true;
                            } else {
                                // Still too large even with compressed image, try without image as last resort
                                console.warn(`Still too large with image (${testSizeMB.toFixed(2)}MB), trying without image...`);
                                gallery.pop();
                                const purchaseDataWithoutImage = {
                                    ...purchaseData,
                                    nodeBodyImage: null,
                                    glbBase64: null
                                };
                                gallery.push(purchaseDataWithoutImage);
                                gallery.sort((a, b) => (b.totalValue || 0) - (a.totalValue || 0));
                                
                                const finalJsonString = JSON.stringify(gallery);
                                const finalSizeMB = new Blob([finalJsonString]).size / (1024 * 1024);
                                
                                localStorage.setItem('gallery_purchases', finalJsonString);
                                console.warn(`âš  Saved purchase WITHOUT image due to storage limits (${finalSizeMB.toFixed(2)}MB)`);
                                return true;
                            }
                        } catch (retryError) {
                            console.error('Failed to save even after aggressive cleanup:', retryError);
                            // Ultimate fallback: clear gallery and save only this purchase
                            try {
                                // Try with image first
                                const purchaseDataWithImage = {
                                    ...purchaseData,
                                    glbBase64: null
                                };
                                const testGallery = [purchaseDataWithImage];
                                const testSize = new Blob([JSON.stringify(testGallery)]).size / (1024 * 1024);
                                
                                if (testSize < 8) {
                                    localStorage.setItem('gallery_purchases', JSON.stringify(testGallery));
                                    console.warn('Cleared gallery and saved purchase WITH image');
                                    return true;
                                } else {
                                    // Last resort: without image
                                    const purchaseDataMinimal = {
                                        ...purchaseData,
                                        nodeBodyImage: null,
                                        glbBase64: null
                                    };
                                    const minimalGallery = [purchaseDataMinimal];
                                    localStorage.setItem('gallery_purchases', JSON.stringify(minimalGallery));
                                    console.warn('Cleared gallery and saved purchase WITHOUT image (storage too limited)');
                                    return true;
                                }
                            } catch (finalError) {
                                console.error('Failed to save even with minimal data:', finalError);
                                return false;
                            }
                        }
                    } else {
                        throw storageError; // Re-throw if it's not a quota error
                    }
                }
            } catch (e) {
                console.error('Error saving purchase to gallery:', e);
                console.error('Purchase data:', {
                    id: purchaseData.id,
                    wordCount: purchaseData.wordCount,
                    totalValue: purchaseData.totalValue,
                    hasImage: !!purchaseData.nodeBodyImage,
                    hasGLB: !!purchaseData.glbBase64,
                    textLength: purchaseData.originalText ? purchaseData.originalText.length : 0
                });
                return false;
            }
        }
        
        function getGalleryPurchases() {
            try {
                const purchases = JSON.parse(localStorage.getItem('gallery_purchases') || '[]');
                // Log image status for debugging
                console.log(`Loading ${purchases.length} purchases from gallery...`);
                purchases.forEach((purchase, idx) => {
                    if (purchase.nodeBodyImage) {
                        const imgSizeKB = (purchase.nodeBodyImage.length * 3) / 4 / 1024;
                        const isValid = purchase.nodeBodyImage.startsWith('data:image/');
                        console.log(`  Purchase ${idx + 1} (ID: ${purchase.id}): Image found (${imgSizeKB.toFixed(2)}KB, valid: ${isValid}), preview: ${purchase.nodeBodyImage.substring(0, 50)}...`);
                    } else {
                        console.warn(`  Purchase ${idx + 1} (ID: ${purchase.id}): NO IMAGE`);
                    }
                });
                return purchases;
            } catch (e) {
                console.error('Error loading gallery purchases:', e);
                return [];
            }
        }
        
        // Get word repetition counts from gallery (for cost increase/decrease)
        // Returns a Map with word -> { count: number, isName: boolean, isCompoundName: boolean }
        // count = number of DIFFERENT purchases that contain this word
        function getWordRepetitionCounts() {
            const gallery = getGalleryPurchases();
            const wordData = new Map();
            
            gallery.forEach(purchase => {
                const wordsInThisPurchase = new Set(); // Track unique words per purchase
                
                if (purchase.topWords && Array.isArray(purchase.topWords)) {
                    purchase.topWords.forEach(wordInfo => {
                        // Handle both old format (string) and new format (object)
                        let wordText, isName, isCompoundName;
                        if (typeof wordInfo === 'string') {
                            wordText = wordInfo.toLowerCase().trim();
                            isName = false;
                            isCompoundName = false;
                        } else {
                            wordText = (wordInfo.text || '').toLowerCase().trim();
                            isName = wordInfo.isName === true || false;
                            isCompoundName = wordInfo.isPartOfCompoundName === true || false;
                        }
                        
                        if (wordText && !wordsInThisPurchase.has(wordText)) {
                            // Count each purchase only once per word
                            wordsInThisPurchase.add(wordText);
                            
                            const existing = wordData.get(wordText) || { count: 0, isName: false, isCompoundName: false };
                            existing.count += 1; // This counts unique purchases, not total appearances
                            // If ANY purchase marks it as name/compound, mark it as such
                            if (isName || isCompoundName) {
                                existing.isName = true;
                            }
                            if (isCompoundName) {
                                existing.isCompoundName = true;
                            }
                            wordData.set(wordText, existing);
                        }
                    });
                }
            });
            
            return wordData;
        }
        
        // Get TOP 20 words from analyzedWords with name information
        function getTop20Words() {
            if (!analyzedWords || analyzedWords.length === 0) return [];
            
            // Sort by finalValue descending and take top 20
            const sorted = [...analyzedWords]
                .filter(w => w && w.text)
                .sort((a, b) => (b.finalValue || b.totalScore || 0) - (a.finalValue || a.totalScore || 0))
                .slice(0, 20)
                .map(w => ({
                    text: w.text,
                    isName: w.isName === true || false,
                    isPartOfCompoundName: w.isPartOfCompoundName === true || false
                }));
            
            return sorted;
        }
        
        // Keep getTop5Words for backward compatibility (returns first 5 of top 20)
        function getTop5Words() {
            return getTop20Words().slice(0, 5);
        }
        
        // Save purchase to gallery after download
        async function savePurchaseToGalleryAfterDownload() {
            try {
                const totalValue = window.totalTextScore || analyzedWords.reduce((sum, w) => sum + (w.finalValue || w.totalScore || 0), 0);
                const wordCount = analyzedWords.length;
                const topWords = getTop20Words();
                const timestamp = new Date().toISOString();
                const purchaseTime = new Date().toLocaleString();
                
                // Get original text input for context comparison
                const textInput = document.getElementById('textInput');
                const originalText = textInput ? textInput.value.trim() : '';
                
                // Capture 3D node body image from claim-3d-container
                // The container has a canvas 2D element with the rendered image - capture that directly!
                let nodeBodyImageData = null;
                const claim3DContainer = document.getElementById('claim-3d-container');
                
                // Verify container exists
                if (!claim3DContainer) {
                    console.error('claim-3d-container not found! Cannot capture image.');
                } else {
                    try {
                        // Wait to ensure the 3D scene is fully rendered
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        // Find the canvas 2D element inside the container
                        const canvas2D = claim3DContainer.querySelector('canvas');
                        
                        if (!canvas2D) {
                            console.error('Canvas not found inside claim-3d-container!');
                        } else {
                            console.log(`Found canvas: ${canvas2D.width}x${canvas2D.height}`);
                            
                            // Capture directly from the canvas using toDataURL
                            // This is much more reliable than html2canvas for canvas elements
                            try {
                                // Get the image data directly from the canvas
                                nodeBodyImageData = canvas2D.toDataURL('image/jpeg', 0.70);
                                console.log(`âœ“ Captured image directly from canvas: ${nodeBodyImageData.length} chars`);
                                
                                if (!nodeBodyImageData || nodeBodyImageData.length < 100) {
                                    console.warn('Captured image seems too small or invalid');
                                    nodeBodyImageData = null;
                                } else {
                                    console.log(`âœ“ Image captured successfully: ${nodeBodyImageData.substring(0, 50)}...`);
                                }
                            } catch (canvasError) {
                                console.error('Error capturing from canvas:', canvasError);
                                // Fallback to html2canvas if direct capture fails
                                console.log('Falling back to html2canvas...');
                                const canvas = await html2canvas(canvas2D, {
                                    backgroundColor: '#000000',
                                    scale: 1,
                                    useCORS: true,
                                    allowTaint: true,
                                    logging: false
                                });
                                nodeBodyImageData = canvas.toDataURL('image/jpeg', 0.70);
                                console.log(`âœ“ Captured using html2canvas fallback: ${nodeBodyImageData.length} chars`);
                            }
                        }
                        
                        // Process the captured image: resize and compress if needed (synchronously)
                        if (nodeBodyImageData && nodeBodyImageData.length > 100) {
                            // Wait for image processing to complete
                            await new Promise((resolve, reject) => {
                                const maxWidth = 350;
                                const maxHeight = 500;
                                
                                const tempImg = new Image();
                                tempImg.onload = () => {
                                    try {
                                        const needsResize = tempImg.width > maxWidth || tempImg.height > maxHeight;
                                        
                                        if (needsResize) {
                                            const scale = Math.min(maxWidth / tempImg.width, maxHeight / tempImg.height);
                                            const finalCanvas = document.createElement('canvas');
                                            finalCanvas.width = tempImg.width * scale;
                                            finalCanvas.height = tempImg.height * scale;
                                            const ctx = finalCanvas.getContext('2d');
                                            ctx.drawImage(tempImg, 0, 0, finalCanvas.width, finalCanvas.height);
                                            
                                            // Compress with JPEG
                                            nodeBodyImageData = finalCanvas.toDataURL('image/jpeg', 0.70);
                                            
                                            const imageSizeKB = (nodeBodyImageData.length * 3) / 4 / 1024;
                                            console.log(`âœ“ Resized and compressed image: ${imageSizeKB.toFixed(2)}KB`);
                                            
                                            // Further compress if still too large
                                            if (imageSizeKB > 500) {
                                                console.warn(`Image too large (${imageSizeKB.toFixed(2)}KB), reducing quality...`);
                                                nodeBodyImageData = finalCanvas.toDataURL('image/jpeg', 0.50);
                                                const newSizeKB = (nodeBodyImageData.length * 3) / 4 / 1024;
                                                console.log(`Reduced to ${newSizeKB.toFixed(2)}KB`);
                                                
                                                if (newSizeKB > 500) {
                                                    nodeBodyImageData = finalCanvas.toDataURL('image/jpeg', 0.40);
                                                    const finalSizeKB = (nodeBodyImageData.length * 3) / 4 / 1024;
                                                    console.log(`Final compressed: ${finalSizeKB.toFixed(2)}KB`);
                                                }
                                            }
                                        } else {
                                            // Just compress without resizing
                                            const finalCanvas = document.createElement('canvas');
                                            finalCanvas.width = tempImg.width;
                                            finalCanvas.height = tempImg.height;
                                            const ctx = finalCanvas.getContext('2d');
                                            ctx.drawImage(tempImg, 0, 0);
                                            
                                            nodeBodyImageData = finalCanvas.toDataURL('image/jpeg', 0.70);
                                            const imageSizeKB = (nodeBodyImageData.length * 3) / 4 / 1024;
                                            console.log(`âœ“ Compressed image: ${imageSizeKB.toFixed(2)}KB`);
                                            
                                            if (imageSizeKB > 500) {
                                                nodeBodyImageData = finalCanvas.toDataURL('image/jpeg', 0.50);
                                            }
                                        }
                                        resolve();
                                    } catch (e) {
                                        console.error('Error processing image:', e);
                                        reject(e);
                                    }
                                };
                                tempImg.onerror = () => {
                                    console.error('Failed to load captured image for processing');
                                    nodeBodyImageData = null;
                                    resolve(); // Resolve anyway to continue
                                };
                                tempImg.src = nodeBodyImageData;
                            });
                        } else if (nodeBodyImageData) {
                            console.warn('Captured image too small, discarding');
                            nodeBodyImageData = null;
                        }
                    } catch (e) {
                        console.error('Could not capture 3D node body image:', e);
                        console.error('Error details:', {
                            message: e.message,
                            stack: e.stack,
                            containerExists: !!claim3DContainer,
                            canvasFound: claim3DContainer ? !!claim3DContainer.querySelector('canvas') : false
                        });
                    }
                }
                
                // Calculate weight (approximate - could be based on file size or node count)
                const weight = nodes.length; // Using node count as weight
                
                // Calculate price (using total value in ETH)
                let priceETH = 0;
                if (ethPriceUSD && totalValue) {
                    priceETH = totalValue / ethPriceUSD;
                }
                
                // Get GLB base64 data if available
                // CRITICAL: GLB files can be very large, so we'll only store them if they're reasonably sized
                let glbBase64 = window.__latestGlbBase64 || null;
                if (glbBase64) {
                    const glbSizeKB = (glbBase64.length * 3) / 4 / 1024;
                    console.log(`GLB data size: ${glbSizeKB.toFixed(2)}KB`);
                    
                    // If GLB is too large (>1MB), don't store it to save space
                    if (glbSizeKB > 1024) {
                        console.warn(`GLB too large (${glbSizeKB.toFixed(2)}KB), not storing to save localStorage space`);
                        glbBase64 = null;
                    }
                }
                
                // Store repetition counts at purchase time for accurate CURRENT VALUE calculation
                const purchaseTimeRepetitions = new Map();
                const wordRepetitionsAtPurchase = getWordRepetitionCounts();
                topWords.forEach(wordInfo => {
                    const wordText = typeof wordInfo === 'string' ? wordInfo : (wordInfo.text || '');
                    const wordLower = wordText.toLowerCase().trim();
                    const repetitionData = wordRepetitionsAtPurchase.get(wordLower);
                    if (repetitionData) {
                        purchaseTimeRepetitions.set(wordLower, {
                            count: repetitionData.count,
                            isName: repetitionData.isName || false,
                            isCompoundName: repetitionData.isCompoundName || false
                        });
                    }
                });
                
                // Log image status before creating purchaseData
                if (nodeBodyImageData) {
                    const imgSizeKB = (nodeBodyImageData.length * 3) / 4 / 1024;
                    console.log(`âœ“ Ready to save purchase with image (${imgSizeKB.toFixed(2)}KB)`);
                    console.log(`âœ“ Image data preview: ${nodeBodyImageData.substring(0, 80)}...`);
                    // Verify it's a valid data URL
                    if (!nodeBodyImageData.startsWith('data:image/')) {
                        console.error('âŒ ERROR: Image data is not a valid data URL!');
                        console.error('First 100 chars:', nodeBodyImageData.substring(0, 100));
                        // Don't save invalid image data
                        nodeBodyImageData = null;
                    } else {
                        console.log(`âœ“ Image data URL format verified: ${nodeBodyImageData.substring(0, 30)}...`);
                        // Test if the image can be loaded
                        const testImg = new Image();
                        testImg.onload = () => {
                            console.log(`âœ“ Image validation test passed: ${testImg.width}x${testImg.height}`);
                        };
                        testImg.onerror = () => {
                            console.error('âŒ Image validation test FAILED - image data is corrupted!');
                        };
                        testImg.src = nodeBodyImageData;
                    }
                } else {
                    console.warn('âš  No image captured for this purchase');
                }
                
                // Store minimal data needed to recreate visualization
                // Store analyzedWords with essential data only (to save space)
                const analyzedWordsData = analyzedWords.map(w => ({
                    text: w.text,
                    pos: w.pos,
                    upos: w.upos,
                    uposType: w.uposType,
                    finalValue: w.finalValue,
                    totalScore: w.totalScore,
                    baseValue: w.baseValue,
                    normalizedScore: w.normalizedScore,
                    isName: w.isName || false,
                    isPartOfCompoundName: w.isPartOfCompoundName || false,
                    isSerEstar: w.isSerEstar || false
                }));

                // Store node positions and connections (minimal data)
                // Include ALL nodes, including convergence nodes
                const nodesData = nodes.map(node => {
                    const pos = node.position || { x: 0, y: 0, z: 0 };
                    // Use index from userData (not wordIndex)
                    const wordIndex = node.userData?.index !== undefined ? node.userData.index : -1;
                    return {
                        wordIndex: wordIndex,
                        position: { x: pos.x, y: pos.y, z: pos.z },
                        wordData: node.userData?.wordData ? {
                            text: node.userData.wordData.text,
                            pos: node.userData.wordData.pos,
                            finalValue: node.userData.wordData.finalValue,
                            totalScore: node.userData.wordData.totalScore
                        } : null,
                        isConvergenceNode: false // Regular nodes are not convergence nodes
                    };
                });
                
                // Collect convergence nodes from all convergence zones
                const convergenceNodesData = [];
                if (convergenceZones && Array.isArray(convergenceZones)) {
                    convergenceZones.forEach(zone => {
                        if (zone.group) {
                            zone.group.traverse((child) => {
                                if (child.userData && child.userData.isConvergenceNode) {
                                    const pos = child.position || { x: 0, y: 0, z: 0 };
                                    // Get world position (relative to convergence zone center)
                                    const worldPos = new THREE.Vector3();
                                    child.getWorldPosition(worldPos);
                                    convergenceNodesData.push({
                                        wordIndex: -1, // Convergence nodes have special index
                                        position: { x: worldPos.x, y: worldPos.y, z: worldPos.z },
                                        wordData: child.userData.wordData ? {
                                            text: child.userData.wordData.text,
                                            pos: child.userData.wordData.pos,
                                            finalValue: child.userData.wordData.finalValue,
                                            totalScore: child.userData.wordData.totalScore
                                        } : null,
                                        isConvergenceNode: true
                                    });
                                }
                            });
                        }
                    });
                }
                
                // Combine regular nodes and convergence nodes
                const allNodesData = [...nodesData, ...convergenceNodesData];
                
                // Count convergence zones and convergence nodes
                const convergenceZoneCount = convergenceZones ? convergenceZones.length : 0;
                const convergenceNodeCount = convergenceNodesData.length;

                // Store connections using wordIndex (index in analyzedWords array)
                // This is more reliable than array positions since wordIndex is stable
                const connectionsData = connections.map(conn => {
                    if (!conn || !conn.userData) return null;
                    
                    // Try fromNode/toNode first (normal mode)
                    let fromNode = conn.userData.fromNode;
                    let toNode = conn.userData.toNode;
                    
                    // Fallback to startNode/endNode if fromNode/toNode don't exist
                    if (!fromNode || !toNode) {
                        fromNode = conn.userData.startNode;
                        toNode = conn.userData.endNode;
                    }
                    
                    if (!fromNode || !toNode) {
                        return null; // Skip connections without valid nodes
                    }
                    
                    // Get wordIndex from userData.index (this is the index in analyzedWords)
                    const fromWordIndex = fromNode.userData?.index !== undefined ? fromNode.userData.index : -1;
                    const toWordIndex = toNode.userData?.index !== undefined ? toNode.userData.index : -1;
                    
                    if (fromWordIndex < 0 || toWordIndex < 0 || fromWordIndex === toWordIndex) {
                        return null; // Skip invalid connections
                    }
                    
                    // Find node indices in nodes array by matching wordIndex
                    // This ensures we match nodes correctly even if array order changes
                    const startIndex = nodes.findIndex(n => {
                        if (!n || !n.userData) return false;
                        const nodeWordIndex = n.userData.index !== undefined ? n.userData.index : -1;
                        return nodeWordIndex === fromWordIndex;
                    });
                    
                    const endIndex = nodes.findIndex(n => {
                        if (!n || !n.userData) return false;
                        const nodeWordIndex = n.userData.index !== undefined ? n.userData.index : -1;
                        return nodeWordIndex === toWordIndex;
                    });
                    
                    if (startIndex < 0 || endIndex < 0) {
                        return null; // Skip if nodes not found
                    }
                    
                    return {
                        startIndex: startIndex,
                        endIndex: endIndex,
                        fromWordIndex: fromWordIndex, // Store wordIndex for verification
                        toWordIndex: toWordIndex
                    };
                }).filter(c => c !== null && c.startIndex >= 0 && c.endIndex >= 0);

                console.log(`Saving purchase: ${connections.length} total connections, ${connectionsData.length} valid connections saved`);
                if (connections.length !== connectionsData.length) {
                    console.warn(`Warning: ${connections.length - connectionsData.length} connections were filtered out`);
                }

                const purchaseData = {
                    id: Date.now().toString(),
                    userId: USER_ID,
                    timestamp: timestamp,
                    purchaseTime: purchaseTime,
                    totalValue: totalValue,
                    priceETH: priceETH,
                    weight: weight,
                    wordCount: wordCount,
                    topWords: topWords,
                    nodeBodyImage: nodeBodyImageData, // CRITICAL: Always include image if captured
                    glbBase64: glbBase64, // Store GLB as base64 for 3D visualization
                    originalText: originalText, // Store original text for context comparison
                    currentValue: totalValue, // Will be updated when words are reused
                    purchaseTimeRepetitions: Array.from(purchaseTimeRepetitions.entries()).map(([word, data]) => ({
                        word: word,
                        count: data.count,
                        isName: data.isName,
                        isCompoundName: data.isCompoundName
                    })), // Store repetition counts at purchase time
                    analyzedWords: analyzedWordsData, // Store analyzed words data for visualization recreation
                    nodesData: allNodesData, // Store node positions (includes all nodes, including convergence nodes)
                    connectionsData: connectionsData, // Store connections
                    convergenceZoneCount: convergenceZoneCount, // Store number of convergence zones
                    convergenceNodeCount: convergenceNodeCount, // Store number of convergence nodes
                    totalNodeCount: allNodesData.length // Store total node count (including convergence nodes)
                };
                
                // Verify image is in purchaseData before saving
                if (purchaseData.nodeBodyImage) {
                    console.log(`âœ“ Purchase data contains image (${purchaseData.nodeBodyImage.length} chars)`);
                    console.log(`âœ“ Image starts with: ${purchaseData.nodeBodyImage.substring(0, 30)}...`);
                } else {
                    console.error('âŒ ERROR: Purchase data does NOT contain image!');
                }
                
                const saved = savePurchaseToGallery(purchaseData);
                if (saved) {
                    console.log('Purchase saved to gallery successfully:', {
                        id: purchaseData.id,
                        wordCount: purchaseData.wordCount,
                        totalValue: purchaseData.totalValue,
                        hasImage: !!purchaseData.nodeBodyImage,
                        hasGLB: !!purchaseData.glbBase64
                    });
                    
                    // Refresh gallery if visible
                    if (galleryVisible) {
                        createGalleryItems();
                        // Update leaderboard visualization when new purchase is made
                        createLeaderboardRightPanelVisualization();
                    }
                    
                    // Update leaderboard button state (now it should be enabled)
                    updateLeaderboardButtonState();
                } else {
                    console.error('Failed to save purchase to gallery. Check console for details.');
                    // Show user-friendly error message
                    alert('Warning: Could not save purchase to gallery. The purchase may have been too large. Check console for details.');
                }
            } catch (e) {
                console.error('Error in savePurchaseToGalleryAfterDownload:', e);
                console.error('Error details:', {
                    message: e.message,
                    stack: e.stack,
                    wordCount: analyzedWords ? analyzedWords.length : 0,
                    hasTextInput: !!document.getElementById('textInput')
                });
                // Show user-friendly error message
                alert('Error saving purchase to gallery. Please check the console for details.');
            }
        }

        // ==================== EXPORTACIÃ“N GLB ====================
        function exportToGLB() {
            if (nodes.length === 0) {
                alert('No nodes to export. Generate a visualization first.');
                return;
            }
            
            // Check if GLTFExporter is available
            if (typeof THREE.GLTFExporter === 'undefined') {
                // Try to load dynamically
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js';
                script.onload = () => {
                    setTimeout(() => performExport(), 100);
                };
                script.onerror = () => {
                    alert('Error loading GLTFExporter. Please check your internet connection.');
                };
                document.head.appendChild(script);
                return;
            }
            
            performExport();
        }
        
        function performExport() {
            // Crear una escena temporal para exportar
            const exportScene = new THREE.Scene();
            
            // Copiar todos los nodos y conexiones
            // Use deep clone (true) for groups (nouns with flat base, "to be" verbs with flat rectangular base)
            nodes.forEach(node => {
                const clonedNode = node.isGroup ? node.clone(true) : node.clone();
                exportScene.add(clonedNode);
            });
            
            connections.forEach(connection => {
                const clonedConnection = connection.clone();
                exportScene.add(clonedConnection);
            });
            
            try {
                // Exportar usando GLTFExporter
                const exporter = new THREE.GLTFExporter();
                
                exporter.parse(exportScene, (result) => {
                    let blob;
                    let filename;
                    
                    if (result instanceof ArrayBuffer) {
                        // GLB binario
                        blob = new Blob([result], { type: 'model/gltf-binary' });
                        filename = `text-body-${getTimestamp()}.glb`;
                    } else if (typeof result === 'object') {
                        // GLTF JSON (fallback)
                        const output = JSON.stringify(result, null, 2);
                        blob = new Blob([output], { type: 'application/json' });
                        filename = `text-body-${getTimestamp()}.gltf`;
                    } else {
                        throw new Error('Formato de resultado no reconocido');
                    }
                    window.__latestGlbBlob = blob;
                    window.__latestGlbFilename = filename;
                    
                    // Convert blob to base64 for gallery storage
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        window.__latestGlbBase64 = reader.result;
                    };
                    reader.readAsDataURL(blob);
                    
                    // Descargar
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Limpiar URL despuÃ©s de un tiempo
                    setTimeout(() => URL.revokeObjectURL(link.href), 100);
                }, {
                    binary: true,
                    trs: false,
                    onlyVisible: true,
                    truncateDrawRange: true,
                    embedImages: true,
                    animations: [],
                    includeCustomExtensions: false
                });
            } catch (error) {
                console.error('Error exporting:', error);
                alert('Error exporting the model. Please try again.');
            }
        }
        
        function getTimestamp() {
            const now = new Date();
            return now.getFullYear() + 
                String(now.getMonth() + 1).padStart(2, '0') + 
                String(now.getDate()).padStart(2, '0') + '-' +
                String(now.getHours()).padStart(2, '0') + 
                String(now.getMinutes()).padStart(2, '0') + 
                String(now.getSeconds()).padStart(2, '0');
        }

        // ==================== CONTROLES DE CÃMARA ====================
        function onMouseDown(event) {
            if (alternativeControlMode) {
                // Alternative mode: Only activate with middle mouse button (button === 1)
                if (event.button !== 1) return;
                
                event.preventDefault();
                isDragging = true;
                
                // Check if Shift is pressed for panning
                isPanning = event.shiftKey;
                
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            } else {
                // Default mode: any mouse button can be used to drag and rotate
                // Prevent default to avoid text selection
                if (event.button === 0 || event.button === 1 || event.button === 2) {
                    event.preventDefault();
                    isDragging = true;
                    isPanning = false; // No panning in default mode
                    
                    previousMousePosition = {
                        x: event.clientX,
                        y: event.clientY
                    };
                }
            }
        }

        function onMouseMove(event) {
            if (!isDragging) return;
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            
            if (alternativeControlMode) {
                // Alternative mode: check for panning or rotation
                // Update panning state if Shift key state changed
                if (event.shiftKey !== isPanning) {
                    isPanning = event.shiftKey;
                }
                
                if (isPanning) {
                    // Pan: translate camera and target together (like Blender)
                    // Get camera's current forward direction
                    const forward = new THREE.Vector3();
                    camera.getWorldDirection(forward);
                    
                    // Calculate right vector (perpendicular to forward and world up)
                    const right = new THREE.Vector3();
                    right.crossVectors(forward, camera.up).normalize();
                    
                    // Use camera's up vector directly
                    const up = new THREE.Vector3();
                    up.copy(camera.up).normalize();
                    
                    // Pan speed factor (relative to camera distance)
                    const panSpeed = cameraRadius * 0.001;
                    
                    // Calculate pan movement in screen space
                    // Negative deltaX moves right, positive deltaY moves up
                    const panRight = right.multiplyScalar(-deltaX * panSpeed);
                    const panUp = up.multiplyScalar(deltaY * panSpeed);
                    const panMovement = new THREE.Vector3();
                    panMovement.addVectors(panRight, panUp);
                    
                    // Move both camera position and target together
                    camera.position.add(panMovement);
                    cameraTarget.add(panMovement);
                    
                    // Update coordinates display when camera moves
                    updateCoordinatesDisplay();
                } else {
                    // Rotate: change camera angles
                    cameraAngleY += deltaX * 0.01;
                    cameraAngleX += deltaY * 0.01;
                    
                    // Limitar Ã¡ngulo vertical
                    cameraAngleX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleX));
                    
                    updateCameraPosition();
                }
            } else {
                // Default mode: always rotate (no panning with mouse)
                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                
                // Limitar Ã¡ngulo vertical
                cameraAngleX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleX));
                
                updateCameraPosition();
            }
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseUp(event) {
            if (alternativeControlMode) {
                // Alternative mode: Only deactivate if middle mouse button is released
                if (event.button === 1) {
                    isDragging = false;
                    isPanning = false;
                }
            } else {
                // Default mode: any mouse button release stops dragging
                if (event.button === 0 || event.button === 1 || event.button === 2) {
                    isDragging = false;
                    isPanning = false;
                }
            }
        }
        
        function onMouseMoveCoordinates(event) {
            // Update global mouse position for use in other functions
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            mouse.x = mouseX;
            mouse.y = mouseY;
            
            // Update coordinates display with camera position
            updateCoordinatesDisplay();
        }
        
        function updateCoordinatesDisplay() {
            // Update coordinates display with camera position (not mouse position)
            const xElement = document.getElementById('realtime-camera-x');
            const yElement = document.getElementById('realtime-camera-y');
            const zElement = document.getElementById('realtime-camera-z');
            
            if (xElement && yElement && zElement && camera) {
                // Show camera position coordinates
                xElement.textContent = camera.position.x.toFixed(2);
                yElement.textContent = camera.position.y.toFixed(2);
                zElement.textContent = camera.position.z.toFixed(2);
            }
        }
        
        function onMouseMoveHover(event) {
            if (isDragging) return; // Don't check hover while dragging
            
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Ensure all nodes are in the scene and detectable
            // Check intersection with nodes (check all children recursively)
            // Use recursive: true to check all nested children in groups
            // Also check the scene directly to catch any nodes that might not be in the nodes array
            const allObjects = [...nodes];
            const intersects = raycaster.intersectObjects(allObjects, true);
            
            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                
                // Helper function to find the node with wordData by traversing up the parent chain
                function findNodeWithWordData(obj) {
                    if (!obj) return null;
                    
                    // Check if this object itself has wordData
                    if (obj.userData && obj.userData.wordData) {
                        return obj;
                    }
                    
                    // Check if it's directly in the nodes array
                    if (nodes.includes(obj)) {
                        return obj;
                    }
                    
                    // Traverse up the parent chain
                    let current = obj;
                    while (current && current.parent) {
                        current = current.parent;
                        if (current.userData && current.userData.wordData) {
                            return current;
                        }
                        // Check if parent is in nodes array
                        if (nodes.includes(current)) {
                            return current;
                        }
                    }
                    
                    // If not found in parent chain, search all nodes to find which one contains this object
                    for (let i = 0; i < nodes.length; i++) {
                        const node = nodes[i];
                        let found = false;
                        node.traverse((child) => {
                            if (child === obj && node.userData && node.userData.wordData) {
                                found = true;
                            }
                        });
                        if (found) {
                            return node;
                        }
                    }
                    
                    return null;
                }
                
                // Find the actual node with wordData
                const actualNode = findNodeWithWordData(intersected);
                
                // Show node info if we found a valid node
                if (actualNode && actualNode.userData && actualNode.userData.wordData) {
                    hoveredNode = actualNode;
                    showNodeInfo(actualNode, event.clientX, event.clientY);
                } else {
                    hideNodeInfo();
                }
            } else {
                hideNodeInfo();
            }
        }
        
        function onNodeClick(event) {
            if (isDragging) return; // Don't check click if we were dragging
            
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Check intersection with nodes (use same logic as hover for consistency)
            const allObjects = [...nodes];
            const intersects = raycaster.intersectObjects(allObjects, true);
            
            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                
                // Helper function to find the node with wordData (same as in onMouseMoveHover)
                function findNodeWithWordData(obj) {
                    if (!obj) return null;
                    
                    // Check if this object itself has wordData
                    if (obj.userData && obj.userData.wordData) {
                        return obj;
                    }
                    
                    // Check if it's directly in the nodes array
                    if (nodes.includes(obj)) {
                        return obj;
                    }
                    
                    // Traverse up the parent chain
                    let current = obj;
                    while (current && current.parent) {
                        current = current.parent;
                        if (current.userData && current.userData.wordData) {
                            return current;
                        }
                        // Check if parent is in nodes array
                        if (nodes.includes(current)) {
                            return current;
                        }
                    }
                    
                    // If not found in parent chain, search all nodes to find which one contains this object
                    for (let i = 0; i < nodes.length; i++) {
                        const node = nodes[i];
                        let found = false;
                        node.traverse((child) => {
                            if (child === obj && node.userData && node.userData.wordData) {
                                found = true;
                            }
                        });
                        if (found) {
                            return node;
                        }
                    }
                    
                    return null;
                }
                
                // Find the actual node with wordData
                const actualNode = findNodeWithWordData(intersected);
                
                // Show node details if we found a valid node
                if (actualNode && actualNode.userData && actualNode.userData.wordData) {
                    hoveredNode = actualNode;
                    showNodeDetails(actualNode);
                    
                    // Move camera to focus on the clicked node (same logic as Map Text)
                    focusCameraOnNode(actualNode);
                } else {
                    console.warn('Could not find node with wordData for click event');
                }
            }
        }
        
        // Helper function to get next available offset
        function getNextRightPanelOffset() {
            // If there's an available offset from a closed panel, use the LOWEST one first
            // This ensures panels always appear in order from bottom to top
            if (availableOffsets.length > 0) {
                // Sort offsets in ascending order and take the lowest
                availableOffsets.sort((a, b) => a - b);
                return availableOffsets.shift(); // Take first (lowest) instead of last
            }
            // Otherwise, calculate new offset based on number of active panels
            return rightPanels.length * 20; // 20px offset per panel
        }
        
        // Helper function to create a cloned right panel
        function createRightPanelClone(panelId, offset) {
            const originalPanel = document.getElementById('right-panel');
            if (!originalPanel) return null;
            
            // Clone the panel
            const clonedPanel = originalPanel.cloneNode(true);
            clonedPanel.id = `right-panel-${panelId}`;
            clonedPanel.className = 'right-panel-clone';
            
            // Set position with offset (elevated to avoid bottom bar - 21px height)
            clonedPanel.style.bottom = (21 + offset) + 'px';
            clonedPanel.style.right = (5 + offset) + 'px';
            
            // Update all IDs in cloned panel to be unique (must do this BEFORE querying elements)
            // But keep track of key container IDs for later reference
            const allElements = clonedPanel.querySelectorAll('[id]');
            const idMap = {};
            let headerId = null;
            let detailsId = null;
            allElements.forEach(el => {
                if (el.id) {
                    const oldId = el.id;
                    const newId = oldId + '-' + panelId;
                    el.id = newId;
                    idMap[oldId] = newId;
                    
                    // Track important container IDs
                    if (oldId === 'right-panel-header') headerId = newId;
                    if (oldId === 'node-details-content') detailsId = newId;
                }
            });
            
            // Store IDs for later use
            clonedPanel.dataset.headerId = headerId;
            clonedPanel.dataset.detailsId = detailsId;
            
            // Update close button to use specific panel ID (after IDs are updated)
            const closeBtn = clonedPanel.querySelector(`#right-panel-close-${panelId}`);
            if (closeBtn) {
                closeBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    hideRightPanel(panelId);
                };
            } else {
                console.error('Close button not found for panel:', panelId);
            }
            
            // Add to body
            document.body.appendChild(clonedPanel);
            
            return clonedPanel;
        }
        
        // Helper function to create 3D scene for a cloned panel
        function createRightPanelScene(panelId) {
            const panel = document.getElementById(`right-panel-${panelId}`);
            if (!panel) {
                console.error('Panel not found:', `right-panel-${panelId}`);
                return null;
            }
            
            // Canvas ID is updated to right-panel-canvas-{panelId}
            const canvas = panel.querySelector(`#right-panel-canvas-${panelId}`) || panel.querySelector('canvas');
            if (!canvas) {
                console.error('Canvas not found in panel:', panelId);
                return null;
            }
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            const camera = new THREE.PerspectiveCamera(50, 200 / 150, 0.1, 100);
            camera.position.set(0, 0, 2);
            camera.lookAt(0, 0, 0);
            
            const renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: false,
                alpha: false
            });
            // Get actual canvas dimensions (accounting for padding: 200px - 10px = 190px)
            const canvasWidth = 190;
            const canvasHeight = 140; // Increased from 90px
            renderer.setSize(canvasWidth, canvasHeight);
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(2, 2, 2);
            scene.add(directionalLight);
            
            return { scene, camera, renderer };
        }
        
        // Helper function to show enlarged node in a specific panel
        function showRightPanelEnlargedNodeForPanel(panelId, node) {
            const panelData = rightPanels.find(p => p.id === panelId);
            if (!panelData || !panelData.scene) return;
            
            // Remove previous mesh
            if (panelData.mesh) {
                panelData.scene.remove(panelData.mesh);
                if (panelData.mesh.geometry) panelData.mesh.geometry.dispose();
                if (panelData.mesh.material) panelData.mesh.material.dispose();
                if (panelData.mesh.children) {
                    panelData.mesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            }
            
            // Clone the node for display (enlarged) using the correct shape
            const wordData = node.userData.wordData;
            const enlargedSize = 0.35;
            
            // Get color - use violet for convergence nodes, otherwise use value-based color
            let color;
            if (node.userData && node.userData.isConvergenceNode) {
                color = 0x8B00FF; // Violet color for convergence nodes
            } else {
                // Get color using the same function as nodes (getValueBasedColor)
                // This ensures colors match between nodes and Map Text
                const nodeIndex = node.userData.index !== undefined ? node.userData.index : 0;
                color = getValueBasedColor(wordData, nodeIndex, analyzedWords);
            }
            
            // Get word type to determine correct shape
            const wordType = getWordTypeForShape(wordData, node.userData.index || 0);
            
            // Determine opacity
            let nodeOpacity = 0.92;
            const semiTransparentTypes = ['proper_noun', 'object_pronoun', 'intensive_pronoun', 
                                         'interrogative_pronoun', 'superlative_adjective', 'modal_verb',
                                         'concrete_noun', 'gerundial_noun', 'interrogative_determiner'];
            if (semiTransparentTypes.includes(wordType)) {
                nodeOpacity = 0.80;
            }
            
            // Create geometry using the correct shape function
            const colorHex = typeof color === 'number' ? color : parseInt(color, 16);
            const mesh = createWordTypeGeometry(wordType, enlargedSize, colorHex, nodeOpacity);
            
            panelData.mesh = mesh;
            panelData.scene.add(mesh);
            
            // Render immediately to show the node
            if (panelData.renderer && panelData.camera) {
                panelData.renderer.render(panelData.scene, panelData.camera);
            }
        }
        
        // Helper function to animate a specific panel
        function animateRightPanelNodeForPanel(panelId) {
            const panelData = rightPanels.find(p => p.id === panelId);
            if (!panelData || !panelData.mesh || !panelData.renderer || !panelData.scene || !panelData.camera) {
                if (panelData && panelData.animationId) {
                    cancelAnimationFrame(panelData.animationId);
                    panelData.animationId = null;
                }
                return;
            }
            
            // Rotate the node
            panelData.mesh.rotation.y += 0.01;
            panelData.mesh.rotation.x += 0.005;
            
            panelData.renderer.render(panelData.scene, panelData.camera);
            panelData.animationId = requestAnimationFrame(() => animateRightPanelNodeForPanel(panelId));
        }
        
        function showNodeDetails(node) {
            if (!node.userData || !node.userData.wordData) return;
            
            // Check if we need to close all panels and start fresh
            if (rightPanels.length >= MAX_RIGHT_PANELS) {
                // Close ALL panels and start fresh (instead of removing oldest)
                console.log(`Maximum panels (${MAX_RIGHT_PANELS}) reached. Closing all panels and starting fresh.`);
                hideNodeDetails(); // This closes all panels
                // Reset the panels array (hideNodeDetails already clears it, but ensure it's empty)
                rightPanels = [];
                availableOffsets = [];
            }
            
            // Get next available offset
            const offset = getNextRightPanelOffset();
            
            // Create new panel
            const panelId = rightPanelCounter++;
            const panelElement = createRightPanelClone(panelId, offset);
            if (!panelElement) return;
            
            // Create 3D scene for this panel
            const sceneData = createRightPanelScene(panelId);
            if (!sceneData) {
                panelElement.remove();
                return;
            }
            
            const wordData = node.userData.wordData;
            const index = node.userData.index;
            const totalValue = window.totalTextScore || 0;
            const individualValue = wordData.finalValue || wordData.totalScore || 0;
            const relativeValue = totalValue > 0 ? ((individualValue / totalValue) * 100).toFixed(2) + '%' : '0%';
            
            // Calculate node size in KB (approximate)
            let nodeSizeKB = 0;
            if (node.userData.isSerEstar) {
                nodeSizeKB = (1 * 1 * 1 * 4 * 3) + (1.5 * 0.1 * 1.2 * 4 * 3);
            } else if (node.userData.isNoun) {
                nodeSizeKB = (8 * 8 * 8 * 4 * 3) + (1 * 1 * 1 * 4 * 3);
            } else if (node.userData.connectionCount > 0) {
                nodeSizeKB = (8 * 4 * 3);
            } else {
                nodeSizeKB = (8 * 8 * 8 * 4 * 3);
            }
            nodeSizeKB = (nodeSizeKB / 1024).toFixed(4);
            
            // Calculate performance impact
            const performanceImpact = node.userData.connectionCount > 0 ? 
                'Medium (' + node.userData.connectionCount + ' connections)' : 
                'Low';
            
            // Convert individual value to ETH for display
            let individualValueETH = 0;
            if (ethPriceUSD) {
                individualValueETH = individualValue / ethPriceUSD;
            }
            const individualValueETHDisplay = individualValueETH >= 0.01 ? 
                `${individualValueETH.toFixed(6)} ETH` : 
                `${individualValueETH.toFixed(10)} ETH`;
            
            // Convert total value to ETH
            let totalValueETH = 0;
            if (ethPriceUSD) {
                totalValueETH = totalValue / ethPriceUSD;
            }
            const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                `${totalValueETH.toFixed(6)} ETH` : 
                `${totalValueETH.toFixed(10)} ETH`;
            
            // Update panel content - find elements using stored IDs or structure
            const headerId = panelElement.dataset.headerId || `right-panel-header-${panelId}`;
            const detailsId = panelElement.dataset.detailsId || `node-details-content-${panelId}`;
            
            const header = panelElement.querySelector(`#${headerId}`);
            const detailsContent = panelElement.querySelector(`#${detailsId}`);
            
            // Update header word - position it in top right corner
            let panelWordEl = panelElement.querySelector(`#right-panel-word-${panelId}`);
            
            // If word element doesn't exist, create it
            if (!panelWordEl) {
                panelWordEl = document.createElement('h3');
                panelWordEl.id = `right-panel-word-${panelId}`;
                panelWordEl.style.cssText = 'position: absolute; top: 2px; right: 5px; color: #000000; font-size: 11px; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; z-index: 10; line-height: 1;';
                panelElement.appendChild(panelWordEl);
            }
            
            if (panelWordEl) {
                panelWordEl.textContent = wordData.text;
            }
            
            // Update details content using innerHTML (like TOP NODES)
            if (detailsContent) {
                // Force visibility BEFORE updating content - match max-value-panel-info exactly
                detailsContent.style.display = 'block';
                detailsContent.style.visibility = 'visible';
                detailsContent.style.opacity = '1';
                detailsContent.style.background = '#000000';
                detailsContent.style.color = '#ffffff';
                detailsContent.style.fontSize = '9px';
                detailsContent.style.fontFamily = 'Helvetica, Arial, sans-serif';
                detailsContent.style.lineHeight = '1.3';
                detailsContent.style.margin = '0';
                detailsContent.style.padding = '8px';
                detailsContent.style.flex = '1';
                detailsContent.style.minHeight = '0';
                detailsContent.style.boxSizing = 'border-box';
                detailsContent.style.overflowY = 'visible';
                
                // Check if it's a convergence node
                const isConvergenceNode = node.userData && node.userData.isConvergenceNode;
                const positionText = isConvergenceNode ? 
                    'Convergence Zone' : 
                    `${index + 1} / ${analyzedWords.length}`;
                
                // Find which convergence zone this node belongs to
                let convergenceZoneInfo = '';
                if (isConvergenceNode) {
                    const zone = convergenceZones.find(z => {
                        if (z.group && z.group.children) {
                            return z.group.children.some(child => child === node || (child.userData && child.userData.isConvergenceNode && child.userData.wordData && child.userData.wordData.text === wordData.text));
                        }
                        return false;
                    });
                    if (zone) {
                        const zoneIndex = convergenceZones.indexOf(zone);
                        convergenceZoneInfo = `<div><strong>Source:</strong> Convergence Zone ${zoneIndex + 1}</div>`;
                    }
                }
                
                detailsContent.innerHTML = `
                    <div><strong>Word:</strong> ${wordData.text}</div>
                    <div><strong>Individual Value:</strong> ${individualValueETHDisplay}</div>
                    <div><strong>Position in Text:</strong> ${positionText}</div>
                    ${convergenceZoneInfo}
                    <div><strong>Value / Total:</strong> ${relativeValue} (${totalValueETHDisplay} total)</div>
                    <div><strong>Connections:</strong> ${node.userData.connectionCount || 0}</div>
                    <div><strong>Size (KB):</strong> ${nodeSizeKB} KB</div>
                    <div><strong>Performance:</strong> ${performanceImpact}</div>
                    <div><strong>3D Coordinates:</strong> (${node.position.x.toFixed(2)}, ${node.position.y.toFixed(2)}, ${node.position.z.toFixed(2)})</div>
                `;
                
                // Verify it's visible after update
                const computedStyle = window.getComputedStyle(detailsContent);
                console.log('Details content updated. Display:', computedStyle.display, 'Visibility:', computedStyle.visibility, 'Opacity:', computedStyle.opacity, 'Background:', computedStyle.backgroundColor, 'Height:', computedStyle.height);
            } else {
                console.error('Details content element not found!');
            }
            
            // Store panel data first
            const panelData = {
                id: panelId,
                element: panelElement,
                node: node,
                scene: sceneData.scene,
                renderer: sceneData.renderer,
                camera: sceneData.camera,
                mesh: null,
                animationId: null,
                offset: offset
            };
            
            rightPanels.push(panelData);
            
            // Make canvas clickeable to show fractal
            const canvas = panelElement.querySelector(`#right-panel-canvas-${panelId}`) || panelElement.querySelector('canvas');
            if (canvas) {
                canvas.style.cursor = 'pointer';
                canvas.addEventListener('click', function(e) {
                    if (node && node.userData && node.userData.wordData) {
                        // Check if it's a convergence node
                        if (node.userData.isConvergenceNode) {
                            showFractalModalForConvergenceNode(node, e.clientX, e.clientY);
                        } else {
                            const wordIndex = node.userData.index;
                            if (wordIndex >= 0 && wordIndex < analyzedWords.length) {
                                showFractalModal(wordIndex, e.clientX, e.clientY);
                            }
                        }
                    }
                });
            }
            
            // Show enlarged node in panel (must be after panelData is in rightPanels array)
            showRightPanelEnlargedNodeForPanel(panelId, node);
            
            // Show panel - ensure it's visible
            panelElement.classList.add('visible');
            panelElement.style.display = 'flex';
            panelElement.style.visibility = 'visible';
            panelElement.style.opacity = '1';
            
            // Debug: log if elements were found
            console.log('Panel created:', panelId, 'Header found:', !!header, 'Details found:', !!detailsContent, 'HeaderId:', headerId, 'DetailsId:', detailsId);
            
            // Start animation
            animateRightPanelNodeForPanel(panelId);
        }
        
        function showRightPanelEnlargedNode(node) {
            if (!rightPanelScene || !rightPanelRenderer) return;
            
            // Remove previous mesh
            if (rightPanelMesh) {
                rightPanelScene.remove(rightPanelMesh);
                if (rightPanelMesh.geometry) rightPanelMesh.geometry.dispose();
                if (rightPanelMesh.material) rightPanelMesh.material.dispose();
                if (rightPanelMesh.children) {
                    rightPanelMesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            }
            
            // Clone the node for display (enlarged)
            const wordData = node.userData.wordData;
            const baseSize = 0.06;
            const enlargedSize = 0.35; // Larger for right panel
            
            // Get color using the same function as nodes (getValueBasedColor)
            // This ensures colors match between nodes and Map Text
            const nodeIndex = node.userData.index !== undefined ? node.userData.index : 0;
            const color = getValueBasedColor(wordData, nodeIndex, analyzedWords);
            
            if (wordData.isSerEstar) {
                // Create cube with flat rectangular base for "to be" verbs
                const cubeGeometry = new THREE.BoxGeometry(enlargedSize, enlargedSize, enlargedSize, 1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const cube = new THREE.Mesh(cubeGeometry, material);
                
                // Make base same size as cube (like names have same size as sphere)
                const flatRectWidth = enlargedSize * 1.0; // Same width as cube
                const flatRectDepth = enlargedSize * 1.0; // Same depth as cube
                const flatRectHeight = enlargedSize * 0.1; // Thin base
                const flatRectGeometry = new THREE.BoxGeometry(flatRectWidth, flatRectHeight, flatRectDepth, 1, 1, 1);
                const flatRectMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const flatRect = new THREE.Mesh(flatRectGeometry, flatRectMaterial);
                flatRect.position.y = -enlargedSize * 2.0; // Same separation as names
                
                const group = new THREE.Group();
                group.add(cube);
                group.add(flatRect);
                rightPanelMesh = group;
            } else if (wordData.pos === 'noun') {
                // Create sphere with flat square for nouns
                const sphereGeometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const sphere = new THREE.Mesh(sphereGeometry, material);
                
                const flatSquareSize = enlargedSize * 1.0;
                const flatSquareGeometry = new THREE.BoxGeometry(flatSquareSize, flatSquareSize * 0.1, flatSquareSize, 1, 1, 1);
                const flatSquareMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const flatSquare = new THREE.Mesh(flatSquareGeometry, flatSquareMaterial);
                flatSquare.position.y = -enlargedSize * 2.0;
                
                const group = new THREE.Group();
                group.add(sphere);
                group.add(flatSquare);
                rightPanelMesh = group;
            } else if (node.userData.connectionCount > 0) {
                // Cube for connected nodes
                let geometry;
                if (node.userData.connectionCount >= 5) {
                    geometry = new THREE.BoxGeometry(enlargedSize * 1.2, enlargedSize * 0.8, enlargedSize * 1.5, 1, 1, 1);
                } else {
                    geometry = new THREE.BoxGeometry(enlargedSize, enlargedSize, enlargedSize, 1, 1, 1);
                }
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                rightPanelMesh = new THREE.Mesh(geometry, material);
            } else {
                // Sphere for unconnected nodes
                const geometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                rightPanelMesh = new THREE.Mesh(geometry, material);
            }
            
            rightPanelScene.add(rightPanelMesh);
        }
        
        function animateRightPanelNode() {
            if (!rightPanelMesh || !rightPanelRenderer || !rightPanelScene || !rightPanelCamera) {
                if (rightPanelAnimationId) {
                    cancelAnimationFrame(rightPanelAnimationId);
                    rightPanelAnimationId = null;
                }
                return;
            }
            
            // Rotate the node
            rightPanelMesh.rotation.y += 0.01;
            rightPanelMesh.rotation.x += 0.005;
            
            rightPanelRenderer.render(rightPanelScene, rightPanelCamera);
            rightPanelAnimationId = requestAnimationFrame(animateRightPanelNode);
        }
        
        // ==================== VALUE LOGIC SUMMARY ====================
        
        function generateTop5Node3D(canvasId, wordData, wordIndex) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            try {
                // Create a small 3D scene for the node
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                
                const canvasWidth = canvas.width || 120;
                const canvasHeight = canvas.height || 90;
                const camera = new THREE.PerspectiveCamera(50, canvasWidth / canvasHeight, 0.1, 100);
                // Camera position for centered, appropriately sized node, slightly to the right
                camera.position.set(0.1, 0, 1.2); // Slight right offset (0.1) to center in recuadro
                camera.lookAt(0.1, 0, 0); // Look at slightly right position
                
                const renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: false,
                    alpha: false
                });
                renderer.setSize(canvasWidth, canvasHeight);
                renderer.setPixelRatio(1);
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(2, 2, 2);
                scene.add(directionalLight);
                
                // Create node geometry based on word data
                const baseSize = 0.06;
                const smallSize = 0.2; // Smaller, appropriately sized for preview
                
                let color;
                const score = wordData.normalizedScore || 0;
                if (score > 0.85) {
                    color = 0xffff00;
                } else if (score > 0.7) {
                    color = 0x4a6fa5;
                } else if (score > 0.5) {
                    color = 0x5a7fb5;
                } else if (score > 0.3) {
                    color = 0x6a8fc5;
                } else if (score > 0.1) {
                    color = 0x7a9fd5;
                } else {
                    color = 0xffffff;
                }
                
                let mesh;
                if (wordData.isSerEstar) {
                    // Cube with flat rectangular base
                    const cubeGeometry = new THREE.BoxGeometry(smallSize, smallSize, smallSize, 1, 1, 1);
                    const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                    const cube = new THREE.Mesh(cubeGeometry, material);
                    
                    const flatRectWidth = smallSize * 1.0;
                    const flatRectDepth = smallSize * 1.0;
                    const flatRectHeight = smallSize * 0.1;
                    const flatRectGeometry = new THREE.BoxGeometry(flatRectWidth, flatRectHeight, flatRectDepth, 1, 1, 1);
                    const flatRectMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                    const flatRect = new THREE.Mesh(flatRectGeometry, flatRectMaterial);
                    flatRect.position.y = -smallSize * 2.0;
                    
                    const group = new THREE.Group();
                    group.add(cube);
                    group.add(flatRect);
                    mesh = group;
                } else if (wordData.pos === 'noun') {
                    // Sphere with flat square
                    const sphereGeometry = new THREE.SphereGeometry(smallSize, 8, 8);
                    const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                    const sphere = new THREE.Mesh(sphereGeometry, material);
                    
                    const flatSquareSize = smallSize * 1.0;
                    const flatSquareGeometry = new THREE.BoxGeometry(flatSquareSize, flatSquareSize * 0.1, flatSquareSize, 1, 1, 1);
                    const flatSquareMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                    const flatSquare = new THREE.Mesh(flatSquareGeometry, flatSquareMaterial);
                    flatSquare.position.y = -smallSize * 2.0;
                    
                    const group = new THREE.Group();
                    group.add(sphere);
                    group.add(flatSquare);
                    mesh = group;
                } else {
                    // Regular sphere
                    const sphereGeometry = new THREE.SphereGeometry(smallSize, 8, 8);
                    const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                    mesh = new THREE.Mesh(sphereGeometry, material);
                }
                
                scene.add(mesh);
                
                // Position mesh slightly to the right for better centering in recuadro
                mesh.position.x = 0.05; // Slight right offset
                
                // Render with slight rotation
                mesh.rotation.y = Math.PI / 4;
                mesh.rotation.x = Math.PI / 6;
                renderer.render(scene, camera);
                
                // Clean up
                setTimeout(() => {
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                    if (mesh.children) {
                        mesh.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    }
                    renderer.dispose();
                }, 100);
            } catch (e) {
                console.warn('Error generating top5 node 3D:', e);
            }
        }
        
        function generateTop5Grid(top4Words) {
            const gridContainer = document.getElementById('value-logic-top5-grid');
            if (!gridContainer) return;
            
            if (!top4Words || top4Words.length === 0) {
                gridContainer.style.display = 'none';
                return;
            }
            
            // Get color mode
            const boxBorder = valueLogicColorMode ? "#000000" : "#ffffff";
            const boxBg = valueLogicColorMode ? "#ffffff" : "#000000";
            const textColor = valueLogicColorMode ? "#000000" : "#ffffff";
            
            // Create grid HTML - 2 columns
            let gridHTML = '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">';
            
            top4Words.forEach((w, idx) => {
                const wordIndex = analyzedWords.indexOf(w);
                if (wordIndex < 0) return;
                
                const fractalCanvasId = `top5-grid-fractal-${idx}`;
                
                // Each cell: fractal in box, word in box at bottom
                gridHTML += `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                        <div style="border: 1px solid ${boxBorder}; background: #000000; width: 100%; padding: 2px;">
                            <canvas id="${fractalCanvasId}" width="120" height="90" style="display: block; width: 100%; height: 90px;"></canvas>
                        </div>
                        <div style="border: 1px solid ${boxBorder}; background: ${boxBg}; padding: 4px; width: 100%;">
                            <div style="color: ${textColor}; font-size: 10px; text-align: center; font-family: Helvetica, Arial, sans-serif;">${w.text}</div>
                        </div>
                    </div>
                `;
            });
            
            gridHTML += '</div>';
            gridContainer.innerHTML = gridHTML;
            gridContainer.style.display = 'block';
            
            // Generate fractals
            setTimeout(() => {
                top4Words.forEach((w, idx) => {
                    const wordIndex = analyzedWords.indexOf(w);
                    if (wordIndex >= 0) {
                        const fractalCanvasId = `top5-grid-fractal-${idx}`;
                        
                        // Generate fractal visualization
                        generateTop5Fractal(fractalCanvasId, wordIndex);
                    }
                });
            }, 150);
        }
        
        function generateTop5Fractal(canvasId, wordIndex) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !analyzedWords || wordIndex < 0 || wordIndex >= analyzedWords.length) {
                return;
            }
            
            try {
                const ctx = canvas.getContext('2d');
                if (!ctx) return;
                
                const wordData = analyzedWords[wordIndex];
                const params = calculateFractalParameters(wordIndex);
                
                // Clear canvas
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Generate fractal at smaller resolution
                const width = canvas.width;
                const height = canvas.height;
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;
                
                // Use lower resolution for performance
                const scale = 0.5;
                const renderWidth = Math.floor(width * scale);
                const renderHeight = Math.floor(height * scale);
                
                // Calculate scaleFactor to fit complete fractal in canvas
                // For Mandelbrot/Julia sets, typical range is -2 to 2 (4 units total)
                // We want the fractal to fit exactly in the canvas boundaries
                // For width=120, to show 4 units: scaleFactor = width / 4 = 30
                // For height=90, to show 4 units: scaleFactor = height / 4 = 22.5
                // Use the smaller value to ensure it fits in both dimensions
                const fractalRange = 4.0; // -2 to 2 range
                const scaleFactorX = width / fractalRange; // ~30 for 120px width
                const scaleFactorY = height / fractalRange; // ~22.5 for 90px height
                const scaleFactor = Math.min(scaleFactorX, scaleFactorY); // Use smaller to fit both dimensions
                
                // Center the fractal (no offset) to show complete fractal
                const offsetX = 0; // Centered
                const offsetY = 0; // Centered
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Generate fractal
                for (let y = 0; y < renderHeight; y++) {
                    for (let x = 0; x < renderWidth; x++) {
                        const px = (x - renderWidth / 2) / scaleFactor + offsetX;
                        const py = (y - renderHeight / 2) / scaleFactor + offsetY;
                        
                        let color = [0, 0, 0, 255];
                        
                        switch (params.family) {
                            case 'Mandelbrot':
                                color = mandelbrotColor(px, py, params);
                                break;
                            case 'Multibrot':
                                color = multibrotColor(px, py, params);
                                break;
                            case 'Julia':
                                color = juliaColor(px, py, params);
                                break;
                            case 'Newton':
                                color = newtonColor(px, py, params);
                                break;
                            case 'OrbitTrap':
                                color = orbitTrapColor(px, py, params);
                                break;
                            default:
                                color = mandelbrotColor(px, py, params);
                        }
                        
                        // Write to image data (scaled up)
                        for (let sy = 0; sy < 1 / scale; sy++) {
                            for (let sx = 0; sx < 1 / scale; sx++) {
                                const idx = ((Math.floor(y / scale) + sy) * width + Math.floor(x / scale) + sx) * 4;
                                if (idx >= 0 && idx < data.length - 3) {
                                    data[idx] = color[0];
                                    data[idx + 1] = color[1];
                                    data[idx + 2] = color[2];
                                    data[idx + 3] = color[3];
                                }
                            }
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            } catch (e) {
                console.warn('Error generating top5 fractal:', e);
            }
        }
        
        function showValueLogicSummary() {
            if (!analyzedWords || analyzedWords.length === 0) {
                alert('No text analyzed. Please generate a visualization first.');
                return;
            }
            
            const modal = document.getElementById('value-logic-modal');
            const modalContainer = document.getElementById('value-logic-modal-container');
            const content = document.getElementById('value-logic-content');
            const totalValueBtn = document.getElementById('total-value-display');
            
            // Show modal explicitly
            if (modal) {
                modal.style.display = 'block';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
                modal.style.pointerEvents = 'auto';
            }
            
            // Position modal below the button (or in 3D visualization space on mobile)
            if (totalValueBtn && modalContainer) {
                // Check if mobile (screen width <= 768px)
                if (window.innerWidth <= 768) {
                    // Ensure mobile elements are positioned first
                    positionMobileElements();
                    
                    // Wait for elements to be positioned correctly, then position modal
                    setTimeout(() => {
                        // Position modal in same space as 3D visualization (below top bar and fps bar)
                        const topBar = document.getElementById('top-bar');
                        const fpsBar = document.getElementById('fps-bar');
                        const bottomBar = document.getElementById('bottom-bar');
                        const leftPanel = document.getElementById('left-panel');
                        
                        const topBarHeight = topBar ? (topBar.offsetHeight || 0) : 0;
                        const fpsBarHeight = fpsBar ? (fpsBar.offsetHeight || 7) : 7;
                        const bottomBarHeight = bottomBar ? (bottomBar.offsetHeight || 7) : 7;
                        const leftPanelHeight = leftPanel && !leftPanel.classList.contains('collapsed') ? (leftPanel.offsetHeight || 0) : 0;
                        
                        const topPosition = topBarHeight + fpsBarHeight;
                        const bottomMargin = bottomBarHeight + leftPanelHeight;
                        const availableHeight = window.innerHeight - topPosition - bottomMargin;
                        
                        // Use setProperty with important flag to override CSS and inline styles
                        modalContainer.style.setProperty('position', 'fixed', 'important');
                        modalContainer.style.setProperty('top', topPosition + 'px', 'important');
                        modalContainer.style.setProperty('left', '50%', 'important');
                        modalContainer.style.setProperty('transform', 'translateX(-50%)', 'important');
                        modalContainer.style.setProperty('margin', '0', 'important');
                        modalContainer.style.setProperty('max-width', '95%', 'important');
                        modalContainer.style.setProperty('width', '95%', 'important');
                        modalContainer.style.setProperty('max-height', Math.max(availableHeight - 10, 100) + 'px', 'important');
                        modalContainer.style.setProperty('bottom', 'auto', 'important');
                        modalContainer.style.setProperty('overflow-y', 'auto', 'important');
                    }, 300); // Increased timeout to ensure elements are positioned
                } else {
                    // Desktop positioning: below button
                    const btnRect = totalValueBtn.getBoundingClientRect();
                    modalContainer.style.top = (btnRect.bottom + 5) + 'px'; // 5px gap below button
                    modalContainer.style.left = btnRect.left + 'px';
                    modalContainer.style.transform = 'none';
                    modalContainer.style.margin = '0'; // Remove auto margin
                }
            }
            
            // Calculate statistics
            const totalWords = analyzedWords.length;
            const totalValuePoints = window.totalTextScore || analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
            const avgBaseValue = analyzedWords.reduce((sum, w) => sum + (w.baseValue || 0), 0) / totalWords;
            const avgFinalValuePoints = totalValuePoints / totalWords;
            
            // Convert points directly to ETH
            let totalValueETH = 0;
            let avgFinalValueETH = 0;
            if (ethPriceUSD) {
                totalValueETH = totalValuePoints / ethPriceUSD;
                avgFinalValueETH = avgFinalValuePoints / ethPriceUSD;
            }
            
            const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                `${totalValueETH.toFixed(6)} ETH` : 
                `${totalValueETH.toFixed(10)} ETH`;
            const avgFinalValueETHDisplay = avgFinalValueETH >= 0.01 ? 
                `${avgFinalValueETH.toFixed(6)} ETH` : 
                `${avgFinalValueETH.toFixed(10)} ETH`;
            
            // Calculate average multipliers
            const avgLengthMultiplier = analyzedWords.reduce((sum, w) => sum + (w.lengthMultiplier || 1), 0) / totalWords;
            const avgOntologicalMultiplier = analyzedWords.reduce((sum, w) => sum + (w.ontologicalMultiplier || 1), 0) / totalWords;
            const avgNameWithToBeMultiplier = analyzedWords.reduce((sum, w) => sum + (w.nameWithToBeMultiplier || 1), 0) / totalWords;
            const avgSemanticMultiplier = analyzedWords.reduce((sum, w) => sum + (w.semanticMultiplier || 1), 0) / totalWords;
            const avgRepetitionMultiplier = analyzedWords.reduce((sum, w) => sum + (w.repetitionMultiplier || 1), 0) / totalWords;
            const avgTenseMultiplier = analyzedWords.reduce((sum, w) => sum + (w.tenseMultiplier || 1), 0) / totalWords;
            const avgNarrativePenalty = analyzedWords.reduce((sum, w) => sum + (w.narrativePenalty || 1), 0) / totalWords;
            
            // Calculate predominant tense
            let presentCount = 0;
            let pastCount = 0;
            let futureCount = 0;
            analyzedWords.forEach((w, idx) => {
                // Use the same tense detection logic as getTenseMultiplier
                if (w.pos === 'verb') {
                    const cleanWord = w.text.toLowerCase().replace(/[^\w]/g, '');
                    const presentVerbs = ['is', 'am', 'are', 'be', 'being', 'exist', 'exists', 'remain', 'remains',
                                         'es', 'son', 'estar', 'ser', 'existe', 'existen', 'permanece', 'permanecen',
                                         'have', 'has', 'do', 'does', 'go', 'goes', 'come', 'comes', 'see', 'sees',
                                         'tengo', 'tiene', 'hago', 'hace', 'voy', 'va', 'vengo', 'viene', 'veo', 've'];
                    const pastVerbs = ['was', 'were', 'been', 'existed', 'remained', 'became', 'had', 'did', 'went',
                                      'came', 'saw', 'fue', 'fueron', 'estuvo', 'estuvieron', 'existiÃ³', 'existieron',
                                      'tuvo', 'hizo', 'fue', 'vino', 'vio', 'said', 'told', 'thought', 'knew',
                                      'dijo', 'contÃ³', 'pensÃ³', 'supo'];
                    const futureVerbs = ['will', 'shall', 'would', 'going', 'gonna',
                                        'serÃ¡', 'serÃ¡n', 'estarÃ¡', 'estarÃ¡n', 'tendrÃ¡', 'tendrÃ¡n', 'harÃ¡', 'harÃ¡n',
                                        'irÃ¡', 'irÃ¡n', 'vendrÃ¡', 'vendrÃ¡n', 'verÃ¡', 'verÃ¡n'];
                    const futureModal = ['will', 'shall', 'would', 'can', 'could', 'may', 'might',
                                        'podrÃ¡', 'podrÃ¡n', 'deberÃ¡', 'deberÃ¡n', 'puede', 'pueden'];
                    
                    if (presentVerbs.includes(cleanWord) || cleanWord.endsWith('ing')) {
                        presentCount++;
                    } else if (pastVerbs.includes(cleanWord) || cleanWord.endsWith('ed')) {
                        pastCount++;
                    } else if (futureVerbs.includes(cleanWord) || futureModal.includes(cleanWord)) {
                        futureCount++;
                    }
                }
            });
            
            let predominantTense = 'none';
            const totalVerbs = presentCount + pastCount + futureCount;
            if (totalVerbs > 0) {
                if (presentCount > pastCount && presentCount > futureCount) {
                    predominantTense = 'present';
                } else if (pastCount > presentCount && pastCount > futureCount) {
                    predominantTense = 'past';
                } else if (futureCount > presentCount && futureCount > pastCount) {
                    predominantTense = 'future';
                } else if (presentCount > 0 && (pastCount > 0 || futureCount > 0)) {
                    if (futureCount > 0) {
                        predominantTense = 'present_future';
                    } else if (pastCount > 0) {
                        predominantTense = 'present_past';
                    }
                }
            }
            
            const tenseLabels = {
                'present': 'Present',
                'past': 'Past',
                'future': 'Future',
                'present_future': 'Present + Future',
                'present_past': 'Present + Past',
                'none': 'No verbs detected'
            };
            
            // Count by POS
            const posCounts = {};
            const posValues = {};
            const posValuesETH = {};
            analyzedWords.forEach(w => {
                const pos = w.pos || 'other';
                posCounts[pos] = (posCounts[pos] || 0) + 1;
                const valueUSD = w.finalValue || 0;
                posValues[pos] = (posValues[pos] || 0) + valueUSD;
                if (ethPriceUSD) {
                    posValuesETH[pos] = (posValuesETH[pos] || 0) + (valueUSD / ethPriceUSD);
                }
            });
            
            // Count special words
            const toBeCount = analyzedWords.filter(w => w.isSerEstar).length;
            
            // Count names: use nameGroups so compound names count as 1, not multiple
            // Each name group (single name or compound name) counts as 1 name
            const nameGroups = window.nameGroups || [];
            const nameCount = nameGroups.length; // Each name or compound name = 1
            
            // Ontological Values: toBeCount + nameCount (each name or compound name counts as 1 ontological value)
            const ontologicalValues = toBeCount + nameCount;
            
            const ontologicalAssertions = analyzedWords.filter(w => w.ontologicalMultiplier > 1).length;
            
            // Top 4 words by value (for visualizations)
            const top4Words = [...analyzedWords]
                .sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0))
                .slice(0, 4);
            
            // Top 20 words by value
            const topWords = [...analyzedWords]
                .sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0))
                .slice(0, 20);
            
            // Helper function to highlight numbers
            function highlightNumber(num) {
                if (valueLogicColorMode) {
                    // White mode: black background, white text
                    return `<span style="background: #000000; color: #ffffff !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;">${num}</span>`;
                } else {
                    // Black mode: white background, black text
                    return `<span style="background: #ffffff; color: #000000 !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;">${num}</span>`;
                }
            }
            
            // Build HTML content with color mode support
            const boxBg = valueLogicColorMode ? "#ffffff" : "#000000";
            const boxBorder = valueLogicColorMode ? "#000000" : "#ffffff";
            const textColor = valueLogicColorMode ? "#000000" : "#ffffff";
            const borderColor = boxBorder;
            const dividerColor = valueLogicColorMode ? "#cccccc" : "#333333";
            const boxStyle = `background: ${boxBg}; border: 1px solid ${boxBorder}; padding: 4px; margin-bottom: 3px; border-radius: 0;`;
            const itemStyle = "margin: 0.5px 0;";
            
            // Format generation date/time
            let generationDateStr = 'N/A';
            if (visualizationGenerationDate) {
                const date = visualizationGenerationDate;
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');
                generationDateStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
            }
            
            let html = `
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">General Summary</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Total Words:</strong> ${highlightNumber(totalWords)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Average Value per Word:</strong> ${highlightNumber(avgFinalValueETHDisplay)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Average Base Value:</strong> ${highlightNumber(avgBaseValue.toFixed(2))}</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Date</h3>
                    <div style="${itemStyle} color: ${textColor};">${generationDateStr}</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Applied Multipliers (Average)</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Length Multiplier:</strong> Ã—${highlightNumber(avgLengthMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Multiplier:</strong> Ã—${highlightNumber(avgOntologicalMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Name + "to be" Multiplier:</strong> Ã—${highlightNumber(avgNameWithToBeMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Semantic Closure Multiplier:</strong> Ã—${highlightNumber(avgSemanticMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Repetition Multiplier:</strong> Ã—${highlightNumber(avgRepetitionMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Temporal Multiplier:</strong> Ã—${highlightNumber(avgTenseMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Predominant Tense:</strong> ${highlightNumber(tenseLabels[predominantTense])} (Present: ${presentCount}, Past: ${pastCount}, Future: ${futureCount})</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Narrative Penalty:</strong> Ã—${highlightNumber(avgNarrativePenalty.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Global Reduction:</strong> Ã—${highlightNumber('1.0')}</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Distribution by Value Range</h3>
            `;
            
            // Calculate value ranges
            const valueRanges = {
                'â‰¥ 1 ETH': { min: 1.0, count: 0, totalValue: 0 },
                '0.1 - 1 ETH': { min: 0.1, max: 1.0, count: 0, totalValue: 0 },
                '0.01 - 0.1 ETH': { min: 0.01, max: 0.1, count: 0, totalValue: 0 },
                '0.001 - 0.01 ETH': { min: 0.001, max: 0.01, count: 0, totalValue: 0 },
                '0.0001 - 0.001 ETH': { min: 0.0001, max: 0.001, count: 0, totalValue: 0 },
                '< 0.0001 ETH': { max: 0.0001, count: 0, totalValue: 0 }
            };
            
            // Count words in each range
            analyzedWords.forEach(w => {
                const valuePoints = w.finalValue || 0;
                const valueETH = ethPriceUSD ? valuePoints / ethPriceUSD : 0;
                
                if (valueETH >= 1.0) {
                    valueRanges['â‰¥ 1 ETH'].count++;
                    valueRanges['â‰¥ 1 ETH'].totalValue += valueETH;
                } else if (valueETH >= 0.1) {
                    valueRanges['0.1 - 1 ETH'].count++;
                    valueRanges['0.1 - 1 ETH'].totalValue += valueETH;
                } else if (valueETH >= 0.01) {
                    valueRanges['0.01 - 0.1 ETH'].count++;
                    valueRanges['0.01 - 0.1 ETH'].totalValue += valueETH;
                } else if (valueETH >= 0.001) {
                    valueRanges['0.001 - 0.01 ETH'].count++;
                    valueRanges['0.001 - 0.01 ETH'].totalValue += valueETH;
                } else if (valueETH >= 0.0001) {
                    valueRanges['0.0001 - 0.001 ETH'].count++;
                    valueRanges['0.0001 - 0.001 ETH'].totalValue += valueETH;
                } else {
                    valueRanges['< 0.0001 ETH'].count++;
                    valueRanges['< 0.0001 ETH'].totalValue += valueETH;
                }
            });
            
            // Sort ranges by total value (descending) and display
            const sortedRanges = Object.keys(valueRanges)
                .map(rangeName => ({
                    name: rangeName,
                    ...valueRanges[rangeName]
                }))
                .filter(range => range.count > 0) // Only show ranges with words
                .sort((a, b) => b.totalValue - a.totalValue); // Sort by total value descending
            
            sortedRanges.forEach(range => {
                const count = range.count;
                const rangeTotalValueETH = range.totalValue;
                const percentage = (count / totalWords * 100).toFixed(1);
                const valuePercentage = totalValueETH > 0 ? ((rangeTotalValueETH / totalValueETH) * 100).toFixed(1) : '0.0';
                const valueETHDisplay = rangeTotalValueETH >= 0.01 ? `${rangeTotalValueETH.toFixed(6)} ETH` : `${rangeTotalValueETH.toFixed(10)} ETH`;
                html += `<div style="${itemStyle} color: ${textColor};"><strong>${range.name}:</strong> ${highlightNumber(count)} words (${highlightNumber(percentage + '%')}) - Total Value: ${highlightNumber(valueETHDisplay)} (${highlightNumber(valuePercentage + '%')} of total)</div>`;
            });
            
            html += `
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Special Elements</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Values:</strong> ${highlightNumber(ontologicalValues)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Names:</strong> ${highlightNumber(nameCount)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Assertions:</strong> ${highlightNumber(ontologicalAssertions)}</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Top 20 Words by Value</h3>
            `;
            
            topWords.forEach((w, idx) => {
                const wordValuePoints = w.finalValue || 0;
                const wordValueETH = ethPriceUSD ? wordValuePoints / ethPriceUSD : 0;
                const wordValueETHDisplay = wordValueETH >= 0.01 ? 
                    `${wordValueETH.toFixed(6)} ETH` : 
                    `${wordValueETH.toFixed(10)} ETH`;
                html += `
                    <div style="${itemStyle} color: ${textColor}; padding: 2px 0; border-top: 1px solid ${dividerColor};">
                        <strong>${idx + 1}. "${w.text}"</strong><br>
                        Value: ${highlightNumber(wordValueETHDisplay)}<br>
                        Base: ${highlightNumber((w.baseValue || 0).toFixed(2))} | 
                        Length: Ã—${highlightNumber((w.lengthMultiplier || 1).toFixed(2))} | 
                        Ontological: Ã—${highlightNumber((w.ontologicalMultiplier || 1).toFixed(2))} | 
                        Repetition: Ã—${highlightNumber((w.repetitionMultiplier || 1).toFixed(2))}
                    </div>
                `;
            });
            
            html += `
                </div>
            `;
            
            // Add input text block at the end
            const inputText = (document.getElementById('textInput')?.value || '').trim();
            if (inputText) {
                html += `
                    <div style="${boxStyle}">
                        <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Input Text</h3>
                        <div style="${itemStyle} color: ${textColor}; white-space: pre-wrap; word-wrap: break-word;">${inputText}</div>
                    </div>
                `;
            }
            
            content.innerHTML = html;
            
            // Create overview visualization
            createValueLogicOverview();
            
            // Generate top 4 grid with nodes and fractals
            generateTop5Grid(top4Words);
            
            // Update total value box
            const totalBox = document.getElementById('value-logic-total-box');
            const totalDisplay = document.getElementById('value-logic-total-display');
            if (totalBox && totalDisplay) {
                totalDisplay.textContent = totalValueETHDisplay;
                totalBox.style.display = 'block';
                
                // Apply color mode to total box
                if (valueLogicColorMode) {
                    totalBox.style.background = '#ffffff';
                    totalBox.style.border = '1px solid #000000';
                    const totalBoxDiv = totalBox.querySelector('div');
                    if (totalBoxDiv) totalBoxDiv.style.color = '#000000';
                } else {
                    totalBox.style.background = '#000000';
                    totalBox.style.border = '1px solid #ffffff';
                    const totalBoxDiv = totalBox.querySelector('div');
                    if (totalBoxDiv) totalBoxDiv.style.color = '#ffffff';
                }
            }
            
            modal.style.display = 'block';
            modal.style.visibility = 'visible';
            modal.style.opacity = '1';
            modal.style.pointerEvents = 'auto';
        }
        
        function toggleValueLogicColorMode() {
            valueLogicColorMode = !valueLogicColorMode;
            
            // Update color indicator
            const indicator = document.getElementById('value-logic-color-indicator');
            if (indicator) {
                indicator.style.background = valueLogicColorMode ? '#ffffff' : '#000000';
            }
            
            // Re-generate the content with new colors
            if (analyzedWords && analyzedWords.length > 0) {
                showValueLogicSummary();
            }
        }
        
        function toggleConvergenceZonesColorMode() {
            convergenceZonesColorMode = !convergenceZonesColorMode;
            
            // Update color indicator
            const indicator = document.getElementById('convergence-zones-color-indicator');
            if (indicator) {
                indicator.style.background = convergenceZonesColorMode ? '#ffffff' : '#000000';
            }
            
            // Re-generate the content with new colors
            if (convergenceZones && convergenceZones.length > 0) {
                showConvergenceZonesModal();
            }
        }
        
        function saveValueLogicSummaryAsImage() {
            const modal = document.getElementById('value-logic-modal');
            if (!modal || modal.style.display === 'none') return;
            
            // Get the modal content container (the inner div, not the overlay)
            const modalContainer = document.getElementById('value-logic-modal-container');
            if (!modalContainer) return;
            
            // Check if html2canvas is available
            if (typeof html2canvas === 'undefined') {
                alert('Error: html2canvas library not loaded. Please check your internet connection.');
                return;
            }
            
            // Capture the 3D canvas overview if it exists and is visible
            const overviewCanvas = document.getElementById('value-logic-overview-canvas');
            const overviewContainer = document.getElementById('value-logic-overview-container');
            let canvasImageData = null;
            let tempImg = null;
            let originalCanvasStyle = null;
            
            if (overviewCanvas && overviewContainer && overviewContainer.style.display !== 'none') {
                try {
                    // Render one more frame to ensure canvas is up to date
                    if (valueLogicOverviewRenderer && valueLogicOverviewScene && valueLogicOverviewCamera) {
                        valueLogicOverviewRenderer.render(valueLogicOverviewScene, valueLogicOverviewCamera);
                    }
                    
                    // Convert canvas to data URL
                    canvasImageData = overviewCanvas.toDataURL('image/png');
                    
                    // Create a temporary image element to replace the canvas
                    tempImg = document.createElement('img');
                    tempImg.src = canvasImageData;
                    tempImg.style.width = '100%';
                    tempImg.style.height = '100%';
                    tempImg.style.display = 'block';
                    
                    // Hide the canvas temporarily
                    originalCanvasStyle = overviewCanvas.style.cssText;
                    overviewCanvas.style.display = 'none';
                    
                    // Insert the image in the container
                    overviewContainer.appendChild(tempImg);
                } catch (e) {
                    console.warn('Could not capture 3D canvas:', e);
                    canvasImageData = null;
                }
            }
            
            // Capture top 4 fractal canvases
            const top5CanvasImages = [];
            for (let i = 0; i < 4; i++) {
                const fractalCanvas = document.getElementById(`top5-grid-fractal-${i}`);
                
                if (fractalCanvas) {
                    try {
                        const fractalDataURL = fractalCanvas.toDataURL('image/png');
                        const fractalImg = document.createElement('img');
                        fractalImg.src = fractalDataURL;
                        fractalImg.style.width = fractalCanvas.style.width || '60px';
                        fractalImg.style.height = fractalCanvas.style.height || '45px';
                        fractalImg.style.display = 'block';
                        top5CanvasImages.push({ canvas: fractalCanvas, img: fractalImg });
                    } catch (e) {
                        console.warn(`Could not capture top5 fractal canvas ${i}:`, e);
                    }
                }
            }
            
            // Replace canvas elements with images temporarily
            top5CanvasImages.forEach(({ canvas, img }) => {
                if (canvas && canvas.parentNode) {
                    const originalStyle = canvas.style.cssText;
                    canvas.style.display = 'none';
                    canvas.parentNode.insertBefore(img, canvas);
                    img.style.cssText = originalStyle;
                }
            });
            
            // Force a small delay to ensure rendering is complete
            setTimeout(() => {
                // Use html2canvas to capture the modal content - let it capture naturally
                // html2canvas will automatically capture the full element including all content
                html2canvas(modalContainer, {
                    backgroundColor: '#dcdcdcc2', // Match the modal background color (rgba(220, 220, 220, 0.76))
                    scale: 2, // Higher quality
                    logging: false,
                    useCORS: true,
                    allowTaint: true, // Allow taint to include canvas images
                    removeContainer: false,
                    imageTimeout: 0,
                    onclone: function(clonedDoc) {
                        // Ensure the cloned element maintains its dimensions
                        const clonedContainer = clonedDoc.getElementById('value-logic-modal-container');
                        if (clonedContainer) {
                            clonedContainer.style.position = 'absolute';
                            clonedContainer.style.left = '0';
                            clonedContainer.style.top = '0';
                        }
                    }
                }).then(canvas => {
                    // Restore original canvas if we replaced it
                    if (tempImg && overviewCanvas && overviewContainer) {
                        try {
                            overviewContainer.removeChild(tempImg);
                            overviewCanvas.style.cssText = originalCanvasStyle || '';
                        } catch (e) {
                            console.warn('Error restoring canvas:', e);
                        }
                    }
                    
                    // Restore top 5 canvases
                    top5CanvasImages.forEach(({ canvas, img }) => {
                        if (canvas && img && img.parentNode) {
                            try {
                                img.parentNode.removeChild(img);
                                canvas.style.display = 'block';
                            } catch (e) {
                                console.warn('Error restoring top5 canvas:', e);
                            }
                        }
                    });
                    
                    // Ensure canvas dimensions are correct - scale is already applied by html2canvas
                    // The canvas width/height should be actualWidth * scale and actualHeight * scale
                    // But html2canvas handles this automatically, so we just need to ensure proper aspect ratio
                    
                    // Convert canvas to blob
                    canvas.toBlob(function(blob) {
                        if (!blob) {
                            alert('Error generating image. Please try again.');
                            return;
                        }
                        
                        // Create download link
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `total-value-summary-${getTimestamp()}.jpg`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        // Clean up URL
                        setTimeout(() => URL.revokeObjectURL(url), 100);
                    }, 'image/jpeg', 1.0); // Maximum quality JPEG
                }).catch(error => {
                    console.error('Error capturing image:', error);
                    
                    // Restore original canvas on error
                    if (tempImg && overviewCanvas && overviewContainer) {
                        try {
                            overviewContainer.removeChild(tempImg);
                            overviewCanvas.style.cssText = originalCanvasStyle || '';
                        } catch (e) {
                            console.warn('Error restoring canvas:', e);
                        }
                    }
                    
                    // Restore top 5 canvases on error
                    canvasReplacements.forEach(({ canvas, img, parent }) => {
                        if (canvas && img && parent && img.parentNode === parent) {
                            try {
                                // Replace image back with canvas
                                parent.replaceChild(canvas, img);
                            } catch (e) {
                                console.warn('Error restoring top5 canvas:', e);
                            }
                        }
                    });
                    
                    alert('Error capturing the window. Please try again.');
                });
            }, 100); // Small delay to ensure rendering is complete
        }
        
        // ==================== FRACTAL GENERATION ====================
        function setupFractalClickListeners() {
            // Right panel canvas click - setup on initialization
            setTimeout(() => {
                if (rightPanelCanvas) {
                    rightPanelCanvas.style.cursor = 'pointer';
                    rightPanelCanvas.addEventListener('click', function(e) {
                        if (selectedNode && selectedNode.userData && selectedNode.userData.wordData) {
                            const wordIndex = selectedNode.userData.index;
                            showFractalModal(wordIndex, e.clientX, e.clientY);
                        }
                    });
                }
                
                // Max value panel canvas click
                if (maxValuePanelCanvas) {
                    maxValuePanelCanvas.style.cursor = 'pointer';
                    maxValuePanelCanvas.addEventListener('click', function(e) {
                        if (maxValueNode && maxValueNode.userData && maxValueNode.userData.wordData) {
                            const wordIndex = maxValueNode.userData.index;
                            showFractalModal(wordIndex, e.clientX, e.clientY);
                        }
                    });
                }
                
                // Node info panel canvas click
                if (nodeInfoCanvas) {
                    nodeInfoCanvas.style.cursor = 'pointer';
                    nodeInfoCanvas.addEventListener('click', function(e) {
                        if (hoveredNode && hoveredNode.userData && hoveredNode.userData.wordData) {
                            const wordIndex = hoveredNode.userData.index;
                            showFractalModal(wordIndex, e.clientX, e.clientY);
                        }
                    });
                }
            }, 100);
        }
        
        function addNodeListCanvasClickListener(canvas, nodeIndex, node) {
            if (canvas && !canvas.dataset.fractalListenerAdded) {
                canvas.style.cursor = 'pointer';
                canvas.dataset.fractalListenerAdded = 'true';
                canvas.addEventListener('click', function(e) {
                    // Check if it's a convergence node (violet node)
                    if (node && node.userData && node.userData.isConvergenceNode) {
                        // For convergence nodes, show fractal using the node's word data
                        showFractalModalForConvergenceNode(node, e.clientX, e.clientY);
                    } else if (analyzedWords && nodeIndex >= 0 && nodeIndex < analyzedWords.length) {
                        // For normal nodes, use the standard fractal modal
                        showFractalModal(nodeIndex, e.clientX, e.clientY);
                    }
                });
            }
        }
        
        function showFractalModal(wordIndex, mouseX, mouseY) {
            if (fractalGenerationInProgress || !analyzedWords || wordIndex < 0 || wordIndex >= analyzedWords.length) {
                return;
            }
            
            const wordData = analyzedWords[wordIndex];
            currentFractalWordIndex = wordIndex;
            
            // Update modal title
            document.getElementById('fractal-word-name').textContent = wordData.text;
            
            // Show modal
            const fractalModal = document.getElementById('fractal-modal');
            fractalModal.style.display = 'block';
            fractalModal.style.visibility = 'visible';
            fractalModal.style.opacity = '1';
            fractalModal.style.pointerEvents = 'auto';
            
            // Position container at mouse position if provided, otherwise use default position
            const fractalModalContainer = document.getElementById('fractal-modal-container');
            if (fractalModalContainer) {
                if (mouseX !== undefined && mouseY !== undefined) {
                    // Position at mouse coordinates
                    fractalModalContainer.style.top = mouseY + 'px';
                    fractalModalContainer.style.left = mouseX + 'px';
                    fractalModalContainer.style.right = 'auto';
                    fractalModalContainer.style.bottom = 'auto';
                    fractalModalContainer.style.transform = 'none';
                    
                    // Ensure modal doesn't go off screen
                    const modalWidth = 300; // max-width of modal
                    const modalHeight = 250; // approximate height
                    if (mouseX + modalWidth > window.innerWidth) {
                        fractalModalContainer.style.left = (window.innerWidth - modalWidth - 10) + 'px';
                    }
                    if (mouseY + modalHeight > window.innerHeight) {
                        fractalModalContainer.style.top = (window.innerHeight - modalHeight - 10) + 'px';
                    }
                } else {
                    // Default position: just below fps bar, fully to the right
                    fractalModalContainer.style.top = '25px';
                    fractalModalContainer.style.right = '0px';
                    fractalModalContainer.style.left = 'auto';
                    fractalModalContainer.style.bottom = 'auto';
                    fractalModalContainer.style.transform = 'none';
                }
            }
            
            // Generate fractal
            generateWordFractal(wordIndex);
        }
        
        function showFractalModalForConvergenceNode(node, mouseX, mouseY) {
            if (fractalGenerationInProgress || !node || !node.userData || !node.userData.wordData) {
                return;
            }
            
            const wordData = node.userData.wordData;
            currentFractalWordIndex = -1; // Special index for convergence nodes
            
            // Update modal title
            document.getElementById('fractal-word-name').textContent = wordData.text;
            
            // Show modal
            const fractalModal = document.getElementById('fractal-modal');
            fractalModal.style.display = 'block';
            fractalModal.style.visibility = 'visible';
            fractalModal.style.opacity = '1';
            fractalModal.style.pointerEvents = 'auto';
            
            // Position container at mouse position if provided, otherwise use default position
            const fractalModalContainer = document.getElementById('fractal-modal-container');
            if (fractalModalContainer) {
                if (mouseX !== undefined && mouseY !== undefined) {
                    // Position at mouse coordinates
                    fractalModalContainer.style.top = mouseY + 'px';
                    fractalModalContainer.style.left = mouseX + 'px';
                    fractalModalContainer.style.right = 'auto';
                    fractalModalContainer.style.bottom = 'auto';
                    fractalModalContainer.style.transform = 'none';
                    
                    // Ensure modal doesn't go off screen
                    const modalWidth = 300; // max-width of modal
                    const modalHeight = 250; // approximate height
                    if (mouseX + modalWidth > window.innerWidth) {
                        fractalModalContainer.style.left = (window.innerWidth - modalWidth - 10) + 'px';
                    }
                    if (mouseY + modalHeight > window.innerHeight) {
                        fractalModalContainer.style.top = (window.innerHeight - modalHeight - 10) + 'px';
                    }
                } else {
                    // Default position: just below fps bar, fully to the right
                    fractalModalContainer.style.top = '25px';
                    fractalModalContainer.style.right = '0px';
                    fractalModalContainer.style.left = 'auto';
                    fractalModalContainer.style.bottom = 'auto';
                    fractalModalContainer.style.transform = 'none';
                }
            }
            
            // Generate fractal for convergence node
            generateWordFractalForConvergenceNode(node);
        }
        
        function generateWordFractalForConvergenceNode(node) {
            if (!fractalCtx || !node || !node.userData || !node.userData.wordData) {
                return;
            }
            
            fractalGenerationInProgress = true;
            
            const wordData = node.userData.wordData;
            // Calculate fractal parameters based on word data
            const params = calculateFractalParametersForConvergenceNode(wordData);
            
            // Clear canvas
            fractalCtx.fillStyle = '#000000';
            fractalCtx.fillRect(0, 0, fractalCanvas.width, fractalCanvas.height);
            
            // Generate fractal based on family type
            setTimeout(() => {
                try {
                    renderFractal(params);
                    fractalGenerationInProgress = false;
                } catch (e) {
                    console.error('Error generating fractal for convergence node:', e);
                    fractalGenerationInProgress = false;
                }
            }, 10); // Small delay to prevent blocking
        }
        
        function calculateFractalParametersForConvergenceNode(wordData) {
            // Use the same logic as calculateFractalParameters but adapted for convergence nodes
            // Since convergence nodes don't have leftWord/rightWord context, we'll use simplified context
            
            const isToBe = wordData.isSerEstar;
            
            // Determine fractal family based on POS and context (same as normal nodes)
            let family = 'Mandelbrot';
            if (wordData.pos === 'pronoun' || wordData.uposType === 'PRON') {
                family = 'OrbitTrap';
            } else if (isToBe) {
                family = 'Multibrot';
            } else if (wordData.pos === 'verb' || wordData.uposType === 'VERB') {
                family = 'Newton';
            } else if (wordData.pos === 'noun' || wordData.uposType === 'NOUN') {
                family = 'Mandelbrot';
            } else if (wordData.pos === 'adjective' || wordData.uposType === 'ADJ') {
                family = 'Julia';
            } else if (wordData.pos === 'conjunction' || wordData.text.toLowerCase().match(/^(if|because|although|though|while)$/)) {
                family = 'LSystem';
            } else if (wordData.pos === 'preposition' || wordData.pos === 'determiner') {
                family = 'IFS';
            } else if (wordData.text.toLowerCase().match(/^(must|can|should|may|might|could|would)$/)) {
                family = 'DomainColoring';
            }
            
            // Calculate depth based on value (same as normal nodes)
            const wordValue = wordData.finalValue || wordData.totalScore || 0;
            
            // Calculate seed from word data (similar to normal nodes but without context words)
            const seedStr = `${wordData.text}|${wordData.pos}|${wordValue}`;
            const seed = simpleHash(seedStr);
            
            // Additional seed-based variations for uniqueness (same as normal nodes)
            const seedNorm1 = (seed % 997) / 997;
            const seedNorm2 = ((seed * 7919) % 997) / 997;
            const seedNorm3 = ((seed * 3571) % 997) / 997;
            
            // Calculate depth (same logic as normal nodes)
            let depth = 200; // Default
            if (wordValue < 0.1) depth = 80;
            else if (wordValue < 2) depth = 80 + (wordValue - 0.1) * (120 / 1.9);
            else if (wordValue < 5) depth = 200 + (wordValue - 2) * (400 / 3);
            else if (wordValue < 10) depth = 600 + (wordValue - 5) * (1400 / 5);
            else depth = 2000;
            depth = Math.round(Math.min(2000, Math.max(80, depth)));
            
            // Calculate zoom (same logic as normal nodes)
            let zoom = 0.3 + seedNorm1 * 0.4;
            if (isToBe) {
                zoom = 0.4 + seedNorm1 * 0.3;
                zoom *= 0.8; // Even lower for "to be"
            } else {
                zoom = 0.2 + seedNorm1 * 0.3 + (wordValue * 0.05);
            }
            zoom = Math.min(1.0, Math.max(0.15, zoom));
            
            // Calculate symmetry (same logic as normal nodes)
            let symmetry = 0.5;
            if (wordData.semanticMultiplier && wordData.semanticMultiplier > 1.2) {
                symmetry = 0.7 + (wordData.semanticMultiplier - 1.2) * 0.3;
            }
            if (isToBe) symmetry = 0.9;
            symmetry = Math.min(1.0, Math.max(0.1, symmetry));
            
            // Calculate perturbation (same logic as normal nodes)
            let perturbation = 0.1;
            const wordLower = wordData.text.toLowerCase();
            if (wordLower === 'not' || wordLower === 'no') {
                perturbation = 0.8;
            } else if (wordLower.match(/^(if|unless|unless|when|while)$/)) {
                perturbation = 0.6;
            }
            
            // Determine palette
            let palette = 'high_contrast'; // Default
            
            return {
                family: family,
                seed: seed,
                seedNorm1: seedNorm1,
                seedNorm2: seedNorm2,
                seedNorm3: seedNorm3,
                depth: depth,
                zoom: zoom,
                symmetry: symmetry,
                perturbation: perturbation,
                palette: palette,
                wordValue: wordValue,
                wordText: wordData.text.toLowerCase(),
                pos: wordData.pos
            };
        }
        
        function generateWordFractal(wordIndex) {
            if (!fractalCtx || !analyzedWords || wordIndex < 0 || wordIndex >= analyzedWords.length) {
                return;
            }
            
            fractalGenerationInProgress = true;
            
            const wordData = analyzedWords[wordIndex];
            const params = calculateFractalParameters(wordIndex);
            
            // Clear canvas
            fractalCtx.fillStyle = '#000000';
            fractalCtx.fillRect(0, 0, fractalCanvas.width, fractalCanvas.height);
            
            // Generate fractal based on family type
            setTimeout(() => {
                try {
                    renderFractal(params);
                    fractalGenerationInProgress = false;
                } catch (e) {
                    console.error('Error generating fractal:', e);
                    fractalGenerationInProgress = false;
                }
            }, 10); // Small delay to prevent blocking
        }
        
        function calculateFractalParameters(wordIndex) {
            if (!analyzedWords || wordIndex < 0 || wordIndex >= analyzedWords.length) {
                return getDefaultFractalParams();
            }
            
            const wordData = analyzedWords[wordIndex];
            const leftWord = wordIndex > 0 ? analyzedWords[wordIndex - 1] : null;
            const rightWord = wordIndex < analyzedWords.length - 1 ? analyzedWords[wordIndex + 1] : null;
            
            // Detect ontological cluster (I/we + am/is/are pattern)
            const isFirstPerson = wordData.pos === 'pronoun' && 
                (wordData.text.toLowerCase() === 'i' || wordData.text.toLowerCase() === 'we');
            const isToBe = wordData.isSerEstar;
            const isAfterToBe = leftWord && leftWord.isSerEstar && 
                (leftWord.text.toLowerCase() === 'am' || leftWord.text.toLowerCase() === 'is' || 
                 leftWord.text.toLowerCase() === 'are' || leftWord.text.toLowerCase() === 'was' || 
                 leftWord.text.toLowerCase() === 'were');
            
            // Determine fractal family based on POS and context
            let family = 'Mandelbrot';
            if (wordData.pos === 'pronoun') {
                family = 'OrbitTrap';
            } else if (isToBe) {
                family = 'Multibrot';
            } else if (wordData.pos === 'verb' && !isToBe) {
                family = 'Newton';
            } else if (wordData.pos === 'noun') {
                // Check if abstract (hard to determine, use as concrete for now)
                family = 'Mandelbrot';
            } else if (wordData.pos === 'adjective') {
                family = 'Julia';
            } else if (wordData.pos === 'conjunction' || wordData.text.toLowerCase().match(/^(if|because|although|though|while)$/)) {
                family = 'LSystem';
            } else if (wordData.pos === 'preposition' || wordData.pos === 'determiner') {
                family = 'IFS';
            } else if (wordData.text.toLowerCase().match(/^(must|can|should|may|might|could|would)$/)) {
                family = 'DomainColoring';
            }
            
            // Calculate depth based on value (calculate first, before using in seed)
            const wordValue = wordData.finalValue || wordData.totalScore || 0;
            
            // Calculate seed from context - more variation (now wordValue is available)
            const seedStr = `${wordData.text}|${leftWord ? leftWord.text : ''}|${rightWord ? rightWord.text : ''}|${wordIndex}|${wordData.pos}|${wordValue}`;
            const seed = simpleHash(seedStr);
            
            // Additional seed-based variations for uniqueness
            const seedNorm1 = (seed % 997) / 997;
            const seedNorm2 = ((seed * 7919) % 997) / 997; // Different prime for variation
            const seedNorm3 = ((seed * 3571) % 997) / 997;
            let depth = 200; // Default
            if (wordValue < 0.1) depth = 80;
            else if (wordValue < 2) depth = 80 + (wordValue - 0.1) * (120 / 1.9);
            else if (wordValue < 5) depth = 200 + (wordValue - 2) * (400 / 3);
            else if (wordValue < 10) depth = 600 + (wordValue - 5) * (1400 / 5);
            else depth = 2000;
            depth = Math.round(Math.min(2000, Math.max(80, depth)));
            
            // Calculate zoom - reduced to show more colored area
            let zoom = 0.3 + seedNorm1 * 0.4; // Base zoom varies by seed (0.3-0.7)
            if (isFirstPerson || isToBe || isAfterToBe) {
                zoom = 0.4 + seedNorm1 * 0.3; // Lower zoom = more area visible for ontological clusters
                if (isToBe) zoom *= 0.8; // Even lower for "to be"
            } else {
                zoom = 0.2 + seedNorm1 * 0.3 + (wordValue * 0.05); // Varied by seed and value
            }
            zoom = Math.min(1.0, Math.max(0.15, zoom)); // Range: 0.15-1.0 for more visible area
            
            // Calculate symmetry (high for semantic closure, low for dependencies)
            let symmetry = 0.5;
            if (wordData.semanticMultiplier && wordData.semanticMultiplier > 1.2) {
                symmetry = 0.7 + (wordData.semanticMultiplier - 1.2) * 0.3;
            }
            if (isToBe) symmetry = 0.9; // Very high symmetry for "to be"
            symmetry = Math.min(1.0, Math.max(0.1, symmetry));
            
            // Calculate perturbation (high for negation/conditionals)
            let perturbation = 0.1;
            const wordLower = wordData.text.toLowerCase();
            if (wordLower === 'not' || wordLower === 'no') {
                perturbation = 0.8;
            } else if (wordLower.match(/^(if|unless|unless|when|while)$/)) {
                perturbation = 0.6;
            }
            
            // Determine palette based on tense
            let palette = 'high_contrast'; // Default (present)
            // This would require tense detection, using default for now
            
            return {
                family: family,
                seed: seed,
                seedNorm1: seedNorm1,
                seedNorm2: seedNorm2,
                seedNorm3: seedNorm3,
                depth: depth,
                zoom: zoom,
                symmetry: symmetry,
                perturbation: perturbation,
                palette: palette,
                wordValue: wordValue,
                wordText: wordData.text.toLowerCase(),
                pos: wordData.pos
            };
        }
        
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return Math.abs(hash);
        }
        
        function getDefaultFractalParams() {
            return {
                family: 'Mandelbrot',
                seed: 12345,
                depth: 200,
                zoom: 1.0,
                symmetry: 0.5,
                perturbation: 0.1,
                palette: 'high_contrast',
                wordValue: 0
            };
        }
        
        function renderFractal(params) {
            const width = fractalCanvas.width;
            const height = fractalCanvas.height;
            const imageData = fractalCtx.createImageData(width, height);
            const data = imageData.data;
            
            // Use lower resolution for performance, then scale up
            const scale = 0.5; // Render at half resolution for speed
            const renderWidth = Math.floor(width * scale);
            const renderHeight = Math.floor(height * scale);
            
            // Use seed-based offset to vary each fractal's view
            const offsetX = ((params.seedNorm1 || 0.5) - 0.5) * 2.0; // -1 to 1
            const offsetY = ((params.seedNorm2 || 0.5) - 0.5) * 2.0; // -1 to 1
            const centerX = width / 2;
            const centerY = height / 2;
            const scaleFactor = params.zoom * 150; // Reduced for more area
            
            // Generate fractal based on family
            for (let y = 0; y < renderHeight; y++) {
                for (let x = 0; x < renderWidth; x++) {
                    const px = (x - renderWidth / 2) / scaleFactor + offsetX;
                    const py = (y - renderHeight / 2) / scaleFactor + offsetY;
                    
                    let color = [0, 0, 0, 255]; // Default black
                    
                    switch (params.family) {
                        case 'Mandelbrot':
                            color = mandelbrotColor(px, py, params);
                            break;
                        case 'Multibrot':
                            color = multibrotColor(px, py, params);
                            break;
                        case 'Julia':
                            color = juliaColor(px, py, params);
                            break;
                        case 'Newton':
                            color = newtonColor(px, py, params);
                            break;
                        case 'OrbitTrap':
                            color = orbitTrapColor(px, py, params);
                            break;
                        default:
                            color = mandelbrotColor(px, py, params);
                    }
                    
                    // Write to image data (scaled up)
                    for (let sy = 0; sy < 1 / scale; sy++) {
                        for (let sx = 0; sx < 1 / scale; sx++) {
                            const idx = ((Math.floor(y / scale) + sy) * width + Math.floor(x / scale) + sx) * 4;
                            if (idx >= 0 && idx < data.length - 3) {
                                data[idx] = color[0];
                                data[idx + 1] = color[1];
                                data[idx + 2] = color[2];
                                data[idx + 3] = color[3];
                            }
                        }
                    }
                }
            }
            
            fractalCtx.putImageData(imageData, 0, 0);
        }
        
        function mandelbrotColor(x, y, params) {
            // Vary starting point based on seed for uniqueness
            const seedOffsetX = (params.seedNorm1 - 0.5) * 0.5;
            const seedOffsetY = (params.seedNorm2 - 0.5) * 0.5;
            let zx = seedOffsetX, zy = seedOffsetY;
            const cx = x + seedOffsetX * 0.3;
            const cy = y + seedOffsetY * 0.3;
            let iterations = 0;
            const maxIter = Math.floor(params.depth * 0.15); // Increased iterations for more detail
            const escapeRadius = 2.5 + params.seedNorm1 * 0.5; // Vary escape radius
            
            while (zx * zx + zy * zy < escapeRadius * escapeRadius && iterations < maxIter) {
                const tmp = zx * zx - zy * zy + cx;
                zy = 2 * zx * zy + cy;
                zx = tmp;
                iterations++;
            }
            
            return iterationsToColor(iterations, maxIter, params);
        }
        
        function multibrotColor(x, y, params) {
            // Vary power based on seed for different shapes
            const power = 2.5 + params.seedNorm1 * 1.5; // 2.5 to 4.0
            let zx = 0, zy = 0;
            const seedOffsetX = (params.seedNorm2 - 0.5) * 0.3;
            const seedOffsetY = (params.seedNorm3 - 0.5) * 0.3;
            const cx = x + seedOffsetX;
            const cy = y + seedOffsetY;
            let iterations = 0;
            const maxIter = Math.floor(params.depth * 0.2); // More iterations for "to be"
            const escapeRadius = 2.0 + params.seedNorm1 * 1.0;
            
            while (zx * zx + zy * zy < escapeRadius * escapeRadius && iterations < maxIter) {
                const r = Math.sqrt(zx * zx + zy * zy);
                const theta = Math.atan2(zy, zx);
                const newR = Math.pow(r, power);
                const newTheta = theta * power;
                zx = newR * Math.cos(newTheta) + cx;
                zy = newR * Math.sin(newTheta) + cy;
                iterations++;
            }
            
            return iterationsToColor(iterations, maxIter, params);
        }
        
        function juliaColor(x, y, params) {
            // Much more variation in Julia set parameters
            const cx = -0.8 + params.seedNorm1 * 1.6; // -0.8 to 0.8
            const cy = -0.8 + params.seedNorm2 * 1.6; // -0.8 to 0.8
            let zx = x + (params.seedNorm3 - 0.5) * 0.5;
            let zy = y + (params.seedNorm1 - 0.5) * 0.5;
            let iterations = 0;
            const maxIter = Math.floor(params.depth * 0.15);
            const escapeRadius = 2.0 + params.seedNorm2 * 1.0;
            
            while (zx * zx + zy * zy < escapeRadius * escapeRadius && iterations < maxIter) {
                const tmp = zx * zx - zy * zy + cx;
                zy = 2 * zx * zy + cy;
                zx = tmp;
                iterations++;
            }
            
            return iterationsToColor(iterations, maxIter, params);
        }
        
        function newtonColor(x, y, params) {
            // Varied Newton fractal with seed-based parameters
            const polynomialOrder = 3 + Math.floor(params.seedNorm1 * 3); // 3 to 6
            let zx = x + (params.seedNorm2 - 0.5) * 0.5;
            let zy = y + (params.seedNorm3 - 0.5) * 0.5;
            let iterations = 0;
            const maxIter = Math.floor(params.depth * 0.08);
            const tolerance = 0.001 + params.seedNorm1 * 0.01;
            
            for (let i = 0; i < maxIter; i++) {
                const zx2 = zx * zx;
                const zy2 = zy * zy;
                const r2 = zx2 + zy2;
                const r2n = Math.pow(r2, polynomialOrder / 2);
                const denom = polynomialOrder * r2n;
                if (Math.abs(denom) < tolerance) break;
                
                // Simplified Newton iteration
                const angle = Math.atan2(zy, zx);
                const r = Math.sqrt(r2);
                const newAngle = angle * (polynomialOrder - 1) / polynomialOrder;
                const newR = Math.pow(r, (polynomialOrder - 1) / polynomialOrder);
                zx = newR * Math.cos(newAngle) - x / polynomialOrder;
                zy = newR * Math.sin(newAngle) - y / polynomialOrder;
                iterations++;
                if (zx * zx + zy * zy < tolerance) break;
            }
            
            return iterationsToColor(iterations, maxIter, params);
        }
        
        function orbitTrapColor(x, y, params) {
            // Varied orbit trap based on seed
            const trapType = Math.floor(params.seedNorm1 * 3); // 0, 1, or 2
            let zx = x + (params.seedNorm2 - 0.5) * 0.3;
            let zy = y + (params.seedNorm3 - 0.5) * 0.3;
            let iterations = 0;
            const maxIter = Math.floor(params.depth * 0.12);
            let minDist = Infinity;
            const cx = -0.4 + params.seedNorm1 * 0.8;
            const cy = -0.4 + params.seedNorm2 * 0.8;
            
            while (zx * zx + zy * zy < 4 && iterations < maxIter) {
                let dist;
                if (trapType === 0) {
                    dist = Math.abs(zx) + Math.abs(zy); // Manhattan
                } else if (trapType === 1) {
                    dist = Math.sqrt(zx * zx + zy * zy); // Euclidean
                } else {
                    dist = Math.max(Math.abs(zx), Math.abs(zy)); // Chebyshev
                }
                minDist = Math.min(minDist, dist);
                const tmp = zx * zx - zy * zy + cx;
                zy = 2 * zx * zy + cy;
                zx = tmp;
                iterations++;
            }
            
            // More colorful based on iterations and distance
            const distFactor = Math.min(1, minDist / 2);
            const iterFactor = iterations / maxIter;
            const r = Math.floor(255 * distFactor * iterFactor);
            const g = Math.floor(200 * distFactor * (1 - iterFactor * 0.5));
            const b = Math.floor(150 * (1 - distFactor) * iterFactor);
            return [r, g, b, 255];
        }
        
        function iterationsToColor(iterations, maxIter, params) {
            // Don't make inside completely black - add some color based on proximity
            const normalized = iterations / maxIter;
            let r, g, b;
            
            if (iterations >= maxIter) {
                // Inside set - use dark color but not pure black, varies by seed
                const darkFactor = 0.1 + params.seedNorm1 * 0.2;
                r = Math.floor(30 * darkFactor);
                g = Math.floor(20 * darkFactor);
                b = Math.floor(40 * darkFactor);
                return [r, g, b, 255];
            }
            
            // Much more variation in color schemes based on word and seed
            const colorScheme = Math.floor((params.seed + params.wordText.charCodeAt(0)) % 5);
            
            if (colorScheme === 0) {
                // High contrast blue-purple
                r = Math.floor(50 + 205 * normalized);
                g = Math.floor(30 + 100 * normalized);
                b = Math.floor(100 + 155 * (1 - normalized * 0.5));
            } else if (colorScheme === 1) {
                // Warm red-orange
                r = Math.floor(80 + 175 * normalized);
                g = Math.floor(40 + 100 * normalized * normalized);
                b = Math.floor(20 + 50 * normalized);
            } else if (colorScheme === 2) {
                // Cool green-cyan
                r = Math.floor(20 + 60 * normalized);
                g = Math.floor(100 + 155 * normalized);
                b = Math.floor(120 + 135 * normalized);
            } else if (colorScheme === 3) {
                // Vibrant rainbow
                const hue = (normalized * 360 + (params.seed % 360)) % 360;
                r = Math.floor(128 + 127 * Math.sin((hue / 360) * Math.PI * 2));
                g = Math.floor(128 + 127 * Math.sin((hue / 360) * Math.PI * 2 + 2.09));
                b = Math.floor(128 + 127 * Math.sin((hue / 360) * Math.PI * 2 + 4.19));
            } else {
                // Cool purple-pink
                r = Math.floor(100 + 155 * normalized);
                g = Math.floor(50 + 80 * normalized);
                b = Math.floor(150 + 105 * normalized);
            }
            
            // Apply seed-based variation
            r = Math.floor(r * (0.85 + params.seedNorm1 * 0.3));
            g = Math.floor(g * (0.85 + params.seedNorm2 * 0.3));
            b = Math.floor(b * (0.85 + params.seedNorm3 * 0.3));
            
            // Apply symmetry effect (brighter)
            if (params.symmetry > 0.7) {
                const symFactor = (params.symmetry - 0.7) / 0.3;
                r = Math.min(255, Math.floor(r * (1 + symFactor * 0.5)));
                g = Math.min(255, Math.floor(g * (1 + symFactor * 0.5)));
                b = Math.min(255, Math.floor(b * (1 + symFactor * 0.5)));
            }
            
            // Ensure minimum brightness to avoid pure black
            r = Math.max(20, r);
            g = Math.max(15, g);
            b = Math.max(25, b);
            
            return [Math.min(255, r), Math.min(255, g), Math.min(255, b), 255];
        }
        
        function hideValueLogicSummary() {
            document.getElementById('value-logic-modal').style.display = 'none';
            
            // Clean up overview scene
            if (valueLogicOverviewAnimationId) {
                cancelAnimationFrame(valueLogicOverviewAnimationId);
                valueLogicOverviewAnimationId = null;
            }
            if (valueLogicOverviewNodes.length > 0) {
                valueLogicOverviewNodes.forEach(node => {
                    if (valueLogicOverviewScene) {
                        valueLogicOverviewScene.remove(node);
                    }
                    if (node.geometry) node.geometry.dispose();
                    if (node.material) node.material.dispose();
                    if (node.children) {
                        node.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    }
                });
                valueLogicOverviewNodes = [];
            }
            if (valueLogicOverviewRenderer) {
                valueLogicOverviewRenderer.dispose();
                valueLogicOverviewRenderer = null;
            }
            valueLogicOverviewScene = null;
            valueLogicOverviewCamera = null;
        }
        
        function showInfoModal() {
            const modal = document.getElementById('info-modal');
            const content = document.getElementById('info-modal-content');
            
            if (!modal || !content) return;
            
            // Show modal
            modal.style.display = 'block';
            modal.style.visibility = 'visible';
            modal.style.opacity = '1';
            modal.style.pointerEvents = 'auto';
            
            // Use same styling as TOTAL VALUE modal (with color mode support)
            const boxBg = infoColorMode ? "#ffffff" : "#000000";
            const boxBorder = infoColorMode ? "#000000" : "#ffffff";
            const textColor = infoColorMode ? "#000000" : "#ffffff";
            const borderColor = boxBorder;
            const boxStyle = `background: ${boxBg}; border: 1px solid ${boxBorder}; padding: 4px; margin-bottom: 3px; border-radius: 0;`;
            const itemStyle = "margin: 0.5px 0;";
            
            // Helper function to highlight numbers (same as TOTAL VALUE)
            function highlightNumber(num) {
                if (infoColorMode) {
                    // White mode: black background, white text
                    return `<span style="background: #000000; color: #ffffff !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;">${num}</span>`;
                } else {
                    // Black mode: white background, black text
                    return `<span style="background: #ffffff; color: #000000 !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;">${num}</span>`;
                }
            }
            
            // Helper function to highlight main terms (same style as numbers)
            function highlightTerm(term) {
                if (infoColorMode) {
                    // White mode: black background, white text
                    return `<span style="background: #000000; color: #ffffff !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;">${term}</span>`;
                } else {
                    // Black mode: white background, black text
                    return `<span style="background: #ffffff; color: #000000 !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;">${term}</span>`;
                }
            }
            
            // Helper function to highlight sylvia variations and forest
            function highlightSylvia(text) {
                // Pattern to match: @sylvia, #sylvia, sylvia.implicit, sylvia.500, sylvia.unit, forest (case insensitive)
                const pattern = /(@sylvia|#sylvia|sylvia\.implicit|sylvia\.500|sylvia\.unit|sylvia\.\w+|forest)/gi;
                const highlightStyle = infoColorMode 
                    ? 'background: #000000; color: #ffffff !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;'
                    : 'background: #ffffff; color: #000000 !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;';
                
                return text.replace(pattern, (match) => {
                    return `<span style="${highlightStyle}">${match}</span>`;
                });
            }
            
            // Update color indicator
            const indicator = document.getElementById('info-color-indicator');
            if (indicator) {
                indicator.style.background = infoColorMode ? '#ffffff' : '#000000';
            }
            
            // Generate content
            const infoHTML = `
                <div style="${boxStyle}">
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 8px;">${highlightSylvia('@sylvia is a language-based, interface-based, decentralised marketplace as an artistic work and body of work, presented within the context of implicit-explicit, a digital culture project that unifies research, artists, events, collaborations and gaming, carried out from within the Ethereum blockchain as its medium.')}</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 8px;">${highlightSylvia('The #sylvia project is based on a critical understanding of language in the digital framework as an object maker (objectifier) through the dynamics of abstraction that appear at the intersection between signified and signifier. A contextualised value is produced within the framework of the work through a text input. Framework, content, and abstraction emerge as body and value, that is, as a meaning and its thing.')}</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 8px;">Starting from a text box, the input language is processed by a series of algorithms that define its composition, interpret a system of semantic contexts, shape it into a complex body, and associate specific values using both given parameters and a meta-contextâ€”or marketâ€”related to the piece immersed in the interaction of the collectors.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 8px;">For each minted body with meaning, the market grows and the given values change, adding dynamics of risk, speculation, flux, and scale. The bodies, composed of node-based diagrammatic structures, form scales of representation. At the atomic level, each word appears with a unique geometric body as typeâ€”a kind of diagram of its ownâ€”depending on its activity within both the input text and the market.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 8px;">${highlightSylvia('@sylvia (#sylvia, sylvia.implicit, sylvia.500, sylvia.unit, even forest) functions by critically understanding the decontextualised token as the ultimate sign of representation, almost as "the closest sign of presentation", producing an interface-based navigation that raises questions about identity associated with objects and their spatiality. Value and objectivity merge in the dynamic process of a language-based, body-based market in-formation, establishing a bridge between the token as a fixed entity and the system as an ever-changing dynamic process. Languageâ€”as technologyâ€”here appears as a form of economy of its own, with the hability to become value producer and/through organisational potency.')}</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">INTERFACE</h3>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('Text box')} (top left corner): Opens or closes the text box.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('Export Body')} (or ENTER key) â†’ converts the text into a node-based body following a series of parameters.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('Map Text')} â†’ visually maps the text box to help access specific nodes and adds colours in reference to the node values.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('CLEAR')} â†’ Deletes all text in the text box.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('TOTAL VALUE')} (to the right of the text box button): Displays the total value of the node body after a series of complex operations. When clicked, it displays a window with a summary of the value calculation and allows you to make the purchase via the ${highlightTerm('CLAIM')} button.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('CLAIM')} â†’ displays a window where you can preview the items in your purchase</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('GALLERY')}: Displays a list of purchases made by other collectors, sorted from highest to lowest value.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('TOP NODES')}: Displays a list of all nodes in the exported body, sorted from highest to lowest value.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">Click on the nodes â†’ Allows you to view a fractal generated based on the semantics and specific value of the node within the body.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('CONVERGENCE ZONES')}: Displays a window where, if available, you can view the generated content of the convergence zones.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('SHOW NAMETAGS')}: Makes the words corresponding to the nodes in the node-based body visible.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('RESET VIEW')}: Allows the user to return to the main view.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('FULLSCREEN')}: Expands the interface to fill the entire screen.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('COLOUR')}: Changes the background colour of the node-based body area to make it easier to find specific nodes and to suit the user's preferences.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('INFO')}: Displays a window with general information about the GUI and the work.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('@SYLVIA')}: Displays a small window with information about the software and the user.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">${highlightTerm('COLLAPSE')} (bottom right corner): Hides the window with the highlighted node (the most valuable node in the text and its information).</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">TEXT INPUT</h3>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">Text can be imported from the text box on the left.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The text accepts up to ${highlightNumber('500')} words.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">Words are recognised and evaluated based on their context within the market (purchases by previous collectors) and based on the context of the text itself. Words have different values if their context is different.</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">GENERATION OF NODE-BASED BODIES</h3>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">Based on the structure of the text and the values of its words, the nodes are organised in different ways.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The same text will never have exactly the same form. Each generation slightly alters the position of the nodes, in an almost imperceptible way.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The colour of the nodes corresponds to their value.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">Each node generated is represented in the ${highlightTerm('TOP NODES')} list, in order of value, from highest to lowest. In this list, you can access specific information about each node.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">Each node contains a fractal generated through the context provided by the body and its specific semantic value in this context.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The shape of the nodes depends on their semantic value in the context of the text itself. There are many different types of nodes, some of which are very rare.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">Navigation can be done with the touchpad, mouse, and keyboard arrows.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">Using the ${highlightTerm('SHOW NAMETAGS')} option, the user can see the location of the words on the nodes that represent them.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">If you click on a word in the text box in the ${highlightTerm('Map Text')} option, or directly on a node in the display, the camera will move around that node. To return to free navigation, click on ${highlightTerm('RESET VIEW')}.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">Each node has an area of activity.</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">CONVERGENCE ZONES</h3>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The areas of activity of the nodes depend on their relative value to the text. The greater the relative value, the larger the area of activity.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">If two areas of activity from two or more nodes converge, ${highlightTerm('convergence zones')} appear.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">Convergence zones generate additional individual node bodies to the main text. These node bodies appear only in convergence zones, hidden between the boundaries of the areas of activity.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The node bodies in convergence zones form texts have a reduced number of words. These words are evaluated like the rest of the words and add value to the total value of the body. It is likely that the more convergence zones there are, the more total value the node body will have.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The texts generated by convergence zones are based on the words of the nodes that have generated the activity areas.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The texts generated in the convergence zones can be accessed from the ${highlightTerm('CONVERGENCE ZONES')} button.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">Convergence may or may not occur, depending on the generation. The same text may have more or fewer convergence zones depending on how close or far apart certain nodes are generated from each other (as we saw previously, where each generation is slightly different in terms of the precise coordinates of its nodes).</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The texts (and therefore the bodies) generated in the convergence zones will always be different, even if the nodes that converge are the same.</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">VALUE CALCULATION</h3>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The individual value of nodes is calculated based on a variety of factors related to the context of the text and starting from a base value associated with each type of word.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The total value is calculated by adding up all the values, and boosts or devaluations are applied depending on general contextual reasons in the text.</div>
                    <div style="${itemStyle} color: ${textColor}; margin-bottom: 3px;">The total value takes into account the most popular words from previous purchases or other collectors, so the base value of specific words may increase if their popularity increases.</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">COMPLETE FLOW SUMMARY</h3>
                    <div style="${itemStyle} color: ${textColor};">${highlightNumber('1')}. Text input â†’ it's analyzed.</div>
                    <div style="${itemStyle} color: ${textColor};">${highlightNumber('2')}. Each word gets a base value by type.</div>
                    <div style="${itemStyle} color: ${textColor};">${highlightNumber('3')}. Value is adjusted by context (repetition, diversity, syntactic position).</div>
                    <div style="${itemStyle} color: ${textColor};">${highlightNumber('4')}. Global adjustments are applied (tense, text length, market (GALLERY)).</div>
                    <div style="${itemStyle} color: ${textColor};">${highlightNumber('6')}. A 3D node-based body is generated based on the text semantic and syntactic structure.</div>
                    <div style="${itemStyle} color: ${textColor};">${highlightNumber('10')}. Through purchasing the body, its words move into an open gallery where their specific values influence the future generations.</div>
                </div>
            `;
            
            content.innerHTML = infoHTML;
            
            // Position modal below the INFO button (right edge aligned) or in 3D visualization space on mobile
            // Do this after content is rendered to get actual modal width
            const infoBtn = document.getElementById('infoBtn');
            const modalContainer = document.getElementById('info-modal-container');
            if (infoBtn && modalContainer) {
                // Check if mobile (screen width <= 768px)
                if (window.innerWidth <= 768) {
                    // Ensure mobile elements are positioned first
                    positionMobileElements();
                    
                    // Wait for elements to be positioned correctly, then position modal
                    setTimeout(() => {
                        // Position modal in same space as 3D visualization (below top bar and fps bar)
                        const topBar = document.getElementById('top-bar');
                        const fpsBar = document.getElementById('fps-bar');
                        const bottomBar = document.getElementById('bottom-bar');
                        const leftPanel = document.getElementById('left-panel');
                        
                        const topBarHeight = topBar ? (topBar.offsetHeight || 0) : 0;
                        const fpsBarHeight = fpsBar ? (fpsBar.offsetHeight || 7) : 7;
                        const bottomBarHeight = bottomBar ? (bottomBar.offsetHeight || 7) : 7;
                        const leftPanelHeight = leftPanel && !leftPanel.classList.contains('collapsed') ? (leftPanel.offsetHeight || 0) : 0;
                        
                        const topPosition = topBarHeight + fpsBarHeight;
                        const bottomMargin = bottomBarHeight + leftPanelHeight;
                        const availableHeight = window.innerHeight - topPosition - bottomMargin;
                        
                        console.log('INFO Modal positioning:', {
                            topBarHeight,
                            fpsBarHeight,
                            bottomBarHeight,
                            leftPanelHeight,
                            topPosition,
                            bottomMargin,
                            availableHeight,
                            windowHeight: window.innerHeight
                        });
                        
                        // Use setProperty with important flag to override CSS and inline styles
                        modalContainer.style.setProperty('position', 'fixed', 'important');
                        modalContainer.style.setProperty('top', topPosition + 'px', 'important');
                        modalContainer.style.setProperty('left', '50%', 'important');
                        modalContainer.style.setProperty('transform', 'translateX(-50%)', 'important');
                        modalContainer.style.setProperty('margin', '0', 'important');
                        modalContainer.style.setProperty('max-width', '95%', 'important');
                        modalContainer.style.setProperty('width', '95%', 'important');
                        modalContainer.style.setProperty('max-height', Math.max(availableHeight - 10, 100) + 'px', 'important');
                        modalContainer.style.setProperty('bottom', 'auto', 'important');
                        modalContainer.style.setProperty('overflow-y', 'auto', 'important');
                    }, 300); // Increased timeout to ensure elements are positioned
                } else {
                    // Desktop positioning: below button, right edge aligned
                    const btnRect = infoBtn.getBoundingClientRect();
                    const modalRect = modalContainer.getBoundingClientRect();
                    
                    // Calculate left position to align right edge of modal with right edge of button
                    let leftPos = btnRect.right - modalRect.width;
                    
                    // Ensure modal doesn't go off the left edge of the screen
                    if (leftPos < 0) {
                        leftPos = 0;
                    }
                    
                    // Position relative to fixed parent container (same as TOTAL VALUE modal)
                    modalContainer.style.top = (btnRect.bottom + 5) + 'px';
                    modalContainer.style.left = leftPos + 'px';
                    modalContainer.style.transform = 'none';
                    modalContainer.style.margin = '0';
                }
            }
        }
        
        function hideInfoModal() {
            const modal = document.getElementById('info-modal');
            if (modal) {
                modal.style.display = 'none';
                modal.style.visibility = 'hidden';
                modal.style.opacity = '0';
                modal.style.pointerEvents = 'none';
            }
        }
        
        function toggleInfoColorMode() {
            infoColorMode = !infoColorMode;
            
            // Update color indicator
            const indicator = document.getElementById('info-color-indicator');
            if (indicator) {
                indicator.style.background = infoColorMode ? '#ffffff' : '#000000';
            }
            
            // Re-generate the content with new colors
            showInfoModal();
        }
        
        function createValueLogicOverview() {
            if (!nodes || nodes.length === 0) return;
            
            const container = document.getElementById('value-logic-overview-container');
            const canvas = document.getElementById('value-logic-overview-canvas');
            if (!container || !canvas) return;
            
            container.style.display = 'block';
            
            // Clean up previous scene if exists
            if (valueLogicOverviewAnimationId) {
                cancelAnimationFrame(valueLogicOverviewAnimationId);
                valueLogicOverviewAnimationId = null;
            }
            if (valueLogicOverviewNodes.length > 0) {
                valueLogicOverviewNodes.forEach(node => {
                    if (valueLogicOverviewScene) {
                        valueLogicOverviewScene.remove(node);
                    }
                    if (node.geometry) node.geometry.dispose();
                    if (node.material) node.material.dispose();
                    if (node.children) {
                        node.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    }
                });
                valueLogicOverviewNodes = [];
            }
            if (valueLogicOverviewRenderer) {
                valueLogicOverviewRenderer.dispose();
            }
            
            // Create scene
            valueLogicOverviewScene = new THREE.Scene();
            valueLogicOverviewScene.background = new THREE.Color(0x000000);
            
            // Get actual container dimensions
            const containerRect = container.getBoundingClientRect();
            const containerWidth = Math.floor(containerRect.width) || 376; // Account for padding
            const containerHeight = 150;
            valueLogicOverviewCamera = new THREE.PerspectiveCamera(50, containerWidth / containerHeight, 0.1, 1000);
            
            // Calculate bounding box of all nodes
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            nodes.forEach(node => {
                const pos = node.position;
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y);
                minZ = Math.min(minZ, pos.z);
                maxZ = Math.max(maxZ, pos.z);
            });
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxSize = Math.max(sizeX, sizeY, sizeZ, 1);
            
            // Position camera far away to see all nodes (static, no rotation)
            const distance = maxSize * 2.5;
            valueLogicOverviewCamera.position.set(centerX, centerY, centerZ + distance);
            valueLogicOverviewCamera.lookAt(centerX, centerY, centerZ);
            
            // Add lights (simple lighting for performance)
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            valueLogicOverviewScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(2, 2, 2);
            valueLogicOverviewScene.add(directionalLight);
            
            // Clone all nodes at smaller scale for overview (reduced quality)
            const scaleFactor = 0.25; // Smaller scale for better performance
            nodes.forEach(node => {
                let clonedNode;
                
                if (node.isGroup) {
                    // Clone group (nouns with flat base, "to be" verbs with flat rectangular base)
                    clonedNode = node.clone(true);
                    clonedNode.scale.set(scaleFactor, scaleFactor, scaleFactor);
                } else {
                    // Clone regular node
                    clonedNode = node.clone();
                    clonedNode.scale.set(scaleFactor, scaleFactor, scaleFactor);
                }
                
                valueLogicOverviewScene.add(clonedNode);
                valueLogicOverviewNodes.push(clonedNode);
            });
            
            // Clone connections (simplified)
            connections.forEach(conn => {
                const clonedConn = conn.clone();
                valueLogicOverviewScene.add(clonedConn);
            });
            
            // Create renderer with reduced quality for performance
            valueLogicOverviewRenderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: false,
                powerPreference: "low-power"
            });
            valueLogicOverviewRenderer.setSize(containerWidth, containerHeight);
            valueLogicOverviewRenderer.setPixelRatio(0.5); // Very low pixel ratio for performance
            
            // Static render (no animation)
            valueLogicOverviewRenderer.render(valueLogicOverviewScene, valueLogicOverviewCamera);
        }
        
        function hideRightPanel(panelId) {
            const panelIndex = rightPanels.findIndex(p => p.id === panelId);
            if (panelIndex === -1) {
                // Panel already removed or doesn't exist - silently return
                // This can happen when closing multiple panels at once
                return;
            }
            
            const panelData = rightPanels[panelIndex];
            
            // Stop animation
            if (panelData.animationId) {
                cancelAnimationFrame(panelData.animationId);
                panelData.animationId = null;
            }
            
            // Clean up 3D mesh
            if (panelData.mesh && panelData.scene) {
                try {
                    panelData.scene.remove(panelData.mesh);
                    if (panelData.mesh.geometry) panelData.mesh.geometry.dispose();
                    if (panelData.mesh.material) {
                        if (Array.isArray(panelData.mesh.material)) {
                            panelData.mesh.material.forEach(mat => mat.dispose());
                        } else {
                            panelData.mesh.material.dispose();
                        }
                    }
                    if (panelData.mesh.children && panelData.mesh.children.length > 0) {
                        panelData.mesh.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => mat.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                    }
                } catch (e) {
                    console.error('Error cleaning up mesh:', e);
                }
                panelData.mesh = null;
            }
            
            // Clean up renderer
            if (panelData.renderer) {
                try {
                    panelData.renderer.dispose();
                } catch (e) {
                    console.error('Error disposing renderer:', e);
                }
            }
            
            // Remove from DOM
            if (panelData.element && panelData.element.parentNode) {
                try {
                    panelData.element.remove();
                } catch (e) {
                    console.error('Error removing element:', e);
                }
            }
            
            // Add offset to available stack for reuse
            if (panelData.offset !== undefined) {
                availableOffsets.push(panelData.offset);
            }
            
            // Remove from array
            rightPanels.splice(panelIndex, 1);
            
            // Clear selectedNode if this was the last panel
            if (rightPanels.length === 0) {
                selectedNode = null;
            }
        }
        
        function hideNodeDetails() {
            // Hide all panels (for backward compatibility)
            // Create a copy of the array to avoid issues when modifying during iteration
            const panelsToClose = [...rightPanels];
            panelsToClose.forEach(panel => {
                hideRightPanel(panel.id);
            });
            
            // Also remove any remaining cloned panels from DOM (safety net)
            // This ensures ALL panels are closed even if there's an issue with the array
            const allClonedPanels = document.querySelectorAll('.right-panel-clone');
            allClonedPanels.forEach(panel => {
                try {
                    // Stop any animations
                    const canvas = panel.querySelector('canvas');
                    if (canvas) {
                        const context = canvas.getContext('webgl') || canvas.getContext('webgl2');
                        if (context) {
                            // Cancel any pending animation frames
                            const panelId = panel.id.replace('right-panel-', '');
                            const panelData = rightPanels.find(p => p.id === parseInt(panelId));
                            if (panelData && panelData.animationId) {
                                cancelAnimationFrame(panelData.animationId);
                            }
                        }
                    }
                    // Remove from DOM
                    panel.remove();
                } catch (e) {
                    console.error('Error removing cloned panel:', e);
                }
            });
            
            // Clear the array completely
            rightPanels = [];
            availableOffsets = [];
            
            hoveredNode = null;
            selectedNode = null;
        }

        // ==================== MAX VALUE PANEL ====================
        function findMaxValueNode() {
            if (nodes.length === 0) return null;
            
            let maxNode = null;
            let maxScore = -1;
            
            nodes.forEach(node => {
                if (node.userData.wordData) {
                    const score = node.userData.wordData.totalScore || 0;
                    if (score > maxScore) {
                        maxScore = score;
                        maxNode = node;
                    }
                }
            });
            
            return maxNode;
        }

        function updateMaxValuePanel() {
            // Hide image and show WebGL canvas (restore normal mode)
            const maxValuePanelImage = document.getElementById('max-value-panel-image');
            const maxValuePanelCanvas = document.getElementById('max-value-panel-canvas');
            if (maxValuePanelImage) {
                maxValuePanelImage.style.display = 'none';
            }
            if (maxValuePanelCanvas) {
                maxValuePanelCanvas.style.display = 'block';
            }
            
            // Reinitialize WebGL renderer if needed
            if (!maxValuePanelRenderer && maxValuePanelCanvas) {
                maxValuePanelScene = new THREE.Scene();
                maxValuePanelScene.background = new THREE.Color(0x000000);
                maxValuePanelCamera = new THREE.PerspectiveCamera(50, 200 / 120, 0.1, 100);
                maxValuePanelCamera.position.set(0, 0, 2);
                maxValuePanelCamera.lookAt(0, 0, 0);
                maxValuePanelRenderer = new THREE.WebGLRenderer({ 
                    canvas: maxValuePanelCanvas,
                    antialias: false
                });
                maxValuePanelRenderer.setSize(200, 120);
                maxValuePanelRenderer.setPixelRatio(0.75);
                const maxValuePanelAmbientLight = new THREE.AmbientLight(0x404040, 0.6);
                maxValuePanelScene.add(maxValuePanelAmbientLight);
                const maxValuePanelDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                maxValuePanelDirectionalLight.position.set(2, 2, 2);
                maxValuePanelScene.add(maxValuePanelDirectionalLight);
            }
            
            if (!maxValuePanelScene || !maxValuePanelRenderer) return;
            
            // Find the node with maximum value
            maxValueNode = findMaxValueNode();
            
            if (!maxValueNode) {
                // Clear panel if no nodes
                if (maxValuePanelMesh) {
                    maxValuePanelScene.remove(maxValuePanelMesh);
                    if (maxValuePanelMesh.geometry) maxValuePanelMesh.geometry.dispose();
                    if (maxValuePanelMesh.material) maxValuePanelMesh.material.dispose();
                    if (maxValuePanelMesh.children) {
                        maxValuePanelMesh.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    }
                    maxValuePanelMesh = null;
                }
                document.getElementById('max-value-panel-word').textContent = '-';
                document.getElementById('max-value-word').textContent = '-';
                document.getElementById('max-value-individual-value').textContent = '-';
                document.getElementById('max-value-position').textContent = '-';
                document.getElementById('max-value-relative-value').textContent = '-';
                document.getElementById('max-value-connections').textContent = '-';
                document.getElementById('max-value-size').textContent = '-';
                document.getElementById('max-value-performance').textContent = '-';
                document.getElementById('max-value-3d-coords').textContent = '-';
                return;
            }
            
            // Update info - same as showNodeDetails
            const wordData = maxValueNode.userData.wordData;
            const index = maxValueNode.userData.index;
            const totalValue = window.totalTextScore || analyzedWords.reduce((sum, w) => sum + (w.finalValue || w.totalScore || 0), 0);
            const individualValue = wordData.finalValue || wordData.totalScore || 0;
            const relativeValue = totalValue > 0 ? ((individualValue / totalValue) * 100).toFixed(2) + '%' : '0%';
            
            // Calculate node size in KB (approximate) - same as showNodeDetails
            let nodeSizeKB = 0;
            if (maxValueNode.userData.isNoun) {
                // Sphere + flat square
                nodeSizeKB = (8 * 8 * 8 * 4 * 3) + (1 * 1 * 1 * 4 * 3);
            } else if (maxValueNode.userData.connectionCount > 0) {
                // Cube
                nodeSizeKB = (8 * 4 * 3);
            } else {
                // Sphere
                nodeSizeKB = (8 * 8 * 8 * 4 * 3);
            }
            nodeSizeKB = (nodeSizeKB / 1024).toFixed(4);
            
            // Calculate performance impact
            const performanceImpact = maxValueNode.userData.connectionCount > 0 ? 
                'Medium (' + maxValueNode.userData.connectionCount + ' connections)' : 
                'Low';
            
            // Convert individual value to ETH for display - same format as showNodeDetails
            let individualValueETH = 0;
            if (ethPriceUSD) {
                individualValueETH = individualValue / ethPriceUSD;
            }
            const individualValueETHDisplay = individualValueETH >= 0.01 ? 
                `${individualValueETH.toFixed(6)} ETH` : 
                `${individualValueETH.toFixed(10)} ETH`;
            
            // Convert total value to ETH
            let totalValueETH = 0;
            if (ethPriceUSD) {
                totalValueETH = totalValue / ethPriceUSD;
            }
            const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                `${totalValueETH.toFixed(6)} ETH` : 
                `${totalValueETH.toFixed(10)} ETH`;
            
            // Update header with word
            document.getElementById('max-value-panel-word').textContent = wordData.text;
            
            // Update all fields
            document.getElementById('max-value-word').textContent = wordData.text;
            document.getElementById('max-value-individual-value').textContent = individualValueETHDisplay;
            // For convergence nodes, show "Convergence Zone" instead of position
            const positionText = maxValueNode.userData.isConvergenceNode ? 
                'Convergence Zone' : 
                ((index + 1) + ' / ' + analyzedWords.length);
            document.getElementById('max-value-position').textContent = positionText;
            document.getElementById('max-value-relative-value').textContent = relativeValue + ' (' + totalValueETHDisplay + ' total)';
            document.getElementById('max-value-connections').textContent = maxValueNode.userData.connectionCount || 0;
            document.getElementById('max-value-size').textContent = nodeSizeKB + ' KB';
            document.getElementById('max-value-performance').textContent = performanceImpact;
            // Show 3D coordinates
            const pos = maxValueNode.position;
            document.getElementById('max-value-3d-coords').textContent = `(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`;
            
            // Remove previous mesh
            if (maxValuePanelMesh) {
                maxValuePanelScene.remove(maxValuePanelMesh);
                if (maxValuePanelMesh.geometry) maxValuePanelMesh.geometry.dispose();
                if (maxValuePanelMesh.material) maxValuePanelMesh.material.dispose();
                if (maxValuePanelMesh.children) {
                    maxValuePanelMesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            }
            
            // Clone the node for display (enlarged) using the correct shape
            const baseSize = 0.06;
            const enlargedSize = 0.3; // Size for max-value-panel
            
            // Get color - use violet for convergence nodes, otherwise use value-based color
            let color;
            if (maxValueNode.userData.isConvergenceNode) {
                color = 0x8B00FF; // Violet color for convergence nodes
            } else {
                const nodeIndex = maxValueNode.userData.index !== undefined ? maxValueNode.userData.index : 0;
                color = getValueBasedColor(wordData, nodeIndex, analyzedWords);
            }
            
            // Get word type to determine correct shape
            const wordType = getWordTypeForShape(wordData, maxValueNode.userData.index || 0);
            
            // Determine opacity
            let nodeOpacity = 0.92;
            const semiTransparentTypes = ['proper_noun', 'object_pronoun', 'intensive_pronoun', 
                                         'interrogative_pronoun', 'superlative_adjective', 'modal_verb',
                                         'concrete_noun', 'gerundial_noun', 'interrogative_determiner'];
            if (semiTransparentTypes.includes(wordType)) {
                nodeOpacity = 0.80;
            }
            
            // Create geometry using the correct shape function
            const colorHex = typeof color === 'number' ? color : parseInt(color, 16);
            maxValuePanelMesh = createWordTypeGeometry(wordType, enlargedSize, colorHex, nodeOpacity);
            
            maxValuePanelScene.add(maxValuePanelMesh);
            
            // Start animation
            if (maxValuePanelAnimationId) {
                cancelAnimationFrame(maxValuePanelAnimationId);
            }
            animateMaxValuePanelNode();
        }

        function animateMaxValuePanelNode() {
            if (!maxValuePanelMesh || !maxValuePanelRenderer || !maxValuePanelScene || !maxValuePanelCamera) {
                if (maxValuePanelAnimationId) {
                    cancelAnimationFrame(maxValuePanelAnimationId);
                    maxValuePanelAnimationId = null;
                }
                return;
            }
            
            maxValuePanelMesh.rotation.y += 0.01;
            maxValuePanelMesh.rotation.x += 0.005;
            
            maxValuePanelRenderer.render(maxValuePanelScene, maxValuePanelCamera);
            maxValuePanelAnimationId = requestAnimationFrame(animateMaxValuePanelNode);
        }
        
        function updateButtonStates() {
            const textInput = document.getElementById('textInput');
            const generateBtn = document.getElementById('generateBtn');
            const totalValueBtn = document.getElementById('total-value-display');
            
            if (!textInput) return;
            
            const hasText = textInput.value.trim().length > 0;
            const hasBody = (nodes && nodes.length > 0) || (analyzedWords && analyzedWords.length > 0);
            
            // Update EXPORT BODY button
            if (generateBtn) {
                if (hasText && !isViewingPurchase) {
                    generateBtn.disabled = false;
                    generateBtn.style.opacity = '1';
                    generateBtn.style.cursor = 'pointer';
                } else {
                    generateBtn.disabled = true;
                    generateBtn.style.opacity = '0.5';
                    generateBtn.style.cursor = 'not-allowed';
                }
            }
            
            // Update TOTAL VALUE button
            if (totalValueBtn) {
                if (isViewingPurchase) {
                    // When viewing a purchase, always show as "RETURN TO INPUT MODE" with full opacity
                    totalValueBtn.style.opacity = '1';
                    totalValueBtn.style.cursor = 'pointer';
                    totalValueBtn.style.pointerEvents = 'auto';
                } else if (hasBody) {
                    // Has body imported - full opacity
                    totalValueBtn.style.opacity = '1';
                    totalValueBtn.style.cursor = 'pointer';
                    totalValueBtn.style.pointerEvents = 'auto';
                } else if (hasText) {
                    // Has text but no body - medium opacity
                    totalValueBtn.style.opacity = '0.5';
                    totalValueBtn.style.cursor = 'not-allowed';
                    totalValueBtn.style.pointerEvents = 'none';
                } else {
                    // No text - even lighter opacity
                    totalValueBtn.style.opacity = '0.3';
                    totalValueBtn.style.cursor = 'not-allowed';
                    totalValueBtn.style.pointerEvents = 'none';
                }
            }
        }
        
        function clearTextBox() {
            // Always close all right panels when clearing
            hideNodeDetails();
            
            // If viewing a purchase, restore normal mode
            if (isViewingPurchase) {
                returnToInputMode();
            }
            
            document.getElementById('textInput').value = '';
            
            // Update button states after clearing
            updateButtonStates();
            // Reset stats
            document.getElementById('valueScore').textContent = '0.00';
            document.getElementById('valueETH').textContent = '';
            
            // Reset mapped text view
            const mappedContainer = document.getElementById('mapped-text-container');
            const textInput = document.getElementById('textInput');
            mappedContainer.style.display = 'none';
            textInput.style.display = 'block';
            mappedTextVisible = false;
            
            // First, remove all convergence zones and their groups from scene
            convergenceZones.forEach(zone => {
                if (zone.group) {
                    // Dispose all children (violet nodes and lines) before removing group
                    zone.group.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    // Remove the entire group from scene
                    scene.remove(zone.group);
                }
            });
            
            // Clear scene - properly handle both regular nodes and noun groups
            nodes.forEach(node => {
                // Remove node from scene
                if (node.parent) {
                    node.parent.remove(node);
                } else {
                    scene.remove(node);
                }
                
                // Handle noun groups (THREE.Group objects)
                if (node.isGroup) {
                    node.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                } else {
                    // Regular nodes
                    if (node.geometry) node.geometry.dispose();
                    if (node.material) node.material.dispose();
                }
            });
            
            connections.forEach(conn => {
                if (conn.parent) {
                    conn.parent.remove(conn);
                } else {
                    scene.remove(conn);
                }
                if (conn.geometry) conn.geometry.dispose();
                if (conn.material) conn.material.dispose();
            });
            
            // Clear arrays
            convergenceZones = [];
            nodes = [];
            connections = [];
            analyzedWords = [];
            selectedNode = null;
            
            // Reset convergence total value
            window.convergenceTotalValue = 0;
            
            // Update convergence zone button state
            updateConvergenceZoneButton();
            
            // Disable Map Text and related buttons after clearing
            disableMapTextButtons();

            // Si TOP NODES estÃ¡ activo, ocultarlo porque el cuerpo desaparece
            if (nodeListVisible) {
                const container = document.getElementById('node-list-container');
                if (container) {
                    container.classList.remove('visible');
                }
                if (typeof clearNodeList === 'function') {
                    clearNodeList();
                }
                nodeListVisible = false;
                const nodeListBtn = document.getElementById('nodeListBtn');
                if (nodeListBtn) nodeListBtn.textContent = 'TOP NODES';
            }
            
            // Si GALLERY estÃ¡ activo, ocultarlo
            if (galleryVisible) {
                const container = document.getElementById('node-list-container');
                if (container) {
                    container.classList.remove('visible');
                }
                if (typeof clearGallery === 'function') {
                    clearGallery();
                }
                galleryVisible = false;
                closeLeaderboardRightPanel();
            }
        }
        
        function showNodeInfo(node, mouseX, mouseY) {
            // Ensure nodeInfoPanel exists
            if (!nodeInfoPanel) {
                nodeInfoPanel = document.getElementById('node-info-panel');
                if (!nodeInfoPanel) {
                    console.warn('node-info-panel not found, cannot show node info');
                    return;
                }
            }
            
            // Validate node has wordData
            if (!node || !node.userData || !node.userData.wordData) {
                hideNodeInfo();
                return;
            }
            
            const wordData = node.userData.wordData;
            const index = node.userData.index;
            const totalValue = window.totalTextScore || 0;
            const individualValue = wordData.finalValue || wordData.totalScore || 0;
            const relativeValue = totalValue > 0 ? ((individualValue / totalValue) * 100).toFixed(2) + '%' : '0%';
            
            // Calculate node size in KB (approximate)
            let nodeSizeKB = 0;
            if (node.userData.isNoun) {
                nodeSizeKB = (8 * 8 * 8 * 4 * 3) + (1 * 1 * 1 * 4 * 3);
            } else if (node.userData.connectionCount > 0) {
                nodeSizeKB = (8 * 4 * 3);
            } else {
                nodeSizeKB = (8 * 8 * 8 * 4 * 3);
            }
            nodeSizeKB = (nodeSizeKB / 1024).toFixed(4);
            
            // Convert individual value to ETH for display
            let individualValueETH = 0;
            if (ethPriceUSD) {
                individualValueETH = individualValue / ethPriceUSD;
            }
            const individualValueETHDisplay = individualValueETH >= 0.01 ? 
                `${individualValueETH.toFixed(4)} ETH` : 
                `${individualValueETH.toFixed(6)} ETH`;
            
            // Update condensed info panel content
            document.getElementById('info-word').textContent = wordData.text.length > 8 ? wordData.text.substring(0, 8) + '...' : wordData.text;
            document.getElementById('info-individual-value').textContent = individualValueETH >= 0.01 ? 
                individualValueETH.toFixed(4) + ' ETH' : individualValueETH.toFixed(6) + ' ETH';
            document.getElementById('info-position').textContent = (index + 1) + '/' + analyzedWords.length;
            document.getElementById('info-relative-value').textContent = relativeValue;
            document.getElementById('info-connections').textContent = node.userData.connectionCount || 0;
            document.getElementById('info-size').textContent = parseFloat(nodeSizeKB).toFixed(2);
            document.getElementById('info-performance').textContent = node.userData.connectionCount > 0 ? 'M' : 'L';
            // Show 3D coordinates (compact format for small panel)
            const pos = node.position;
            document.getElementById('info-3d-coords').textContent = `${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)}`;
            
            // Show enlarged node in canvas
            showEnlargedNode(node);
            
            // Start animation
            if (nodeInfoAnimationId) {
                cancelAnimationFrame(nodeInfoAnimationId);
            }
            animateNodeInfo();
            
            // Calculate node position on screen
            const vector = new THREE.Vector3();
            if (node.userData.isNoun && node.userData.mainNode) {
                node.userData.mainNode.getWorldPosition(vector);
            } else {
                node.getWorldPosition(vector);
            }
            vector.project(camera);
            
            // Convert to screen coordinates
            const nodeScreenX = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const nodeScreenY = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            // Position panel next to node on screen
            const panelWidth = 220;
            const panelHeight = 220;
            let panelX = nodeScreenX + 20;
            let panelY = nodeScreenY - 20;
            
            // Keep panel within viewport
            if (panelX + panelWidth > window.innerWidth) {
                panelX = nodeScreenX - panelWidth - 20;
            }
            if (panelY + panelHeight > window.innerHeight) {
                panelY = window.innerHeight - panelHeight - 10;
            }
            if (panelX < 0) panelX = 10;
            if (panelY < 0) panelY = 10;
            
            nodeInfoPanel.style.left = panelX + 'px';
            nodeInfoPanel.style.top = panelY + 'px';
            nodeInfoPanel.classList.add('visible');
        }
        
        function showEnlargedNode(node) {
            if (!nodeInfoScene || !nodeInfoRenderer) return;
            
            // Remove previous mesh
            if (nodeInfoMesh) {
                nodeInfoScene.remove(nodeInfoMesh);
                if (nodeInfoMesh.geometry) nodeInfoMesh.geometry.dispose();
                if (nodeInfoMesh.material) nodeInfoMesh.material.dispose();
                if (nodeInfoMesh.children) {
                    nodeInfoMesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            }
            
            // Clone the node for display (enlarged) using the correct shape
            const wordData = node.userData.wordData;
            const baseSize = 0.06;
            const enlargedSize = 0.3; // 5x larger
            
            // Get color - use violet for convergence nodes, otherwise use value-based color
            let color;
            if (node.userData && node.userData.isConvergenceNode) {
                color = 0x8B00FF; // Violet color for convergence nodes
            } else {
                // Get color using the same function as nodes (getValueBasedColor)
                // This ensures colors match between nodes and hover panel
                const nodeIndex = node.userData.index !== undefined ? node.userData.index : 0;
                color = getValueBasedColor(wordData, nodeIndex, analyzedWords);
            }
            
            // Get word type to determine correct shape
            const wordType = getWordTypeForShape(wordData, node.userData.index || 0);
            
            // Determine opacity
            let nodeOpacity = 0.92;
            const semiTransparentTypes = ['proper_noun', 'object_pronoun', 'intensive_pronoun', 
                                         'interrogative_pronoun', 'superlative_adjective', 'modal_verb',
                                         'concrete_noun', 'gerundial_noun', 'interrogative_determiner'];
            if (semiTransparentTypes.includes(wordType)) {
                nodeOpacity = 0.80;
            }
            
            // Create geometry using the correct shape function
            const colorHex = typeof color === 'number' ? color : parseInt(color, 16);
            nodeInfoMesh = createWordTypeGeometry(wordType, enlargedSize, colorHex, nodeOpacity);
            
            nodeInfoScene.add(nodeInfoMesh);
        }
        
        function animateNodeInfo() {
            if (!nodeInfoMesh || !nodeInfoRenderer || !nodeInfoScene || !nodeInfoCamera) {
                if (nodeInfoAnimationId) {
                    cancelAnimationFrame(nodeInfoAnimationId);
                    nodeInfoAnimationId = null;
                }
                return;
            }
            
            // Rotate the node
            nodeInfoMesh.rotation.y += 0.01;
            nodeInfoMesh.rotation.x += 0.005;
            
            nodeInfoRenderer.render(nodeInfoScene, nodeInfoCamera);
            nodeInfoAnimationId = requestAnimationFrame(animateNodeInfo);
        }
        
        function hideNodeInfo() {
            if (nodeInfoPanel) {
                nodeInfoPanel.classList.remove('visible');
            }
            hoveredNode = null;
            if (nodeInfoAnimationId) {
                cancelAnimationFrame(nodeInfoAnimationId);
                nodeInfoAnimationId = null;
            }
            if (nodeInfoMesh) {
                nodeInfoScene.remove(nodeInfoMesh);
                if (nodeInfoMesh.geometry) nodeInfoMesh.geometry.dispose();
                if (nodeInfoMesh.material) nodeInfoMesh.material.dispose();
                if (nodeInfoMesh.children) {
                    nodeInfoMesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
                nodeInfoMesh = null;
            }
        }

        function onWheel(event) {
            event.preventDefault();
            
            // Normal zoom behavior only (pan is done with Shift + middle mouse button + drag)
            // Calculate minimum distance from camera to any node
            let minDistance = Infinity;
            if (nodes && nodes.length > 0) {
                const cameraPos = camera.position;
                const nodeWorldPos = new THREE.Vector3();
                
                for (let i = 0; i < nodes.length; i++) {
                    const node = nodes[i];
                    if (node) {
                        // Get world position of the node
                        node.getWorldPosition(nodeWorldPos);
                        const distance = cameraPos.distanceTo(nodeWorldPos);
                        if (distance < minDistance) {
                            minDistance = distance;
                        }
                    }
                }
            }
            
            // If no nodes or distance is very large, use default sensitivity
            if (minDistance === Infinity || minDistance > 20) {
                minDistance = 20; // Default far distance
            }
            
            // Adjust zoom sensitivity based on distance to nearest node
            // Closer nodes = lower sensitivity (more precise)
            // Further nodes = higher sensitivity (faster zoom)
            // The further away, the more sensitive the zoom becomes
            // In alternative control mode (touchpad), increase sensitivity multiplier
            const sensitivityMultiplier = alternativeControlMode ? 1.0 : 8.0; // Default mode (false) = high sensitivity, Alternative mode (true) = normal sensitivity
            const baseSensitivity = 0.02;
            const minSensitivity = 0.0008; // Minimum sensitivity when very close
            const closeDistance = 3.0; // Distance at which we want minimum sensitivity
            const farDistance = 20.0; // Distance at which we want base sensitivity
            const veryFarDistance = 40.0; // Distance at which we want maximum sensitivity
            const maxSensitivity = 0.05; // Maximum sensitivity when very far away
            
            // Map distance to sensitivity using a smooth interpolation
            let sensitivity;
            if (minDistance <= closeDistance) {
                // Very close: use minimum sensitivity
                sensitivity = minSensitivity;
            } else if (minDistance >= veryFarDistance) {
                // Very far away: use maximum sensitivity
                sensitivity = maxSensitivity;
            } else if (minDistance >= farDistance) {
                // Far away: interpolate between base and max sensitivity
                const t = (minDistance - farDistance) / (veryFarDistance - farDistance);
                const smoothT = t * t * (3 - 2 * t); // Smoothstep
                sensitivity = baseSensitivity + (maxSensitivity - baseSensitivity) * smoothT;
            } else {
                // Medium distance: interpolate between min and base sensitivity
                const t = (minDistance - closeDistance) / (farDistance - closeDistance);
                const smoothT = t * t * t * (t * (t * 6 - 15) + 10); // Smootherstep (6th order)
                sensitivity = minSensitivity + (baseSensitivity - minSensitivity) * smoothT;
            }
            
            // Apply multiplier for alternative control mode
            sensitivity *= sensitivityMultiplier;
            
            // Apply zoom with adjusted sensitivity
            cameraRadius += event.deltaY * sensitivity;
            // Allow zooming closer to the center (minimum 0.1 instead of 3)
            cameraRadius = Math.max(0.1, Math.min(50, cameraRadius));
            updateCameraPosition();
        }
        
        function onKeyDown(event) {
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || 
                event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                event.preventDefault();
                keysPressed[event.key] = true;
            }
        }
        
        function onKeyUp(event) {
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || 
                event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                event.preventDefault();
                keysPressed[event.key] = false;
            }
        }
        
        // Update camera position based on keyboard input
        function updateKeyboardNavigation() {
            // Use the same pan logic as Shift + middle mouse button
            // Calculate pan movement based on camera orientation (like Blender)
            
            // Pan speed factor (relative to camera distance, same as mouse pan)
            // Increase sensitivity in alternative control mode
            const basePanSpeed = cameraRadius * 0.001;
            const panSpeed = alternativeControlMode ? basePanSpeed : basePanSpeed * 5.0; // Default mode (false) = high sensitivity, Alternative mode (true) = normal sensitivity
            
            // Get camera's current forward direction
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            
            // Calculate right vector (perpendicular to forward and world up)
            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();
            
            // Use camera's up vector directly
            const up = new THREE.Vector3();
            up.copy(camera.up).normalize();
            
            // Calculate pan movement in camera space
            const panMovement = new THREE.Vector3();
            
            if (keysPressed.ArrowUp) {
                // Move up (in camera's up direction)
                const upMove = up.clone().multiplyScalar(panSpeed);
                panMovement.add(upMove);
            }
            if (keysPressed.ArrowDown) {
                // Move down (opposite to camera's up direction)
                const downMove = up.clone().multiplyScalar(-panSpeed);
                panMovement.add(downMove);
            }
            if (keysPressed.ArrowLeft) {
                // Move left (opposite to camera's right direction)
                const leftMove = right.clone().multiplyScalar(-panSpeed);
                panMovement.add(leftMove);
            }
            if (keysPressed.ArrowRight) {
                // Move right (in camera's right direction)
                const rightMove = right.clone().multiplyScalar(panSpeed);
                panMovement.add(rightMove);
            }
            
            // Move both camera position and target together (same as mouse pan)
            if (panMovement.length() > 0) {
                camera.position.add(panMovement);
                cameraTarget.add(panMovement);
                updateCameraPosition();
                // Coordinates will be updated by updateCoordinatesDisplay in animate loop
                updateCoordinatesDisplay();
            }
        }
        
        function resetCamera() {
            // If viewing a purchase, reset to purchase view position
            if (isViewingPurchase && window.currentPurchase) {
                positionCameraForPurchase(window.currentPurchase);
                return;
            }
            
            // Reset camera to initial position
            cameraRadius = initialCameraRadius;
            cameraAngleX = initialCameraAngleX;
            cameraAngleY = initialCameraAngleY;
            cameraTarget.copy(initialCameraTarget);
            updateCameraPosition();
        }
        
        function toggleControlMode() {
            alternativeControlMode = !alternativeControlMode;
            const switchBtn = document.getElementById('switchControlModesBtn');
            
            if (switchBtn) {
                if (alternativeControlMode) {
                    switchBtn.textContent = 'SWITCH CONTROL MODES (Alternative Active)';
                } else {
                    switchBtn.textContent = 'SWITCH CONTROL MODES';
                }
            }
            
            // Reset dragging state when switching modes
            isDragging = false;
            isPanning = false;
        }
        
        // Function to focus camera on a specific node
        // "Teleports" camera instantly to the closest possible position to the node
        function focusCameraOnNode(node) {
            if (!node || !camera) return;
            
            // Get node position (handle groups and regular nodes)
            let nodePosition;
            if (node.isGroup) {
                // For groups, use the group's position
                nodePosition = node.position.clone();
            } else {
                // For regular nodes, use the node's position
                nodePosition = node.position.clone();
            }
            
            // Calculate actual node size by finding bounding box
            let maxNodeSize = 0.5; // Default minimum size
            
            // Try to get bounding box of the node and all its children
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    if (child.geometry) {
                        child.geometry.computeBoundingBox();
                        const childBox = child.geometry.boundingBox;
                        if (childBox) {
                            // Transform box to world coordinates
                            const worldBox = childBox.clone();
                            worldBox.applyMatrix4(child.matrixWorld);
                            
                            // Get size of this child
                            const childSize = worldBox.getSize(new THREE.Vector3());
                            const maxChildDimension = Math.max(childSize.x, childSize.y, childSize.z);
                            maxNodeSize = Math.max(maxNodeSize, maxChildDimension);
                        }
                    }
                });
            }
            
            // Also check if node has geometry directly
            if (node.geometry) {
                node.geometry.computeBoundingBox();
                const nodeBox = node.geometry.boundingBox;
                if (nodeBox) {
                    const nodeSize = nodeBox.getSize(new THREE.Vector3());
                    const maxNodeDimension = Math.max(nodeSize.x, nodeSize.y, nodeSize.z);
                    maxNodeSize = Math.max(maxNodeSize, maxNodeDimension);
                }
            }
            
            // Position camera as close as possible: node size + minimal offset for visibility
            // Use a very small offset (0.1) to get as close as possible while keeping node visible
            const minDistance = (maxNodeSize / 2) + 0.1; // Half size (radius) + tiny offset
            
            // Ensure minimum distance is reasonable (at least 0.3 for very small nodes)
            const finalDistance = Math.max(minDistance, 0.3);
            
            // Calculate direction from origin to node (normalized)
            const direction = nodePosition.clone().normalize();
            
            // Calculate angles based on node position
            // angleY: rotation around Y axis (horizontal)
            // angleX: rotation around X axis (vertical)
            const angleY = Math.atan2(direction.x, direction.z);
            const angleX = Math.asin(Math.max(-0.8, Math.min(0.8, direction.y))); // Limit vertical angle
            
            // Set camera angles (position camera in front of the node)
            cameraAngleY = angleY;
            cameraAngleX = angleX;
            
            // Set camera target to node position
            cameraTarget.copy(nodePosition);
            
            // Set camera radius to be as close as possible
            cameraRadius = finalDistance;
            
            // Update camera position immediately (instant teleport)
            updateCameraPosition();
            
            console.log(`[CAMERA TELEPORT] Moved camera instantly to node "${node.userData?.wordData?.text || 'unknown'}" at distance ${finalDistance.toFixed(3)} (node size: ${maxNodeSize.toFixed(3)})`);
        }
        
        // Function to move camera as close as possible to a node (called on node click)
        // "Teleports" camera instantly to the closest possible position to the node
        function moveCameraToNode(node) {
            if (!node || !camera) return;
            
            // Get node position (handle groups and regular nodes)
            let nodePosition;
            if (node.isGroup) {
                // For groups, use the group's position
                nodePosition = node.position.clone();
            } else {
                // For regular nodes, use the node's position
                nodePosition = node.position.clone();
            }
            
            // Calculate actual node size by finding bounding box
            let maxNodeSize = 0.5; // Default minimum size
            const box = new THREE.Box3();
            
            // Try to get bounding box of the node and all its children
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    if (child.geometry) {
                        child.geometry.computeBoundingBox();
                        const childBox = child.geometry.boundingBox;
                        if (childBox) {
                            // Transform box to world coordinates
                            const worldBox = childBox.clone();
                            worldBox.applyMatrix4(child.matrixWorld);
                            
                            // Get size of this child
                            const childSize = worldBox.getSize(new THREE.Vector3());
                            const maxChildDimension = Math.max(childSize.x, childSize.y, childSize.z);
                            maxNodeSize = Math.max(maxNodeSize, maxChildDimension);
                        }
                    }
                });
            }
            
            // Also check if node has geometry directly
            if (node.geometry) {
                node.geometry.computeBoundingBox();
                const nodeBox = node.geometry.boundingBox;
                if (nodeBox) {
                    const nodeSize = nodeBox.getSize(new THREE.Vector3());
                    const maxNodeDimension = Math.max(nodeSize.x, nodeSize.y, nodeSize.z);
                    maxNodeSize = Math.max(maxNodeSize, maxNodeDimension);
                }
            }
            
            // Calculate distance from origin to node
            const distanceToOrigin = nodePosition.length();
            
            // Position camera as close as possible: node size + minimal offset for visibility
            // Use a very small offset (0.1) to get as close as possible while keeping node visible
            const minDistance = (maxNodeSize / 2) + 0.1; // Half size (radius) + tiny offset
            
            // Ensure minimum distance is reasonable (at least 0.3 for very small nodes)
            const finalDistance = Math.max(minDistance, 0.3);
            
            // Calculate direction from origin to node (normalized)
            const direction = nodePosition.clone().normalize();
            
            // Calculate camera position: node position minus direction * finalDistance
            // This places camera slightly away from node in the direction from origin
            const cameraPosition = nodePosition.clone().sub(direction.clone().multiplyScalar(finalDistance));
            
            // Calculate angles based on camera position relative to origin
            const angleY = Math.atan2(cameraPosition.x, cameraPosition.z);
            const angleX = Math.asin(Math.max(-0.8, Math.min(0.8, cameraPosition.y / cameraPosition.length())));
            
            // Set camera angles and target INSTANTLY (teleport, no animation)
            cameraAngleY = angleY;
            cameraAngleX = angleX;
            cameraTarget.copy(nodePosition);
            cameraRadius = cameraPosition.length();
            
            // Update camera position immediately (instant teleport)
            updateCameraPosition();
            
            console.log(`[CAMERA TELEPORT] Moved camera instantly to node "${node.userData?.wordData?.text || 'unknown'}" at distance ${finalDistance.toFixed(3)} (node size: ${maxNodeSize.toFixed(3)})`);
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && !document.msFullscreenElement) {
                // Enter fullscreen
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) {
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen (ESC key also works by default)
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }
        
        function changeBackgroundColor() {
            // If grid is active, only allow black and grey
            if (gridMode) {
                // Toggle between black and grey
                if (currentBackgroundColor === 0x000000) {
                    currentBackgroundColor = 0x808080; // Grey
                    backgroundColorIndex = backgroundColors.indexOf(0x808080);
                } else {
                    currentBackgroundColor = 0x000000; // Black
                    backgroundColorIndex = backgroundColors.indexOf(0x000000);
                }
                if (backgroundColorIndex === -1) {
                    backgroundColorIndex = 1; // Fallback to black index
                }
            } else {
                // Normal mode: Cycle through colors: AZUL -> NEGRO -> GRIS -> ROSA -> AZUL
                backgroundColorIndex = (backgroundColorIndex + 1) % backgroundColors.length;
                currentBackgroundColor = backgroundColors[backgroundColorIndex];
            }
            
            // Update background-container (separate from 3D scene)
            const backgroundContainer = document.getElementById('background-container');
            if (backgroundContainer) {
                // Remove any existing pattern elements
                const existingCanvas = backgroundContainer.querySelector('canvas');
                if (existingCanvas) {
                    existingCanvas.remove();
                }
                const existingQuadrants = backgroundContainer.querySelectorAll('.checkerboard-quadrant');
                existingQuadrants.forEach(q => q.remove());
                backgroundContainer.style.background = '';
                backgroundContainer.style.backgroundImage = '';
                const hexColor = '#' + currentBackgroundColor.toString(16).padStart(6, '0');
                backgroundContainer.style.backgroundColor = hexColor;
            }
            
            // Scene always stays transparent
            scene.background = null;
            renderer.setClearColor(0x000000, 0);
            
            // Update the color square in the button
            const colorSquare = document.getElementById('bgColorSquare');
            if (colorSquare) {
                colorSquare.style.backgroundSize = '';
                const hexColor = '#' + currentBackgroundColor.toString(16).padStart(6, '0');
                colorSquare.style.background = hexColor;
            }
            
            // Update reference sphere colors (lines and crosses)
            updateReferenceSphereColors();
        }
        
        function updateBackgroundColor() {
            // Initialize background color on startup
            const backgroundContainer = document.getElementById('background-container');
            if (backgroundContainer) {
                const hexColor = '#' + currentBackgroundColor.toString(16).padStart(6, '0');
                backgroundContainer.style.backgroundColor = hexColor;
            }
        }
        
        function toggleGrid() {
            // Toggle grid mode
            gridMode = !gridMode;
            
            const gridContainerElement = document.getElementById('grid-container');
            if (!gridContainerElement) {
                console.error('Grid container element not found');
                return;
            }
            
            if (!gridMode) {
                // Hide grid
                gridContainerElement.style.display = 'none';
                if (gridContainer) {
                    gridContainer.innerHTML = ''; // Clear grid squares
                }
                // Clear caches
                gridSquareValueHistory.clear();
                gridSquareCache.length = 0;
                console.log('Grid mode deactivated');
                return;
            }
            
            // When activating grid, ensure background container has a visible color first
            // If color is not black or grey, change to black
            if (currentBackgroundColor !== 0x000000 && currentBackgroundColor !== 0x808080) {
                currentBackgroundColor = 0x000000;
                // Update backgroundColorIndex to match black
                backgroundColorIndex = backgroundColors.indexOf(0x000000);
                if (backgroundColorIndex === -1) {
                    backgroundColorIndex = 1; // Fallback to index 1 (black)
                }
            }
            
            // Update background container to ensure it has a visible color
            const backgroundContainer = document.getElementById('background-container');
            if (backgroundContainer) {
                const hexColor = '#' + currentBackgroundColor.toString(16).padStart(6, '0');
                backgroundContainer.style.backgroundColor = hexColor;
                backgroundContainer.style.display = 'block';
            }
            
            // Update color square in button
            const colorSquare = document.getElementById('bgColorSquare');
            if (colorSquare) {
                const hexColor = '#' + currentBackgroundColor.toString(16).padStart(6, '0');
                colorSquare.style.background = hexColor;
            }
            
            // Update reference sphere colors
            updateReferenceSphereColors();
            
            // Now make 3D scene background completely transparent so grid is visible
            if (scene) {
                scene.background = null;
            }
            if (renderer) {
                renderer.setClearColor(0x000000, 0); // Completely transparent
                // Force render to apply transparency immediately
                if (scene && camera) {
                    renderer.render(scene, camera);
                }
            }
            
            // Ensure canvas container background is transparent
            const canvasContainer = document.getElementById('canvas-container');
            if (canvasContainer) {
                canvasContainer.style.background = 'transparent';
                canvasContainer.style.backgroundColor = 'transparent';
            }
            
            // Ensure renderer canvas background is transparent
            if (renderer && renderer.domElement) {
                renderer.domElement.style.background = 'transparent';
                renderer.domElement.style.backgroundColor = 'transparent';
            }
            
            // Ensure grid container is visible
            gridContainerElement.style.display = 'grid';
            
            console.log('Grid mode activated');
            
            // Get or create grid container
            gridContainer = gridContainerElement;
            
            // Clear existing grid
            gridContainer.innerHTML = '';
            
            // Calculate number of rows and columns for grid (36px squares - more squares to cover full screen)
            const squareSize = 36;
            const cols = Math.ceil(window.innerWidth / squareSize);
            const rows = Math.ceil(window.innerHeight / squareSize);
            
            console.log(`Creating grid: ${cols} columns x ${rows} rows = ${cols * rows} squares`);
            
            // Set grid container styles - use exact number of columns/rows to ensure full coverage
            gridContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                pointer-events: none;
                z-index: 50;
                display: grid;
                grid-template-columns: repeat(${cols}, ${squareSize}px);
                grid-template-rows: repeat(${rows}, ${squareSize}px);
                will-change: transform;
                transform: translateZ(0);
                backface-visibility: hidden;
                -webkit-backface-visibility: hidden;
            `;
            
            // Create grid squares
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const square = document.createElement('div');
                    square.className = 'grid-square';
                    square.style.cssText = `
                        width: ${squareSize}px;
                        height: ${squareSize}px;
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        box-sizing: border-box;
                        position: relative;
                        display: flex;
                        flex-direction: column;
                    `;
                    
                    // Create SVG for graph
                    const graphSVG = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    graphSVG.className = 'grid-square-graph';
                    graphSVG.setAttribute('width', '100%');
                    graphSVG.setAttribute('height', '100%');
                    graphSVG.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        pointer-events: none;
                        overflow: visible;
                    `;
                    square.appendChild(graphSVG);
                    
                    // Create value label container at the top
                    const valueLabel = document.createElement('div');
                    valueLabel.className = 'grid-square-value-label';
                    valueLabel.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        height: 6px;
                        font-size: 4px;
                        color: #ffffff !important;
                        text-align: left;
                        padding: 1px 2px;
                        overflow: hidden;
                        white-space: nowrap;
                        text-overflow: ellipsis;
                        background: rgba(0, 0, 0, 0.5);
                        line-height: 1;
                        z-index: 10;
                        display: block !important;
                        visibility: visible !important;
                    `;
                    valueLabel.textContent = '0p';
                    square.appendChild(valueLabel);
                    
                    // Create word label container at the bottom
                    const wordLabel = document.createElement('div');
                    wordLabel.className = 'grid-square-word-label';
                    wordLabel.style.cssText = `
                        position: absolute;
                        bottom: 0;
                        left: 0;
                        right: 0;
                        height: 6px;
                        font-size: 4px;
                        color: #ff0000 !important;
                        text-align: left;
                        padding: 1px 2px;
                        overflow: hidden;
                        white-space: nowrap;
                        text-overflow: ellipsis;
                        background: rgba(0, 0, 0, 0.5);
                        line-height: 1;
                        z-index: 10;
                        display: block !important;
                        visibility: visible !important;
                    `;
                    wordLabel.textContent = 'w:';
                    square.appendChild(wordLabel);
                    
                    // Initialize value history for this square
                    const squareId = `${row}-${col}`;
                    gridSquareValueHistory.set(squareId, []);
                    
                    // Store grid position for distance calculation
                    square.dataset.gridRow = row;
                    square.dataset.gridCol = col;
                    
                    gridContainer.appendChild(square);
                }
            }
            
            console.log(`Grid created with ${gridContainer.children.length} squares`);
            
            // Initialize last update time and build cache
            lastGridLabelUpdate = performance.now();
            buildGridSquareCache();
            // Update once after a short delay
            setTimeout(() => {
                updateGridWordLabels();
            }, 200);
            
            // Ensure canvas is transparent so grid shows through
            if (renderer) {
                renderer.setClearColor(0x000000, 0); // Fully transparent
                const canvas = renderer.domElement;
                if (canvas) {
                    canvas.style.backgroundColor = 'transparent';
                }
            }
            if (scene) {
                scene.background = null;
            }
            
            // Force render to apply transparency
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // Build cache of square data (only called once when grid is created)
        function buildGridSquareCache() {
            if (!gridContainer) return;
            
            gridSquareCache.length = 0; // Clear cache
            const allSquares = gridContainer.querySelectorAll('.grid-square');
            const squareSize = 36;
            const squareSizeHalf = squareSize / 2;
            
            for (let i = 0; i < allSquares.length; i++) {
                const square = allSquares[i];
                if (!square) continue;
                
                const row = parseInt(square.dataset.gridRow) || 0;
                const col = parseInt(square.dataset.gridCol) || 0;
                const squareId = `${row}-${col}`;
                
                // Find or create value label (top)
                let valueLabel = square.querySelector('.grid-square-value-label');
                if (!valueLabel) {
                    valueLabel = document.createElement('div');
                    valueLabel.className = 'grid-square-value-label';
                    valueLabel.style.cssText = 'position: absolute; top: 0; left: 0; right: 0; height: 6px; font-size: 4px; color: #ffffff !important; text-align: left; padding: 1px 2px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; background: rgba(0, 0, 0, 0.5); line-height: 1; z-index: 10; display: block !important; visibility: visible !important;';
                    valueLabel.textContent = '0p';
                    square.appendChild(valueLabel);
                }
                
                // Find or create word label (bottom)
                let label = square.querySelector('.grid-square-word-label');
                if (!label) {
                    label = document.createElement('div');
                    label.className = 'grid-square-word-label';
                    label.style.cssText = 'position: absolute; bottom: 0; left: 0; right: 0; height: 6px; font-size: 4px; color: #ff0000 !important; text-align: left; padding: 1px 2px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; background: rgba(0, 0, 0, 0.5); line-height: 1; z-index: 10; display: block !important; visibility: visible !important;';
                    label.innerHTML = 'w:';
                    square.appendChild(label);
                }
                
                // Find or create graph SVG
                let graphSVG = square.querySelector('.grid-square-graph');
                if (!graphSVG) {
                    graphSVG = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    graphSVG.className = 'grid-square-graph';
                    graphSVG.setAttribute('width', String(squareSize));
                    graphSVG.setAttribute('height', String(squareSize));
                    graphSVG.setAttribute('viewBox', `0 0 ${squareSize} ${squareSize}`);
                    graphSVG.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible; z-index: 1; display: block; visibility: visible;';
                    square.appendChild(graphSVG);
                }
                
                gridSquareCache.push({
                    centerX: col * squareSize + squareSizeHalf,
                    centerY: row * squareSize + squareSizeHalf,
                    label: label,
                    valueLabel: valueLabel,
                    graphSVG: graphSVG,
                    squareId: squareId
                });
            }
        }
        
        // Function to update word labels in grid squares (optimized)
        function updateGridWordLabels() {
            if (!gridMode || !gridContainer || gridSquareCache.length === 0) {
                return;
            }
            
            if (!camera || !nodes || nodes.length === 0) {
                // Clear all labels if no nodes
                for (let i = 0; i < gridSquareCache.length; i++) {
                    const cached = gridSquareCache[i];
                    if (cached.label) cached.label.innerHTML = 'w:';
                    if (cached.valueLabel) cached.valueLabel.textContent = '0p';
                    if (cached.graphSVG) cached.graphSVG.innerHTML = '';
                }
                return;
            }
            
            const vector = new THREE.Vector3();
            const nodeScreenData = [];
            const nodeCount = nodes.length;
            
            // Project all node positions to screen coordinates (optimized)
            for (let i = 0; i < nodeCount; i++) {
                const node = nodes[i];
                if (!node || !node.userData || !node.userData.wordData) continue;
                
                try {
                    if (node.userData.isNoun && node.userData.mainNode) {
                        node.userData.mainNode.getWorldPosition(vector);
                    } else {
                        node.getWorldPosition(vector);
                    }
                    vector.project(camera);
                    
                    const wordData = node.userData.wordData;
                    // Always use finalValue (with all devaluations applied), never totalScore
                    // Access finalValue directly from wordData to ensure we get the most up-to-date value
                    // with all devaluations applied (including global devaluation, 50% reduction, 25% reduction)
                    let nodeValue = 0;
                    if (wordData && wordData.finalValue !== undefined && wordData.finalValue !== null) {
                        nodeValue = wordData.finalValue;
                    } else if (wordData && wordData.totalScore !== undefined && wordData.totalScore !== null) {
                        // Fallback to totalScore only if finalValue is not available
                        nodeValue = wordData.totalScore;
                    }
                    
                    nodeScreenData.push({
                        x: (vector.x * 0.5 + 0.5) * window.innerWidth,
                        y: (-vector.y * 0.5 + 0.5) * window.innerHeight,
                        word: wordData.text,
                        value: nodeValue
                    });
                } catch (e) {
                    continue;
                }
            }
            
            if (nodeScreenData.length === 0) {
                // Clear all labels if no visible nodes
                for (let i = 0; i < gridSquareCache.length; i++) {
                    const cached = gridSquareCache[i];
                    if (cached.label) cached.label.innerHTML = 'w:';
                    if (cached.graphSVG) cached.graphSVG.innerHTML = '';
                }
                return;
            }
            
            // Find min/max values for graph normalization
            let minValue = Infinity;
            let maxValue = -Infinity;
            const nodeScreenDataLength = nodeScreenData.length;
            for (let j = 0; j < nodeScreenDataLength; j++) {
                const val = nodeScreenData[j].value;
                if (val < minValue) minValue = val;
                if (val > maxValue) maxValue = val;
            }
            const valueRange = Math.max(maxValue - minValue, 1);
            const squareSize = 45;
            
            // Update each grid square using cached data
            const nodeDataCount = nodeScreenData.length;
            const squareCount = gridSquareCache.length;
            
            for (let i = 0; i < squareCount; i++) {
                const cached = gridSquareCache[i];
                if (!cached || !cached.label || !cached.valueLabel || !cached.graphSVG) continue;
                
                // Find closest node using squared distance
                let closestNodeData = null;
                let minDistanceSquared = Infinity;
                let closestDistance = Infinity;
                
                for (let j = 0; j < nodeDataCount; j++) {
                    const nodeData = nodeScreenData[j];
                    if (!nodeData || !nodeData.word) continue;
                    
                    const dx = nodeData.x - cached.centerX;
                    const dy = nodeData.y - cached.centerY;
                    const distanceSquared = dx * dx + dy * dy;
                    
                    if (distanceSquared < minDistanceSquared) {
                        minDistanceSquared = distanceSquared;
                        closestDistance = Math.sqrt(distanceSquared); // Calculate actual distance
                        closestNodeData = nodeData;
                    }
                }
                
                // Update label only if changed
                if (closestNodeData && closestNodeData.word) {
                    const wordText = String(closestNodeData.word).trim();
                    if (wordText) {
                        // Create HTML with white "w:" and red word
                        const newHTML = `<span style="color: #ffffff;">w:</span><span style="color: #ff0000;">${wordText}</span>`;
                        const currentHTML = cached.label.innerHTML;
                        // Only update if content changed
                        if (currentHTML !== newHTML) {
                            cached.label.innerHTML = newHTML;
                        }
                        
                        // Update value history
                        const history = gridSquareValueHistory.get(cached.squareId) || [];
                        const currentValue = closestNodeData.value || 0;
                        
                        history.push(currentValue);
                        if (history.length > MAX_HISTORY_POINTS) {
                            history.shift();
                        }
                        gridSquareValueHistory.set(cached.squareId, history);
                        
                        // Calculate sum of last 5 values (last 5 seconds)
                        const last5Values = history.slice(-5);
                        const sumLast5 = last5Values.reduce((sum, val) => sum + val, 0);
                        
                        // Display as points with "p" suffix
                        const displayValue = Math.round(sumLast5).toString() + 'p';
                        
                        // Update value label at top
                        cached.valueLabel.textContent = displayValue;
                        
                        // Draw graph only if enough history
                        // Pass distance and node value to affect graph height based on node distance and value
                        if (history.length >= 2) {
                            const nodeValue = closestNodeData.value || 0;
                            drawGraph(cached.graphSVG, history, minValue, maxValue, valueRange, squareSize, closestDistance, nodeValue);
                        }
                    }
                } else {
                    if (cached.label.innerHTML !== 'w:') {
                        cached.label.innerHTML = 'w:';
                    }
                    if (cached.valueLabel.textContent !== '0p') {
                        cached.valueLabel.textContent = '0p';
                    }
                    if (cached.graphSVG.innerHTML !== '') {
                        cached.graphSVG.innerHTML = '';
                    }
                }
            }
        }
        
        // Function to draw graph in SVG
        function drawGraph(svg, history, minValue, maxValue, valueRange, squareSize, nodeDistance = 0, nodeValue = 0) {
            if (!svg || !history || history.length < 2) {
                if (svg) svg.innerHTML = '';
                return;
            }
            
            try {
                // Clear previous graph
                svg.innerHTML = '';
                
                const width = squareSize;
                const height = squareSize;
                const padding = 2;
                const graphWidth = width - (padding * 2);
                const graphHeight = height - (padding * 2) - 6; // Leave space for label
                
                // Calculate distance attenuation factor
                // The further the node, the less the graph should be affected
                // Use a maximum distance threshold (e.g., 150 pixels) beyond which graph is barely affected
                const maxDistance = 150; // Maximum distance for full effect
                
                // Calculate distance factor (1.0 when close, 0.0 when far)
                // Closer nodes (distance = 0) get full effect, farther nodes get reduced effect
                const distanceFactor = Math.max(0, Math.min(1, 1 - (nodeDistance / maxDistance)));
                
                // Calculate value factor (normalize node value relative to maxValue)
                // Higher value nodes should have more impact on graph height
                const valueFactor = maxValue > 0 ? Math.min(1, nodeValue / maxValue) : 0;
                
                // Combined factor: distance * value
                // Graph height is affected by both how close the node is AND how valuable it is
                const combinedFactor = distanceFactor * valueFactor;
                
                // Set viewBox and ensure SVG is visible
                svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                svg.setAttribute('width', width);
                svg.setAttribute('height', height);
                svg.style.display = 'block';
                svg.style.visibility = 'visible';
                svg.style.opacity = '0.9';
                
                // Calculate local min/max for this history to better visualize changes
                let localMin = Infinity;
                let localMax = -Infinity;
                const historyLength = history.length;
                for (let i = 0; i < historyLength; i++) {
                    const val = history[i];
                    if (val < localMin) localMin = val;
                    if (val > localMax) localMax = val;
                }
                const localRange = Math.max(localMax - localMin, 1); // Avoid division by zero
                
                // Draw lines connecting points
                for (let i = 1; i < historyLength; i++) {
                    const prevValue = history[i - 1];
                    const currentValue = history[i];
                    
                    // Calculate positions (distribute across available width)
                    const x1 = padding + ((i - 1) / (historyLength - 1)) * graphWidth;
                    const x2 = padding + (i / (historyLength - 1)) * graphWidth;
                    
                    // Normalize values to graph height (inverted Y: higher value = higher on screen)
                    // Use local range for better visualization
                    const normalizedPrev = ((prevValue - localMin) / localRange);
                    const normalizedCurrent = ((currentValue - localMin) / localRange);
                    
                    // Apply distance and value factor to graph height
                    // The graph should be taller when node is closer AND has higher value
                    // Base Y position (bottom of graph area)
                    const baseY = height - padding - 6;
                    
                    // Calculate Y positions with distance/value attenuation
                    // combinedFactor = 1.0 means full height, combinedFactor = 0.0 means minimal height
                    const y1 = baseY - (normalizedPrev * graphHeight * combinedFactor);
                    const y2 = baseY - (normalizedCurrent * graphHeight * combinedFactor);
                    
                    // Determine color based on value change
                    let color = '#ffffff'; // Default white
                    const valueChange = currentValue - prevValue;
                    
                    if (valueChange > 0) {
                        // Value increased - check if it's a very abrupt increase
                        // Consider it abrupt if the change is more than 30% of the local range
                        const changeRatio = valueChange / localRange;
                        if (changeRatio > 0.3) {
                            // Very abrupt increase - blue
                            color = '#0000ff';
                        } else {
                            // Normal increase - green
                            color = '#00ff00';
                        }
                    } else if (valueChange < 0) {
                        // Value decreased (less valuable) - red
                        color = '#ff0000';
                    } else {
                        // No change - yellow
                        color = '#ffff00';
                    }
                    
                    // Draw line
                    // Graph height is already affected by distance and value through y1 and y2
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', String(x1));
                    line.setAttribute('y1', String(y1));
                    line.setAttribute('x2', String(x2));
                    line.setAttribute('y2', String(y2));
                    line.setAttribute('stroke', color);
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('opacity', '0.9');
                    svg.appendChild(line);
                }
            } catch (error) {
                console.error('Error drawing graph:', error);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            // Update top-bar and bottom-bar positions based on left panel state
            setTimeout(() => {
                const leftPanel = document.getElementById('left-panel');
                const topBar = document.getElementById('top-bar');
                const fpsBar = document.getElementById('fps-bar');
                const bottomBar = document.getElementById('bottom-bar');
                
                if (leftPanel && leftPanel.classList.contains('collapsed')) {
                    // Panel is collapsed, position bars at left edge of screen
                    document.body.classList.add('left-panel-collapsed');
                    if (topBar) {
                        topBar.style.left = '0';
                        topBar.style.position = 'fixed';
                        topBar.style.top = '0';
                        topBar.style.right = '0';
                        topBar.style.display = 'flex';
                        topBar.style.paddingLeft = '10px'; // Add left margin
                    }
                    if (fpsBar) {
                        fpsBar.style.left = '0';
                        fpsBar.style.position = 'fixed';
                        fpsBar.style.top = '18px';
                        fpsBar.style.right = '0';
                        fpsBar.style.display = 'flex';
                    }
                    if (bottomBar) {
                        bottomBar.style.left = '0';
                        bottomBar.style.position = 'fixed';
                        bottomBar.style.bottom = '0';
                        bottomBar.style.right = '0';
                        bottomBar.style.display = 'flex';
                    }
                } else {
                    // Panel is expanded, remove inline styles to let CSS handle positioning
                    document.body.classList.remove('left-panel-collapsed');
                    if (topBar) {
                        topBar.style.removeProperty('left');
                        topBar.style.position = 'fixed';
                        topBar.style.top = '0';
                        topBar.style.right = '0';
                        topBar.style.display = 'flex';
                        topBar.style.paddingLeft = ''; // Remove left margin when expanded
                    }
                    if (fpsBar) {
                        fpsBar.style.removeProperty('left');
                        fpsBar.style.position = 'fixed';
                        fpsBar.style.top = '18px';
                        fpsBar.style.right = '0';
                        fpsBar.style.display = 'flex';
                    }
                    if (bottomBar) {
                        bottomBar.style.removeProperty('left');
                        bottomBar.style.position = 'fixed';
                        bottomBar.style.bottom = '0';
                        bottomBar.style.right = '0';
                        bottomBar.style.display = 'flex';
                    }
                }
            }, 10);
            
            // On mobile, canvas should fill entire screen behind UI
            if (window.innerWidth <= 768) {
                const canvasContainer = document.getElementById('canvas-container');
                const topBar = document.getElementById('top-bar');
                const leftPanel = document.getElementById('left-panel');
                
                if (canvasContainer) {
                    // Canvas fills entire viewport behind all UI elements
                    canvasContainer.style.top = '0';
                    canvasContainer.style.left = '0';
                    canvasContainer.style.width = '100%';
                    canvasContainer.style.height = '100vh';
                    canvasContainer.style.bottom = 'auto';
                    
                    // Calculate visible area for renderer
                    let renderHeight = window.innerHeight;
                    if (topBar) {
                        renderHeight -= (topBar.offsetHeight || 80);
                    }
                    if (leftPanel && !leftPanel.classList.contains('collapsed')) {
                        renderHeight -= (leftPanel.offsetHeight || 0);
                    }
                    
                    // Renderer uses full viewport size (canvas will be behind UI)
                    renderer.setSize(window.innerWidth, window.innerHeight);
                } else {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            } else {
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Regenerate grid if active
            if (gridMode && gridContainer) {
                // Regenerate grid with new dimensions
                const gridContainerElement = document.getElementById('grid-container');
                if (gridContainerElement) {
                    gridContainer = gridContainerElement;
                    gridContainer.innerHTML = '';
                    
                    const squareSize = 36;
                    const cols = Math.ceil(window.innerWidth / squareSize);
                    const rows = Math.ceil(window.innerHeight / squareSize);
                    
                    gridContainer.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100vw;
                        height: 100vh;
                        pointer-events: none;
                        z-index: 50;
                        display: grid;
                        grid-template-columns: repeat(${cols}, ${squareSize}px);
                        grid-template-rows: repeat(${rows}, ${squareSize}px);
                        will-change: transform;
                        transform: translateZ(0);
                        backface-visibility: hidden;
                        -webkit-backface-visibility: hidden;
                    `;
                    
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const square = document.createElement('div');
                            square.className = 'grid-square';
                            square.style.cssText = `
                                width: ${squareSize}px;
                                height: ${squareSize}px;
                                border: 1px solid rgba(255, 255, 255, 0.1);
                                box-sizing: border-box;
                                position: relative;
                                display: flex;
                                flex-direction: column;
                            `;
                            
                            const graphSVG = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                            graphSVG.className = 'grid-square-graph';
                            graphSVG.setAttribute('width', '100%');
                            graphSVG.setAttribute('height', '100%');
                            graphSVG.style.cssText = `
                                position: absolute;
                                top: 0;
                                left: 0;
                                width: 100%;
                                height: 100%;
                                pointer-events: none;
                                overflow: visible;
                            `;
                            square.appendChild(graphSVG);
                            
                            const valueLabel = document.createElement('div');
                            valueLabel.className = 'grid-square-value-label';
                            valueLabel.style.cssText = `
                                position: absolute;
                                top: 0;
                                left: 0;
                                right: 0;
                                height: 6px;
                                font-size: 4px;
                                color: #ffffff !important;
                                text-align: left;
                                padding: 1px 2px;
                                overflow: hidden;
                                white-space: nowrap;
                                text-overflow: ellipsis;
                                background: rgba(0, 0, 0, 0.5);
                                line-height: 1;
                                z-index: 10;
                                display: block !important;
                                visibility: visible !important;
                            `;
                            valueLabel.textContent = '0p';
                            square.appendChild(valueLabel);
                            
                            const wordLabel = document.createElement('div');
                            wordLabel.className = 'grid-square-word-label';
                            wordLabel.style.cssText = `
                                position: absolute;
                                bottom: 0;
                                left: 0;
                                right: 0;
                                height: 6px;
                                font-size: 4px;
                                color: #ff0000 !important;
                                text-align: left;
                                padding: 1px 2px;
                                overflow: hidden;
                                white-space: nowrap;
                                text-overflow: ellipsis;
                                background: rgba(0, 0, 0, 0.5);
                                line-height: 1;
                                z-index: 10;
                                display: block !important;
                                visibility: visible !important;
                            `;
                            wordLabel.textContent = 'w:';
                            square.appendChild(wordLabel);
                            
                            square.dataset.gridRow = row;
                            square.dataset.gridCol = col;
                            
                            gridContainer.appendChild(square);
                        }
                    }
                    
                    buildGridSquareCache();
                    setTimeout(() => {
                        updateGridWordLabels();
                    }, 200);
                }
            }
        }

        // ==================== ACTUALIZACIÃ“N DE ESTADÃSTICAS ====================
        function updateStats() {
            // Calculate and display total value (accumulated, not normalized)
            // Using finalValue from the new linguistic scoring system
            const totalValue = window.totalTextScore || analyzedWords.reduce((sum, wordData) => {
                return sum + (wordData.finalValue || wordData.totalScore || 0);
            }, 0);
            
            // Convert points directly to ETH and display
            // Note: The totalValue is in points, converted directly to ETH
            convertToEthereum(totalValue);
            
            // Update real-time info panel
            updateRealtimeInfo();
        }
        
        function updateRealtimeInfo() {
            // FPS (already calculated in animate)
            document.getElementById('realtime-fps').textContent = fps;
            
            // Mouse coordinates in 3D space (updated on mouse move)
            // These are updated by onMouseMoveCoordinates function
            
            // Nodes
            document.getElementById('realtime-nodes').textContent = nodes.length;
            
            // Connections
            document.getElementById('realtime-connections').textContent = connections.length;
            
            // Total Value (using new linguistic scoring system) - convert points directly to ETH
            const totalValuePoints = window.totalTextScore || analyzedWords.reduce((sum, wordData) => {
                return sum + (wordData.finalValue || wordData.totalScore || 0);
            }, 0);
            
            let totalValueETH = 0;
            if (ethPriceUSD) {
                totalValueETH = totalValuePoints / ethPriceUSD;
            }
            const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                `${totalValueETH.toFixed(6)} ETH` : 
                `${totalValueETH.toFixed(10)} ETH`;
            document.getElementById('realtime-total-value').textContent = totalValueETHDisplay;
            
            // Average Value per Node
            const avgValueETH = nodes.length > 0 ? totalValueETH / nodes.length : 0;
            const avgValueETHDisplay = avgValueETH >= 0.01 ? 
                `${avgValueETH.toFixed(6)} ETH` : 
                `${avgValueETH.toFixed(10)} ETH`;
            document.getElementById('realtime-avg-value').textContent = avgValueETHDisplay;
        }
        
        // Fetch Ethereum price and convert USD value to ETH
        // Convert points directly to ETH (no USD conversion)
        async function convertToEthereum(pointsValue) {
            try {
                // Fetch current Ethereum price from CoinGecko API (used as conversion rate)
                if (!ethPriceUSD) {
                    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
                    const data = await response.json();
                    ethPriceUSD = data.ethereum.usd;
                }
                
                // Convert points directly to ETH (points are treated as USD-equivalent, then converted to ETH)
                const ethValue = pointsValue / ethPriceUSD;
                
                // Display ETH value only
                const ethDisplay = ethValue >= 0.01 ? 
                    `${ethValue.toFixed(6)} ETH` : 
                    `${ethValue.toFixed(10)} ETH`;
                
                document.getElementById('valueScore').textContent = ethDisplay;
                document.getElementById('valueETH').textContent = ''; // Keep empty
            } catch (error) {
                console.error('Error fetching Ethereum price:', error);
                document.getElementById('valueScore').textContent = 'ETH price unavailable';
                document.getElementById('valueETH').textContent = '';
                
                // Try alternative API (CoinCap) as fallback
                try {
                    const response = await fetch('https://api.coincap.io/v2/assets/ethereum');
                    const data = await response.json();
                    ethPriceUSD = parseFloat(data.data.priceUsd);
                    const ethValue = pointsValue / ethPriceUSD;
                    const ethDisplay = ethValue >= 0.01 ? 
                        `${ethValue.toFixed(6)} ETH` : 
                        `${ethValue.toFixed(10)} ETH`;
                    document.getElementById('valueScore').textContent = ethDisplay;
                    document.getElementById('valueETH').textContent = '';
                } catch (fallbackError) {
                    console.error('Fallback API also failed:', fallbackError);
                }
            }
        }
        
        // Fetch Ethereum price on page load
        window.addEventListener('load', () => {
            // Reset gallery data on page reload
            localStorage.removeItem('gallery_purchases');
            console.log('[GALLERY] Gallery data reset on page load');
            
            fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd')
                .then(response => response.json())
                .then(data => {
                    ethPriceUSD = data.ethereum.usd;
                })
                .catch(error => {
                    console.error('Error fetching initial ETH price:', error);
                });
        });

        // ==================== NAMETAGS ====================
        function toggleNametags() {
            nametagsVisible = !nametagsVisible;
            const toggleBtn = document.getElementById('toggleNametagsBtn');
            
            if (nametagsVisible) {
                createNametags();
                if (toggleBtn) toggleBtn.textContent = 'HIDE NAMETAGS';
            } else {
                removeNametags();
                if (toggleBtn) toggleBtn.textContent = 'SHOW NAMETAGS';
            }
        }

        // ==================== TOP NODES ====================
        function toggleNodeList() {
            console.log('[TOP NODES] toggleNodeList called, current state:', nodeListVisible);
            const nodeListBtn = document.getElementById('nodeListBtn');
            
            // Check if button is disabled
            if (nodeListBtn && nodeListBtn.disabled) {
                console.warn('[TOP NODES] Button is disabled');
                alert('Please generate a visualization first');
                return;
            }
            
            nodeListVisible = !nodeListVisible;
            const container = document.getElementById('node-list-container');
            
            if (!container) {
                console.error('[TOP NODES] Container not found!');
                return;
            }
            
            if (!nodeListBtn) {
                console.error('[TOP NODES] Button not found!');
                return;
            }
            
            console.log('[TOP NODES] New state:', nodeListVisible, 'nodes.length:', nodes.length);
            
            if (nodeListVisible) {
                // Si GALLERY estÃ¡ visible, ocultarlo
                if (galleryVisible) {
                    console.log('[TOP NODES] Closing gallery');
                    galleryVisible = false;
                    clearGallery();
                    closeLeaderboardRightPanel();
                }
                if (!nodes || nodes.length === 0) {
                    console.warn('[TOP NODES] No nodes available');
                    alert('Please generate a visualization first');
                    nodeListVisible = false;
                    return;
                }
                console.log('[TOP NODES] Showing node list');
                container.classList.add('visible');
                createNodeListItems();
                if (nodeListBtn) nodeListBtn.textContent = 'HIDE NODES';
            } else {
                console.log('[TOP NODES] Hiding node list');
                container.classList.remove('visible');
                clearNodeList();
                if (nodeListBtn) nodeListBtn.textContent = 'TOP NODES';
            }
        }

        function findTop12Nodes() {
            if (nodes.length === 0) return [];
            
            // Separar nodos normales de nodos de convergencia
            const normalNodes = nodes.filter(n => !n.userData || !n.userData.isConvergenceNode);
            const convergenceNodes = nodes.filter(n => n.userData && n.userData.isConvergenceNode);
            
            // Sort normal nodes by their totalScore
            const sortedNormalNodes = [...normalNodes].sort((a, b) => {
                const scoreA = a.userData.wordData ? (a.userData.wordData.totalScore || 0) : 0;
                const scoreB = b.userData.wordData ? (b.userData.wordData.totalScore || 0) : 0;
                return scoreB - scoreA; // Descending order
            });
            
            // Sort convergence nodes by their totalScore (only include those with significant value)
            const sortedConvergenceNodes = [...convergenceNodes].sort((a, b) => {
                const scoreA = a.userData.wordData ? (a.userData.wordData.totalScore || 0) : 0;
                const scoreB = b.userData.wordData ? (b.userData.wordData.totalScore || 0) : 0;
                return scoreB - scoreA; // Descending order
            });
            
            // Get top 1000 normal nodes
            const topNormalNodes = sortedNormalNodes.slice(0, 1000);
            
            // Include convergence nodes that have high enough value to appear in top nodes
            // They should compete with normal nodes based on their value
            const allNodesSorted = [...topNormalNodes, ...sortedConvergenceNodes].sort((a, b) => {
                const scoreA = a.userData.wordData ? (a.userData.wordData.totalScore || 0) : 0;
                const scoreB = b.userData.wordData ? (b.userData.wordData.totalScore || 0) : 0;
                return scoreB - scoreA; // Descending order
            });
            
            // Return top 1000 nodes (which may include convergence nodes if they have high values)
            return allNodesSorted.slice(0, 1000);
        }

        function createNodeListItems() {
            clearNodeList();
            
            const top12Nodes = findTop12Nodes();
            const container = document.getElementById('node-list-container');
            
            top12Nodes.forEach((node, index) => {
                if (!node.userData || !node.userData.wordData) return;
                
                // Create item container
                const item = document.createElement('div');
                item.className = 'node-list-item';
                item.id = `node-list-item-${index}`;
                
                // Create header
                const header = document.createElement('div');
                header.className = 'node-list-item-header';
                const headerText = document.createElement('h3');
                headerText.style.cssText = 'color: #000000; font-size: 11px; margin: 0; font-family: Helvetica, Arial, sans-serif;';
                headerText.textContent = node.userData.wordData.text;
                header.appendChild(headerText);
                
                // Create canvas container
                const canvasContainer = document.createElement('div');
                canvasContainer.className = 'node-list-item-canvas-container';
                const canvas = document.createElement('canvas');
                canvas.className = 'node-list-item-canvas';
                canvas.id = `node-list-canvas-${index}`;
                canvasContainer.appendChild(canvas);
                
                // Create info container
                const infoContainer = document.createElement('div');
                infoContainer.className = 'node-list-item-info';
                
                // Populate info (same as showNodeDetails)
                const wordData = node.userData.wordData;
                const nodeIndex = node.userData.index;
                const totalValue = window.totalTextScore || analyzedWords.reduce((sum, w) => sum + (w.finalValue || w.totalScore || 0), 0);
                const individualValue = wordData.finalValue || wordData.totalScore || 0;
                const relativeValue = totalValue > 0 ? ((individualValue / totalValue) * 100).toFixed(2) + '%' : '0%';
                
                // Calculate node size in KB
                let nodeSizeKB = 0;
                if (node.userData.isSerEstar) {
                    // Cube + flat rectangular base
                    nodeSizeKB = (1 * 1 * 1 * 4 * 3) + (1.0 * 0.1 * 1.0 * 4 * 3);
                } else if (node.userData.isNoun) {
                    nodeSizeKB = (8 * 8 * 8 * 4 * 3) + (1 * 1 * 1 * 4 * 3);
                } else if (node.userData.connectionCount > 0) {
                    nodeSizeKB = (8 * 4 * 3);
                } else {
                    nodeSizeKB = (8 * 8 * 8 * 4 * 3);
                }
                nodeSizeKB = (nodeSizeKB / 1024).toFixed(4);
                
                const performanceImpact = node.userData.connectionCount > 0 ? 
                    'Medium (' + node.userData.connectionCount + ' connections)' : 
                    'Low';
                
                // Convert to ETH
                let individualValueETH = 0;
                if (ethPriceUSD) {
                    individualValueETH = individualValue / ethPriceUSD;
                }
                const individualValueETHDisplay = individualValueETH >= 0.01 ? 
                    `${individualValueETH.toFixed(6)} ETH` : 
                    `${individualValueETH.toFixed(10)} ETH`;
                
                let totalValueETH = 0;
                if (ethPriceUSD) {
                    totalValueETH = totalValue / ethPriceUSD;
                }
                const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                    `${totalValueETH.toFixed(6)} ETH` : 
                    `${totalValueETH.toFixed(10)} ETH`;
                
                // Check if it's a convergence node
                const isConvergenceNode = node.userData && node.userData.isConvergenceNode;
                const positionText = isConvergenceNode ? 
                    'Convergence Zone' : 
                    `${nodeIndex + 1} / ${analyzedWords.length}`;
                
                // Find which convergence zone this node belongs to
                let convergenceZoneInfo = '';
                if (isConvergenceNode) {
                    const zone = convergenceZones.find(z => {
                        if (z.group && z.group.children) {
                            return z.group.children.some(child => child === node || (child.userData && child.userData.isConvergenceNode && child.userData.wordData && child.userData.wordData.text === wordData.text));
                        }
                        return false;
                    });
                    if (zone) {
                        const zoneIndex = convergenceZones.indexOf(zone);
                        convergenceZoneInfo = `<div><strong>Source:</strong> Convergence Zone ${zoneIndex + 1}</div>`;
                    }
                }
                
                // Add info fields
                infoContainer.innerHTML = `
                    <div><strong>Word:</strong> ${wordData.text}</div>
                    <div><strong>Individual Value:</strong> ${individualValueETHDisplay}</div>
                    <div><strong>Position in Text:</strong> ${positionText}</div>
                    ${convergenceZoneInfo}
                    <div><strong>Value / Total:</strong> ${relativeValue} (${totalValueETHDisplay} total)</div>
                    <div><strong>Connections:</strong> ${node.userData.connectionCount || 0}</div>
                    <div><strong>Size (KB):</strong> ${nodeSizeKB} KB</div>
                    <div><strong>Performance:</strong> ${performanceImpact}</div>
                    <div><strong>3D Coordinates:</strong> (${node.position.x.toFixed(2)}, ${node.position.y.toFixed(2)}, ${node.position.z.toFixed(2)})</div>
                `;
                
                // Assemble item
                item.appendChild(header);
                item.appendChild(canvasContainer);
                item.appendChild(infoContainer);
                container.appendChild(item);
                
                // Store node data for lazy loading
                item.dataset.nodeIndex = index;
                item.dataset.nodeData = JSON.stringify({
                    word: wordData.text,
                    pos: wordData.pos,
                    normalizedScore: wordData.normalizedScore || 0,
                    isNoun: node.userData.isNoun,
                    isSerEstar: wordData.isSerEstar || false,
                    connectionCount: node.userData.connectionCount || 0
                });
            });
            
            // Setup Intersection Observer for lazy loading
            setupNodeListIntersectionObserver();
        }
        
        function setupNodeListIntersectionObserver() {
            // Clean up existing observer
            if (nodeListIntersectionObserver) {
                nodeListIntersectionObserver.disconnect();
            }
            
            // Create new observer
            nodeListIntersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const item = entry.target;
                    const index = parseInt(item.dataset.nodeIndex);
                    
                    if (entry.isIntersecting) {
                        // Node is visible, create 3D scene if not already created
                        if (!nodeListRenderers[index]) {
                            const canvas = item.querySelector('.node-list-item-canvas');
                            const nodeData = JSON.parse(item.dataset.nodeData);
                            // Find the actual node from the nodes array
                            const top12Nodes = findTop12Nodes();
                            if (top12Nodes[index]) {
                                createNodeList3DScene(index, top12Nodes[index], canvas);
                                // Add fractal click listener
                                const nodeIndex = top12Nodes[index].userData.index;
                                addNodeListCanvasClickListener(canvas, nodeIndex, top12Nodes[index]);
                            }
                        }
                    } else {
                        // Node is not visible, cleanup if needed (optional - keep for performance)
                        // We'll keep them loaded but could cleanup here if needed
                    }
                });
            }, {
                root: document.getElementById('node-list-container'),
                rootMargin: '50px', // Start loading 50px before entering viewport
                threshold: 0.1
            });
            
            // Observe all node list items
            const items = document.querySelectorAll('.node-list-item');
            items.forEach(item => {
                nodeListIntersectionObserver.observe(item);
            });
        }

        function createNodeList3DScene(index, node, canvas) {
            // Usar renderer compartido si no existe
            if (!sharedTopNodesRenderer) {
                // Crear un canvas temporal para el renderer compartido
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 200;
                tempCanvas.height = 120;
                sharedTopNodesRenderer = new THREE.WebGLRenderer({ canvas: tempCanvas, antialias: false });
                sharedTopNodesRenderer.setSize(200, 120);
                sharedTopNodesRenderer.setPixelRatio(0.75);
                
                sharedTopNodesScene = new THREE.Scene();
                sharedTopNodesScene.background = new THREE.Color(0x000000);
                
                sharedTopNodesCamera = new THREE.PerspectiveCamera(50, 200 / 120, 0.1, 100);
                sharedTopNodesCamera.position.set(0, 0, 2);
                sharedTopNodesCamera.lookAt(0, 0, 0);
                
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                sharedTopNodesScene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(2, 2, 2);
                sharedTopNodesScene.add(directionalLight);
            }
            
            // Limpiar escena anterior (mantener solo las luces)
            while (sharedTopNodesScene.children.length > 2) {
                const child = sharedTopNodesScene.children[2];
                sharedTopNodesScene.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            }
            
            // Create mesh (same as showRightPanelEnlargedNode)
            const wordData = node.userData.wordData;
            const enlargedSize = 0.35;
            
            // Get color - use violet for convergence nodes, otherwise use value-based color
            let color;
            if (node.userData && node.userData.isConvergenceNode) {
                color = 0x8B00FF; // Violet color for convergence nodes
            } else {
                // Get color using the same function as nodes (getValueBasedColor)
                // This ensures colors match between nodes and TOP NODES list
                const nodeIndex = node.userData.index !== undefined ? node.userData.index : 0;
                color = getValueBasedColor(wordData, nodeIndex, analyzedWords);
            }
            
            // Get word type to determine correct shape
            const wordType = getWordTypeForShape(wordData, node.userData.index || 0);
            
            // Determine opacity
            let nodeOpacity = 0.92;
            const semiTransparentTypes = ['proper_noun', 'object_pronoun', 'intensive_pronoun', 
                                         'interrogative_pronoun', 'superlative_adjective', 'modal_verb',
                                         'concrete_noun', 'gerundial_noun', 'interrogative_determiner'];
            if (semiTransparentTypes.includes(wordType)) {
                nodeOpacity = 0.80;
            }
            
            // Create geometry using the correct shape function
            const colorHex = typeof color === 'number' ? color : parseInt(color, 16);
            const mesh = createWordTypeGeometry(wordType, enlargedSize, colorHex, nodeOpacity);
            
            sharedTopNodesScene.add(mesh);
            
            // Renderizar a una textura temporal
            const renderTarget = new THREE.WebGLRenderTarget(200, 120);
            
            // Guardar estado del renderer
            const originalSize = sharedTopNodesRenderer.getSize(new THREE.Vector2());
            const originalClearColor = sharedTopNodesRenderer.getClearColor(new THREE.Color());
            
            // Renderizar
            sharedTopNodesRenderer.setRenderTarget(renderTarget);
            sharedTopNodesRenderer.setClearColor(0x000000, 1);
            sharedTopNodesRenderer.render(sharedTopNodesScene, sharedTopNodesCamera);
            
            // Leer la textura y dibujarla en el canvas 2D
            const ctx2D = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 120;
            const pixels = new Uint8Array(200 * 120 * 4);
            sharedTopNodesRenderer.readRenderTargetPixels(renderTarget, 0, 0, 200, 120, pixels);
            
            const imageData = ctx2D.createImageData(200, 120);
            for (let i = 0; i < pixels.length; i += 4) {
                imageData.data[i] = pixels[i];
                imageData.data[i + 1] = pixels[i + 1];
                imageData.data[i + 2] = pixels[i + 2];
                imageData.data[i + 3] = pixels[i + 3];
            }
            ctx2D.putImageData(imageData, 0, 0);
            
            // Restaurar estado del renderer
            sharedTopNodesRenderer.setRenderTarget(null);
            sharedTopNodesRenderer.setSize(originalSize.x, originalSize.y);
            sharedTopNodesRenderer.setClearColor(originalClearColor, 1);
            
            // Limpiar render target
            renderTarget.dispose();
            
            // Remover el mesh de la escena
            sharedTopNodesScene.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => m.dispose());
                } else {
                    mesh.material.dispose();
                }
            }
            // Si es un grupo, limpiar tambiÃ©n los hijos
            if (mesh.isGroup) {
                mesh.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
        }

        function clearNodeList() {
            const container = document.getElementById('node-list-container');
            container.innerHTML = '';
            
            // Stop all animations and clean up (ya no hay animaciones, pero mantenemos por compatibilidad)
            nodeListAnimationIds.forEach(id => {
                if (id) cancelAnimationFrame(id);
            });
            
            // Clean up renderers and scenes (ya se limpian en createNodeList3DScene, pero mantenemos por seguridad)
            nodeListRenderers.forEach(renderer => {
                if (renderer) {
                    renderer.dispose();
                }
            });
            
            // Limpiar renderer compartido
            if (sharedTopNodesRenderer) {
                if (sharedTopNodesScene) {
                    sharedTopNodesScene.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    sharedTopNodesScene = null;
                }
                sharedTopNodesRenderer.dispose();
                sharedTopNodesRenderer = null;
                sharedTopNodesCamera = null;
            }
            
            nodeListScenes = [];
            nodeListRenderers = [];
            nodeListMeshes = [];
            nodeListAnimationIds = [];
            nodeListItems = [];
        }

        // ==================== GALLERY ====================
        // Helper function to close leaderboard right panel
        function closeLeaderboardRightPanel() {
            const rightPanel = document.getElementById('leaderboard-right-panel');
            if (rightPanel) {
                rightPanel.classList.remove('visible');
            }
            
            const infoPanel = document.getElementById('leaderboard-info-panel');
            if (infoPanel) {
                infoPanel.classList.remove('visible');
            }
            
            // Clean up visualization
            if (leaderboardRightPanelAnimationId) {
                cancelAnimationFrame(leaderboardRightPanelAnimationId);
                leaderboardRightPanelAnimationId = null;
            }
            if (leaderboardRightPanelScene) {
                leaderboardRightPanelScene.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
            if (leaderboardRightPanelRenderer) {
                try {
                    leaderboardRightPanelRenderer.dispose();
                } catch (e) {
                    console.warn('[Leaderboard Right Panel] Error disposing renderer:', e);
                }
                leaderboardRightPanelRenderer = null;
            }
            leaderboardRightPanelScene = null;
            leaderboardRightPanelCamera = null;
            leaderboardRightPanelSphereLines = [];
            leaderboardRightPanelSphereCrosses = [];
        }
        
        function updateLeaderboardButtonState() {
            const galleryBtn = document.getElementById('galleryBtn');
            if (!galleryBtn) return;
            
            const purchases = getGalleryPurchases();
            const hasPurchases = purchases && purchases.length > 0;
            
            if (hasPurchases) {
                // Normal opacity when there are purchases
                galleryBtn.style.opacity = '1';
                galleryBtn.style.cursor = 'pointer';
            } else {
                // More transparent (clearer) when no purchases
                galleryBtn.style.opacity = '0.3';
                galleryBtn.style.cursor = 'not-allowed';
            }
        }
        
        function toggleGallery() {
            // Check if there are any purchases before opening
            const purchases = getGalleryPurchases();
            if (!purchases || purchases.length === 0) {
                // Don't open if there are no purchases
                return;
            }
            
            galleryVisible = !galleryVisible;
            const container = document.getElementById('node-list-container');
            const rightPanel = document.getElementById('leaderboard-right-panel');
            
            if (galleryVisible) {
                // Si TOP NODES estÃ¡ visible, ocultarlo
                if (nodeListVisible) {
                    nodeListVisible = false;
                    clearNodeList();
                    const nodeListBtn = document.getElementById('nodeListBtn');
                    if (nodeListBtn) nodeListBtn.textContent = 'TOP NODES';
                }
                container.classList.add('visible');
                if (rightPanel) {
                    rightPanel.classList.add('visible');
                }
                const infoPanel = document.getElementById('leaderboard-info-panel');
                if (infoPanel) {
                    infoPanel.classList.add('visible');
                }
                createGalleryItems();
                createLeaderboardRightPanelVisualization();
                
                // Update max-value-panel with first purchase if available
                const purchases = getGalleryPurchases();
                if (purchases.length > 0) {
                    purchases.sort((a, b) => (b.totalValue || 0) - (a.totalValue || 0));
                    updateLeaderboardInfoPanel(purchases);
                    updateMaxValuePanelWithPurchase(purchases[0]);
                }
            } else {
                container.classList.remove('visible');
                closeLeaderboardRightPanel();
                clearGallery();
                
                // Clean up right panel visualization
                if (leaderboardRightPanelAnimationId) {
                    cancelAnimationFrame(leaderboardRightPanelAnimationId);
                    leaderboardRightPanelAnimationId = null;
                }
                if (leaderboardRightPanelScene) {
                    leaderboardRightPanelScene.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    leaderboardRightPanelScene = null;
                }
                if (leaderboardRightPanelRenderer) {
                    leaderboardRightPanelRenderer.dispose();
                    leaderboardRightPanelRenderer = null;
                }
                leaderboardRightPanelCamera = null;
                
                // Restore max-value-panel to show top node if available
                if (nodes.length > 0 && analyzedWords.length > 0) {
                    updateMaxValuePanel();
                }
            }
        }

        function createGalleryItems() {
            clearGallery();
            
            const container = document.getElementById('node-list-container');
            const purchases = getGalleryPurchases();
            
            // Note: CURRENT VALUE calculation removed per user request
            // All purchases will use totalValue as their display value
            
            // Sort by total value (descending) - already sorted in storage, but re-sort to be sure
            purchases.sort((a, b) => (b.totalValue || 0) - (a.totalValue || 0));
            
            // Create gallery items for each purchase
            purchases.forEach((purchase, index) => {
                // Create item container
                const item = document.createElement('div');
                item.className = 'node-list-item';
                item.id = `gallery-item-${index}`;
                
                // Create header con nÃºmero (ranking)
                const header = document.createElement('div');
                header.className = 'node-list-item-header';
                const headerText = document.createElement('h3');
                headerText.style.cssText = 'color: #000000; font-size: 11px; margin: 0; font-family: Helvetica, Arial, sans-serif;';
                headerText.textContent = (index + 1).toString();
                header.appendChild(headerText);
                
                // Create canvas container con imagen del cuerpo de nodos
                const canvasContainer = document.createElement('div');
                canvasContainer.className = 'node-list-item-canvas-container';
                const canvas = document.createElement('canvas');
                canvas.className = 'node-list-item-canvas';
                canvas.id = `gallery-canvas-${index}`;
                
                // Set canvas dimensions explicitly BEFORE adding to DOM
                canvas.width = 200;
                canvas.height = 120;
                canvas.style.width = '200px';
                canvas.style.height = '120px';
                canvas.style.display = 'block';
                canvas.style.backgroundColor = '#000000';
                
                // Add canvas to container FIRST
                canvasContainer.appendChild(canvas);
                
                // Function to draw image on canvas (called after canvas is in DOM)
                const drawImageOnCanvas = (imageData, targetCanvas) => {
                    console.log(`drawImageOnCanvas called for purchase ${purchase.id}`);
                    console.log(`Image data type: ${typeof imageData}, length: ${imageData ? imageData.length : 0}`);
                    
                    if (!imageData || imageData.length < 100) {
                        console.error(`âŒ No valid image data for purchase ${purchase.id} - length: ${imageData ? imageData.length : 0}`);
                        // Draw black background
                        try {
                            const ctx = targetCanvas.getContext('2d');
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(0, 0, 200, 120);
                        } catch (e) {
                            console.error('Error drawing black background:', e);
                        }
                        return;
                    }
                    
                    // Check if it's a valid data URL
                    if (!imageData.startsWith('data:image/')) {
                        console.error(`âŒ Invalid image data URL format for purchase ${purchase.id}`);
                        console.error('Image data preview:', imageData.substring(0, 100));
                        // Draw black background
                        try {
                            const ctx = targetCanvas.getContext('2d');
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(0, 0, 200, 120);
                        } catch (e) {
                            console.error('Error drawing black background:', e);
                        }
                        return;
                    }
                    
                    console.log(`âœ“ Valid image data URL detected, creating Image object...`);
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = function() {
                        console.log(`âœ“ Image loaded successfully for purchase ${purchase.id}: ${img.width}x${img.height}`);
                        try {
                            // Get fresh context AFTER canvas is in DOM
                            const drawCtx = targetCanvas.getContext('2d');
                            if (!drawCtx) {
                                console.error('âŒ Could not get canvas context for purchase:', purchase.id);
                                return;
                            }
                            
                            // Verify image loaded correctly
                            if (img.width === 0 || img.height === 0 || !isFinite(img.width) || !isFinite(img.height)) {
                                console.error(`âŒ Image has invalid dimensions for purchase ${purchase.id}: ${img.width}x${img.height}`);
                                // Draw black background
                                drawCtx.fillStyle = '#000000';
                                drawCtx.fillRect(0, 0, 200, 120);
                                return;
                            }
                            
                            // Calculate aspect ratio and drawing dimensions
                            const imgAspect = img.width / img.height;
                            const canvasAspect = 200 / 120;
                            let drawWidth, drawHeight, drawX, drawY;
                            
                            if (imgAspect > canvasAspect) {
                                // Image is wider - fit to width
                                drawWidth = 200;
                                drawHeight = 200 / imgAspect;
                                drawX = 0;
                                drawY = (120 - drawHeight) / 2;
                            } else {
                                // Image is taller - fit to height
                                drawHeight = 120;
                                drawWidth = 120 * imgAspect;
                                drawX = (200 - drawWidth) / 2;
                                drawY = 0;
                            }
                            
                            // Ensure dimensions are valid
                            if (!isFinite(drawWidth) || !isFinite(drawHeight) || drawWidth <= 0 || drawHeight <= 0) {
                                console.error(`âŒ Invalid draw dimensions for purchase ${purchase.id}: ${drawWidth}x${drawHeight}`);
                                // Draw black background
                                drawCtx.fillStyle = '#000000';
                                drawCtx.fillRect(0, 0, 200, 120);
                                return;
                            }
                            
                            // Clear canvas and redraw background
                            drawCtx.fillStyle = '#000000';
                            drawCtx.fillRect(0, 0, 200, 120);
                            
                            // Draw image
                            drawCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                            
                            console.log(`âœ… SUCCESS: Gallery image drawn for purchase ${purchase.id} (${img.width}x${img.height} â†’ ${drawWidth.toFixed(0)}x${drawHeight.toFixed(0)})`);
                        } catch (e) {
                            console.error('âŒ Error drawing gallery image:', e);
                            console.error('Image dimensions:', img.width, 'x', img.height);
                            console.error('Canvas dimensions:', targetCanvas.width, 'x', targetCanvas.height);
                            console.error('Error stack:', e.stack);
                            // Draw black background on error
                            try {
                                const errorCtx = targetCanvas.getContext('2d');
                                errorCtx.fillStyle = '#000000';
                                errorCtx.fillRect(0, 0, 200, 120);
                            } catch (err) {
                                console.error('Could not draw error background:', err);
                            }
                        }
                    };
                    
                    img.onerror = function(error) {
                        console.error('âŒ Failed to load gallery image for purchase:', purchase.id);
                        console.error('Image data length:', imageData ? imageData.length : 0);
                        console.error('Image data preview:', imageData ? imageData.substring(0, 100) : 'null');
                        console.error('Image data starts with:', imageData ? imageData.substring(0, 20) : 'null');
                        console.error('Error details:', error);
                        // Draw black background on error
                        try {
                            const errorCtx = targetCanvas.getContext('2d');
                            errorCtx.fillStyle = '#000000';
                            errorCtx.fillRect(0, 0, 200, 120);
                        } catch (err) {
                            console.error('Could not draw error background:', err);
                        }
                    };
                    
                    // Set image source (this triggers onload/onerror)
                    console.log(`Setting img.src for purchase ${purchase.id}...`);
                    img.src = imageData;
                };
                
                // Initialize canvas with black background
                const initCtx = canvas.getContext('2d');
                initCtx.fillStyle = '#000000';
                initCtx.fillRect(0, 0, 200, 120);
                
                // Draw image if available (after canvas is in DOM)
                console.log(`Processing purchase ${index + 1} (ID: ${purchase.id}):`);
                console.log(`  - Has nodeBodyImage: ${!!purchase.nodeBodyImage}`);
                console.log(`  - Image length: ${purchase.nodeBodyImage ? purchase.nodeBodyImage.length : 0}`);
                console.log(`  - Image preview: ${purchase.nodeBodyImage ? purchase.nodeBodyImage.substring(0, 50) : 'null'}...`);
                
                // Add canvas to DOM first, then draw image
                item.appendChild(header);
                item.appendChild(canvasContainer);
                
                // Draw image if available (after canvas is in DOM)
                if (purchase.nodeBodyImage && purchase.nodeBodyImage.length > 100) {
                    // Verify it's a valid data URL
                    if (!purchase.nodeBodyImage.startsWith('data:image/')) {
                        console.error(`âš  Invalid image format for purchase ${purchase.id}: ${purchase.nodeBodyImage.substring(0, 50)}...`);
                    } else {
                        console.log(`âœ“ Valid image data URL found, drawing to canvas...`);
                        // Use longer timeout to ensure canvas is fully in DOM and rendered
                        setTimeout(() => {
                            console.log(`Attempting to draw image for purchase ${purchase.id}...`);
                            drawImageOnCanvas(purchase.nodeBodyImage, canvas);
                        }, 100);
                    }
                } else {
                    // No image or image too small
                    if (!purchase.nodeBodyImage) {
                        console.warn(`âš  No nodeBodyImage for purchase: ${purchase.id}`);
                    } else {
                        console.warn(`âš  nodeBodyImage too small for purchase: ${purchase.id}, length: ${purchase.nodeBodyImage.length}`);
                    }
                }
                
                // Create info container con informaciÃ³n simplificada
                const infoContainer = document.createElement('div');
                infoContainer.className = 'node-list-item-info';
                infoContainer.style.cssText = 'background: #000000; color: #ffffff; padding: 6px; font-family: Helvetica, Arial, sans-serif; font-size: 10px; line-height: 1.4;';
                
                // Format price
                const priceDisplay = purchase.priceETH >= 0.01 ? 
                    `${purchase.priceETH.toFixed(6)} ETH` : 
                    `${purchase.priceETH.toFixed(10)} ETH`;
                
                // Convert total value to ETH
                let totalValueETH = 0;
                if (ethPriceUSD && purchase.totalValue) {
                    totalValueETH = purchase.totalValue / ethPriceUSD;
                }
                const totalValueDisplay = totalValueETH >= 0.01 ? 
                    `${totalValueETH.toFixed(6)} ETH` : 
                    `${totalValueETH.toFixed(10)} ETH`;
                
                // Format time
                const timeDisplay = purchase.purchaseTime || new Date(purchase.timestamp).toLocaleString();
                
                // Format top words (handle both old format strings and new format objects)
                const topWordsDisplay = purchase.topWords && purchase.topWords.length > 0 ? 
                    purchase.topWords.map(w => typeof w === 'string' ? w : (w.text || '')).join(', ') : 'N/A';
                
                infoContainer.innerHTML = `
                    <div style="margin-bottom: 3px;"><strong>USER:</strong> ${purchase.userId || 'N/A'}</div>
                    <div style="margin-bottom: 3px;"><strong>PRICE:</strong> ${priceDisplay}</div>
                    <div style="margin-bottom: 3px;"><strong>WEIGHT:</strong> ${purchase.weight || 0}</div>
                    <div style="margin-bottom: 3px;"><strong>WORDS:</strong> ${purchase.wordCount || 0}</div>
                    <div style="margin-bottom: 3px;"><strong>TIME:</strong> ${timeDisplay}</div>
                    <div style="margin-bottom: 3px; color: #ffff00;"><strong>TOTAL VALUE:</strong> ${totalValueDisplay}</div>
                    <div style="margin-top: 4px; padding-top: 3px; border-top: 1px solid #333333;"><strong>TOP WORDS:</strong> ${topWordsDisplay}</div>
                `;
                
                // Assemble item
                item.appendChild(header);
                item.appendChild(canvasContainer);
                item.appendChild(infoContainer);
                
                // Add click listener to open visualization window
                item.style.cursor = 'pointer';
                item.addEventListener('click', () => {
                    // Update max-value-panel with purchase info before opening
                    updateMaxValuePanelWithPurchase(purchase);
                    openPurchaseVisualization(purchase);
                });
                
                // Add hover listener to update max-value-panel on hover
                item.addEventListener('mouseenter', () => {
                    if (!isViewingPurchase) {
                        updateMaxValuePanelWithPurchase(purchase);
                    }
                });
                
                container.appendChild(item);
            });
        }

        function clearGallery() {
            const container = document.getElementById('node-list-container');
            // Solo limpiar elementos de galerÃ­a
            const galleryItems = container.querySelectorAll('[id^="gallery-item-"]');
            galleryItems.forEach(item => item.remove());
        }
        
        // Variables for leaderboard right panel visualization
        let leaderboardRightPanelRenderer = null;
        let leaderboardRightPanelScene = null;
        let leaderboardRightPanelCamera = null;
        let leaderboardRightPanelAnimationId = null;
        let leaderboardRightPanelSphereLines = [];
        let leaderboardRightPanelSphereCrosses = [];
        
        function updateLeaderboardRightPanelStats(purchases) {
            const statsElement = document.getElementById('leaderboard-right-panel-stats');
            if (!statsElement || !purchases || purchases.length === 0) {
                if (statsElement) {
                    statsElement.innerHTML = '';
                }
                return;
            }
            
            // Calculate CONVERGENCE: average number of convergence zones per purchase
            // Scale: 100 zones average = 100%, 0 zones = 0%
            let totalConvergenceZones = 0;
            
            // Calculate TRAFFIC: average number of nodes per purchase (including convergence nodes)
            // Scale: 1000 nodes = 100%, 1 node = 0.1%
            let totalNodes = 0;
            
            purchases.forEach(purchase => {
                // Count convergence zones
                let convergenceZoneCount = 0;
                if (purchase.convergenceZoneCount !== undefined && purchase.convergenceZoneCount !== null) {
                    // Use stored convergence zone count if available
                    convergenceZoneCount = purchase.convergenceZoneCount;
                } else if (purchase.convergenceZonesData && Array.isArray(purchase.convergenceZonesData)) {
                    convergenceZoneCount = purchase.convergenceZonesData.length;
                } else if (purchase.convergenceZones && Array.isArray(purchase.convergenceZones)) {
                    convergenceZoneCount = purchase.convergenceZones.length;
                }
                totalConvergenceZones += convergenceZoneCount;
                
                // Count ALL nodes including convergence nodes
                let nodeCount = 0;
                if (purchase.totalNodeCount !== undefined && purchase.totalNodeCount !== null) {
                    // Use stored total node count if available (includes convergence nodes)
                    nodeCount = purchase.totalNodeCount;
                } else if (purchase.nodesData && Array.isArray(purchase.nodesData)) {
                    // Count all nodes in nodesData (should include convergence nodes if marked)
                    nodeCount = purchase.nodesData.length;
                } else if (purchase.analyzedWords && Array.isArray(purchase.analyzedWords)) {
                    // Fallback: use analyzedWords count (but this doesn't include convergence nodes)
                    nodeCount = purchase.analyzedWords.length;
                }
                totalNodes += nodeCount;
            });
            
            // Calculate CONVERGENCE percentage
            // Average convergence zones per purchase
            const avgConvergenceZones = purchases.length > 0 ? totalConvergenceZones / purchases.length : 0;
            // Scale: 100 zones = 100%, so each zone = 1%
            const convergencePercentage = Math.min(100, avgConvergenceZones);
            
            // Calculate TRAFFIC percentage
            // Average nodes per purchase
            const avgNodes = purchases.length > 0 ? totalNodes / purchases.length : 0;
            // Scale: 1000 nodes = 100%, so each node = 0.1%
            const trafficPercentage = Math.min(100, (avgNodes / 1000) * 100);
            
            // Update stats display
            statsElement.innerHTML = `
                <div>CONVERGENCE: ${convergencePercentage.toFixed(1)}%</div>
                <div>TRAFFIC: ${trafficPercentage.toFixed(1)}%</div>
            `;
        }
        
        function updateLeaderboardInfoPanel(purchases) {
            const infoPanel = document.getElementById('leaderboard-info-panel');
            const contentElement = document.getElementById('leaderboard-info-panel-content');
            
            if (!infoPanel || !contentElement || !purchases || purchases.length === 0) {
                if (infoPanel) {
                    infoPanel.classList.remove('visible');
                }
                if (contentElement) {
                    contentElement.innerHTML = '';
                }
                return;
            }
            
            // Collect all top words from all purchases
            const allTopWords = new Map();
            const userCollectors = new Set();
            const purchaseDates = [];
            
            purchases.forEach(purchase => {
                // Collect top words
                if (purchase.topWords && Array.isArray(purchase.topWords)) {
                    purchase.topWords.forEach(wordInfo => {
                        const wordText = typeof wordInfo === 'string' ? wordInfo : (wordInfo.text || wordInfo.word || '');
                        const wordLower = wordText.toLowerCase().trim();
                        if (wordLower) {
                            const currentCount = allTopWords.get(wordLower) || 0;
                            allTopWords.set(wordLower, currentCount + 1);
                        }
                    });
                }
                
                // Collect user IDs
                if (purchase.userId) {
                    userCollectors.add(purchase.userId);
                }
                
                // Collect dates
                if (purchase.purchaseTime) {
                    purchaseDates.push({
                        date: purchase.purchaseTime,
                        userId: purchase.userId || 'Unknown',
                        value: purchase.totalValue || 0
                    });
                } else if (purchase.timestamp) {
                    purchaseDates.push({
                        date: new Date(purchase.timestamp).toLocaleString(),
                        userId: purchase.userId || 'Unknown',
                        value: purchase.totalValue || 0
                    });
                }
            });
            
            // Sort top words by frequency
            const sortedTopWords = Array.from(allTopWords.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 100); // Top 100 most frequent words
            
            // Sort dates by most recent first
            purchaseDates.sort((a, b) => {
                const dateA = new Date(a.date);
                const dateB = new Date(b.date);
                return dateB - dateA;
            });
            
            // Build HTML content with blocks like TOTAL VALUE
            const boxBg = "#000000";
            const boxBorder = "#ffffff";
            const textColor = "#ffffff";
            const borderColor = boxBorder;
            const dividerColor = "#333333";
            const boxStyle = `background: ${boxBg}; border: 1px solid ${boxBorder}; padding: 4px; margin-bottom: 3px; border-radius: 0;`;
            const itemStyle = "margin: 0.5px 0;";
            
            // Helper function to wrap numbers with white background
            const wrapNumber = (num) => `<span class="leaderboard-info-number">${num}</span>`;
            
            let html = '';
            
            // Top Words Section (as block)
            html += `<div style="${boxStyle}">`;
            html += `<h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">TOP WORDS</h3>`;
            if (sortedTopWords.length > 0) {
                sortedTopWords.forEach(([word, count], index) => {
                    html += `<div style="${itemStyle} color: ${textColor};"><strong>${wrapNumber(index + 1)}. ${word}:</strong> ${wrapNumber(count)} ${count === 1 ? 'purchase' : 'purchases'}</div>`;
                });
            } else {
                html += `<div style="${itemStyle} color: ${textColor};">No top words available</div>`;
            }
            html += '</div>';
            
            // Collectors Section (as block)
            html += `<div style="${boxStyle}">`;
            html += `<h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">COLLECTORS</h3>`;
            html += `<div style="${itemStyle} color: ${textColor};"><strong>Total Collectors:</strong> ${wrapNumber(userCollectors.size)}</div>`;
            const sortedCollectors = Array.from(userCollectors).sort();
            sortedCollectors.slice(0, 10).forEach((userId, index) => {
                html += `<div style="${itemStyle} color: ${textColor};"><strong>${wrapNumber(index + 1)}.</strong> ${userId}</div>`;
            });
            if (sortedCollectors.length > 10) {
                html += `<div style="${itemStyle} color: ${textColor};">... and ${wrapNumber(sortedCollectors.length - 10)} more</div>`;
            }
            html += '</div>';
            
            // Recent Purchases Section (as block)
            html += `<div style="${boxStyle}">`;
            html += `<h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">RECENT PURCHASES</h3>`;
            if (purchaseDates.length > 0) {
                purchaseDates.slice(0, 10).forEach((purchase, index) => {
                    const valueETH = ethPriceUSD && purchase.value ? (purchase.value / ethPriceUSD).toFixed(6) : '0.000000';
                    html += `<div style="${itemStyle} color: ${textColor}; padding: 2px 0; border-top: 1px solid ${dividerColor};"><strong>${wrapNumber(index + 1)}. ${purchase.date}</strong><br>`;
                    html += `<span style="font-size: 8px;">User: ${purchase.userId} | Value: <span class="leaderboard-info-number">${valueETH}</span> ETH</span></div>`;
                });
            } else {
                html += `<div style="${itemStyle} color: ${textColor};">No purchase dates available</div>`;
            }
            html += '</div>';
            
            // Statistics Section (as block)
            html += `<div style="${boxStyle}">`;
            html += `<h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">STATISTICS</h3>`;
            const totalPurchases = purchases.length;
            const totalValue = purchases.reduce((sum, p) => sum + (p.totalValue || 0), 0);
            const avgValue = totalPurchases > 0 ? totalValue / totalPurchases : 0;
            const totalValueETH = ethPriceUSD && totalValue ? (totalValue / ethPriceUSD).toFixed(6) : '0.000000';
            const avgValueETH = ethPriceUSD && avgValue ? (avgValue / ethPriceUSD).toFixed(6) : '0.000000';
            
            html += `<div style="${itemStyle} color: ${textColor};"><strong>Total Purchases:</strong> ${wrapNumber(totalPurchases)}</div>`;
            html += `<div style="${itemStyle} color: ${textColor};"><strong>Total Value:</strong> <span class="leaderboard-info-number">${totalValueETH}</span> ETH</div>`;
            html += `<div style="${itemStyle} color: ${textColor};"><strong>Average Value:</strong> <span class="leaderboard-info-number">${avgValueETH}</span> ETH</div>`;
            html += '</div>';
            
            contentElement.innerHTML = html;
        }
        
        function createLeaderboardRightPanelVisualization() {
            const canvas = document.getElementById('leaderboard-right-panel-canvas');
            const panel = document.getElementById('leaderboard-right-panel');
            if (!canvas || !panel) {
                console.warn('[Leaderboard Right Panel] Canvas or panel not found');
                return;
            }
            
            // Ensure panel is visible
            if (!panel.classList.contains('visible')) {
                console.warn('[Leaderboard Right Panel] Panel is not visible');
                return;
            }
            
            // Wait a bit for panel to be fully rendered
            setTimeout(() => {
                // Get dimensions - force a reflow to ensure accurate measurements
                panel.offsetHeight; // Force reflow
                const width = panel.offsetWidth || 400;
                const height = panel.offsetHeight || (window.innerHeight * 0.5); // 50vh
                
                if (width === 0 || height === 0) {
                    console.warn(`[Leaderboard Right Panel] Invalid dimensions: ${width}x${height}`);
                    return;
                }
                
                console.log(`[Leaderboard Right Panel] Creating visualization with dimensions: ${width}x${height}`);
                
                // Clean up previous visualization first
                if (leaderboardRightPanelAnimationId) {
                    cancelAnimationFrame(leaderboardRightPanelAnimationId);
                    leaderboardRightPanelAnimationId = null;
                }
                if (leaderboardRightPanelRenderer) {
                    try {
                        leaderboardRightPanelRenderer.dispose();
                    } catch (e) {
                        console.warn('[Leaderboard Right Panel] Error disposing renderer:', e);
                    }
                    leaderboardRightPanelRenderer = null;
                }
                if (leaderboardRightPanelScene) {
                    leaderboardRightPanelScene.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }
                // Clear sphere lines and crosses arrays
                leaderboardRightPanelSphereLines = [];
                leaderboardRightPanelSphereCrosses = [];
                
                // Set canvas size first
                canvas.width = width;
                canvas.height = height;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                
                // Clear any existing WebGL context from canvas
                try {
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl') || canvas.getContext('webgl2');
                    if (gl) {
                        const loseContext = gl.getExtension('WEBGL_lose_context');
                        if (loseContext) {
                            loseContext.loseContext();
                            console.log('[Leaderboard Right Panel] Cleared existing WebGL context');
                        }
                    }
                } catch (e) {
                    console.warn('[Leaderboard Right Panel] Error clearing WebGL context:', e);
                }
                
                // Create scene with black background
                leaderboardRightPanelScene = new THREE.Scene();
                leaderboardRightPanelScene.background = new THREE.Color(0x000000);
                
                // Create camera - position it closer to see the nodes better
                leaderboardRightPanelCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                leaderboardRightPanelCamera.position.set(3, 2, 3); // Adjusted position to see the scene better
                leaderboardRightPanelCamera.lookAt(0, 0, 0);
                console.log(`[Leaderboard Right Panel] Camera positioned at (${leaderboardRightPanelCamera.position.x}, ${leaderboardRightPanelCamera.position.y}, ${leaderboardRightPanelCamera.position.z})`);
                
                // Create renderer with black background - use the existing canvas
                try {
                    // Remove any existing context from canvas
                    const existingContext = canvas.getContext('webgl') || canvas.getContext('experimental-webgl') || canvas.getContext('webgl2');
                    if (existingContext) {
                        // Try to lose the context if possible
                        const loseContext = existingContext.getExtension('WEBGL_lose_context');
                        if (loseContext) {
                            loseContext.loseContext();
                        }
                    }
                    
                    // Create renderer with the canvas
                    leaderboardRightPanelRenderer = new THREE.WebGLRenderer({ 
                        canvas: canvas,
                        antialias: true,
                        alpha: false,
                        powerPreference: "low-power"
                    });
                    leaderboardRightPanelRenderer.setSize(width, height);
                    leaderboardRightPanelRenderer.setClearColor(0x000000, 1); // Black background
                    console.log('[Leaderboard Right Panel] Renderer created successfully');
                } catch (e) {
                    console.error('[Leaderboard Right Panel] Error creating renderer:', e);
                    // Try alternative: create renderer without canvas and insert it
                    try {
                        leaderboardRightPanelRenderer = new THREE.WebGLRenderer({ 
                            antialias: true,
                            alpha: false,
                            powerPreference: "low-power"
                        });
                        leaderboardRightPanelRenderer.setSize(width, height);
                        leaderboardRightPanelRenderer.setClearColor(0x000000, 1);
                        
                        // Insert renderer canvas into the grid container
                        const gridContainer = document.getElementById('leaderboard-right-panel-grid');
                        if (gridContainer) {
                            // Remove old canvas if it exists
                            const oldCanvas = gridContainer.querySelector('#leaderboard-right-panel-canvas');
                            if (oldCanvas) {
                                oldCanvas.remove();
                            }
                            // Add new canvas
                            const rendererCanvas = leaderboardRightPanelRenderer.domElement;
                            rendererCanvas.id = 'leaderboard-right-panel-canvas';
                            rendererCanvas.style.cssText = canvas.style.cssText;
                            gridContainer.appendChild(rendererCanvas);
                            console.log('[Leaderboard Right Panel] Renderer created with new canvas');
                        }
                    } catch (e2) {
                        console.error('[Leaderboard Right Panel] Failed to create renderer with alternative method:', e2);
                        return;
                    }
                }
                
                // Create reference sphere with lines and crosses (similar to main visualization)
                const sphereRadius = 1.8; // Adjusted for smaller panel
                leaderboardRightPanelSphereLines = [];
                leaderboardRightPanelSphereCrosses = [];
                
                // Create vertical line (meridian) - goes around the sphere vertically
                const verticalLineGeometry = new THREE.BufferGeometry();
                const verticalPoints = [];
                const verticalSegments = 128; // Reduced resolution for performance
                for (let i = 0; i <= verticalSegments; i++) {
                    const theta = (i / verticalSegments) * Math.PI * 2;
                    const x = sphereRadius * Math.cos(theta);
                    const z = sphereRadius * Math.sin(theta);
                    verticalPoints.push(new THREE.Vector3(x, 0, z));
                }
                verticalLineGeometry.setFromPoints(verticalPoints);
                const verticalLineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff, 
                    linewidth: 1,
                    depthTest: true,
                    depthWrite: false,
                    transparent: false
                });
                const verticalLine = new THREE.Line(verticalLineGeometry, verticalLineMaterial);
                verticalLine.renderOrder = -1;
                leaderboardRightPanelScene.add(verticalLine);
                leaderboardRightPanelSphereLines.push(verticalLine);
                
                // Create second vertical line (perpendicular to first)
                const verticalLine2Geometry = new THREE.BufferGeometry();
                const vertical2Points = [];
                for (let i = 0; i <= verticalSegments; i++) {
                    const theta = (i / verticalSegments) * Math.PI * 2;
                    const y = sphereRadius * Math.cos(theta);
                    const z = sphereRadius * Math.sin(theta);
                    vertical2Points.push(new THREE.Vector3(0, y, z));
                }
                verticalLine2Geometry.setFromPoints(vertical2Points);
                const verticalLine2 = new THREE.Line(verticalLine2Geometry, verticalLineMaterial);
                verticalLine2.renderOrder = -1;
                leaderboardRightPanelScene.add(verticalLine2);
                leaderboardRightPanelSphereLines.push(verticalLine2);
                
                // Create horizontal line (equator)
                const horizontalLineGeometry = new THREE.BufferGeometry();
                const horizontalPoints = [];
                for (let i = 0; i <= verticalSegments; i++) {
                    const theta = (i / verticalSegments) * Math.PI * 2;
                    const x = sphereRadius * Math.cos(theta);
                    const y = sphereRadius * Math.sin(theta);
                    horizontalPoints.push(new THREE.Vector3(x, y, 0));
                }
                horizontalLineGeometry.setFromPoints(horizontalPoints);
                const horizontalLine = new THREE.Line(horizontalLineGeometry, verticalLineMaterial);
                horizontalLine.renderOrder = -1;
                leaderboardRightPanelScene.add(horizontalLine);
                leaderboardRightPanelSphereLines.push(horizontalLine);
                
                // Create 8 simple X marks (equis) in the 8 octants
                const crossSize = 0.15;
                const octantPositions = [
                    { x: sphereRadius * 0.577, y: sphereRadius * 0.577, z: sphereRadius * 0.577 },
                    { x: -sphereRadius * 0.577, y: sphereRadius * 0.577, z: sphereRadius * 0.577 },
                    { x: -sphereRadius * 0.577, y: -sphereRadius * 0.577, z: sphereRadius * 0.577 },
                    { x: sphereRadius * 0.577, y: -sphereRadius * 0.577, z: sphereRadius * 0.577 },
                    { x: sphereRadius * 0.577, y: sphereRadius * 0.577, z: -sphereRadius * 0.577 },
                    { x: -sphereRadius * 0.577, y: sphereRadius * 0.577, z: -sphereRadius * 0.577 },
                    { x: -sphereRadius * 0.577, y: -sphereRadius * 0.577, z: -sphereRadius * 0.577 },
                    { x: sphereRadius * 0.577, y: -sphereRadius * 0.577, z: -sphereRadius * 0.577 }
                ];
                
                octantPositions.forEach(pos => {
                    const posVec = new THREE.Vector3(pos.x, pos.y, pos.z).normalize();
                    const centerPoint = posVec.clone().multiplyScalar(sphereRadius);
                    
                    // Create tangent vectors
                    let tangent1;
                    if (Math.abs(posVec.x) < 0.9) {
                        tangent1 = new THREE.Vector3(1, 0, 0).cross(posVec).normalize();
                    } else if (Math.abs(posVec.y) < 0.9) {
                        tangent1 = new THREE.Vector3(0, 1, 0).cross(posVec).normalize();
                    } else {
                        tangent1 = new THREE.Vector3(0, 0, 1).cross(posVec).normalize();
                    }
                    const tangent2 = posVec.clone().cross(tangent1).normalize();
                    
                    // Create diagonal directions for X
                    const diag1 = tangent1.clone().add(tangent2).normalize();
                    const diag2 = tangent1.clone().sub(tangent2).normalize();
                    
                    // Create X mark
                    const xGroup = new THREE.Group();
                    
                    const x1Start = centerPoint.clone().add(diag1.clone().multiplyScalar(-crossSize));
                    const x1End = centerPoint.clone().add(diag1.clone().multiplyScalar(crossSize));
                    const x1Geometry = new THREE.BufferGeometry().setFromPoints([x1Start, x1End]);
                    const x1Line = new THREE.Line(x1Geometry, verticalLineMaterial);
                    xGroup.add(x1Line);
                    
                    const x2Start = centerPoint.clone().add(diag2.clone().multiplyScalar(-crossSize));
                    const x2End = centerPoint.clone().add(diag2.clone().multiplyScalar(crossSize));
                    const x2Geometry = new THREE.BufferGeometry().setFromPoints([x2Start, x2End]);
                    const x2Line = new THREE.Line(x2Geometry, verticalLineMaterial);
                    xGroup.add(x2Line);
                    
                    leaderboardRightPanelScene.add(xGroup);
                    leaderboardRightPanelSphereCrosses.push(xGroup);
                });
                
                // Get all purchases and collect top valuable nodes
                const purchases = getGalleryPurchases();
                console.log(`[Leaderboard Right Panel] Processing ${purchases.length} purchases`);
                
                const allTopNodes = [];
                
                purchases.forEach(purchase => {
                    if (purchase.analyzedWords && Array.isArray(purchase.analyzedWords)) {
                        // Get top 10 most valuable words from this purchase
                        const sortedWords = [...purchase.analyzedWords]
                            .filter(w => w && w.text && (w.finalValue || w.totalScore || 0) > 0)
                            .sort((a, b) => (b.finalValue || b.totalScore || 0) - (a.finalValue || a.totalScore || 0))
                            .slice(0, 10);
                        
                        sortedWords.forEach(wordData => {
                            allTopNodes.push({
                                text: wordData.text,
                                value: wordData.finalValue || wordData.totalScore || 0,
                                isName: wordData.isName || false,
                                purchaseId: purchase.id
                            });
                        });
                    }
                });
                
                console.log(`[Leaderboard Right Panel] Collected ${allTopNodes.length} top nodes from all purchases`);
                
                // Group by word text and keep the highest value instance
                const nodeMap = new Map();
                allTopNodes.forEach(node => {
                    const key = node.text.toLowerCase().trim();
                    const existing = nodeMap.get(key);
                    if (!existing || node.value > existing.value) {
                        nodeMap.set(key, node);
                    }
                });
                
                // Sort by value and take top 30 (reduced for performance)
                let topNodes = Array.from(nodeMap.values())
                    .sort((a, b) => b.value - a.value)
                    .slice(0, 30);
                
                console.log(`[Leaderboard Right Panel] Creating visualization with ${topNodes.length} unique nodes`);
                
                // If no nodes, create some test nodes to verify visualization works
                if (topNodes.length === 0) {
                    console.warn('[Leaderboard Right Panel] No nodes found - creating test nodes');
                    topNodes = [
                        { text: 'Test1', value: 100, isName: false },
                        { text: 'Test2', value: 80, isName: true },
                        { text: 'Test3', value: 60, isName: false },
                        { text: 'Test4', value: 40, isName: true },
                        { text: 'Test5', value: 20, isName: false }
                    ];
                }
                
                // Create 3D nodes with organic distribution inside the sphere
                const nodeCount = topNodes.length;
                
                // Distribute nodes organically within the sphere (using Fibonacci sphere distribution)
                const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // Golden angle in radians
                
                // Calculate max value for normalization
                const maxValue = Math.max(...topNodes.map(n => n.value));
                
                topNodes.forEach((nodeData, index) => {
                        // Fibonacci sphere distribution for organic node placement
                        // Fix division by zero when nodeCount === 1
                        const y = nodeCount === 1 ? 0 : 1 - (index / (nodeCount - 1)) * 2; // y goes from 1 to -1
                        const radius = Math.sqrt(Math.max(0, 1 - y * y)); // radius at y, ensure non-negative
                        const theta = goldenAngle * index; // golden angle increment
                        const x = Math.cos(theta) * radius * sphereRadius * 0.8;
                        const z = Math.sin(theta) * radius * sphereRadius * 0.8;
                        const finalY = y * sphereRadius * 0.8;
                        
                        // Add some organic variation
                        const variation = (index % 7) / 7 * 0.2;
                        const x_final = x * (1 - variation);
                        const y_final = finalY * (1 + variation * 0.5);
                        const z_final = z * (1 - variation * 0.3);
                        
                        // Calculate node size based on value (normalized) - make them much smaller
                        const normalizedValue = maxValue > 0 ? nodeData.value / maxValue : 1;
                        const nodeSize = 0.02 + (normalizedValue * 0.04); // Much smaller: 0.02-0.06
                        
                        // Create sphere geometry with fewer segments for performance
                        const geometry = new THREE.SphereGeometry(nodeSize, 8, 8);
                        
                        // Get color using the same function as main visualization (getValueBasedColor)
                        // Create a wordData object compatible with getValueBasedColor
                        const wordData = {
                            text: nodeData.text,
                            finalValue: nodeData.value,
                            isName: nodeData.isName || false,
                            index: index
                        };
                        
                        // Use all topNodes as the allWords array for percentile calculation
                        const allWordsForColor = topNodes.map((n, idx) => ({
                            text: n.text,
                            finalValue: n.value,
                            isName: n.isName || false,
                            index: idx
                        }));
                        
                        const color = getValueBasedColor(wordData, index, allWordsForColor);
                        const material = new THREE.MeshBasicMaterial({ 
                            color: color,
                            transparent: true,
                            opacity: 0.9
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(x_final, y_final, z_final);
                        
                        // Store node data
                        mesh.userData = {
                            text: nodeData.text,
                            value: nodeData.value,
                            isName: nodeData.isName
                        };
                        
                        leaderboardRightPanelScene.add(mesh);
                        console.log(`[Leaderboard Right Panel] Added node: ${nodeData.text} at (${x_final.toFixed(2)}, ${y_final.toFixed(2)}, ${z_final.toFixed(2)}) size: ${nodeSize.toFixed(2)}`);
                });
                
                console.log(`[Leaderboard Right Panel] Scene now has ${leaderboardRightPanelScene.children.length} children`);
                
                // Calculate and display CONVERGENCE and TRAFFIC metrics
                updateLeaderboardRightPanelStats(purchases);
                updateLeaderboardInfoPanel(purchases);
                
                // Force initial render immediately
                if (leaderboardRightPanelScene && leaderboardRightPanelCamera && leaderboardRightPanelRenderer) {
                    leaderboardRightPanelRenderer.render(leaderboardRightPanelScene, leaderboardRightPanelCamera);
                    console.log('[Leaderboard Right Panel] Initial render completed');
                } else {
                    console.error('[Leaderboard Right Panel] Missing scene, camera, or renderer for initial render');
                }
                
                // Animate
                function animate() {
                    if (!leaderboardRightPanelScene || !leaderboardRightPanelCamera || !leaderboardRightPanelRenderer) {
                        console.error('[Leaderboard Right Panel] Animation stopped - missing scene, camera, or renderer');
                        return;
                    }
                    
                    // Rotate all nodes (only mesh nodes, not lines or crosses)
                    leaderboardRightPanelScene.children.forEach(child => {
                        if (child.isMesh && !leaderboardRightPanelSphereLines.includes(child) && !leaderboardRightPanelSphereCrosses.includes(child)) {
                            child.rotation.y += 0.01;
                            child.rotation.x += 0.005;
                        }
                    });
                    
                    // Rotate camera around the scene - slower rotation for better view
                    const time = Date.now() * 0.0003; // Slower rotation
                    const radius = 4; // Camera orbit radius
                    leaderboardRightPanelCamera.position.x = Math.cos(time) * radius;
                    leaderboardRightPanelCamera.position.y = Math.sin(time * 0.5) * 1.5; // Add vertical movement
                    leaderboardRightPanelCamera.position.z = Math.sin(time) * radius;
                    leaderboardRightPanelCamera.lookAt(0, 0, 0);
                    
                    leaderboardRightPanelRenderer.render(leaderboardRightPanelScene, leaderboardRightPanelCamera);
                    leaderboardRightPanelAnimationId = requestAnimationFrame(animate);
                }
                
                // Start animation
                animate();
                console.log('[Leaderboard Right Panel] Animation started');
            }, 100);
        }
        
        function updateMaxValuePanelWithPurchase(purchase) {
            // Update max-value-panel to show purchase preview (same as leaderboard items)
            const maxValuePanelWord = document.getElementById('max-value-panel-word');
            const maxValuePanelHashtag = document.getElementById('max-value-panel-hashtag');
            const maxValuePanelCanvas = document.getElementById('max-value-panel-canvas');
            const maxValuePanelInfo = document.getElementById('max-value-panel-info');
            
            if (!maxValuePanelWord || !maxValuePanelHashtag || !maxValuePanelCanvas || !maxValuePanelInfo) {
                return;
            }
            
            // Stop 3D animation and clear 3D scene
            if (maxValuePanelAnimationId) {
                cancelAnimationFrame(maxValuePanelAnimationId);
                maxValuePanelAnimationId = null;
            }
            
            // Remove 3D mesh from scene
            if (maxValuePanelMesh && maxValuePanelScene) {
                maxValuePanelScene.remove(maxValuePanelMesh);
                if (maxValuePanelMesh.geometry) maxValuePanelMesh.geometry.dispose();
                if (maxValuePanelMesh.material) maxValuePanelMesh.material.dispose();
                if (maxValuePanelMesh.children) {
                    maxValuePanelMesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
                maxValuePanelMesh = null;
            }
            
            // Hide WebGL canvas and show image element
            const maxValuePanelImage = document.getElementById('max-value-panel-image');
            if (maxValuePanelCanvas) {
                maxValuePanelCanvas.style.display = 'none';
            }
            if (maxValuePanelImage) {
                maxValuePanelImage.style.display = 'block';
            }
            
            // Get purchase ranking (index in sorted list)
            const purchases = getGalleryPurchases();
            purchases.sort((a, b) => (b.totalValue || 0) - (a.totalValue || 0));
            const ranking = purchases.findIndex(p => p.id === purchase.id) + 1;
            
            // Update header
            maxValuePanelHashtag.textContent = `#${ranking}`;
            maxValuePanelWord.textContent = 'PURCHASE PREVIEW';
            
            // Show purchase image using img element (same as leaderboard items)
            if (maxValuePanelImage) {
                if (purchase.nodeBodyImage && purchase.nodeBodyImage.length > 100) {
                    maxValuePanelImage.src = purchase.nodeBodyImage;
                    maxValuePanelImage.onerror = function() {
                        maxValuePanelImage.style.backgroundColor = '#000000';
                    };
                } else {
                    maxValuePanelImage.src = '';
                    maxValuePanelImage.style.backgroundColor = '#000000';
                }
            }
            
            // Format price
            const priceDisplay = purchase.priceETH >= 0.01 ? 
                `${purchase.priceETH.toFixed(6)} ETH` : 
                `${purchase.priceETH.toFixed(10)} ETH`;
            
            // Convert total value to ETH
            let totalValueETH = 0;
            if (ethPriceUSD && purchase.totalValue) {
                totalValueETH = purchase.totalValue / ethPriceUSD;
            }
            const totalValueDisplay = totalValueETH >= 0.01 ? 
                `${totalValueETH.toFixed(6)} ETH` : 
                `${totalValueETH.toFixed(10)} ETH`;
            
            // Format time
            const timeDisplay = purchase.purchaseTime || new Date(purchase.timestamp).toLocaleString();
            
            // Format top words (handle both old format strings and new format objects)
            const topWordsDisplay = purchase.topWords && purchase.topWords.length > 0 ? 
                purchase.topWords.map(w => typeof w === 'string' ? w : (w.text || '')).join(', ') : 'N/A';
            
            // Update info panel (same format as leaderboard items)
            maxValuePanelInfo.innerHTML = `
                <div style="margin-bottom: 3px;"><strong>USER:</strong> ${purchase.userId || 'N/A'}</div>
                <div style="margin-bottom: 3px;"><strong>PRICE:</strong> ${priceDisplay}</div>
                <div style="margin-bottom: 3px;"><strong>WEIGHT:</strong> ${purchase.weight || 0}</div>
                <div style="margin-bottom: 3px;"><strong>WORDS:</strong> ${purchase.wordCount || 0}</div>
                <div style="margin-bottom: 3px;"><strong>TIME:</strong> ${timeDisplay}</div>
                <div style="margin-bottom: 3px; color: #ffff00;"><strong>TOTAL VALUE:</strong> ${totalValueDisplay}</div>
                <div style="margin-top: 4px; padding-top: 3px; border-top: 1px solid #333333;"><strong>TOP WORDS:</strong> ${topWordsDisplay}</div>
            `;
        }

        // ==================== PURCHASE VISUALIZATION ====================
        // Variables for purchase visualization
        let purchaseVisRenderer = null;
        let purchaseVisRenderTarget = null; // Render target for using main renderer
        let purchaseVisScene = null;
        let purchaseVisCamera = null;
        let purchaseVisNodes = [];
        let purchaseVisConnections = [];
        let purchaseVisAnalyzedWords = [];
        let purchaseVisAnimationId = null;
        let purchaseVisRaycaster = null;
        let purchaseVisMouse = new THREE.Vector2();
        let purchaseVisIsDragging = false;
        let purchaseVisPreviousMousePosition = { x: 0, y: 0 };
        let purchaseVisBackgroundColorIndex = 0; // 0=AZUL, 1=NEGRO, 2=GRIS
        const purchaseVisBackgroundColors = [0x0000FF, 0x000000, 0x808080]; // AZUL, NEGRO, GRIS
        let purchaseVisNametagsVisible = false;
        let purchaseVisCurrentPurchase = null;
        let purchaseVisControls = null;

        async function openPurchaseVisualization(purchase) {
            // Set flag to indicate we're viewing a purchase
            isViewingPurchase = true;
            
            // Hide leaderboard container
            const leaderboardContainer = document.getElementById('node-list-container');
            if (leaderboardContainer) {
                leaderboardContainer.classList.remove('visible');
                galleryVisible = false;
            }
            
            // Hide leaderboard right panel using helper function
            closeLeaderboardRightPanel();
            
            // Clear the main scene first
            clearScene();
            
            // Load analyzed words
            if (purchase.analyzedWords && purchase.analyzedWords.length > 0) {
                analyzedWords = purchase.analyzedWords;
                console.log('Purchase visualization: Loaded analyzedWords', analyzedWords.length);
            }
            
            // Load text into textarea
            const textInput = document.getElementById('textInput');
            if (textInput && purchase.originalText) {
                textInput.value = purchase.originalText;
                // Make textarea readonly
                textInput.readOnly = true;
                textInput.style.backgroundColor = '#000000';
                textInput.style.color = '#ffffff';
            }
            
            // Load nodes and connections into main scene
            await loadPurchaseIntoMainScene(purchase);
            
            // Activate or update MAP TEXT mode automatically
            // Always update the mapped text, even if already visible
            if (!mappedTextVisible) {
                mapText();
            } else {
                // If already in Map Text mode, force update by temporarily disabling
                mappedTextVisible = false;
                mapText(); // This will regenerate the mapped text with new content
            }
            
            // Disable EXPORT BODY button
            const generateBtn = document.getElementById('generateBtn');
            if (generateBtn) {
                generateBtn.disabled = true;
                generateBtn.style.opacity = '0.5';
                generateBtn.style.cursor = 'not-allowed';
            }
            
            // Enable TOP NODES button when viewing a purchase
            const nodeListBtn = document.getElementById('nodeListBtn');
            if (nodeListBtn) {
                nodeListBtn.disabled = false;
                nodeListBtn.style.opacity = '1';
                nodeListBtn.style.cursor = 'pointer';
            }
            
            // Enable SHOW NAMETAGS button when viewing a purchase
            const toggleNametagsBtn = document.getElementById('toggleNametagsBtn');
            if (toggleNametagsBtn) {
                toggleNametagsBtn.disabled = false;
                toggleNametagsBtn.style.opacity = '1';
                toggleNametagsBtn.style.cursor = 'pointer';
            }
            
            // Enable Reset View button when viewing a purchase
            const resetCameraBtn = document.getElementById('resetCameraBtn');
            if (resetCameraBtn) {
                resetCameraBtn.disabled = false;
                resetCameraBtn.style.opacity = '1';
                resetCameraBtn.style.cursor = 'pointer';
            }
            
            // Change TOTAL VALUE button to "RETURN TO INPUT MODE"
            const totalValueBtn = document.getElementById('total-value-display');
            if (totalValueBtn) {
                // Store original text
                if (!totalValueBtn.dataset.originalText) {
                    totalValueBtn.dataset.originalText = totalValueBtn.innerHTML;
                }
                // Change text to "RETURN TO INPUT MODE"
                totalValueBtn.innerHTML = '<span style="font-size: 11px; font-weight: bold; font-family: Helvetica, Arial, sans-serif;">RETURN TO INPUT MODE</span>';
                totalValueBtn.style.pointerEvents = 'auto';
                totalValueBtn.style.opacity = '1';
                totalValueBtn.style.cursor = 'pointer';
            }
            
            // Store current purchase for resetCamera function
            window.currentPurchase = purchase;
            
            // Position camera to view all nodes
            positionCameraForPurchase(purchase);
        }
        
        function returnToInputMode() {
            // Restore normal mode
            isViewingPurchase = false;
            window.currentPurchase = null;
            
            // Clear the scene
            clearScene();
            
            // Restore textarea
            const textInput = document.getElementById('textInput');
            if (textInput) {
                textInput.readOnly = false;
                textInput.style.backgroundColor = '';
                textInput.style.color = '';
                textInput.value = '';
            }
            
            // Restore EXPORT BODY button (will be updated by updateButtonStates based on text)
            updateButtonStates();
            
            // Disable TOP NODES button when returning to input mode (if no nodes)
            const nodeListBtn = document.getElementById('nodeListBtn');
            if (nodeListBtn && (!nodes || nodes.length === 0)) {
                nodeListBtn.disabled = true;
                nodeListBtn.style.opacity = '0.4';
                nodeListBtn.style.cursor = 'not-allowed';
            }
            
            // Restore TOTAL VALUE button text
            const totalValueBtn = document.getElementById('total-value-display');
            if (totalValueBtn && totalValueBtn.dataset.originalText) {
                totalValueBtn.innerHTML = totalValueBtn.dataset.originalText;
                delete totalValueBtn.dataset.originalText;
            }
            
            // Reset mapped text view
            const mappedContainer = document.getElementById('mapped-text-container');
            if (mappedContainer) {
                mappedContainer.style.display = 'none';
            }
            if (textInput) {
                textInput.style.display = 'block';
            }
            mappedTextVisible = false;
            
            // Update button states after returning to input mode
            updateButtonStates();
            
            // Reset stats
            document.getElementById('valueScore').textContent = '0.00';
            document.getElementById('valueETH').textContent = '';
            
            // Clear analyzed words
            analyzedWords = [];
            
            // Hide any open panels
            hideNodeDetails();
            
            // Restore max-value-panel if gallery is visible
            if (galleryVisible) {
                const purchases = getGalleryPurchases();
                if (purchases.length > 0) {
                    purchases.sort((a, b) => (b.totalValue || 0) - (a.totalValue || 0));
                    updateMaxValuePanelWithPurchase(purchases[0]);
                }
            } else if (nodes.length > 0 && analyzedWords.length > 0) {
                // Restore to show top node if available
                updateMaxValuePanel();
            }
            
            // Reset camera to initial position (same as RESET VIEW)
            resetCamera();
        }
        
        async function loadPurchaseIntoMainScene(purchase) {
            if (!purchase.nodesData || purchase.nodesData.length === 0) {
                console.warn('Purchase visualization: No nodesData found');
                return;
            }
            
            console.log('Purchase visualization: Loading purchase into main scene', {
                nodesDataCount: purchase.nodesData.length,
                analyzedWordsCount: purchase.analyzedWords.length
            });
            
            // Load nodes
            loadPurchaseNodes(purchase);
            
            // Load connections
            loadPurchaseConnections(purchase);
            
            // Detect and create convergence zones (same as in generateVisualization)
            await detectAndCreateConvergenceZones();
        }
        
        function loadPurchaseNodes(purchase) {
            let createdCount = 0;
            let errorCount = 0;

            purchase.nodesData.forEach((nodeData, index) => {
                try {
                    if (!nodeData || nodeData.wordIndex < 0 || nodeData.wordIndex >= purchase.analyzedWords.length) {
                        if (index < 5) console.warn(`Purchase visualization: Skipping invalid nodeData at index ${index}`, nodeData);
                        return;
                    }
                    
                    const wordData = purchase.analyzedWords[nodeData.wordIndex];
                    if (!wordData) {
                        if (index < 5) console.warn(`Purchase visualization: No wordData found for index ${nodeData.wordIndex}`);
                        return;
                    }

                    // Initialize connection count (same as create3DNode)
                    wordData.connectionCount = 0;

                    // Create node using the same logic as create3DNode
                    const baseSize = 0.06;
                    const wordType = getWordTypeForShape(wordData, nodeData.wordIndex);
                    
                    // Get color based on value
                    const color = getValueBasedColor(wordData, nodeData.wordIndex, purchase.analyzedWords);
                    const colorHex = typeof color === 'number' ? color : (color && color.getHex ? color.getHex() : 0xffffff);
                    
                    // Determine opacity
                    let nodeOpacity = 0.92;
                    const semiTransparentTypes = ['proper_noun', 'object_pronoun', 'intensive_pronoun', 
                                                 'interrogative_pronoun', 'superlative_adjective', 'modal_verb',
                                                 'concrete_noun', 'gerundial_noun', 'interrogative_determiner'];
                    if (semiTransparentTypes.includes(wordType)) {
                        nodeOpacity = 0.80;
                    }

                    // Create geometry
                    const geometryGroup = createWordTypeGeometry(wordType, baseSize, colorHex, nodeOpacity);
                    
                    if (!geometryGroup) {
                        console.error(`Purchase visualization: Failed to create geometry for node ${index}`);
                        errorCount++;
                        return;
                    }
                    
                    // Enable shadows
                    geometryGroup.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    // Calculate sphere size
                    const wordValue = wordData.finalValue || wordData.totalScore || 0;
                    const allValues = purchase.analyzedWords.map(w => w.finalValue || w.totalScore || 0).filter(v => v > 0);
                    let sphereSizeMultiplier = 2.25;
                    
                    if (allValues.length > 0) {
                        const minValue = Math.min(...allValues);
                        const maxValue = Math.max(...allValues);
                        if (maxValue > minValue && wordValue > 0) {
                            const normalizedValue = (wordValue - minValue) / (maxValue - minValue);
                            if (normalizedValue <= 0.5) {
                                sphereSizeMultiplier = 2.25 + (normalizedValue * 0.75);
                            } else {
                                const upperNormalized = (normalizedValue - 0.5) / 0.5;
                                const exponentialValue = Math.pow(upperNormalized, 1.5);
                                sphereSizeMultiplier = 3.0 + (exponentialValue * 7.5);
                            }
                            sphereSizeMultiplier = Math.min(sphereSizeMultiplier, 10.5);
                        }
                    }

                    const sphereSize = baseSize * sphereSizeMultiplier;
                    
                    // Create sphere
                    const sphereGeometry = new THREE.SphereGeometry(sphereSize, 16, 16);
                    const sphereMaterial = new THREE.MeshStandardMaterial({
                        color: 0x808080,
                        transparent: true,
                        opacity: 0.21,
                        metalness: 0.1,
                        roughness: 0.8,
                        side: THREE.DoubleSide
                    });
                    const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphereMesh.raycast = function() { return []; };
                    geometryGroup.add(sphereMesh);

                    // Position node - ensure position exists
                    if (nodeData.position && typeof nodeData.position.x === 'number') {
                        geometryGroup.position.set(nodeData.position.x, nodeData.position.y, nodeData.position.z);
                    } else {
                        console.warn(`Purchase visualization: Invalid position for node ${index}`, nodeData.position);
                        geometryGroup.position.set(0, 0, 0);
                    }

                    // Store user data
                    geometryGroup.userData = {
                        wordData: wordData,
                        index: nodeData.wordIndex,
                        connectionCount: 0,
                        isGroup: true,
                        wordType: wordType,
                        sphereSize: sphereSize,
                        sphereMesh: sphereMesh
                    };

                    scene.add(geometryGroup);
                    nodes.push(geometryGroup);
                    createdCount++;
                } catch (error) {
                    console.error(`Purchase visualization: Error creating node ${index}:`, error);
                    errorCount++;
                }
            });

            console.log('Purchase visualization: Nodes loaded into main scene', {
                created: createdCount,
                errors: errorCount,
                total: nodes.length
            });
        }
        
        function loadPurchaseConnections(purchase) {
            // If no connectionsData, try to recreate connections based on node positions and text structure
            if (!purchase.connectionsData || purchase.connectionsData.length === 0) {
                console.log('Purchase visualization: No connectionsData found, attempting to recreate connections from node structure');
                recreateConnectionsFromNodesForMainScene(purchase);
                return;
            }
            
            if (nodes.length === 0) {
                console.warn('Purchase visualization: No nodes available to create connections');
                return;
            }

            let createdCount = 0;
            let errorCount = 0;

            purchase.connectionsData.forEach((connData, index) => {
                try {
                    if (!connData) {
                        errorCount++;
                        return;
                    }
                    
                    // Try to find nodes by wordIndex first (more reliable)
                    let startNode = null;
                    let endNode = null;
                    
                    if (connData.fromWordIndex !== undefined && connData.toWordIndex !== undefined) {
                        // Use wordIndex to find nodes (more reliable than array index)
                        startNode = nodes.find(n => n && n.userData && n.userData.index === connData.fromWordIndex);
                        endNode = nodes.find(n => n && n.userData && n.userData.index === connData.toWordIndex);
                    }
                    
                    // Fallback to array index if wordIndex lookup failed
                    if (!startNode || !endNode) {
                        if (connData.startIndex >= 0 && connData.startIndex < nodes.length &&
                            connData.endIndex >= 0 && connData.endIndex < nodes.length) {
                            startNode = nodes[connData.startIndex];
                            endNode = nodes[connData.endIndex];
                        }
                    }
                    
                    if (!startNode || !endNode) {
                        if (index < 10) {
                            console.warn(`Purchase visualization: Could not find nodes for connection ${index}`, {
                                startIndex: connData.startIndex,
                                endIndex: connData.endIndex,
                                fromWordIndex: connData.fromWordIndex,
                                toWordIndex: connData.toWordIndex,
                                nodesLength: nodes.length
                            });
                        }
                        errorCount++;
                        return;
                    }
                    
                    // Verify nodes have matching wordIndex if available
                    if (connData.fromWordIndex !== undefined && startNode.userData?.index !== connData.fromWordIndex) {
                        if (index < 5) {
                            console.warn(`Purchase visualization: Node wordIndex mismatch for start node`, {
                                expected: connData.fromWordIndex,
                                actual: startNode.userData?.index
                            });
                        }
                    }
                    if (connData.toWordIndex !== undefined && endNode.userData?.index !== connData.toWordIndex) {
                        if (index < 5) {
                            console.warn(`Purchase visualization: Node wordIndex mismatch for end node`, {
                                expected: connData.toWordIndex,
                                actual: endNode.userData?.index
                            });
                        }
                    }

                    // Get positions - handle groups and get world position
                    let startPos, endPos;
                    
                    // For groups, get the main node position or group position
                    if (startNode.isGroup) {
                        if (startNode.userData?.mainNode) {
                            startPos = startNode.userData.mainNode.position.clone();
                        } else {
                            startPos = startNode.position.clone();
                        }
                        // Apply group transform
                        startPos.applyMatrix4(startNode.matrixWorld);
                    } else {
                        startPos = startNode.position.clone();
                        if (startNode.parent && startNode.parent.isGroup) {
                            startPos.applyMatrix4(startNode.parent.matrixWorld);
                        }
                    }
                    
                    if (endNode.isGroup) {
                        if (endNode.userData?.mainNode) {
                            endPos = endNode.userData.mainNode.position.clone();
                        } else {
                            endPos = endNode.position.clone();
                        }
                        // Apply group transform
                        endPos.applyMatrix4(endNode.matrixWorld);
                    } else {
                        endPos = endNode.position.clone();
                        if (endNode.parent && endNode.parent.isGroup) {
                            endPos.applyMatrix4(endNode.parent.matrixWorld);
                        }
                    }

                    // Create connection line using the same logic as createConnection
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(startPos.x, startPos.y, startPos.z),
                        new THREE.Vector3(endPos.x, endPos.y, endPos.z)
                    ]);
                    
                    // Get word data and colors (same logic as createConnection)
                    const fromWordData = startNode.userData?.wordData;
                    const toWordData = endNode.userData?.wordData;
                    const fromIndex = startNode.userData?.index !== undefined ? startNode.userData.index : 0;
                    const toIndex = endNode.userData?.index !== undefined ? endNode.userData.index : 0;
                    
                    // Get colors from nodes
                    const fromColor = fromWordData ? getValueBasedColor(fromWordData, fromIndex, analyzedWords) : 0x808080;
                    const toColor = toWordData ? getValueBasedColor(toWordData, toIndex, analyzedWords) : 0x808080;
                    
                    // Check if both nodes are yellow (0xffff00) or white (0xffffff)
                    const yellowColor = 0xffff00;
                    const whiteColor = 0xffffff;
                    const bothAreYellow = (fromColor === yellowColor && toColor === yellowColor);
                    const bothAreWhite = (fromColor === whiteColor && toColor === whiteColor);
                    
                    // Get values to determine which node has higher value
                    const fromValue = fromWordData && fromWordData.finalValue !== undefined 
                        ? fromWordData.finalValue 
                        : (fromWordData && fromWordData.normalizedScore !== undefined ? fromWordData.normalizedScore : 0);
                    const toValue = toWordData && toWordData.finalValue !== undefined 
                        ? toWordData.finalValue 
                        : (toWordData && toWordData.normalizedScore !== undefined ? toWordData.normalizedScore : 0);
                    
                    let connectionColor;
                    
                    // If both nodes are white, use brighter white for the connection line
                    if (bothAreWhite) {
                        connectionColor = 0xffffff; // Bright white for connections between white nodes
                    } else if (bothAreYellow) {
                        connectionColor = 0xffffff; // White for connections between yellow nodes
                    } else {
                        // Determine which node has higher value (predominates)
                        const higherValue = Math.max(fromValue, toValue);
                        const lowerValue = Math.min(fromValue, toValue);
                        const higherValueColor = fromValue >= toValue ? fromColor : toColor;
                        const lowerValueColor = fromValue >= toValue ? toColor : fromColor;
                        
                        // Mix colors: 70% from higher value node, 30% from lower value node
                        const mixRatio = 0.7;
                        
                        // Convert hex colors to RGB
                        const getRGB = (hex) => {
                            return {
                                r: (hex >> 16) & 0xFF,
                                g: (hex >> 8) & 0xFF,
                                b: hex & 0xFF
                            };
                        };
                        
                        const higherRGB = getRGB(higherValueColor);
                        const lowerRGB = getRGB(lowerValueColor);
                        
                        // Mix colors
                        let mixedR = Math.round(higherRGB.r * mixRatio + lowerRGB.r * (1 - mixRatio));
                        let mixedG = Math.round(higherRGB.g * mixRatio + lowerRGB.g * (1 - mixRatio));
                        let mixedB = Math.round(higherRGB.b * mixRatio + lowerRGB.b * (1 - mixRatio));
                        
                        // Increase brightness for better visibility against blue background
                        const brightnessBoost = 1.3;
                        mixedR = Math.min(255, Math.round(mixedR * brightnessBoost));
                        mixedG = Math.min(255, Math.round(mixedG * brightnessBoost));
                        mixedB = Math.min(255, Math.round(mixedB * brightnessBoost));
                        
                        // Convert back to hex
                        connectionColor = (mixedR << 16) | (mixedG << 8) | mixedB;
                    }
                    
                    // Calculate opacity based on average value (same logic as createConnection)
                    const avgValue = (fromValue + toValue) / 2;
                    const normalizedAvg = Math.min(1.0, Math.max(0.0, avgValue));
                    
                    let lineOpacity;
                    if (bothAreWhite) {
                        lineOpacity = 0.85 + (normalizedAvg * 0.1); // 0.85-0.95 for white connections
                    } else {
                        lineOpacity = 0.6 + (normalizedAvg * 0.15); // 0.6-0.75 for other connections
                    }
                    
                    const material = new THREE.LineBasicMaterial({
                        color: connectionColor,
                        transparent: true,
                        opacity: lineOpacity
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.userData = {
                        fromNode: startNode,
                        toNode: endNode,
                        startNode: startNode,
                        endNode: endNode
                    };
                    
                    // Update connection counts (handle both regular nodes and noun groups)
                    // Same logic as createConnection
                    if (startNode.userData) {
                        startNode.userData.connectionCount = (startNode.userData.connectionCount || 0) + 1;
                        if (startNode.userData.wordData) {
                            startNode.userData.wordData.connectionCount = (startNode.userData.wordData.connectionCount || 0) + 1;
                        }
                    }
                    if (endNode.userData) {
                        endNode.userData.connectionCount = (endNode.userData.connectionCount || 0) + 1;
                        if (endNode.userData.wordData) {
                            endNode.userData.wordData.connectionCount = (endNode.userData.wordData.connectionCount || 0) + 1;
                        }
                    }
                    
                    scene.add(line);
                    connections.push(line);
                    createdCount++;
                } catch (error) {
                    console.error(`Purchase visualization: Error creating connection ${index}:`, error);
                    errorCount++;
                }
            });

            console.log('Purchase visualization: Connections loaded into main scene', {
                created: createdCount,
                errors: errorCount,
                total: connections.length,
                expected: purchase.connectionsData.length,
                nodesCount: nodes.length
            });
            
            // Verify connection counts match
            if (createdCount !== purchase.connectionsData.length) {
                console.warn(`Warning: Expected ${purchase.connectionsData.length} connections but created ${createdCount}`);
            }
        }
        
        function recreateConnectionsFromNodesForMainScene(purchase) {
            if (nodes.length < 2) {
                console.log('Purchase visualization: Not enough nodes to create connections');
                return;
            }

            let createdCount = 0;
            
            // Create connections based on text order and proximity
            // Connect each node to the next node in the text
            for (let i = 0; i < nodes.length - 1; i++) {
                const currentNode = nodes[i];
                const nextNode = nodes[i + 1];
                
                if (!currentNode || !nextNode || !currentNode.userData || !nextNode.userData) {
                    continue;
                }
                
                // Get positions
                let startPos, endPos;
                
                if (currentNode.isGroup && currentNode.userData?.mainNode) {
                    startPos = currentNode.userData.mainNode.position.clone();
                    startPos.applyMatrix4(currentNode.matrixWorld);
                } else {
                    startPos = currentNode.position.clone();
                    if (currentNode.parent && currentNode.parent.isGroup) {
                        startPos.applyMatrix4(currentNode.parent.matrixWorld);
                    }
                }
                
                if (nextNode.isGroup && nextNode.userData?.mainNode) {
                    endPos = nextNode.userData.mainNode.position.clone();
                    endPos.applyMatrix4(nextNode.matrixWorld);
                } else {
                    endPos = nextNode.position.clone();
                    if (nextNode.parent && nextNode.parent.isGroup) {
                        endPos.applyMatrix4(nextNode.parent.matrixWorld);
                    }
                }
                
                // Create connection line using the same logic as createConnection
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(startPos.x, startPos.y, startPos.z),
                    new THREE.Vector3(endPos.x, endPos.y, endPos.z)
                ]);
                
                // Get word data and colors (same logic as createConnection)
                const fromWordData = currentNode.userData?.wordData;
                const toWordData = nextNode.userData?.wordData;
                const fromIndex = currentNode.userData?.index !== undefined ? currentNode.userData.index : 0;
                const toIndex = nextNode.userData?.index !== undefined ? nextNode.userData.index : 0;
                
                // Get colors from nodes
                const fromColor = fromWordData ? getValueBasedColor(fromWordData, fromIndex, analyzedWords) : 0x808080;
                const toColor = toWordData ? getValueBasedColor(toWordData, toIndex, analyzedWords) : 0x808080;
                
                // Check if both nodes are yellow (0xffff00) or white (0xffffff)
                const yellowColor = 0xffff00;
                const whiteColor = 0xffffff;
                const bothAreYellow = (fromColor === yellowColor && toColor === yellowColor);
                const bothAreWhite = (fromColor === whiteColor && toColor === whiteColor);
                
                // Get values to determine which node has higher value
                const fromValue = fromWordData && fromWordData.finalValue !== undefined 
                    ? fromWordData.finalValue 
                    : (fromWordData && fromWordData.normalizedScore !== undefined ? fromWordData.normalizedScore : 0);
                const toValue = toWordData && toWordData.finalValue !== undefined 
                    ? toWordData.finalValue 
                    : (toWordData && toWordData.normalizedScore !== undefined ? toWordData.normalizedScore : 0);
                
                let connectionColor;
                
                // If both nodes are white, use brighter white for the connection line
                if (bothAreWhite) {
                    connectionColor = 0xffffff; // Bright white for connections between white nodes
                } else if (bothAreYellow) {
                    connectionColor = 0xffffff; // White for connections between yellow nodes
                } else {
                    // Determine which node has higher value (predominates)
                    const higherValue = Math.max(fromValue, toValue);
                    const lowerValue = Math.min(fromValue, toValue);
                    const higherValueColor = fromValue >= toValue ? fromColor : toColor;
                    const lowerValueColor = fromValue >= toValue ? toColor : fromColor;
                    
                    // Mix colors: 70% from higher value node, 30% from lower value node
                    const mixRatio = 0.7;
                    
                    // Convert hex colors to RGB
                    const getRGB = (hex) => {
                        return {
                            r: (hex >> 16) & 0xFF,
                            g: (hex >> 8) & 0xFF,
                            b: hex & 0xFF
                        };
                    };
                    
                    const higherRGB = getRGB(higherValueColor);
                    const lowerRGB = getRGB(lowerValueColor);
                    
                    // Mix colors
                    let mixedR = Math.round(higherRGB.r * mixRatio + lowerRGB.r * (1 - mixRatio));
                    let mixedG = Math.round(higherRGB.g * mixRatio + lowerRGB.g * (1 - mixRatio));
                    let mixedB = Math.round(higherRGB.b * mixRatio + lowerRGB.b * (1 - mixRatio));
                    
                    // Increase brightness for better visibility against blue background
                    const brightnessBoost = 1.3;
                    mixedR = Math.min(255, Math.round(mixedR * brightnessBoost));
                    mixedG = Math.min(255, Math.round(mixedG * brightnessBoost));
                    mixedB = Math.min(255, Math.round(mixedB * brightnessBoost));
                    
                    // Convert back to hex
                    connectionColor = (mixedR << 16) | (mixedG << 8) | mixedB;
                }
                
                // Calculate opacity based on average value (same logic as createConnection)
                const avgValue = (fromValue + toValue) / 2;
                const normalizedAvg = Math.min(1.0, Math.max(0.0, avgValue));
                
                let lineOpacity;
                if (bothAreWhite) {
                    lineOpacity = 0.85 + (normalizedAvg * 0.1); // 0.85-0.95 for white connections
                } else {
                    lineOpacity = 0.6 + (normalizedAvg * 0.15); // 0.6-0.75 for other connections
                }
                
                const material = new THREE.LineBasicMaterial({
                    color: connectionColor,
                    transparent: true,
                    opacity: lineOpacity
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = {
                    fromNode: currentNode,
                    toNode: nextNode,
                    startNode: currentNode,
                    endNode: nextNode
                };
                
                // Update connection counts (handle both regular nodes and noun groups)
                // Same logic as createConnection
                if (currentNode.userData) {
                    currentNode.userData.connectionCount = (currentNode.userData.connectionCount || 0) + 1;
                    if (currentNode.userData.wordData) {
                        currentNode.userData.wordData.connectionCount = (currentNode.userData.wordData.connectionCount || 0) + 1;
                    }
                }
                if (nextNode.userData) {
                    nextNode.userData.connectionCount = (nextNode.userData.connectionCount || 0) + 1;
                    if (nextNode.userData.wordData) {
                        nextNode.userData.wordData.connectionCount = (nextNode.userData.wordData.connectionCount || 0) + 1;
                    }
                }
                
                scene.add(line);
                connections.push(line);
                createdCount++;
            }
            
            // Also connect nodes that are close in 3D space (within a threshold)
            const connectionThreshold = 2.0; // Distance threshold for connections
            for (let i = 0; i < nodes.length; i++) {
                const node1 = nodes[i];
                if (!node1 || !node1.userData) continue;
                
                let pos1;
                if (node1.isGroup && node1.userData?.mainNode) {
                    pos1 = node1.userData.mainNode.position.clone();
                    pos1.applyMatrix4(node1.matrixWorld);
                } else {
                    pos1 = node1.position.clone();
                    if (node1.parent && node1.parent.isGroup) {
                        pos1.applyMatrix4(node1.parent.matrixWorld);
                    }
                }
                
                for (let j = i + 2; j < nodes.length; j++) {
                    const node2 = nodes[j];
                    if (!node2 || !node2.userData) continue;
                    
                    let pos2;
                    if (node2.isGroup && node2.userData?.mainNode) {
                        pos2 = node2.userData.mainNode.position.clone();
                        pos2.applyMatrix4(node2.matrixWorld);
                    } else {
                        pos2 = node2.position.clone();
                        if (node2.parent && node2.parent.isGroup) {
                            pos2.applyMatrix4(node2.parent.matrixWorld);
                        }
                    }
                    
                    const distance = pos1.distanceTo(pos2);
                    if (distance < connectionThreshold) {
                        // Check if connection already exists
                        const exists = connections.some(conn => {
                            if (!conn || !conn.userData) return false;
                            const connFrom = conn.userData.fromNode || conn.userData.startNode;
                            const connTo = conn.userData.toNode || conn.userData.endNode;
                            return (connFrom === node1 && connTo === node2) || 
                                   (connFrom === node2 && connTo === node1);
                        });
                        
                        if (!exists) {
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(pos1.x, pos1.y, pos1.z),
                                new THREE.Vector3(pos2.x, pos2.y, pos2.z)
                            ]);
                            
                            // Get word data and colors (same logic as createConnection)
                            const fromWordData = node1.userData?.wordData;
                            const toWordData = node2.userData?.wordData;
                            const fromIndex = node1.userData?.index !== undefined ? node1.userData.index : 0;
                            const toIndex = node2.userData?.index !== undefined ? node2.userData.index : 0;
                            
                            // Get colors from nodes
                            const fromColor = fromWordData ? getValueBasedColor(fromWordData, fromIndex, analyzedWords) : 0x808080;
                            const toColor = toWordData ? getValueBasedColor(toWordData, toIndex, analyzedWords) : 0x808080;
                            
                            // Check if both nodes are yellow (0xffff00) or white (0xffffff)
                            const yellowColor = 0xffff00;
                            const whiteColor = 0xffffff;
                            const bothAreYellow = (fromColor === yellowColor && toColor === yellowColor);
                            const bothAreWhite = (fromColor === whiteColor && toColor === whiteColor);
                            
                            // Get values to determine which node has higher value
                            const fromValue = fromWordData && fromWordData.finalValue !== undefined 
                                ? fromWordData.finalValue 
                                : (fromWordData && fromWordData.normalizedScore !== undefined ? fromWordData.normalizedScore : 0);
                            const toValue = toWordData && toWordData.finalValue !== undefined 
                                ? toWordData.finalValue 
                                : (toWordData && toWordData.normalizedScore !== undefined ? toWordData.normalizedScore : 0);
                            
                            let connectionColor;
                            
                            // If both nodes are white, use brighter white for the connection line
                            if (bothAreWhite) {
                                connectionColor = 0xffffff; // Bright white for connections between white nodes
                            } else if (bothAreYellow) {
                                connectionColor = 0xffffff; // White for connections between yellow nodes
                            } else {
                                // Determine which node has higher value (predominates)
                                const higherValue = Math.max(fromValue, toValue);
                                const lowerValue = Math.min(fromValue, toValue);
                                const higherValueColor = fromValue >= toValue ? fromColor : toColor;
                                const lowerValueColor = fromValue >= toValue ? toColor : fromColor;
                                
                                // Mix colors: 70% from higher value node, 30% from lower value node
                                const mixRatio = 0.7;
                                
                                // Convert hex colors to RGB
                                const getRGB = (hex) => {
                                    return {
                                        r: (hex >> 16) & 0xFF,
                                        g: (hex >> 8) & 0xFF,
                                        b: hex & 0xFF
                                    };
                                };
                                
                                const higherRGB = getRGB(higherValueColor);
                                const lowerRGB = getRGB(lowerValueColor);
                                
                                // Mix colors
                                let mixedR = Math.round(higherRGB.r * mixRatio + lowerRGB.r * (1 - mixRatio));
                                let mixedG = Math.round(higherRGB.g * mixRatio + lowerRGB.g * (1 - mixRatio));
                                let mixedB = Math.round(higherRGB.b * mixRatio + lowerRGB.b * (1 - mixRatio));
                                
                                // Increase brightness for better visibility against blue background
                                const brightnessBoost = 1.3;
                                mixedR = Math.min(255, Math.round(mixedR * brightnessBoost));
                                mixedG = Math.min(255, Math.round(mixedG * brightnessBoost));
                                mixedB = Math.min(255, Math.round(mixedB * brightnessBoost));
                                
                                // Convert back to hex
                                connectionColor = (mixedR << 16) | (mixedG << 8) | mixedB;
                            }
                            
                            // Calculate opacity based on average value (same logic as createConnection)
                            const avgValue = (fromValue + toValue) / 2;
                            const normalizedAvg = Math.min(1.0, Math.max(0.0, avgValue));
                            
                            let lineOpacity;
                            if (bothAreWhite) {
                                lineOpacity = 0.85 + (normalizedAvg * 0.1); // 0.85-0.95 for white connections
                            } else {
                                lineOpacity = 0.6 + (normalizedAvg * 0.15); // 0.6-0.75 for other connections
                            }
                            
                            const material = new THREE.LineBasicMaterial({
                                color: connectionColor,
                                transparent: true,
                                opacity: lineOpacity
                            });
                            
                            const line = new THREE.Line(geometry, material);
                            line.userData = {
                                fromNode: node1,
                                toNode: node2,
                                startNode: node1,
                                endNode: node2
                            };
                            
                            // Update connection counts (handle both regular nodes and noun groups)
                            // Same logic as createConnection
                            if (node1.userData) {
                                node1.userData.connectionCount = (node1.userData.connectionCount || 0) + 1;
                                if (node1.userData.wordData) {
                                    node1.userData.wordData.connectionCount = (node1.userData.wordData.connectionCount || 0) + 1;
                                }
                            }
                            if (node2.userData) {
                                node2.userData.connectionCount = (node2.userData.connectionCount || 0) + 1;
                                if (node2.userData.wordData) {
                                    node2.userData.wordData.connectionCount = (node2.userData.wordData.connectionCount || 0) + 1;
                                }
                            }
                            
                            scene.add(line);
                            connections.push(line);
                            createdCount++;
                        }
                    }
                }
            }
            
            console.log('Purchase visualization: Recreated connections from node structure in main scene', {
                created: createdCount,
                total: connections.length
            });
        }
        
        function positionCameraForPurchase(purchase) {
            if (!nodes || nodes.length === 0) return;
            
            // Calculate bounding box of all nodes
            const box = new THREE.Box3();
            nodes.forEach(node => {
                if (node.isGroup) {
                    node.traverse((child) => {
                        if (child.isMesh) {
                            box.expandByObject(child);
                        }
                    });
                } else {
                    box.expandByObject(node);
                }
            });
            
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 2.5;
            
            // Position camera to view all nodes
            camera.position.set(
                center.x + distance * 0.7,
                center.y + distance * 0.5,
                center.z + distance * 0.7
            );
            camera.lookAt(center);
            camera.updateProjectionMatrix();
        }

        function displayPurchaseMappedText(purchase) {
            const textContainer = document.getElementById('purchase-vis-mapped-text');
            if (!textContainer || !purchase.originalText) return;

            // If we have analyzedWords data, use it to create colored map text
            if (purchase.analyzedWords && purchase.analyzedWords.length > 0) {
                purchaseVisAnalyzedWords = purchase.analyzedWords;
                const text = purchase.originalText;
                const words = splitTextIntoWords(text);
                let mappedHTML = '';
                let currentTextIndex = 0;
                let lastBgColor = '#000000';
                let lastTextColor = '#ffffff';

                words.forEach((word, wordIndex) => {
                    const wordStart = text.indexOf(word, currentTextIndex);
                    const wordKey = word.toLowerCase();
                    
                    // Find matching analyzed word
                    let wordData = null;
                    let analyzedWordIndex = -1;
                    for (let i = 0; i < purchase.analyzedWords.length; i++) {
                        if (purchase.analyzedWords[i].text.toLowerCase() === wordKey) {
                            wordData = purchase.analyzedWords[i];
                            analyzedWordIndex = i;
                            break;
                        }
                    }

                    let bgColor, textColor;
                    if (wordData && analyzedWordIndex >= 0) {
                        // Use the exact same color logic as mapText and nodes
                        const color = getValueBasedColor(wordData, analyzedWordIndex, purchase.analyzedWords);
                        // Convert hex color number to hex string for CSS (to match node colors exactly)
                        const colorNum = typeof color === 'number' ? color : parseInt(color, 16);
                        const r = (colorNum >> 16) & 0xFF;
                        const g = (colorNum >> 8) & 0xFF;
                        const b = colorNum & 0xFF;
                        // Convert to hex string with proper padding
                        bgColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                        // Determine text color based on background brightness
                        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                        textColor = brightness > 128 ? '#000000' : '#ffffff';
                    } else {
                        bgColor = lastBgColor;
                        textColor = lastTextColor;
                    }

                    // Add text before word
                    if (wordStart > currentTextIndex) {
                        const beforeWord = text.substring(currentTextIndex, wordStart);
                        const escapedBefore = beforeWord.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        mappedHTML += `<span style="background-color: ${lastBgColor}; color: ${lastTextColor}; padding: 0; margin: 0; display: inline;">${escapedBefore}</span>`;
                    }

                    // Add word
                    const escapedWord = word.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    mappedHTML += `<span style="background-color: ${bgColor}; color: ${textColor}; padding: 0; margin: 0; display: inline;">${escapedWord}</span>`;

                    lastBgColor = bgColor;
                    lastTextColor = textColor;
                    currentTextIndex = wordStart + word.length;
                });

                // Add remaining text
                if (currentTextIndex < text.length) {
                    const remaining = text.substring(currentTextIndex);
                    const escapedRemaining = remaining.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    mappedHTML += `<span style="background-color: ${lastBgColor}; color: ${lastTextColor}; padding: 0; margin: 0; display: inline;">${escapedRemaining}</span>`;
                }

                textContainer.innerHTML = mappedHTML;
            } else {
                // Fallback: just show text
                textContainer.textContent = purchase.originalText;
            }
        }

        function initPurchaseVisualization3D(purchase) {
            const container = document.getElementById('purchase-vis-canvas-container');
            if (!container) {
                console.error('Purchase visualization: Container not found');
                return;
            }

            console.log('Purchase visualization: Initializing 3D scene', {
                hasAnalyzedWords: !!purchase.analyzedWords,
                analyzedWordsLength: purchase.analyzedWords ? purchase.analyzedWords.length : 0,
                hasNodesData: !!purchase.nodesData,
                nodesDataLength: purchase.nodesData ? purchase.nodesData.length : 0,
                hasConnectionsData: !!purchase.connectionsData,
                connectionsDataLength: purchase.connectionsData ? purchase.connectionsData.length : 0
            });

            // Clean up previous visualization
            cleanupPurchaseVisualization();

            // Wait a bit to ensure DOM is ready and modal is visible
            setTimeout(() => {
                // Ensure modal is visible and has valid dimensions
                const modal = document.getElementById('purchase-visualization-modal');
                if (modal && modal.style.display === 'none') {
                    console.warn('Purchase visualization: Modal not visible, retrying...');
                    setTimeout(() => initPurchaseVisualization3D(purchase), 200);
                    return;
                }

                // Get container dimensions - ensure they are valid
                let width = container.clientWidth;
                let height = container.clientHeight;
                
                // If dimensions are 0, use fallback values
                if (width === 0 || height === 0) {
                    width = Math.max(window.innerWidth - 20, 800);
                    height = Math.max(window.innerHeight - 250, 600);
                    console.warn('Purchase visualization: Using fallback dimensions', { width, height });
                }
                
                // Ensure minimum dimensions
                width = Math.max(width, 100);
                height = Math.max(height, 100);
                
                // Remove any existing canvas from container
                const existingCanvas = container.querySelector('canvas');
                if (existingCanvas) {
                    existingCanvas.remove();
                }
                
                // Use the main renderer to render to a texture, then display on canvas 2D
                // This avoids creating a new WebGL context
                const canvas = document.createElement('canvas');
                canvas.id = 'purchase-vis-canvas';
                canvas.width = width;
                canvas.height = height;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.display = 'block';
                canvas.style.position = 'relative';
                container.appendChild(canvas);

                console.log('Purchase visualization: Canvas created', { 
                    width, 
                    height, 
                    canvasWidth: canvas.width, 
                    canvasHeight: canvas.height
                });

                // Use main renderer to render purchase scene to texture
                try {
                    // We'll use the main renderer to render the purchase scene
                    // Store reference to main renderer for later use
                    if (!renderer) {
                        throw new Error('Main renderer not available');
                    }
                    
                    // Create scene for purchase visualization
                    purchaseVisScene = new THREE.Scene();
                    const currentBgColor = purchaseVisBackgroundColors[purchaseVisBackgroundColorIndex];
                    purchaseVisScene.background = new THREE.Color(currentBgColor);

                    // Create camera
                    purchaseVisCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);

                    // Create raycaster
                    purchaseVisRaycaster = new THREE.Raycaster();
                    
                    console.log('Purchase visualization: Using main renderer for visualization');

                    // Load analyzedWords from purchase data
                    if (purchase.analyzedWords && purchase.analyzedWords.length > 0) {
                        purchaseVisAnalyzedWords = purchase.analyzedWords;
                        console.log('Purchase visualization: Loaded analyzedWords', purchaseVisAnalyzedWords.length);
                        
                        // Recreate nodes from saved data
                        if (purchase.nodesData && purchase.nodesData.length > 0) {
                            console.log('Purchase visualization: Recreating nodes', purchase.nodesData.length);
                            recreatePurchaseNodes(purchase);
                            console.log('Purchase visualization: Created nodes', purchaseVisNodes.length);
                        } else {
                            console.warn('Purchase visualization: No nodesData found in purchase');
                        }
                        
                        // Recreate connections from saved data
                        if (purchase.connectionsData && purchase.connectionsData.length > 0) {
                            console.log('Purchase visualization: Recreating connections', purchase.connectionsData.length);
                            recreatePurchaseConnections(purchase);
                            console.log('Purchase visualization: Created connections', purchaseVisConnections.length);
                        } else {
                            // Silent handling for old purchases without connectionsData
                            // Don't show warning - this is expected for older purchases
                            console.log('Purchase visualization: No connectionsData found (old purchase format - connections will not be displayed)');
                        }
                    } else {
                        console.error('Purchase visualization: No analyzedWords found in purchase. Purchase may be from an older version.');
                        // Show error message to user
                        const textContainer = document.getElementById('purchase-vis-mapped-text');
                        if (textContainer) {
                            textContainer.innerHTML = '<div style="color: #ff0000; padding: 20px;">Error: This purchase does not contain visualization data. It may be from an older version.</div>';
                        }
                    }

                    // Calculate bounding box and position camera
                    if (purchaseVisNodes.length > 0) {
                        let minX = Infinity, maxX = -Infinity;
                        let minY = Infinity, maxY = -Infinity;
                        let minZ = Infinity, maxZ = -Infinity;
                        
                        purchaseVisNodes.forEach(node => {
                            const pos = node.position;
                            minX = Math.min(minX, pos.x);
                            maxX = Math.max(maxX, pos.x);
                            minY = Math.min(minY, pos.y);
                            maxY = Math.max(maxY, pos.y);
                            minZ = Math.min(minZ, pos.z);
                            maxZ = Math.max(maxZ, pos.z);
                        });
                        
                        const centerX = (minX + maxX) / 2;
                        const centerY = (minY + maxY) / 2;
                        const centerZ = (minZ + maxZ) / 2;
                        
                        const sizeX = maxX - minX;
                        const sizeY = maxY - minY;
                        const sizeZ = maxZ - minZ;
                        const maxSize = Math.max(sizeX, sizeY, sizeZ, 1);
                        
                        const distance = maxSize * 2.5;
                        purchaseVisCamera.position.set(centerX, centerY, centerZ + distance);
                        purchaseVisCamera.lookAt(centerX, centerY, centerZ);
                    } else {
                        purchaseVisCamera.position.set(0, 0, 10);
                        purchaseVisCamera.lookAt(0, 0, 0);
                    }

                    // Add lights
                    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                    purchaseVisScene.add(ambientLight);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(5, 5, 5);
                    purchaseVisScene.add(directionalLight);

                    // Attach mouse event listeners to canvas
                    canvas.addEventListener('mousedown', onPurchaseVisMouseDown);
                    canvas.addEventListener('mousemove', onPurchaseVisMouseMove);
                    canvas.addEventListener('mouseup', onPurchaseVisMouseUp);
                    canvas.addEventListener('wheel', onPurchaseVisWheel);
                    canvas.addEventListener('click', onPurchaseVisClick);

                    // Start animation loop
                    animatePurchaseVisualization();
                } catch (error) {
                    console.error('Purchase visualization: Error creating renderer:', error);
                    alert('Error creating 3D renderer: ' + error.message + '\n\nThis may be due to WebGL context limits. Try closing other 3D visualizations or refreshing the page.');
                    return;
                }
            }, 200); // Delay to ensure DOM is ready
        }

        function recreatePurchaseNodes(purchase) {
            if (!purchase.nodesData || !purchase.analyzedWords) {
                console.error('Purchase visualization: Missing nodesData or analyzedWords');
                return;
            }

            console.log('Purchase visualization: Starting node recreation', {
                nodesDataCount: purchase.nodesData.length,
                analyzedWordsCount: purchase.analyzedWords.length
            });

            let createdCount = 0;
            let errorCount = 0;

            purchase.nodesData.forEach((nodeData, index) => {
                try {
                    if (!nodeData || nodeData.wordIndex < 0 || nodeData.wordIndex >= purchase.analyzedWords.length) {
                        if (index < 5) console.warn(`Purchase visualization: Skipping invalid nodeData at index ${index}`, nodeData);
                        return;
                    }
                    
                    const wordData = purchase.analyzedWords[nodeData.wordIndex];
                    if (!wordData) {
                        if (index < 5) console.warn(`Purchase visualization: No wordData found for index ${nodeData.wordIndex}`);
                        return;
                    }

                    // Create node using the same logic as create3DNode
                    const baseSize = 0.06;
                    const wordType = getWordTypeForShape(wordData, nodeData.wordIndex);
                    
                    // Get color based on value
                    const color = getValueBasedColor(wordData, nodeData.wordIndex, purchase.analyzedWords);
                    const colorHex = typeof color === 'number' ? color : (color && color.getHex ? color.getHex() : 0xffffff);
                    
                    // Determine opacity
                    let nodeOpacity = 0.92;
                    const semiTransparentTypes = ['proper_noun', 'object_pronoun', 'intensive_pronoun', 
                                                 'interrogative_pronoun', 'superlative_adjective', 'modal_verb',
                                                 'concrete_noun', 'gerundial_noun', 'interrogative_determiner'];
                    if (semiTransparentTypes.includes(wordType)) {
                        nodeOpacity = 0.80;
                    }

                    // Create geometry
                    const geometryGroup = createWordTypeGeometry(wordType, baseSize, colorHex, nodeOpacity);
                    
                    if (!geometryGroup) {
                        console.error(`Purchase visualization: Failed to create geometry for node ${index}`);
                        errorCount++;
                        return;
                    }
                    
                    // Enable shadows
                    geometryGroup.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    // Calculate sphere size
                    const wordValue = wordData.finalValue || wordData.totalScore || 0;
                    const allValues = purchase.analyzedWords.map(w => w.finalValue || w.totalScore || 0).filter(v => v > 0);
                    let sphereSizeMultiplier = 2.25;
                    
                    if (allValues.length > 0) {
                        const minValue = Math.min(...allValues);
                        const maxValue = Math.max(...allValues);
                        if (maxValue > minValue && wordValue > 0) {
                            const normalizedValue = (wordValue - minValue) / (maxValue - minValue);
                            if (normalizedValue <= 0.5) {
                                sphereSizeMultiplier = 2.25 + (normalizedValue * 0.75);
                            } else {
                                const upperNormalized = (normalizedValue - 0.5) / 0.5;
                                const exponentialValue = Math.pow(upperNormalized, 1.5);
                                sphereSizeMultiplier = 3.0 + (exponentialValue * 7.5);
                            }
                            sphereSizeMultiplier = Math.min(sphereSizeMultiplier, 10.5);
                        }
                    }

                    const sphereSize = baseSize * sphereSizeMultiplier;
                    
                    // Create sphere
                    const sphereGeometry = new THREE.SphereGeometry(sphereSize, 16, 16);
                    const sphereMaterial = new THREE.MeshStandardMaterial({
                        color: 0x808080,
                        transparent: true,
                        opacity: 0.21,
                        metalness: 0.1,
                        roughness: 0.8,
                        side: THREE.DoubleSide
                    });
                    const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphereMesh.raycast = function() { return []; };
                    geometryGroup.add(sphereMesh);

                    // Position node - ensure position exists
                    if (nodeData.position && typeof nodeData.position.x === 'number') {
                        geometryGroup.position.set(nodeData.position.x, nodeData.position.y, nodeData.position.z);
                    } else {
                        console.warn(`Purchase visualization: Invalid position for node ${index}`, nodeData.position);
                        geometryGroup.position.set(0, 0, 0);
                    }

                    // Store user data
                    geometryGroup.userData = {
                        wordData: wordData,
                        index: nodeData.wordIndex,
                        connectionCount: 0,
                        isGroup: true,
                        wordType: wordType,
                        sphereSize: sphereSize,
                        sphereMesh: sphereMesh
                    };

                    purchaseVisScene.add(geometryGroup);
                    purchaseVisNodes.push(geometryGroup);
                    createdCount++;
                } catch (error) {
                    console.error(`Purchase visualization: Error creating node ${index}:`, error);
                    errorCount++;
                }
            });

            console.log('Purchase visualization: Node recreation complete', {
                created: createdCount,
                errors: errorCount,
                total: purchaseVisNodes.length
            });
        }

        function recreatePurchaseConnections(purchase) {
            // If no connectionsData, try to recreate connections based on node positions and text structure
            if (!purchase.connectionsData || purchase.connectionsData.length === 0) {
                console.log('Purchase visualization: No connectionsData found, attempting to recreate connections from node structure');
                recreateConnectionsFromNodes(purchase);
                return;
            }
            
            if (purchaseVisNodes.length === 0) {
                console.warn('Purchase visualization: No nodes available to create connections');
                return;
            }

            let createdCount = 0;
            let errorCount = 0;

            purchase.connectionsData.forEach((connData, index) => {
                try {
                    if (!connData || connData.startIndex < 0 || connData.startIndex >= purchaseVisNodes.length ||
                        connData.endIndex < 0 || connData.endIndex >= purchaseVisNodes.length) {
                        if (index < 5) {
                            console.warn(`Purchase visualization: Skipping invalid connection at index ${index}`, {
                                connData,
                                startIndex: connData?.startIndex,
                                endIndex: connData?.endIndex,
                                nodesLength: purchaseVisNodes.length
                            });
                        }
                        errorCount++;
                        return;
                    }

                    const startNode = purchaseVisNodes[connData.startIndex];
                    const endNode = purchaseVisNodes[connData.endIndex];
                    
                    if (!startNode || !endNode) {
                        if (index < 5) {
                            console.warn(`Purchase visualization: Missing node for connection at index ${index}`, {
                                startNode: !!startNode,
                                endNode: !!endNode,
                                startIndex: connData.startIndex,
                                endIndex: connData.endIndex
                            });
                        }
                        errorCount++;
                        return;
                    }

                    // Get positions - handle groups and get world position
                    let startPos, endPos;
                    
                    // For groups, get the main node position or group position
                    if (startNode.isGroup) {
                        if (startNode.userData?.mainNode) {
                            startPos = startNode.userData.mainNode.position.clone();
                        } else {
                            startPos = startNode.position.clone();
                        }
                        // Apply group transform
                        startPos.applyMatrix4(startNode.matrixWorld);
                    } else {
                        startPos = startNode.position.clone();
                        if (startNode.parent && startNode.parent.isGroup) {
                            startPos.applyMatrix4(startNode.parent.matrixWorld);
                        }
                    }
                    
                    if (endNode.isGroup) {
                        if (endNode.userData?.mainNode) {
                            endPos = endNode.userData.mainNode.position.clone();
                        } else {
                            endPos = endNode.position.clone();
                        }
                        // Apply group transform
                        endPos.applyMatrix4(endNode.matrixWorld);
                    } else {
                        endPos = endNode.position.clone();
                        if (endNode.parent && endNode.parent.isGroup) {
                            endPos.applyMatrix4(endNode.parent.matrixWorld);
                        }
                    }

                    // Create connection line
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(startPos.x, startPos.y, startPos.z),
                        new THREE.Vector3(endPos.x, endPos.y, endPos.z)
                    ]);
                    
                    // Create connection line with more visible settings
                    const material = new THREE.LineBasicMaterial({
                        color: 0x808080,
                        transparent: false, // Disable transparency for better visibility
                        opacity: 1.0,
                        depthTest: true,
                        depthWrite: true,
                        linewidth: 2
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.userData = {
                        startNode: startNode,
                        endNode: endNode
                    };
                    
                    // Ensure line is added to scene BEFORE nodes (so they render on top)
                    // Actually, let's add them after nodes so they render behind
                    purchaseVisScene.add(line);
                    purchaseVisConnections.push(line);
                    
                    if (index < 10) {
                        console.log(`Purchase visualization: Created connection ${index} from node ${connData.startIndex} to ${connData.endIndex}`, {
                            startPos: { x: startPos.x.toFixed(2), y: startPos.y.toFixed(2), z: startPos.z.toFixed(2) },
                            endPos: { x: endPos.x.toFixed(2), y: endPos.y.toFixed(2), z: endPos.z.toFixed(2) },
                            lineInScene: purchaseVisScene.children.includes(line),
                            sceneChildrenCount: purchaseVisScene.children.length,
                            geometryPoints: geometry.attributes.position.count,
                            materialColor: material.color.getHex()
                        });
                    }
                    
                    createdCount++;
                } catch (error) {
                    console.error(`Purchase visualization: Error creating connection ${index}:`, error);
                    errorCount++;
                }
            });

            console.log('Purchase visualization: Connection recreation complete', {
                created: createdCount,
                errors: errorCount,
                total: purchaseVisConnections.length,
                sceneChildrenCount: purchaseVisScene.children.length,
                connectionsInScene: purchaseVisScene.children.filter(child => child.type === 'Line').length,
                allConnectionsVisible: purchaseVisConnections.every(conn => conn && conn.visible !== false)
            });
            
            // Verify connections are in scene and visible
            if (createdCount > 0 && purchaseVisConnections.length > 0) {
                const firstConn = purchaseVisConnections[0];
                console.log('Purchase visualization: First connection verification', {
                    exists: !!firstConn,
                    inScene: firstConn ? purchaseVisScene.children.includes(firstConn) : false,
                    visible: firstConn ? firstConn.visible : false,
                    hasGeometry: firstConn ? !!firstConn.geometry : false,
                    hasMaterial: firstConn ? !!firstConn.material : false,
                    materialVisible: firstConn && firstConn.material ? firstConn.material.visible : false
                });
            }
        }

        function cleanupPurchaseVisualization() {
            // Stop animation
            if (purchaseVisAnimationId) {
                cancelAnimationFrame(purchaseVisAnimationId);
                purchaseVisAnimationId = null;
            }

            // Dispose of renderer
            if (purchaseVisRenderer) {
                purchaseVisRenderer.dispose();
                purchaseVisRenderer = null;
            }

            // Dispose of scene objects
            if (purchaseVisScene) {
                purchaseVisScene.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                purchaseVisScene = null;
            }

            purchaseVisNodes = [];
            purchaseVisConnections = [];
            purchaseVisCamera = null;
        }

        function animatePurchaseVisualization() {
            purchaseVisAnimationId = requestAnimationFrame(animatePurchaseVisualization);
            
            if (purchaseVisScene && purchaseVisCamera && renderer) {
                try {
                    const canvas = document.getElementById('purchase-vis-canvas');
                    if (!canvas) return;
                    
                    // Use main renderer to render to texture, then draw to canvas 2D
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // Create render target if needed
                    if (!purchaseVisRenderTarget) {
                        purchaseVisRenderTarget = new THREE.WebGLRenderTarget(width, height);
                    } else if (purchaseVisRenderTarget.width !== width || purchaseVisRenderTarget.height !== height) {
                        purchaseVisRenderTarget.dispose();
                        purchaseVisRenderTarget = new THREE.WebGLRenderTarget(width, height);
                    }
                    
                    // Save current renderer state
                    const originalRenderTarget = renderer.getRenderTarget();
                    const originalSize = renderer.getSize(new THREE.Vector2());
                    const originalClearColor = renderer.getClearColor(new THREE.Color());
                    
                    // Render purchase scene to texture
                    const currentBgColor = purchaseVisBackgroundColors[purchaseVisBackgroundColorIndex];
                    renderer.setRenderTarget(purchaseVisRenderTarget);
                    renderer.setSize(width, height);
                    renderer.setClearColor(currentBgColor, 1);
                    
                    // Ensure all connections are visible and renderable
                    purchaseVisConnections.forEach(conn => {
                        if (conn) {
                            conn.visible = true;
                            if (conn.material) {
                                conn.material.visible = true;
                            }
                        }
                    });
                    
                    // Render the entire scene (including connections)
                    renderer.render(purchaseVisScene, purchaseVisCamera);
                    
                    // Read pixels from render target
                    const pixels = new Uint8Array(width * height * 4);
                    renderer.readRenderTargetPixels(purchaseVisRenderTarget, 0, 0, width, height, pixels);
                    
                    // Draw to canvas 2D
                    const ctx2D = canvas.getContext('2d');
                    if (ctx2D) {
                        const imageData = ctx2D.createImageData(width, height);
                        for (let i = 0; i < pixels.length; i += 4) {
                            imageData.data[i] = pixels[i];     // R
                            imageData.data[i + 1] = pixels[i + 1]; // G
                            imageData.data[i + 2] = pixels[i + 2]; // B
                            imageData.data[i + 3] = pixels[i + 3]; // A
                        }
                        ctx2D.putImageData(imageData, 0, 0);
                    }
                    
                    // Restore renderer state
                    renderer.setRenderTarget(originalRenderTarget);
                    renderer.setSize(originalSize.x, originalSize.y);
                    renderer.setClearColor(originalClearColor, 1);
                } catch (error) {
                    console.error('Purchase visualization: Error in animation loop:', error);
                }
            }
        }

        function setupPurchaseVisualizationListeners() {
            // Close button
            const closeBtn = document.getElementById('purchase-vis-close-btn');
            if (closeBtn) {
                closeBtn.onclick = (e) => {
                    e.stopPropagation();
                    hidePurchaseVisualization();
                };
            }

            // TOP NODES button
            const topNodesBtn = document.getElementById('purchase-vis-top-nodes-btn');
            if (topNodesBtn) {
                topNodesBtn.onclick = () => {
                    togglePurchaseVisNodeList();
                };
            }

            // Background color button
            const bgColorBtn = document.getElementById('purchase-vis-bg-color-btn');
            if (bgColorBtn) {
                bgColorBtn.onclick = () => {
                    changePurchaseVisBackgroundColor();
                };
            }

            // Nametags button
            const nametagsBtn = document.getElementById('purchase-vis-nametags-btn');
            if (nametagsBtn) {
                nametagsBtn.onclick = () => {
                    togglePurchaseVisNametags();
                };
            }

            // Right panel close
            const rightPanelClose = document.getElementById('purchase-vis-right-panel-close');
            if (rightPanelClose) {
                rightPanelClose.onclick = () => {
                    const rightPanel = document.getElementById('purchase-vis-right-panel');
                    if (rightPanel) {
                        rightPanel.style.display = 'none';
                    }
                };
            }

            // Mouse controls for 3D navigation
            const canvas = document.getElementById('purchase-vis-canvas');
            if (canvas) {
                canvas.addEventListener('mousedown', onPurchaseVisMouseDown);
                canvas.addEventListener('mousemove', onPurchaseVisMouseMove);
                canvas.addEventListener('mouseup', onPurchaseVisMouseUp);
                canvas.addEventListener('wheel', onPurchaseVisWheel);
                canvas.addEventListener('click', onPurchaseVisClick);
            }

            // Window resize
            window.addEventListener('resize', onPurchaseVisResize);
        }

        function hidePurchaseVisualization() {
            const modal = document.getElementById('purchase-visualization-modal');
            if (modal) {
                modal.style.display = 'none';
                cleanupPurchaseVisualization();
                purchaseVisCurrentPurchase = null;
            }
        }

        function changePurchaseVisBackgroundColor() {
            // Cycle through colors: AZUL -> NEGRO -> GRIS -> ROSA -> AZUL
            purchaseVisBackgroundColorIndex = (purchaseVisBackgroundColorIndex + 1) % purchaseVisBackgroundColors.length;
            const currentBgColor = purchaseVisBackgroundColors[purchaseVisBackgroundColorIndex];
            
            // Update scene background
            if (purchaseVisScene) {
                purchaseVisScene.background = new THREE.Color(currentBgColor);
            }
            
            // Update color square in button
            const colorSquare = document.getElementById('purchase-vis-bg-color-square');
            if (colorSquare) {
                const hexColor = '#' + currentBgColor.toString(16).padStart(6, '0');
                colorSquare.style.background = hexColor;
            }
        }

        function togglePurchaseVisNodeList() {
            const container = document.getElementById('purchase-vis-node-list-container');
            const topNodesBtn = document.getElementById('purchase-vis-top-nodes-btn');
            
            if (!container) {
                console.error('[Purchase Vis TOP NODES] Container not found');
                return;
            }
            
            if (!purchaseVisNodes || purchaseVisNodes.length === 0) {
                console.warn('[Purchase Vis TOP NODES] No nodes available');
                alert('No nodes available in this purchase');
                return;
            }
            
            const isVisible = container.style.display !== 'none' && container.style.display !== '';
            
            if (!isVisible) {
                // Show node list
                container.style.display = 'flex';
                createPurchaseVisNodeList();
                if (topNodesBtn) topNodesBtn.textContent = 'HIDE NODES';
            } else {
                // Hide node list
                container.style.display = 'none';
                if (topNodesBtn) topNodesBtn.textContent = 'TOP NODES';
            }
        }

        // Shared renderer for purchase vis node list (similar to main node list)
        let purchaseVisNodeListRenderer = null;
        let purchaseVisNodeListScene = null;
        let purchaseVisNodeListCamera = null;
        let purchaseVisNodeListMeshes = {};
        let purchaseVisNodeListAnimationId = null;
        let purchaseVisNodeListIntersectionObserver = null;

        function createPurchaseVisNodeList() {
            const container = document.getElementById('purchase-vis-node-list-container');
            if (!container || !purchaseVisAnalyzedWords || purchaseVisAnalyzedWords.length === 0) return;
            
            container.innerHTML = '';
            
            // Sort nodes by value
            const sortedNodes = [...purchaseVisNodes]
                .filter(n => n.userData && n.userData.wordData)
                .sort((a, b) => {
                    const aValue = a.userData.wordData.finalValue || a.userData.wordData.totalScore || 0;
                    const bValue = b.userData.wordData.finalValue || b.userData.wordData.totalScore || 0;
                    return bValue - aValue;
                })
                .slice(0, 1000); // Top 1000 nodes
            
            sortedNodes.forEach((node, index) => {
                if (!node.userData || !node.userData.wordData) return;
                
                // Create item container (same structure as main node list)
                const item = document.createElement('div');
                item.className = 'node-list-item';
                item.id = `purchase-vis-node-list-item-${index}`;
                
                // Create header
                const header = document.createElement('div');
                header.className = 'node-list-item-header';
                const headerText = document.createElement('h3');
                headerText.style.cssText = 'color: #000000; font-size: 11px; margin: 0; font-family: Helvetica, Arial, sans-serif;';
                headerText.textContent = node.userData.wordData.text;
                header.appendChild(headerText);
                
                // Create canvas container (same as main node list)
                const canvasContainer = document.createElement('div');
                canvasContainer.className = 'node-list-item-canvas-container';
                const canvas = document.createElement('canvas');
                canvas.className = 'node-list-item-canvas';
                canvas.id = `purchase-vis-node-list-canvas-${index}`;
                canvasContainer.appendChild(canvas);
                
                // Create info container
                const infoContainer = document.createElement('div');
                infoContainer.className = 'node-list-item-info';
                
                // Populate info (same as main node list)
                const wordData = node.userData.wordData;
                const nodeIndex = node.userData.index;
                const totalValue = purchaseVisAnalyzedWords.reduce((sum, w) => sum + (w.finalValue || w.totalScore || 0), 0);
                const individualValue = wordData.finalValue || wordData.totalScore || 0;
                const relativeValue = totalValue > 0 ? ((individualValue / totalValue) * 100).toFixed(2) + '%' : '0%';
                
                // Calculate node size in KB
                let nodeSizeKB = 0;
                if (node.userData.isSerEstar) {
                    nodeSizeKB = (1 * 1 * 1 * 4 * 3) + (1.0 * 0.1 * 1.0 * 4 * 3);
                } else if (node.userData.isNoun) {
                    nodeSizeKB = (8 * 8 * 8 * 4 * 3) + (1 * 1 * 1 * 4 * 3);
                } else if (node.userData.connectionCount > 0) {
                    nodeSizeKB = (8 * 4 * 3);
                } else {
                    nodeSizeKB = (8 * 8 * 8 * 4 * 3);
                }
                nodeSizeKB = (nodeSizeKB / 1024).toFixed(4);
                
                const performanceImpact = node.userData.connectionCount > 0 ? 
                    'Medium (' + node.userData.connectionCount + ' connections)' : 
                    'Low';
                
                // Convert to ETH
                let individualValueETH = 0;
                if (ethPriceUSD) {
                    individualValueETH = individualValue / ethPriceUSD;
                }
                const individualValueETHDisplay = individualValueETH >= 0.01 ? 
                    `${individualValueETH.toFixed(6)} ETH` : 
                    `${individualValueETH.toFixed(10)} ETH`;
                
                let totalValueETH = 0;
                if (ethPriceUSD) {
                    totalValueETH = totalValue / ethPriceUSD;
                }
                const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                    `${totalValueETH.toFixed(6)} ETH` : 
                    `${totalValueETH.toFixed(10)} ETH`;
                
                // Check if it's a convergence node
                const isConvergenceNode = node.userData && node.userData.isConvergenceNode;
                const positionText = isConvergenceNode ? 
                    'Convergence Zone' : 
                    `${nodeIndex + 1} / ${purchaseVisAnalyzedWords.length}`;
                
                let convergenceZoneInfo = '';
                if (isConvergenceNode) {
                    convergenceZoneInfo = `<div><strong>Source:</strong> Convergence Zone</div>`;
                }
                
                // Add info fields (same format as main node list)
                infoContainer.innerHTML = `
                    <div><strong>Word:</strong> ${wordData.text}</div>
                    <div><strong>Individual Value:</strong> ${individualValueETHDisplay}</div>
                    <div><strong>Position in Text:</strong> ${positionText}</div>
                    ${convergenceZoneInfo}
                    <div><strong>Value / Total:</strong> ${relativeValue} (${totalValueETHDisplay} total)</div>
                    <div><strong>Connections:</strong> ${node.userData.connectionCount || 0}</div>
                    <div><strong>Size (KB):</strong> ${nodeSizeKB} KB</div>
                    <div><strong>Performance:</strong> ${performanceImpact}</div>
                    <div><strong>3D Coordinates:</strong> (${node.position.x.toFixed(2)}, ${node.position.y.toFixed(2)}, ${node.position.z.toFixed(2)})</div>
                `;
                
                // Assemble item
                item.appendChild(header);
                item.appendChild(canvasContainer);
                item.appendChild(infoContainer);
                container.appendChild(item);
                
                // Store node data for lazy loading
                item.dataset.nodeIndex = index;
                item.dataset.nodeData = JSON.stringify({
                    word: wordData.text,
                    pos: wordData.pos,
                    normalizedScore: wordData.normalizedScore || 0,
                    isNoun: node.userData.isNoun,
                    isSerEstar: wordData.isSerEstar || false,
                    connectionCount: node.userData.connectionCount || 0,
                    isConvergenceNode: isConvergenceNode
                });
            });
            
            // Setup Intersection Observer for lazy loading
            setupPurchaseVisNodeListIntersectionObserver();
        }
        
        function setupPurchaseVisNodeListIntersectionObserver() {
            // Clean up existing observer
            if (purchaseVisNodeListIntersectionObserver) {
                purchaseVisNodeListIntersectionObserver.disconnect();
            }
            
            // Create new observer
            purchaseVisNodeListIntersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const item = entry.target;
                    const index = parseInt(item.dataset.nodeIndex);
                    
                    if (entry.isIntersecting) {
                        // Node is visible, create 3D scene if not already created
                        if (!purchaseVisNodeListMeshes[index]) {
                            const canvas = item.querySelector('.node-list-item-canvas');
                            const nodeData = JSON.parse(item.dataset.nodeData);
                            // Find the actual node from sorted nodes
                            const sortedNodes = [...purchaseVisNodes]
                                .filter(n => n.userData && n.userData.wordData)
                                .sort((a, b) => {
                                    const aValue = a.userData.wordData.finalValue || a.userData.wordData.totalScore || 0;
                                    const bValue = b.userData.wordData.finalValue || b.userData.wordData.totalScore || 0;
                                    return bValue - aValue;
                                })
                                .slice(0, 1000);
                            if (sortedNodes[index]) {
                                createPurchaseVisNodeList3DScene(index, sortedNodes[index], canvas);
                            }
                        }
                    }
                });
            }, {
                root: document.getElementById('purchase-vis-node-list-container'),
                rootMargin: '50px',
                threshold: 0.1
            });
            
            // Observe all node list items
            const items = document.querySelectorAll('#purchase-vis-node-list-container .node-list-item');
            items.forEach(item => {
                purchaseVisNodeListIntersectionObserver.observe(item);
            });
        }

        function createPurchaseVisNodeList3DScene(index, node, canvas) {
            // Use shared renderer (similar to main node list)
            if (!purchaseVisNodeListRenderer) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 200;
                tempCanvas.height = 120;
                purchaseVisNodeListRenderer = new THREE.WebGLRenderer({ canvas: tempCanvas, antialias: false });
                purchaseVisNodeListRenderer.setSize(200, 120);
                purchaseVisNodeListRenderer.setPixelRatio(0.75);
                
                purchaseVisNodeListScene = new THREE.Scene();
                purchaseVisNodeListScene.background = new THREE.Color(0x000000);
                
                purchaseVisNodeListCamera = new THREE.PerspectiveCamera(50, 200 / 120, 0.1, 100);
                purchaseVisNodeListCamera.position.set(0, 0, 2);
                purchaseVisNodeListCamera.lookAt(0, 0, 0);
                
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                purchaseVisNodeListScene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(2, 2, 2);
                purchaseVisNodeListScene.add(directionalLight);
            }
            
            // Clone node for display
            const wordData = node.userData.wordData;
            const enlargedSize = 0.3;
            
            // Get color - use violet for convergence nodes, otherwise use value-based color
            let color;
            if (node.userData && node.userData.isConvergenceNode) {
                color = 0x8B00FF; // Violet color for convergence nodes
            } else {
                const nodeIndex = node.userData.index !== undefined ? node.userData.index : 0;
                color = getValueBasedColor(wordData, nodeIndex, purchaseVisAnalyzedWords);
            }
            
            // Get word type to determine correct shape
            const wordType = getWordTypeForShape(wordData, node.userData.index || 0);
            
            // Determine opacity
            let nodeOpacity = 0.92;
            const semiTransparentTypes = ['proper_noun', 'object_pronoun', 'intensive_pronoun', 
                                         'interrogative_pronoun', 'superlative_adjective', 'modal_verb',
                                         'concrete_noun', 'gerundial_noun', 'interrogative_determiner'];
            if (semiTransparentTypes.includes(wordType)) {
                nodeOpacity = 0.80;
            }
            
            // Create geometry using the correct shape function
            const colorHex = typeof color === 'number' ? color : parseInt(color, 16);
            const mesh = createWordTypeGeometry(wordType, enlargedSize, colorHex, nodeOpacity);
            
            // Store mesh for animation
            purchaseVisNodeListMeshes[index] = mesh;
            purchaseVisNodeListScene.add(mesh);
            
            // Render to canvas using shared renderer
            purchaseVisNodeListRenderer.setRenderTarget(null);
            purchaseVisNodeListRenderer.render(purchaseVisNodeListScene, purchaseVisNodeListCamera);
            
            // Copy rendered image to canvas
            const ctx2D = canvas.getContext('2d');
            if (ctx2D && purchaseVisNodeListRenderer.domElement) {
                ctx2D.drawImage(purchaseVisNodeListRenderer.domElement, 0, 0, canvas.width, canvas.height);
            }
            
            // Start animation loop if not already running
            if (!purchaseVisNodeListAnimationId) {
                animatePurchaseVisNodeList();
            }
        }

        function animatePurchaseVisNodeList() {
            purchaseVisNodeListAnimationId = requestAnimationFrame(animatePurchaseVisNodeList);
            
            if (!purchaseVisNodeListRenderer || !purchaseVisNodeListScene || !purchaseVisNodeListCamera) {
                if (purchaseVisNodeListAnimationId) {
                    cancelAnimationFrame(purchaseVisNodeListAnimationId);
                    purchaseVisNodeListAnimationId = null;
                }
                return;
            }
            
            // Rotate all meshes
            Object.values(purchaseVisNodeListMeshes).forEach(mesh => {
                if (mesh) {
                    mesh.rotation.y += 0.01;
                    mesh.rotation.x += 0.005;
                }
            });
            
            // Render to all visible canvases
            const items = document.querySelectorAll('#purchase-vis-node-list-container .node-list-item');
            items.forEach((item, index) => {
                const canvas = item.querySelector('.node-list-item-canvas');
                if (canvas && purchaseVisNodeListMeshes[index]) {
                    purchaseVisNodeListRenderer.setRenderTarget(null);
                    purchaseVisNodeListRenderer.render(purchaseVisNodeListScene, purchaseVisNodeListCamera);
                    
                    const ctx2D = canvas.getContext('2d');
                    if (ctx2D && purchaseVisNodeListRenderer.domElement) {
                        ctx2D.drawImage(purchaseVisNodeListRenderer.domElement, 0, 0, canvas.width, canvas.height);
                    }
                }
            });
        }

        function togglePurchaseVisNametags() {
            purchaseVisNametagsVisible = !purchaseVisNametagsVisible;
            // TODO: Show/hide nametags on nodes
            const btn = document.getElementById('purchase-vis-nametags-btn');
            if (btn) {
                btn.textContent = purchaseVisNametagsVisible ? 'HIDE NAMETAGS' : 'SHOW NAMETAGS';
            }
        }

        function onPurchaseVisMouseDown(event) {
            purchaseVisIsDragging = true;
            purchaseVisPreviousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onPurchaseVisMouseMove(event) {
            if (purchaseVisIsDragging && purchaseVisCamera) {
                const deltaX = event.clientX - purchaseVisPreviousMousePosition.x;
                const deltaY = event.clientY - purchaseVisPreviousMousePosition.y;
                
                // Rotate camera
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(purchaseVisCamera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                purchaseVisCamera.position.setFromSpherical(spherical);
                purchaseVisCamera.lookAt(0, 0, 0);
                
                purchaseVisPreviousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        }

        function onPurchaseVisMouseUp(event) {
            purchaseVisIsDragging = false;
        }

        function onPurchaseVisWheel(event) {
            if (purchaseVisCamera) {
                // Calculate zoom direction and amount
                const delta = event.deltaY * 0.02; // Increased sensitivity
                const currentDistance = purchaseVisCamera.position.length();
                const newDistance = Math.max(0.5, Math.min(100, currentDistance * (1 + delta)));
                
                // Scale camera position to maintain direction but change distance
                purchaseVisCamera.position.normalize().multiplyScalar(newDistance);
                
                // Update camera to look at the center
                purchaseVisCamera.lookAt(0, 0, 0);
            }
            event.preventDefault();
            event.stopPropagation();
        }

        function onPurchaseVisClick(event) {
            if (purchaseVisIsDragging) return;
            
            const canvas = document.getElementById('purchase-vis-canvas');
            if (!canvas || !purchaseVisRaycaster || !purchaseVisCamera) return;
            
            const rect = canvas.getBoundingClientRect();
            purchaseVisMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            purchaseVisMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            purchaseVisRaycaster.setFromCamera(purchaseVisMouse, purchaseVisCamera);
            const intersects = purchaseVisRaycaster.intersectObjects(purchaseVisNodes, true);
            
            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                let node = intersected;
                while (node && !node.userData?.wordData) {
                    node = node.parent;
                }
                if (node && node.userData?.wordData) {
                    showPurchaseVisNodeDetails(node);
                }
            }
        }
        
        function showPurchaseVisNodeDetails(node) {
            const rightPanel = document.getElementById('purchase-vis-right-panel');
            const content = document.getElementById('purchase-vis-right-panel-content');
            if (!rightPanel || !content) return;
            
            const wordData = node.userData.wordData;
            const value = wordData.finalValue || wordData.totalScore || 0;
            
            content.innerHTML = `
                <div style="font-size: 11px; color: #000000; font-family: Helvetica, Arial, sans-serif;">
                    <h3 style="margin: 0 0 8px 0; font-size: 12px;">${wordData.text}</h3>
                    <div style="margin-bottom: 4px;"><strong>Value:</strong> ${value.toFixed(2)}</div>
                    <div style="margin-bottom: 4px;"><strong>POS:</strong> ${wordData.pos || 'N/A'}</div>
                    <div style="margin-bottom: 4px;"><strong>Connections:</strong> ${node.userData.connectionCount || 0}</div>
                    <div style="margin-bottom: 4px;"><strong>Position:</strong> X: ${node.position.x.toFixed(2)}, Y: ${node.position.y.toFixed(2)}, Z: ${node.position.z.toFixed(2)}</div>
                </div>
            `;
            
            rightPanel.style.display = 'block';
        }

        function onPurchaseVisResize() {
            const container = document.getElementById('purchase-vis-canvas-container');
            const canvas = document.getElementById('purchase-vis-canvas');
            if (container && canvas && purchaseVisCamera) {
                const width = Math.max(container.clientWidth, 100);
                const height = Math.max(container.clientHeight, 100);
                canvas.width = width;
                canvas.height = height;
                // Dispose old render target if size changed
                if (purchaseVisRenderTarget && (purchaseVisRenderTarget.width !== width || purchaseVisRenderTarget.height !== height)) {
                    purchaseVisRenderTarget.dispose();
                    purchaseVisRenderTarget = null;
                }
                purchaseVisCamera.aspect = width / height;
                purchaseVisCamera.updateProjectionMatrix();
            }
        }

        // ==================== MAP TEXT ====================
        function mapText() {
            const mappedContainer = document.getElementById('mapped-text-container');
            const textInput = document.getElementById('textInput');
            
            // Toggle between mapped view and normal textarea
            if (mappedTextVisible) {
                // Switch back to textarea
                mappedContainer.style.display = 'none';
                textInput.style.display = 'block';
                mappedTextVisible = false;
                return;
            }
            
            const text = document.getElementById('textInput').value;
            
            if (!text || text.trim().length === 0) {
                alert('Please enter some text first');
                return;
            }
            
            // If viewing a purchase, analyzedWords should already be loaded
            // Otherwise, analyze text and calculate scores if not already done
            if (!isViewingPurchase && analyzedWords.length === 0) {
                analyzeText(text);
                calculateScores();
            }
            
            // Hide textarea and show mapped container
            textInput.style.display = 'none';
            mappedContainer.style.display = 'block';
            mappedTextVisible = true;
            
            // Create a map of words to their scores
            const wordScoreMap = new Map();
            analyzedWords.forEach((wordData, index) => {
                const wordKey = wordData.text.toLowerCase();
                if (!wordScoreMap.has(wordKey)) {
                    wordScoreMap.set(wordKey, wordData.normalizedScore || 0);
                }
            });
            
            // Process text character by character to preserve spaces with colors
            const words = splitTextIntoWords(text);
            let mappedHTML = '';
            let currentTextIndex = 0;
            let lastBgColor = '#000000';
            let lastTextColor = '#ffffff';
            
            // Create a map of word text to analyzedWords indices (handle multiple occurrences)
            const wordToIndicesMap = new Map();
            analyzedWords.forEach((wordData, index) => {
                const wordKey = wordData.text.toLowerCase();
                if (!wordToIndicesMap.has(wordKey)) {
                    wordToIndicesMap.set(wordKey, []);
                }
                wordToIndicesMap.get(wordKey).push(index);
            });
            
            let wordOccurrenceIndex = 0; // Track which occurrence of each word we're on
            
            words.forEach((word, wordIndex) => {
                // Find the word in the original text
                const wordStart = text.indexOf(word, currentTextIndex);
                
                // Get the score for this word
                const wordKey = word.toLowerCase();
                const score = wordScoreMap.get(wordKey) || 0;
                
                // Find the corresponding analyzedWords index for this occurrence
                const wordIndices = wordToIndicesMap.get(wordKey) || [];
                let analyzedWordIndex = -1;
                if (wordIndices.length > 0) {
                    // Use the occurrence index to get the right word
                    analyzedWordIndex = wordIndices[Math.min(wordOccurrenceIndex, wordIndices.length - 1)];
                    wordOccurrenceIndex++;
                }
                
                let bgColor, textColor;
                
                // Get color based on value (same logic as getValueBasedColor - MUST MATCH NODE COLORS EXACTLY)
                const wordData = analyzedWords[analyzedWordIndex];
                if (wordData && analyzedWordIndex >= 0) {
                    // CRITICAL: Use the exact same function and parameters as nodes use
                    const color = getValueBasedColor(wordData, analyzedWordIndex, analyzedWords);
                    // Convert hex color number to hex string for CSS (to match node colors exactly)
                    // Ensure color is a number (hex format like 0xffff00)
                    const colorNum = typeof color === 'number' ? color : parseInt(color, 16);
                    const r = (colorNum >> 16) & 0xFF;
                    const g = (colorNum >> 8) & 0xFF;
                    const b = colorNum & 0xFF;
                    // Convert to hex string with proper padding
                    bgColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    // Determine text color based on background brightness
                    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                    textColor = brightness > 128 ? '#000000' : '#ffffff';
                } else {
                    // Fallback to old logic
                    if (score > 0.85) {
                        bgColor = '#ffff00';
                        textColor = '#000000';
                    } else if (score > 0.7 && score <= 0.85) {
                        bgColor = '#4a8fa5';
                        textColor = '#ffffff';
                    } else if (score > 0.5 && score <= 0.7) {
                        bgColor = '#5a7fa5';
                        textColor = '#ffffff';
                    } else if (score > 0.3 && score <= 0.5) {
                        bgColor = '#6a8fb5';
                        textColor = '#ffffff';
                    } else {
                        bgColor = '#808080';
                        textColor = '#ffffff';
                    }
                }
                
                // Add any text before the word (spaces, punctuation, etc.) with the previous word's color
                if (wordStart > currentTextIndex) {
                    const beforeWord = text.substring(currentTextIndex, wordStart);
                    const escapedBefore = beforeWord.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const fontSize = window.innerWidth <= 768 ? 'font-size: 12px !important;' : '';
                    mappedHTML += `<span style="background-color: ${lastBgColor}; color: ${lastTextColor}; padding: 0; margin: 0; display: inline; ${fontSize}">${escapedBefore}</span>`;
                }
                
                // Add the word with its color and data attribute for click handling
                const escapedWord = word.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const wordSpanId = `mapped-word-${analyzedWordIndex}`;
                const fontSize = window.innerWidth <= 768 ? 'font-size: 12px !important;' : '';
                mappedHTML += `<span id="${wordSpanId}" data-word-index="${analyzedWordIndex}" class="mapped-word" style="background-color: ${bgColor}; color: ${textColor}; padding: 0; margin: 0; display: inline; cursor: pointer; ${fontSize}" title="Click to view node details">${escapedWord}</span>`;
                
                // Update last colors for next iteration
                lastBgColor = bgColor;
                lastTextColor = textColor;
                
                currentTextIndex = wordStart + word.length;
            });
            
            // Add any remaining text after the last word with the last word's color
            if (currentTextIndex < text.length) {
                const remaining = text.substring(currentTextIndex);
                const escapedRemaining = remaining.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const fontSize = window.innerWidth <= 768 ? 'font-size: 12px !important;' : '';
                mappedHTML += `<span style="background-color: ${lastBgColor}; color: ${lastTextColor}; padding: 0; margin: 0; display: inline; ${fontSize}">${escapedRemaining}</span>`;
            }
            
            mappedContainer.innerHTML = mappedHTML;
            
            // Add hover event listeners for tooltip
            mappedContainer.querySelectorAll('[data-word-index]').forEach(span => {
                span.addEventListener('mouseenter', function(e) {
                    const wordIndex = parseInt(this.getAttribute('data-word-index'));
                    if (wordIndex >= 0 && wordIndex < analyzedWords.length) {
                        // Find the corresponding node
                        const node = nodes.find(n => {
                            if (!n.userData) return false;
                            if (n.userData.isGroup) {
                                return n.userData.index === wordIndex;
                            }
                            return n.userData.index === wordIndex;
                        });
                        
                        if (node) {
                            showNodeInfo(node, e.clientX, e.clientY);
                        } else {
                            // Create temporary node for tooltip
                            const wordData = analyzedWords[wordIndex];
                            if (wordData) {
                                const tempNode = {
                                    userData: {
                                        wordData: wordData,
                                        index: wordIndex,
                                        connectionCount: 0,
                                        isGroup: false
                                    },
                                    position: new THREE.Vector3(0, 0, 0)
                                };
                                showNodeInfo(tempNode, e.clientX, e.clientY);
                            }
                        }
                    }
                });
                
                span.addEventListener('mouseleave', function() {
                    hideNodeInfo();
                });
            });
            
            // Add click event listeners to all word spans
            mappedContainer.querySelectorAll('[data-word-index]').forEach(span => {
                span.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const wordIndex = parseInt(this.getAttribute('data-word-index'));
                    if (wordIndex >= 0 && wordIndex < analyzedWords.length) {
                        // Find the corresponding node in the 3D scene
                        const node = nodes.find(n => {
                            if (!n.userData) return false;
                            // Handle both regular nodes and groups
                            if (n.userData.isGroup) {
                                return n.userData.index === wordIndex;
                            }
                            return n.userData.index === wordIndex;
                        });
                        
                        if (node) {
                            // Move camera to focus on the node
                            focusCameraOnNode(node);
                            // Show node details in right panel
                            showNodeDetails(node);
                        } else {
                            // If node not found, try to find it by checking all nodes more thoroughly
                            // Sometimes nodes might be in groups or have different structures
                            console.log(`Node not found for word index ${wordIndex}`);
                        }
                    }
                });
            });
        }
        
        function createNametags() {
            removeNametags(); // Clear any existing nametags
            
            nodes.forEach(node => {
                const nametag = document.createElement('div');
                nametag.className = 'nametag';
                nametag.textContent = node.userData.wordData.text;
                nametag.id = `nametag-${node.userData.index}`;
                document.body.appendChild(nametag);
                nametags.push(nametag);
            });
            
            updateNametags();
        }
        
        function removeNametags() {
            nametags.forEach(tag => {
                if (tag.parentNode) {
                    tag.parentNode.removeChild(tag);
                }
            });
            nametags = [];
        }
        
        function updateNametags() {
            if (!nametagsVisible || nametags.length === 0) return;
            
            const vector = new THREE.Vector3();
            
            nodes.forEach((node, index) => {
                const nametag = nametags[index];
                if (!nametag) return;
                
                // Get 3D position and project to screen coordinates
                // Handle both regular nodes and noun groups
                if (node.userData.isNoun && node.userData.mainNode) {
                    node.userData.mainNode.getWorldPosition(vector);
                } else {
                    node.getWorldPosition(vector);
                }
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                
                // Only show nametag if node is in front of camera
                if (vector.z < 1) {
                    nametag.style.left = `${x}px`;
                    nametag.style.top = `${y}px`;
                    nametag.style.display = 'block';
                } else {
                    nametag.style.display = 'none';
                }
            });
        }

        // ==================== ANIMACIÃ“N ====================
        let lastFrameTime = 0;
        const targetFPS = 30; // Limit to 30 FPS for better performance
        const frameInterval = 1000 / targetFPS;
        let nodeInfoAnimationId = null;
        let fps = 0;
        let fpsLastTime = 0;
        let fpsFrameCount = 0;
        
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            
            // Calculate FPS
            if (fpsLastTime === 0) {
                fpsLastTime = currentTime;
            }
            fpsFrameCount++;
            if (currentTime - fpsLastTime >= 1000) {
                fps = fpsFrameCount;
                fpsFrameCount = 0;
                fpsLastTime = currentTime;
                // Repeat FPS text many times
                const fpsText = `FPS: ${fps} `;
                const fpsRepeatedElement = document.getElementById('fpsRepeated');
                if (fpsRepeatedElement) {
                    fpsRepeatedElement.textContent = fpsText.repeat(100);
                }
                // Update bottom FPS bar too
                const bottomFpsRepeatedElement = document.getElementById('bottom-fpsRepeated');
                if (bottomFpsRepeatedElement) {
                    bottomFpsRepeatedElement.textContent = fpsText.repeat(100);
                }
                // Update real-time info panel
                updateRealtimeInfo();
            }
            
            // Throttle frame rate for better performance
            const deltaTime = currentTime - lastFrameTime;
            if (deltaTime < frameInterval) {
                return;
            }
            lastFrameTime = currentTime - (deltaTime % frameInterval);
            
            // Update keyboard navigation (works in both modes, with different sensitivity)
            if (keysPressed.ArrowUp || keysPressed.ArrowDown || 
                keysPressed.ArrowLeft || keysPressed.ArrowRight) {
                updateKeyboardNavigation();
            }
            
            // Update connections if nodes move (less frequently)
            if (connections.length > 0 && Math.floor(currentTime / frameInterval) % 2 === 0) {
                updateConnections();
            }
            
            // Update nametags position (less frequently)
            if (nametagsVisible && Math.floor(currentTime / frameInterval) % 2 === 0) {
                updateNametags();
            }
            
            // Update grid word labels (every second)
            if (gridMode && currentTime - lastGridLabelUpdate >= GRID_LABEL_UPDATE_INTERVAL) {
                updateGridWordLabels();
                lastGridLabelUpdate = currentTime;
            }
            
            // Update coordinates display continuously (every frame)
            updateCoordinatesDisplay();
            
            // Ensure renderer context is still valid and background is set
            if (renderer && renderer.domElement) {
                try {
                    // If grid is active, keep background transparent, otherwise use current background color
                    if (gridMode) {
                        renderer.setClearColor(0x000000, 0); // Completely transparent
                        if (scene) {
                            scene.background = null;
                        }
                    } else {
                        renderer.setClearColor(currentBackgroundColor, 1);
                    }
                } catch (e) {
                    console.warn('Renderer context issue:', e);
                }
            }
            
            // Render main scene
            if (renderer && scene && camera) {
                try {
                    renderer.render(scene, camera);
                } catch (e) {
                    console.warn('Render error:', e);
                }
            }
        }

        // Mobile menu toggle handler
        function setupMobileMenu() {
            const mobileMenuToggle = document.getElementById('mobile-menu-toggle');
            const topBar = document.getElementById('top-bar');
            
            if (mobileMenuToggle && topBar) {
                mobileMenuToggle.addEventListener('click', function(e) {
                    e.stopPropagation();
                    topBar.classList.toggle('mobile-collapsed');
                });
                
                // Close menu when clicking outside on mobile
                document.addEventListener('click', function(e) {
                    if (window.innerWidth <= 768) {
                        if (!topBar.contains(e.target) && !topBar.classList.contains('mobile-collapsed')) {
                            topBar.classList.add('mobile-collapsed');
                        }
                    }
                });
            }
        }
        
        // Position FPS bars and adjust margins on mobile
        function positionMobileElements() {
            if (window.innerWidth <= 768) {
                const topBar = document.getElementById('top-bar');
                const fpsBar = document.getElementById('fps-bar');
                const bottomBar = document.getElementById('bottom-bar');
                const leftPanel = document.getElementById('left-panel');
                const nodeListContainer = document.getElementById('node-list-container');
                
                if (topBar && fpsBar) {
                    // Position fps bar below top bar
                    const topBarHeight = topBar.offsetHeight || 0;
                    fpsBar.style.top = topBarHeight + 'px';
                    fpsBar.style.bottom = 'auto';
                }
                
                if (leftPanel && bottomBar) {
                    // Position bottom fps bar above left panel
                    const leftPanelHeight = leftPanel.offsetHeight || 0;
                    bottomBar.style.bottom = leftPanelHeight + 'px';
                    bottomBar.style.top = 'auto';
                }
                
                // Adjust node list container margins
                if (nodeListContainer && topBar && fpsBar && bottomBar && leftPanel) {
                    const topBarHeight = topBar.offsetHeight || 0;
                    const fpsBarHeight = fpsBar.offsetHeight || 7;
                    const bottomBarHeight = bottomBar.offsetHeight || 7;
                    const leftPanelHeight = leftPanel.classList.contains('collapsed') ? 0 : (leftPanel.offsetHeight || 0);
                    
                    const topMargin = topBarHeight + fpsBarHeight;
                    const bottomMargin = bottomBarHeight + leftPanelHeight;
                    
                    nodeListContainer.style.top = topMargin + 'px';
                    nodeListContainer.style.bottom = bottomMargin + 'px';
                }
            }
        }
        
        // Handle window resize for mobile adaptations
        function handleMobileResize() {
            const topBar = document.getElementById('top-bar');
            if (window.innerWidth > 768 && topBar) {
                topBar.classList.remove('mobile-collapsed');
            }
            
            // Position mobile elements
            positionMobileElements();
            
            // Adjust canvas on mobile resize
            if (window.innerWidth <= 768 && renderer && camera) {
                setTimeout(() => {
                    onWindowResize();
                }, 100);
            }
        }
        
        // Start screen handler
        document.addEventListener('DOMContentLoaded', function() {
            const startScreen = document.getElementById('start-screen');
            const startButton = document.getElementById('start-button');
            
            // Setup mobile menu
            setupMobileMenu();
            
            // Position mobile elements on load
            setTimeout(() => {
                positionMobileElements();
            }, 100);
            
            // Handle window resize
            window.addEventListener('resize', handleMobileResize);
            
            // Observe top bar and left panel changes for dynamic positioning
            if (window.innerWidth <= 768) {
                const topBar = document.getElementById('top-bar');
                const leftPanel = document.getElementById('left-panel');
                
                if (topBar) {
                    const topBarObserver = new MutationObserver(() => {
                        positionMobileElements();
                    });
                    topBarObserver.observe(topBar, { attributes: true, childList: true, subtree: true });
                }
                
                if (leftPanel) {
                    const leftPanelObserver = new MutationObserver(() => {
                        positionMobileElements();
                    });
                    leftPanelObserver.observe(leftPanel, { attributes: true, childList: true, subtree: true });
                }
            }
            
            // Initially hide all main content (exclude modals - they should stay hidden)
            const mainContent = document.querySelectorAll('#canvas-container, #left-panel, #top-bar, #fps-bar, #realtime-info-panel, #node-list-container, #max-value-panel');
            
            // Modals should always stay hidden until explicitly shown
            const valueLogicModal = document.getElementById('value-logic-modal');
            const fractalModal = document.getElementById('fractal-modal');
            const nodeInfoPanel = document.getElementById('node-info-panel');
            const rightPanel = document.getElementById('right-panel');
            
            mainContent.forEach(el => {
                if (el) el.style.display = 'none';
            });
            
            // Keep modals and panels hidden (they show on hover/click only)
            if (valueLogicModal) {
                valueLogicModal.style.display = 'none';
                valueLogicModal.style.visibility = 'hidden';
                valueLogicModal.style.opacity = '0';
            }
            if (fractalModal) {
                fractalModal.style.display = 'none';
                fractalModal.style.visibility = 'hidden';
                fractalModal.style.opacity = '0';
            }
            if (nodeInfoPanel) {
                nodeInfoPanel.style.display = 'none';
                nodeInfoPanel.style.visibility = 'hidden';
                nodeInfoPanel.style.opacity = '0';
            }
            if (rightPanel) {
                rightPanel.style.display = 'none';
                rightPanel.style.visibility = 'hidden';
                rightPanel.style.opacity = '0';
            }
            
            startButton.addEventListener('click', function() {
                // Mostrar modal de conexiÃ³n de wallet
                const walletModal = document.getElementById('wallet-connect-modal');
                if (walletModal) {
                    walletModal.style.display = 'block';
                    walletModal.style.visibility = 'visible';
                    walletModal.style.opacity = '1';
                }
            });
            
            // Event listeners para el modal de wallet
            const walletModal = document.getElementById('wallet-connect-modal');
            const walletCloseBtn = document.getElementById('wallet-connect-close-btn');
            const walletConnectBtn = document.getElementById('wallet-connect-wallet-btn');
            
            function hideWalletModal() {
                if (walletModal) {
                    walletModal.style.display = 'none';
                    walletModal.style.visibility = 'hidden';
                    walletModal.style.opacity = '0';
                }
            }
            
            function proceedToMainApp() {
                // Ocultar modal de wallet
                hideWalletModal();
                
                // Hide start screen
                startScreen.classList.add('hidden');
                
                // Show all main content (but NOT modals - they show only when activated)
                mainContent.forEach(el => {
                    if (el) el.style.display = '';
                });
                
                // Ensure modals and panels stay hidden (they show on hover/click only)
                if (valueLogicModal) {
                    valueLogicModal.style.display = 'none';
                    valueLogicModal.style.visibility = 'hidden';
                    valueLogicModal.style.opacity = '0';
                }
                if (fractalModal) {
                    fractalModal.style.display = 'none';
                    fractalModal.style.visibility = 'hidden';
                    fractalModal.style.opacity = '0';
                }
                if (nodeInfoPanel) {
                    nodeInfoPanel.style.display = 'none';
                    nodeInfoPanel.style.visibility = 'hidden';
                    nodeInfoPanel.style.opacity = '0';
                    nodeInfoPanel.classList.remove('visible');
                }
                if (rightPanel) {
                    rightPanel.style.display = 'none';
                    rightPanel.style.visibility = 'hidden';
                    rightPanel.style.opacity = '0';
                    rightPanel.classList.remove('visible');
                }
                
                // Initialize the application
                init();
                
                // Double-check after init() that modals and panels remain hidden
                setTimeout(() => {
                    if (valueLogicModal && valueLogicModal.style.display !== 'block') {
                        valueLogicModal.style.display = 'none';
                        valueLogicModal.style.visibility = 'hidden';
                        valueLogicModal.style.opacity = '0';
                    }
                    if (fractalModal && fractalModal.style.display !== 'block') {
                        fractalModal.style.display = 'none';
                        fractalModal.style.visibility = 'hidden';
                        fractalModal.style.opacity = '0';
                    }
                    if (nodeInfoPanel && !nodeInfoPanel.classList.contains('visible')) {
                        nodeInfoPanel.style.display = 'none';
                        nodeInfoPanel.style.visibility = 'hidden';
                        nodeInfoPanel.style.opacity = '0';
                    }
                    if (rightPanel && !rightPanel.classList.contains('visible')) {
                        rightPanel.style.display = 'none';
                        rightPanel.style.visibility = 'hidden';
                        rightPanel.style.opacity = '0';
                    }
                }, 100);
            }
            
            if (walletCloseBtn) {
                walletCloseBtn.addEventListener('click', hideWalletModal);
            }
            
            if (walletConnectBtn) {
                walletConnectBtn.addEventListener('click', proceedToMainApp);
            }
            
            // Cerrar modal al hacer click fuera de Ã©l
            if (walletModal) {
                walletModal.addEventListener('click', function(e) {
                    if (e.target === walletModal) {
                        hideWalletModal();
                    }
                });
            }
        });
    </script>
       <script type="module">
import { connectWallet, mintMoralText } from "./js/main.js";
import { uploadGlbToIpfs, uploadMetadataToIpfs } from "./js/ipfs.js";

  let connectedAddress = null;

  const startScreen = document.getElementById("start-screen");
  const startButton = document.getElementById("start-button");

  const walletModal = document.getElementById("wallet-connect-modal");
  const walletConnectBtn = document.getElementById("wallet-connect-wallet-btn");
  const walletCloseBtn = document.getElementById("wallet-connect-close-btn");

    const claimPurchaseBtn = document.getElementById("claim-purchase-btn");

    claimPurchaseBtn.addEventListener("click", async () => {
    try {
      claimPurchaseBtn.disabled = true;
      claimPurchaseBtn.textContent = "MINTING...";

      // 1) Make sure we have a GLB from Export Body
      const glbBlob = window.__latestGlbBlob;
      const glbFilename = window.__latestGlbFilename || "text-body.glb";

      if (!glbBlob) {
        alert("No GLB found. Please export your text body first.");
        return;
      }

      // 2) Upload GLB to IPFS
      const glbUp = await uploadGlbToIpfs(glbBlob, glbFilename);
      // glbUp.ipfsUri is like ipfs://...

      // Build metadata 
      // Put the GLB in animation_url
      const metadata = {
        name: "Moral Text",
        description: "Minted from the Moral Text app.",
        animation_url: glbUp.ipfsUri,
        attributes: [
          // TODO: replace these with your real values from the app
          { trait_type: "totalValue", value: window.__totalValue ?? null },
          { trait_type: "createdAt", value: new Date().toISOString() },
        ],
        // Store the raw text 
      };

      // Upload metadata JSON to IPFS
      const metaUp = await uploadMetadataToIpfs(metadata);

      // Mint using tokenURI = metadata ipfs uri
      const receipt = await mintMoralText(metaUp.ipfsUri);
      console.log("Minted:", receipt);

      console.log("Minted! Check console for tx details.");
    } catch (e) {
        console.error("Minting failed:", e);
        alert("Minting failed: " + (e?.message || e));
    } finally {
      claimPurchaseBtn.disabled = false;
      claimPurchaseBtn.textContent = "PURCHASE";
    }
  });

  // Open wallet modal when clicking CONNECT
  startButton.addEventListener("click", () => {
    walletModal.style.display = "block";
  });

  // Close modal
  walletCloseBtn.addEventListener("click", () => {
    walletModal.style.display = "none";
  });

  // Connect MetaMask
  walletConnectBtn.addEventListener("click", async () => {
    try {
      walletConnectBtn.disabled = true;
      walletConnectBtn.textContent = "CONNECTING...";

      const { address, chainId } = await connectWallet();
      connectedAddress = address;

     alert("Minted! Check console for tx details.");


      // Hide UI overlays
      walletModal.style.display = "none";
      startScreen.classList.add("hidden");

      // Unlock buttons
      document.getElementById("galleryBtn").disabled = false;

    } catch (err) {
      throw new Error(err?.message || "Wallet connection failed");
    } finally {
      walletConnectBtn.disabled = false;
      walletConnectBtn.textContent = "CONNECT WALLET";
    }
  });

  // Make address accessible later
  window.getConnectedWallet = () => connectedAddress;
</script>
</body>
</html>

