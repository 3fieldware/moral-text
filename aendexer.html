<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Text-Based Body Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            padding: 0;
            background: #000000;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        #left-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 250px;
            height: 100vh;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            background: #ffffff;
        }
        
        #left-panel.collapsed {
            background: transparent;
        }
        
        #left-panel-header-wrapper {
            background: #ffffff;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            flex-direction: row;
            gap: 5px;
            padding: 5px 10px 5px 10px;
            flex-shrink: 0;
            align-items: flex-start;
        }
        
        #left-panel.collapsed #left-panel-header-wrapper {
            border-bottom: 1px solid #ffffff;
        }

        #text-box-toggle-btn {
            padding: 0;
            background: #808080;
            border: none;
            color: #ffffff;
            cursor: pointer;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            line-height: 1.2;
            white-space: nowrap;
            flex: 0 1 auto;
        }
        
        #text-box-toggle-btn:hover {
            background: #707070;
        }

        #text-container {
            flex: 1;
            padding: 10px 10px 0 10px;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            transition: flex 0.3s ease, padding 0.3s ease;
            background: #ffffff;
        }
        
        #text-container.collapsed {
            flex: 0 0 0;
            padding: 0;
            overflow: hidden;
            background: transparent;
        }
        
        #text-container.collapsed #textInput,
        #text-container.collapsed #mapped-text-container {
            display: none;
        }

        #generate-button-container {
            padding: 5px 10px 5px 10px;
            background: #ffffff;
            display: flex;
            gap: 5px;
            align-items: flex-start;
            flex-shrink: 0;
        }
        
        #left-panel.collapsed #generate-button-container {
            display: none;
        }
        
        #generateBtn, #mapTextBtn, #clearTextBtn {
            padding: 0;
            background: #808080;
            border: none;
            color: #ffffff;
            cursor: pointer;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            line-height: 1.2;
            white-space: nowrap;
            flex: 0 1 auto;
        }

        #top-bar {
            position: fixed;
            top: 0;
            left: 250px;
            right: 0;
            height: 18px;
            z-index: 1000;
            display: flex;
            flex-direction: row;
            gap: 5px;
            background: #ffffff;
            align-items: center;
        }

        #fps-bar {
            position: fixed;
            top: 18px;
            left: 250px;
            right: 0;
            height: auto;
            min-height: 7px;
            z-index: 1000;
            background: #ff6600;
            color: #000000;
            font-size: 7px;
            font-family: Helvetica, Arial, sans-serif;
            display: flex;
            align-items: center;
            overflow: hidden;
            white-space: nowrap;
            line-height: 7px;
            padding: 0;
            transition: left 0.3s ease;
        }
        
        body.left-panel-collapsed #fps-bar {
            left: 0;
        }
        
        #realtime-info-panel {
            position: fixed;
            bottom: 0;
            left: 250px;
            right: 200px;
            height: auto;
            z-index: 998;
            background: transparent;
            padding: 2px 5px;
            overflow-x: auto;
            overflow-y: hidden;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 9px;
            color: #ffffff;
            text-align: center;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 5px;
            white-space: nowrap;
        }
        
        #realtime-info-panel .info-item {
            margin: 0;
            line-height: 1.2;
            display: inline-block;
            background: rgba(0, 0, 0, 0.35);
            padding: 2px 6px;
            text-align: right;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        #realtime-info-panel .info-label {
            font-weight: bold;
            display: inline;
        }
        
        #realtime-info-panel .info-value {
            color: #ffffff;
        }

        #max-value-panel {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 200px;
            height: 350px;
            z-index: 999;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 5px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
        }

        #max-value-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            padding: 2px;
            flex-shrink: 0;
            min-height: 15px;
        }
        
        #max-value-panel-hashtag {
            color: #000000;
            font-size: 11px;
            font-family: Helvetica, Arial, sans-serif;
            font-weight: bold;
        }

        #max-value-panel-canvas-container {
            width: 100%;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border: none;
            margin: 0 0 8px 0;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            box-sizing: border-box;
        }

        #max-value-panel-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #max-value-panel-info {
            flex: 1;
            overflow-y: visible;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 9px;
            line-height: 1.3;
            margin: 0;
            padding: 8px;
            background: #000000;
            min-height: 0;
            box-sizing: border-box;
        }
        
        #max-value-panel-info div {
            margin: 2px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        #node-list-container {
            position: fixed;
            top: 25px;
            left: 250px;
            right: 200px;
            bottom: 0;
            z-index: 998;
            overflow-y: auto;
            overflow-x: hidden;
            display: none;
            padding: 10px;
            gap: 10px;
            flex-wrap: wrap;
            align-content: flex-start;
            /* Hide scrollbar */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }
        #node-list-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        #node-list-container.visible {
            display: flex;
        }

        .node-list-item {
            width: 200px;
            height: 350px;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 5px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .node-list-item-header {
            text-align: center;
            margin-bottom: 5px;
            padding: 2px;
            flex-shrink: 0;
            min-height: 15px;
        }

        .node-list-item-canvas-container {
            width: 100%;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border: none;
            margin: 0 0 8px 0;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            box-sizing: border-box;
        }

        .node-list-item-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .node-list-item-info {
            flex: 1;
            overflow-y: visible;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 9px;
            line-height: 1.3;
            margin: 0;
            padding: 8px;
            background: #000000;
            min-height: 0;
            box-sizing: border-box;
        }

        .node-list-item-info div {
            margin: 2px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        #right-panel {
            position: fixed;
            bottom: 15px;
            right: 5px;
            width: 200px;
            height: 350px;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 0 5px 5px 5px !important;
            display: none !important;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
            visibility: hidden !important;
            opacity: 0 !important;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        #right-panel.visible {
            display: flex !important;
        }
        
        #right-panel::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        
        /* Styles for cloned right panels */
        .right-panel-clone {
            position: fixed;
            width: 200px;
            height: 350px;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 0 5px 5px 5px !important;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
            display: none;
            visibility: hidden;
            opacity: 0;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        .right-panel-clone.visible {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .right-panel-clone.visible {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .right-panel-clone::-webkit-scrollbar {
            display: none;
        }
        
        #right-panel-header {
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            margin: 0 5px 5px 5px !important;
            margin-top: 0 !important;
            padding: 0 !important;
            padding-top: 0 !important;
            flex-shrink: 0;
            min-height: auto;
        }
        
        #right-panel-close {
            background: #808080 !important;
            color: #ffffff !important;
            border: none !important;
            padding: 0 !important;
            border-radius: 0 !important;
            cursor: pointer;
            font-family: Helvetica, Arial, sans-serif !important;
            font-size: 8px !important;
            display: inline-flex !important;
            align-items: center !important;
            gap: 2px !important;
            white-space: nowrap !important;
            margin: 0 !important;
            text-transform: uppercase !important;
            line-height: 1 !important;
            height: auto !important;
            min-height: 0 !important;
        }
        
        #right-panel-close span {
            margin: 0 !important;
            padding: 0 !important;
            line-height: 1 !important;
            display: inline !important;
        }
        
        #right-panel-close span:first-child {
            font-size: 8px !important;
            margin-right: 2px !important;
        }
        
        #right-panel-close:hover {
            background: #999999;
        }
        
        #right-panel-canvas-container {
            width: calc(100% - 10px);
            height: 140px;
            background: rgba(0, 0, 0, 0.3);
            border: none;
            margin-top: 8px !important;
            margin-left: 5px !important;
            margin-right: 5px !important;
            margin-bottom: 8px !important;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        
        #node-details-content {
            flex: 1;
            overflow-y: visible;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 9px;
            line-height: 1.3;
            margin: 0 !important;
            margin-bottom: 0 !important;
            padding: 8px;
            background: #000000;
            min-height: 0;
            box-sizing: border-box;
            display: block;
        }
        
        #node-details-content div {
            margin: 2px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        #right-panel-canvas {
            width: 100%;
            height: 100%;
        }
        
        #node-details-content {
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 9px;
            line-height: 1.3;
            margin: 0;
            padding: 8px;
            background: #000000;
        }

        .top-bar-item {
            background: #ffffff;
            border: none;
            padding: 2px 6px;
            border-radius: 0;
            display: flex;
            align-items: center;
            white-space: nowrap;
            font-size: 8px;
        }

        .top-bar-item.black {
            background: #000000;
            color: #ffffff;
        }

        .top-bar-item.grey {
            background: #808080;
            color: #ffffff;
            border: none;
            text-transform: uppercase;
        }

        .control-panel h2 {
            font-size: 12px;
            margin-bottom: 6px;
            color: #000000;
            font-family: Helvetica, Arial, sans-serif;
            font-weight: normal;
        }

        #textInput {
            width: 100%;
            flex: 1;
            padding: 10px;
            background: #000000;
            border: 1px solid #000000;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            resize: none;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        #textInput::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        #textInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #mapped-text-container {
            width: 100%;
            flex: 1;
            padding: 10px;
            background: #000000;
            border: 1px solid #000000;
            color: #ffffff;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 11px;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
            -webkit-overflow-scrolling: touch;
            min-height: 0;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        #mapped-text-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        
        #value-logic-modal::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        #mapped-text-container span {
            padding: 0;
            margin: 0;
            display: inline;
        }
        

        .button-group {
            display: flex;
            gap: 0;
            flex-wrap: wrap;
            margin-top: 6px;
        }

        button {
            padding: 4px 8px;
            background: #808080;
            border: none;
            color: #ffffff;
            cursor: pointer;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 10px;
            transition: all 0.2s ease;
            border-radius: 0;
        }

        button:hover {
            background: #999999;
        }

        button:active {
            background: #666666;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #606060;
        }

        #stats {
            font-size: 10px;
            line-height: 1.4;
            color: #000000;
            font-family: Helvetica, Arial, sans-serif;
        }

        .stat-item {
            margin-bottom: 3px;
        }

        .info-text {
            font-size: 9px;
            color: #000000;
            margin-top: 0;
            line-height: 1.3;
            font-family: Helvetica, Arial, sans-serif;
        }
        
        .nametag {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 1px 3px;
            border-radius: 0;
            font-size: 8px;
            font-family: Helvetica, Arial, sans-serif;
            white-space: nowrap;
            border: none;
            transform: translate(-50%, -100%);
            margin-top: -3px;
        }
        
        .node-info-panel {
            position: fixed;
            background: #ffffff;
            border: 1px solid #000000;
            padding: 3px;
            z-index: 2000;
            pointer-events: none;
            min-width: 100px;
            max-width: 110px;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 4px;
            color: #000000;
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        
        .node-info-panel.visible {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .node-info-header {
            display: none;
        }
        
        .node-info-canvas-container {
            width: 100%;
            height: 60px;
            background: #000000;
            border: 1px solid #000000;
            margin: 0 0 2px 0;
            position: relative;
            overflow: hidden;
        }
        
        .node-info-canvas {
            width: 100%;
            height: 100%;
        }
        
        .node-info-content {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1px 1.5px;
            border: 1px solid #000000;
            padding: 1.5px;
            background: #ffffff;
        }
        
        .node-info-item {
            margin: 0;
            line-height: 1.0;
            padding: 1px;
            background: #000000;
            color: #ffffff;
        }
        
        .node-info-label {
            color: #ffffff;
            display: block;
            font-size: 3px;
            margin-bottom: 0;
        }
        
        .node-info-value {
            color: #ffffff;
            font-weight: normal;
            font-size: 3.5px;
        }
        
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0000FF;
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.3s ease;
        }
        
        #start-screen.hidden {
            opacity: 0;
            pointer-events: none;
            display: none;
        }
        
        #start-button {
            background: #808080;
            color: #ffffff;
            border: none;
            padding: 0 2px !important;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s ease;
            text-transform: uppercase;
            line-height: 1;
            margin: 0;
        }
        
        #start-button:hover {
            background: #707070;
        }
        
        #start-button:active {
            background: #606060;
        }
        
        /* Ensure these panels are completely hidden until explicitly shown */
        #node-info-panel:not(.visible),
        #right-panel:not(.visible) {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
        
        /* Ensure modals are hidden by default, but allow JavaScript to show them */
        #value-logic-modal {
            display: none;
        }
        
        #fractal-modal {
            display: none;
        }
        
        /* When modals are explicitly shown via JavaScript, they will override the default */
        #value-logic-modal[style*="display: block"],
        #value-logic-modal[style*="display: flex"] {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        #fractal-modal[style*="display: block"],
        #fractal-modal[style*="display: flex"] {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        #value-logic-modal-container,
        #fractal-modal > div {
            visibility: inherit;
            opacity: inherit;
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <button id="start-button">CONNECT</button>
    </div>
    
    <!-- Wallet Connection Modal -->
    <div id="wallet-connect-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 40000; pointer-events: auto;">
        <div id="wallet-connect-modal-container" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #ffffff; padding: 9px; border: 2px solid #000000; min-width: 300px; max-width: 400px; display: flex; flex-direction: column;">
            <div style="position: relative; margin-bottom: 12px; min-height: 18px;">
                <button id="wallet-connect-close-btn" style="position: absolute; top: 0; left: 0; background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; display: flex; align-items: center; gap: 2px; white-space: nowrap; border-radius: 0; margin: 0; min-height: 16px; height: 16px; line-height: 1;">
                    <span style="font-size: 12px;">×</span>
                    <span>CLOSE</span>
                </button>
            </div>
            <div style="margin: 0 auto 7px auto; font-family: Helvetica, Arial, sans-serif; font-size: 10px; color: #ffffff; text-align: left; background: #000000; padding: 8px 9px 8px 9px; border: 1px solid #000000; width: 98%;">
                You need to connect your wallet to continue.
            </div>
            <div style="position: relative; min-height: 27px; margin-top: 7px;">
                <button id="wallet-connect-wallet-btn" style="position: absolute; bottom: 0; right: 0; background: #808080; color: #ffffff; border: none; padding: 4px 8px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 10px; border-radius: 0; margin: 0;">CONNECT WALLET</button>
            </div>
        </div>
    </div>
    <div id="canvas-container"></div>
    
    <div id="node-info-panel" class="node-info-panel">
        <div class="node-info-canvas-container">
            <canvas id="node-info-canvas" class="node-info-canvas"></canvas>
        </div>
        <div class="node-info-content">
            <div class="node-info-item">
                <span class="node-info-label">W</span>
                <span class="node-info-value" id="info-word">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">V</span>
                <span class="node-info-value" id="info-individual-value">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">P</span>
                <span class="node-info-value" id="info-position">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">%</span>
                <span class="node-info-value" id="info-relative-value">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">POS</span>
                <span class="node-info-value" id="info-pos">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">C</span>
                <span class="node-info-value" id="info-connections">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">KB</span>
                <span class="node-info-value" id="info-size">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">Perf</span>
                <span class="node-info-value" id="info-performance">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">N</span>
                <span class="node-info-value" id="info-is-name">-</span>
            </div>
            <div class="node-info-item">
                <span class="node-info-label">S/E</span>
                <span class="node-info-value" id="info-is-ser-estar">-</span>
            </div>
        </div>
    </div>
    
    <div id="left-panel">
        <div id="left-panel-header-wrapper">
            <button id="text-box-toggle-btn">TEXT BOX</button>
        </div>
        <div id="text-container">
            <textarea id="textInput" placeholder="Enter your text here... (Max 700 words)" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
            <div id="mapped-text-container" style="display: none;"></div>
        </div>
        <div id="generate-button-container">
            <button id="generateBtn">Export Body</button>
            <button id="mapTextBtn">Preview Body</button>
            <button id="clearTextBtn">CLEAR</button>
        </div>
    </div>

    <div id="top-bar">
        <div class="top-bar-item black" id="total-value-display" style="cursor: pointer;">
            <span style="font-size: 9px; font-weight: bold; font-family: Helvetica, Arial, sans-serif;">Total Value: <span id="valueScore">0.00</span> <span id="valueETH"></span></span>
        </div>
        <button class="top-bar-item grey" id="exportBtn" disabled style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 8px;">CLAIM</button>
        <button class="top-bar-item grey" id="galleryBtn" disabled style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 8px;">GALLERY</button>
        <button class="top-bar-item grey" id="toggleNametagsBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 8px;">Show Nametags</button>
        <button class="top-bar-item grey" id="nodeListBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 8px;">TOP NODES</button>
        <button class="top-bar-item grey" id="resetCameraBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 8px;">Reset View</button>
        <button class="top-bar-item grey" id="fullscreenBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 8px;">Fullscreen</button>
        <button class="top-bar-item grey" id="backgroundColorBtn" style="cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 8px; display: flex; align-items: center; gap: 4px;">
            <span id="bgColorSquare" style="display: inline-block; width: 10px; height: 10px; background: #0000FF; border: 1px solid #000000;"></span>
            <span>BG</span>
        </button>
        <a href="https://s02.bianjie.systems/" target="_blank" class="top-bar-item" style="margin-left: auto; background: #808080; text-decoration: none; padding: 2px 4px;">
            <span style="font-size: 8px; font-family: Helvetica, Arial, sans-serif; font-weight: bold; color: #ffffff;">CPAAF </span>
            <span style="font-size: 8px; font-family: Helvetica, Arial, sans-serif; font-weight: bold; color: #ffffff;">[critical point as a field]</span>
            <span style="font-size: 8px; font-family: Helvetica, Arial, sans-serif; font-weight: bold; color: #ffffff;"> as part of</span>
            <span style="font-size: 8px; font-family: Helvetica, Arial, sans-serif; font-weight: bold; color: #ffffff; text-transform: uppercase;"> [IMPLICIT-EXPLICIT] </span>
            <span style="font-size: 8px; font-family: Helvetica, Arial, sans-serif; font-weight: bold; color: #ffffff;">projects</span>
        </a>
    </div>

    <div id="fps-bar">
        <span id="fpsRepeated"></span>
    </div>

    <div id="realtime-info-panel">
        <div class="info-item">
            <span class="info-label">FPS:</span>
            <span class="info-value" id="realtime-fps">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Camera:</span>
            <span class="info-value">X: <span id="realtime-camera-x">0.00</span> Y: <span id="realtime-camera-y">0.00</span> Z: <span id="realtime-camera-z">0.00</span></span>
        </div>
        <div class="info-item">
            <span class="info-label">Nodes:</span>
            <span class="info-value" id="realtime-nodes">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Connections:</span>
            <span class="info-value" id="realtime-connections">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Names:</span>
            <span class="info-value" id="realtime-names">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Nouns:</span>
            <span class="info-value" id="realtime-nouns">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Verbs:</span>
            <span class="info-value" id="realtime-verbs">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Adj:</span>
            <span class="info-value" id="realtime-adjectives">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Adv:</span>
            <span class="info-value" id="realtime-adverbs">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Other:</span>
            <span class="info-value" id="realtime-other">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Total Value:</span>
            <span class="info-value" id="realtime-total-value">0.00 ETH</span>
        </div>
        <div class="info-item">
            <span class="info-label">Avg Value/Node:</span>
            <span class="info-value" id="realtime-avg-value">0.00 ETH</span>
        </div>
    </div>

    <div id="node-list-container"></div>

    <!-- Value Logic Summary Modal -->
    <div id="value-logic-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0); z-index: 10000; overflow-y: auto; pointer-events: none; scrollbar-width: none; -ms-overflow-style: none;">
        <div id="value-logic-modal-container" style="position: absolute; max-width: 400px; background: rgba(220, 220, 220, 0.76); padding: 4px 12px 12px 12px; border-radius: 0; color: #000000; font-family: Helvetica, Arial, sans-serif; pointer-events: auto;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 3px; margin-top: 0;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <button id="close-value-logic-modal" style="background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; display: flex; align-items: center; gap: 2px; white-space: nowrap; border-radius: 0; margin: 0; min-height: 16px; height: 16px;">
                        <span style="font-size: 12px;">×</span>
                        <span>CLOSE</span>
                    </button>
                    <button id="value-logic-save-btn" style="background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; display: flex; align-items: center; gap: 2px; white-space: nowrap; border-radius: 0; margin: 0; justify-content: center; min-height: 16px; height: 16px;">
                        SAVE
                    </button>
                </div>
                <div id="value-logic-color-btn" style="width: 16px; height: 16px; background: #808080; border: none; cursor: pointer; padding: 1px; display: flex; align-items: center; justify-content: center; border-radius: 0; margin: 0; position: absolute; top: 4px; right: 12px;">
                    <div id="value-logic-color-indicator" style="width: 12px; height: 12px; background: #000000; border-radius: 0;"></div>
                </div>
            </div>
            <div id="value-logic-content" style="font-size: 11px; line-height: 1.1; color: #000000; margin-top: 5px;">
                <!-- Content will be generated here -->
            </div>
            <div id="value-logic-overview-container" style="width: 100%; max-width: 100%; height: 150px; background: #000000; border: 1px solid #ffffff; margin-top: 5px; margin-bottom: 5px; border-radius: 0; position: relative; display: none; overflow: hidden; box-sizing: border-box;">
                <canvas id="value-logic-overview-canvas" style="width: 100%; height: 100%; display: block;"></canvas>
            </div>
            <div id="value-logic-top5-grid" style="display: none; margin-top: 5px; margin-bottom: 5px;">
                <!-- Top 4 nodes and fractals will be generated here -->
            </div>
            <div id="value-logic-total-box" style="background: #000000; border: 1px solid #ffffff; padding: 6px; margin-top: 5px; border-radius: 0; display: none;">
                <div style="color: #ffffff; font-size: 11px;"><strong>Total Value:</strong> <span id="value-logic-total-display">-</span></div>
            </div>
        </div>
    </div>

    <!-- Claim Modal -->
    <div id="claim-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0); z-index: 30000; overflow-y: auto; pointer-events: auto; scrollbar-width: none; -ms-overflow-style: none;">
        <style>
            #claim-modal::-webkit-scrollbar {
                display: none;
            }
            #claim-total-value-container::-webkit-scrollbar {
                display: none;
                width: 0;
                height: 0;
            }
            #claim-nodes-list-container::-webkit-scrollbar {
                display: none;
                width: 0;
                height: 0;
            }
            #claim-modal-container::-webkit-scrollbar {
                display: none;
                width: 0;
                height: 0;
            }
            #claim-total-value-container {
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            #claim-nodes-list-container {
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
        </style>
        <div id="claim-modal-container" style="position: relative; width: 100%; max-width: 730px; margin: 60px auto 20px auto; padding: 10px; background: rgba(255, 255, 255, 0.7); border: 1px solid #000000;">
            <div style="display: flex; justify-content: flex-start; align-items: center; margin-bottom: 10px;">
                <button id="claim-back-btn" style="background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; border-radius: 0; display: flex; align-items: center; gap: 2px; white-space: nowrap;"><span style="font-size: 12px;">×</span><span>CLOSE</span></button>
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: nowrap; margin-bottom: 10px; align-items: flex-start;">
                <div id="claim-3d-container" style="flex: 0 0 auto; width: 350px; height: 500px; background: #000000; position: relative; border: 1px solid #000000;"></div>
                <div id="claim-total-value-container" style="flex: 0 0 auto; width: 350px; height: 500px; background: rgba(220, 220, 220, 0.95); padding: 4px 8px 8px 8px; border-radius: 0; color: #000000; font-family: Helvetica, Arial, sans-serif; overflow-y: auto; scrollbar-width: none; -ms-overflow-style: none; border: 1px solid #000000; position: relative;">
                    <div id="claim-total-value-content"></div>
                    <button id="claim-scroll-down-btn" style="position: absolute; bottom: 5px; right: 5px; background: rgba(128, 128, 128, 0.7); color: #ffffff; border: none; padding: 2px 4px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 8px; border-radius: 0; z-index: 10;">↓</button>
                </div>
            </div>
            <div style="text-align: center; margin-top: 10px;">
                <button id="claim-purchase-btn" style="background: #808080; color: #ffffff; border: none; padding: 4px 8px; font-size: 10px; font-family: Helvetica, Arial, sans-serif; cursor: pointer; border-radius: 0;">PURCHASE</button>
            </div>
        </div>
    </div>

    <!-- Fractal Modal -->
    <div id="fractal-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0); z-index: 20000; overflow-y: auto; pointer-events: none;">
        <div id="fractal-modal-container" style="position: absolute; top: 25px; right: 0px; max-width: 300px; background: rgba(220, 220, 220, 0.76); padding: 4px 6px 6px 6px; border-radius: 0; color: #000000; font-family: Helvetica, Arial, sans-serif; pointer-events: auto;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 3px; margin-top: 0;">
                <button id="close-fractal-modal" style="background: #808080; color: #ffffff; border: none; padding: 1px 3px; cursor: pointer; font-family: Helvetica, Arial, sans-serif; font-size: 9px; display: flex; align-items: center; gap: 2px; white-space: nowrap; border-radius: 0; margin: 0; min-height: 16px; height: 16px;">
                    <span style="font-size: 12px;">×</span>
                    <span>CLOSE</span>
                </button>
                <div id="fractal-word-title" style="color: #000000; font-size: 10px; font-weight: bold; font-family: Helvetica, Arial, sans-serif; text-transform: uppercase; position: absolute; left: 50%; transform: translateX(-50%);">CP: <span id="fractal-word-name">-</span></div>
                <div></div>
            </div>
            <canvas id="fractal-canvas" style="width: 100%; max-width: 100%; height: 200px; display: block; background: #000000; border: 1px solid #ffffff;"></canvas>
        </div>
    </div>

    <div id="max-value-panel">
        <div id="max-value-panel-header">
            <span id="max-value-panel-hashtag">#1</span>
            <h3 id="max-value-panel-word" style="color: #000000; font-size: 11px; margin: 0; font-family: Helvetica, Arial, sans-serif;">-</h3>
        </div>
        <div id="max-value-panel-canvas-container">
            <canvas id="max-value-panel-canvas"></canvas>
        </div>
        <div id="max-value-panel-info">
            <div><strong>Word:</strong> <span id="max-value-word">-</span></div>
            <div><strong>Individual Value:</strong> <span id="max-value-individual-value">-</span></div>
            <div><strong>Position in Text:</strong> <span id="max-value-position">-</span></div>
            <div><strong>Value / Total:</strong> <span id="max-value-relative-value">-</span></div>
            <div><strong>Part of Speech:</strong> <span id="max-value-pos">-</span></div>
            <div><strong>Connections:</strong> <span id="max-value-connections">-</span></div>
            <div><strong>Size (KB):</strong> <span id="max-value-size">-</span></div>
            <div><strong>Performance:</strong> <span id="max-value-performance">-</span></div>
            <div><strong>Is Name:</strong> <span id="max-value-is-name">-</span></div>
            <div><strong>Is identity:</strong> <span id="max-value-is-ser-estar">-</span></div>
        </div>
    </div>

    <div id="right-panel">
        <div id="right-panel-header">
            <button id="right-panel-close" style="padding: 0 !important; margin: 0 !important;">
                <span style="font-size: 8px !important; padding: 0 !important; margin: 0 !important;">×</span>
                <span style="padding: 0 !important; margin: 0 !important;">CLOSE</span>
            </button>
        </div>
        <h3 id="right-panel-word" style="position: absolute; top: 2px; right: 5px; color: #000000; font-size: 11px; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; z-index: 10;">-</h3>
        <div id="right-panel-canvas-container">
            <canvas id="right-panel-canvas"></canvas>
        </div>
        <div id="node-details-content">
            <div><strong>Word:</strong> <span id="detail-word">-</span></div>
            <div><strong>Individual Value:</strong> <span id="detail-individual-value">-</span></div>
            <div><strong>Position in Text:</strong> <span id="detail-position">-</span></div>
            <div><strong>Value / Total:</strong> <span id="detail-relative-value">-</span></div>
            <div><strong>Part of Speech:</strong> <span id="detail-pos">-</span></div>
            <div><strong>Connections:</strong> <span id="detail-connections">-</span></div>
            <div><strong>Size (KB):</strong> <span id="detail-size">-</span></div>
            <div><strong>Performance:</strong> <span id="detail-performance">-</span></div>
            <div><strong>Is Name:</strong> <span id="detail-is-name">-</span></div>
            <div><strong>Is identity:</strong> <span id="detail-is-ser-estar">-</span></div>
        </div>
    </div>

    <script>
        // ==================== VARIABLES GLOBALES ====================
        let scene, camera, renderer;
        let nodes = [];
        let connections = [];
        let analyzedWords = [];
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngleX = 0;
        let cameraAngleY = 0;
        let cameraRadius = 10;
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        // Store initial camera values for reset
        const initialCameraRadius = 10;
        const initialCameraAngleX = 0;
        const initialCameraAngleY = 0;
        const initialCameraTarget = new THREE.Vector3(0, 0, 0);
        let nametagsVisible = false;
        let nametags = [];
        let mappedTextVisible = false;
        let nodeListVisible = false;
        let nodeListItems = [];
        let nodeListScenes = [];
        let nodeListRenderers = [];
        let nodeListMeshes = [];
        let nodeListAnimationIds = [];
        let nodeListIntersectionObserver = null;
        // Renderer compartido para nodos de la lista (evita múltiples contextos WebGL)
        let sharedTopNodesRenderer = null;
        let sharedTopNodesScene = null;
        let sharedTopNodesCamera = null;
        let ethPriceUSD = null; // Store current Ethereum price in USD
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let hoveredNode = null;
        let selectedNode = null; // Node currently displayed in right-panel
        let nodeInfoPanel = null;
        let nodeInfoCanvas = null;
        let nodeInfoRenderer = null;
        let nodeInfoScene = null;
        let nodeInfoCamera = null;
        let nodeInfoMesh = null;
        let rightPanelCanvas = null;
        let rightPanelRenderer = null;
        let rightPanelScene = null;
        let rightPanelCamera = null;
        let rightPanelMesh = null;
        let rightPanelAnimationId = null;
        
        // Multiple right panels system
        let rightPanels = []; // Array of active panel objects: { id, element, node, scene, renderer, camera, mesh, animationId, offset }
        let rightPanelCounter = 0; // Counter for unique panel IDs
        const MAX_RIGHT_PANELS = 5;
        let availableOffsets = []; // Stack of available offsets when panels are closed
        let maxValuePanelCanvas = null;
        let maxValuePanelRenderer = null;
        let maxValuePanelScene = null;
        let maxValuePanelCamera = null;
        let maxValuePanelMesh = null;
        
        // Fractal generation
        let fractalCanvas = null;
        let fractalCtx = null;
        let fractalWorker = null;
        let currentFractalWordIndex = -1;
        let fractalGenerationInProgress = false;
        let maxValuePanelAnimationId = null;
        let maxValueNode = null;
        let currentBackgroundColor = 0x0000FF; // Start with blue (AZUL)
        let backgroundColorIndex = 0; // 0=AZUL, 1=NEGRO, 2=GRIS
        const backgroundColors = [0x0000FF, 0x000000, 0x808080]; // AZUL, NEGRO, GRIS
        const backgroundColorNames = ['AZUL', 'NEGRO', 'GRIS'];
        let keysPressed = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };
        let valueLogicColorMode = false; // false = black boxes, true = white boxes
        let valueLogicOverviewScene = null;
        let valueLogicOverviewRenderer = null;
        let valueLogicOverviewCamera = null;
        let valueLogicOverviewNodes = [];
        let valueLogicOverviewAnimationId = null;
        let visualizationGenerationDate = null; // Store date/time when visualization is generated

        // ==================== INICIALIZACIÓN ====================
        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(currentBackgroundColor); // Background color (AZUL, NEGRO, or GRIS)

            // Create camera with reduced far plane for performance
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500); // Reduced far plane from 1000 to 500
            updateCameraPosition();

            // Create renderer with reduced quality for better performance
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, // Disable antialiasing for performance
                powerPreference: "low-power" // Use low power mode
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(currentBackgroundColor, 1); // Background color (AZUL, NEGRO, or GRIS)
            renderer.setPixelRatio(0.75); // Reduce pixel ratio for better performance
            
            // Handle WebGL context loss
            renderer.domElement.addEventListener('webglcontextlost', function(event) {
                event.preventDefault();
                console.warn('WebGL context lost');
            });
            
            renderer.domElement.addEventListener('webglcontextrestored', function() {
                console.log('WebGL context restored');
                // Re-initialize if needed
                renderer.setClearColor(currentBackgroundColor, 1);
            });
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights (reduced for performance)
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reduced intensity
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = false; // Disable shadows for performance
            scene.add(directionalLight);

            // Event listeners
            setupEventListeners();

            // Initialize node info panel for hover
            nodeInfoPanel = document.getElementById('node-info-panel');
            nodeInfoCanvas = document.getElementById('node-info-canvas');
            
            // Create 3D scene for enlarged node view
            nodeInfoScene = new THREE.Scene();
            nodeInfoScene.background = new THREE.Color(0x000000);
            
            nodeInfoCamera = new THREE.PerspectiveCamera(50, 100 / 60, 0.1, 100);
            nodeInfoCamera.position.set(0, 0, 2);
            nodeInfoCamera.lookAt(0, 0, 0);
            
            nodeInfoRenderer = new THREE.WebGLRenderer({ 
                canvas: nodeInfoCanvas,
                antialias: false
            });
            nodeInfoRenderer.setSize(100, 60);
            nodeInfoRenderer.setPixelRatio(0.75);
            
            // Add lights
            const nodeInfoAmbientLight = new THREE.AmbientLight(0x404040, 0.6);
            nodeInfoScene.add(nodeInfoAmbientLight);
            
            const nodeInfoDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            nodeInfoDirectionalLight.position.set(2, 2, 2);
            nodeInfoScene.add(nodeInfoDirectionalLight);
            
            // Initialize right panel canvas for enlarged node view
            rightPanelCanvas = document.getElementById('right-panel-canvas');
            
            // Create 3D scene for right panel enlarged node view
            rightPanelScene = new THREE.Scene();
            rightPanelScene.background = new THREE.Color(0x000000);
            
            rightPanelCamera = new THREE.PerspectiveCamera(50, 200 / 150, 0.1, 100);
            rightPanelCamera.position.set(0, 0, 2);
            rightPanelCamera.lookAt(0, 0, 0);
            
            rightPanelRenderer = new THREE.WebGLRenderer({ 
                canvas: rightPanelCanvas,
                antialias: false
            });
            rightPanelRenderer.setSize(200, 150);
            rightPanelRenderer.setPixelRatio(0.75);
            
            // Add lights
            const rightPanelAmbientLight = new THREE.AmbientLight(0x404040, 0.6);
            rightPanelScene.add(rightPanelAmbientLight);
            
            const rightPanelDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            rightPanelDirectionalLight.position.set(2, 2, 2);
            rightPanelScene.add(rightPanelDirectionalLight);
            
            // Initialize max-value-panel
            maxValuePanelCanvas = document.getElementById('max-value-panel-canvas');
            
            // Create 3D scene for max-value-panel
            maxValuePanelScene = new THREE.Scene();
            maxValuePanelScene.background = new THREE.Color(0x000000);
            
            maxValuePanelCamera = new THREE.PerspectiveCamera(50, 200 / 120, 0.1, 100);
            maxValuePanelCamera.position.set(0, 0, 2);
            maxValuePanelCamera.lookAt(0, 0, 0);
            
            maxValuePanelRenderer = new THREE.WebGLRenderer({ 
                canvas: maxValuePanelCanvas,
                antialias: false
            });
            maxValuePanelRenderer.setSize(200, 120);
            maxValuePanelRenderer.setPixelRatio(0.75);
            
            // Add lights
            const maxValuePanelAmbientLight = new THREE.AmbientLight(0x404040, 0.6);
            maxValuePanelScene.add(maxValuePanelAmbientLight);
            
            const maxValuePanelDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            maxValuePanelDirectionalLight.position.set(2, 2, 2);
            maxValuePanelScene.add(maxValuePanelDirectionalLight);
            
            // Start animation
            animate();
        }

        function toggleTextBox() {
            const textContainer = document.getElementById('text-container');
            const leftPanel = document.getElementById('left-panel');
            textContainer.classList.toggle('collapsed');
            leftPanel.classList.toggle('collapsed');
            // Add/remove class to body to control fps-bar position
            if (leftPanel.classList.contains('collapsed')) {
                document.body.classList.add('left-panel-collapsed');
            } else {
                document.body.classList.remove('left-panel-collapsed');
            }
        }

        function setupEventListeners() {
            // Buttons
            document.getElementById('generateBtn').addEventListener('click', generateVisualization);
            document.getElementById('exportBtn').addEventListener('click', navigateToClaim);
            document.getElementById('resetCameraBtn').addEventListener('click', resetCamera);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            document.getElementById('toggleNametagsBtn').addEventListener('click', toggleNametags);
            document.getElementById('nodeListBtn').addEventListener('click', toggleNodeList);
            document.getElementById('mapTextBtn').addEventListener('click', mapText);
            document.getElementById('backgroundColorBtn').addEventListener('click', changeBackgroundColor);
            document.getElementById('right-panel-close').addEventListener('click', hideNodeDetails);
            document.getElementById('total-value-display').addEventListener('click', showValueLogicSummary);
            document.getElementById('close-value-logic-modal').addEventListener('click', hideValueLogicSummary);
            
            // Claim modal buttons
            const claimBackBtn = document.getElementById('claim-back-btn');
            const claimPurchaseBtn = document.getElementById('claim-purchase-btn');
            if (claimBackBtn) {
                claimBackBtn.addEventListener('click', hideClaimModal);
            }
            if (claimPurchaseBtn) {
                claimPurchaseBtn.addEventListener('click', downloadClaimPurchasePack);
            }
            const claimScrollDownBtn = document.getElementById('claim-scroll-down-btn');
            if (claimScrollDownBtn) {
                claimScrollDownBtn.addEventListener('click', function() {
                    const totalValueContainer = document.getElementById('claim-total-value-container');
                    if (totalValueContainer) {
                        totalValueContainer.scrollTo({
                            top: totalValueContainer.scrollHeight,
                            behavior: 'smooth'
                        });
                    }
                });
            }
            const colorBtn = document.getElementById('value-logic-color-btn');
            if (colorBtn) {
                colorBtn.addEventListener('click', toggleValueLogicColorMode);
                // Initialize color indicator
                const indicator = document.getElementById('value-logic-color-indicator');
                if (indicator) {
                    indicator.style.background = valueLogicColorMode ? '#ffffff' : '#000000';
                }
            }
            const saveBtn = document.getElementById('value-logic-save-btn');
            if (saveBtn) {
                saveBtn.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent event from bubbling up
                    saveValueLogicSummaryAsImage();
                });
            }
            
            // Close modal when clicking outside (only on the modal container, not the overlay)
            const modalContainer = document.getElementById('value-logic-modal-container');
            if (modalContainer) {
                document.addEventListener('click', (e) => {
                    const modal = document.getElementById('value-logic-modal');
                    // Don't close if clicking on SAVE button or its parent container
                    const isSaveButton = e.target.id === 'value-logic-save-btn' || e.target.closest('#value-logic-save-btn');
                    if (modal.style.display === 'block' && !modalContainer.contains(e.target) && e.target.id !== 'total-value-display' && !e.target.closest('#total-value-display') && !isSaveButton) {
                        hideValueLogicSummary();
                    }
                });
            }
            document.getElementById('clearTextBtn').addEventListener('click', clearTextBox);
            document.getElementById('text-box-toggle-btn').addEventListener('click', toggleTextBox);
            
            // Initialize fractal modal
            fractalCanvas = document.getElementById('fractal-canvas');
            if (fractalCanvas) {
                fractalCtx = fractalCanvas.getContext('2d');
                fractalCanvas.width = 288; // Match modal width (300px - padding 6px * 2)
                fractalCanvas.height = 200;
            }
            document.getElementById('close-fractal-modal').addEventListener('click', function() {
                document.getElementById('fractal-modal').style.display = 'none';
                fractalGenerationInProgress = false;
            });
            
            // Setup fractal click listeners
            setupFractalClickListeners();
            
            // Text input validation - limit to 700 words
            const textInput = document.getElementById('textInput');
            textInput.addEventListener('input', limitWordCount);
            textInput.addEventListener('paste', handlePaste);
            textInput.addEventListener('keydown', function(event) {
                // Allow backspace, delete, arrow keys, etc.
                if (event.key === 'Backspace' || event.key === 'Delete' || 
                    event.key.startsWith('Arrow') || event.key === 'Tab' ||
                    (event.ctrlKey && (event.key === 'a' || event.key === 'c' || event.key === 'v' || event.key === 'x'))) {
                    return; // Allow these keys
                }
                
                // Check if adding this character would exceed the limit
                const currentText = textInput.value;
                const selectionStart = textInput.selectionStart;
                const selectionEnd = textInput.selectionEnd;
                const newText = currentText.substring(0, selectionStart) + 
                              (event.key.length === 1 ? event.key : '') + 
                              currentText.substring(selectionEnd);
                const words = splitTextIntoWords(newText);
                
                if (words.length > 700) {
                    event.preventDefault();
                    // Show warning
                    const existingWarning = document.getElementById('wordLimitWarning');
                    if (existingWarning) {
                        existingWarning.remove();
                    }
                    const warning = document.createElement('div');
                    warning.id = 'wordLimitWarning';
                    warning.style.cssText = 'color: #ff6600; font-size: 11px; margin-top: 5px;';
                    warning.textContent = 'Maximum 700 words reached. Cannot type more.';
                    textInput.parentNode.appendChild(warning);
                    setTimeout(() => {
                        if (warning.parentNode) {
                            warning.parentNode.removeChild(warning);
                        }
                    }, 3000);
                }
            });

            // Camera controls
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Mouse move for hover (condensed info)
            renderer.domElement.addEventListener('mousemove', onMouseMoveHover);
            
            // Mouse move for coordinates update
            renderer.domElement.addEventListener('mousemove', onMouseMoveCoordinates);
            
            // Mouse click for detailed info in side panel
            renderer.domElement.addEventListener('click', onNodeClick);
            
            // Keyboard navigation
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            // Resize
            window.addEventListener('resize', onWindowResize);
        }

        function updateCameraPosition() {
            const x = Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraRadius;
            const y = Math.sin(cameraAngleX) * cameraRadius;
            const z = Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraRadius;

            camera.position.set(x, y, z);
            camera.lookAt(cameraTarget);
            
            // Update coordinates display when camera moves
            updateCoordinatesDisplay();
        }

        // ==================== ANÁLISIS LINGÜÍSTICO ====================
        // Conjunto ampliado de palabras comunes que pueden ir en mayúscula sin ser nombres propios
        const COMMON_CAPITALIZED_WORDS = new Set([
            // English articles / determiners / pronouns / conjunctions
            'I','The','A','An','This','That','These','Those','He','She','We','They','You','It','And','Or','But','If','When','Where','How','Why','What','Who',
            // Spanish equivalents
            'El','La','Los','Las','Un','Una','Unos','Unas','Este','Esta','Estos','Estas','Ese','Esa','Esos','Esas','Aquel','Aquella','Aquellos','Aquellas',
            'Yo','Tú','Él','Ella','Nosotros','Nosotras','Vosotros','Vosotras','Ellos','Ellas','Usted','Ustedes','Y','O','Pero','Si','Cuando','Donde','Como',
            // Common discourse markers often capitalized at line start
            'Thus','Therefore','Hence','However','Nevertheless','Moreover','Meanwhile','Entonces','Sin','Embargo','Además','Asimismo',
            // Months / days (frequently capitalized but not names)
            'Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday',
            'January','February','March','April','May','June','July','August','September','October','November','December',
            'Lunes','Martes','Miércoles','Jueves','Viernes','Sábado','Domingo',
            'Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'
        ]);

        function getPOS(word, context) {
            // context = { prevWord: string, nextWord: string, index: number, allWords: array }
            const originalWord = word; // Keep original for capitalization check
            const cleanWord = word.replace(/[^\w\u4e00-\u9fff]/g, '').toLowerCase();
            
            // FIRST: Check if it's a known proper noun (like "Carbajal") - these are always nouns
            if (KNOWN_PROPER_NOUNS.has(cleanWord)) {
                return 'noun';
            }
            
            // SECOND: Check if capitalized (likely a proper noun/name) - prioritize noun classification
            const isCapitalized = /^[A-Z\u00C0-\u017F]/.test(originalWord.replace(/[^\w\u4e00-\u9fff]/g, '')) && originalWord.length > 1;
            if (isCapitalized && !COMMON_CAPITALIZED_WORDS.has(originalWord) && !COMMON_CAPITALIZED_WORDS.has(originalWord.toLowerCase())) {
                // Capitalized words that aren't common words are likely proper nouns (names)
                return 'noun';
            }
            
            // Verificar si contiene caracteres chinos
            const hasChinese = /[\u4e00-\u9fff]/.test(cleanWord);
            
            if (hasChinese) {
                return classifyChineseCharacter(cleanWord);
            } else {
                return classifyLatinWord(cleanWord, context);
            }
        }

        function classifyChineseCharacter(char) {
            const chinesePOS = {
                '人': 'noun', '天': 'noun', '地': 'noun', '水': 'noun', '火': 'noun',
                '是': 'verb', '有': 'verb', '在': 'verb', '来': 'verb', '去': 'verb',
                '大': 'adjective', '小': 'adjective', '好': 'adjective', '坏': 'adjective',
                '很': 'adverb', '太': 'adverb', '非常': 'adverb'
            };
            
            return chinesePOS[char] || 'noun';
        }

        function classifyLatinWord(word, context) {
            // context = { prevWord: string, nextWord: string, index: number, allWords: array }
            const prevWord = context?.prevWord ? context.prevWord.replace(/[^\w\u4e00-\u9fff]/g, '').toLowerCase() : '';
            const nextWord = context?.nextWord ? context.nextWord.replace(/[^\w\u4e00-\u9fff]/g, '').toLowerCase() : '';
            
            // Most common English verbs (based on frequency lists)
            const commonVerbs = new Set([
                // Most frequent English verbs
                'have', 'has', 'had', 'having', 'do', 'does', 'did', 'done', 'doing', 'say', 'says', 'said', 'saying',
                'go', 'goes', 'went', 'gone', 'going', 'get', 'gets', 'got', 'gotten', 'getting', 'make', 'makes', 'made', 'making',
                'know', 'knows', 'knew', 'known', 'knowing', 'think', 'thinks', 'thought', 'thinking', 'take', 'takes', 'took', 'taken', 'taking',
                'see', 'sees', 'saw', 'seen', 'seeing', 'come', 'comes', 'came', 'coming', 'want', 'wants', 'wanted', 'wanting',
                'use', 'uses', 'used', 'using', 'find', 'finds', 'found', 'finding', 'give', 'gives', 'gave', 'given', 'giving',
                'tell', 'tells', 'told', 'telling', 'work', 'works', 'worked', 'working', 'call', 'calls', 'called', 'calling',
                'try', 'tries', 'tried', 'trying', 'ask', 'asks', 'asked', 'asking', 'need', 'needs', 'needed', 'needing',
                'feel', 'feels', 'felt', 'feeling', 'become', 'becomes', 'became', 'become', 'becoming', 'leave', 'leaves', 'left', 'leaving',
                'put', 'puts', 'putting', 'mean', 'means', 'meant', 'meaning', 'keep', 'keeps', 'kept', 'keeping',
                'let', 'lets', 'letting', 'begin', 'begins', 'began', 'begun', 'beginning', 'seem', 'seems', 'seemed', 'seeming',
                'help', 'helps', 'helped', 'helping', 'talk', 'talks', 'talked', 'talking', 'turn', 'turns', 'turned', 'turning',
                'start', 'starts', 'started', 'starting', 'show', 'shows', 'showed', 'shown', 'showing', 'hear', 'hears', 'heard', 'hearing',
                'play', 'plays', 'played', 'playing', 'run', 'runs', 'ran', 'running', 'move', 'moves', 'moved', 'moving',
                'like', 'likes', 'liked', 'liking', 'live', 'lives', 'lived', 'living', 'believe', 'believes', 'believed', 'believing',
                'hold', 'holds', 'held', 'holding', 'bring', 'brings', 'brought', 'bringing', 'happen', 'happens', 'happened', 'happening',
                'write', 'writes', 'wrote', 'written', 'writing', 'sit', 'sits', 'sat', 'sitting', 'stand', 'stands', 'stood', 'standing',
                'lose', 'loses', 'lost', 'losing', 'pay', 'pays', 'paid', 'paying', 'meet', 'meets', 'met', 'meeting',
                'include', 'includes', 'included', 'including', 'continue', 'continues', 'continued', 'continuing', 'set', 'sets', 'setting',
                'learn', 'learns', 'learned', 'learnt', 'learning', 'change', 'changes', 'changed', 'changing', 'lead', 'leads', 'led', 'leading',
                'understand', 'understands', 'understood', 'understanding', 'watch', 'watches', 'watched', 'watching', 'follow', 'follows', 'followed', 'following',
                'stop', 'stops', 'stopped', 'stopping', 'create', 'creates', 'created', 'creating', 'speak', 'speaks', 'spoke', 'spoken', 'speaking',
                'read', 'reads', 'reading', 'spend', 'spends', 'spent', 'spending', 'grow', 'grows', 'grew', 'grown', 'growing',
                'open', 'opens', 'opened', 'opening', 'walk', 'walks', 'walked', 'walking', 'win', 'wins', 'won', 'winning',
                'teach', 'teaches', 'taught', 'teaching', 'offer', 'offers', 'offered', 'offering', 'remember', 'remembers', 'remembered', 'remembering',
                'love', 'loves', 'loved', 'loving', 'consider', 'considers', 'considered', 'considering', 'appear', 'appears', 'appeared', 'appearing',
                'buy', 'buys', 'bought', 'buying', 'serve', 'serves', 'served', 'serving', 'die', 'dies', 'died', 'dying',
                'send', 'sends', 'sent', 'sending', 'build', 'builds', 'built', 'building', 'stay', 'stays', 'stayed', 'staying',
                'fall', 'falls', 'fell', 'fallen', 'falling', 'cut', 'cuts', 'cutting', 'reach', 'reaches', 'reached', 'reaching',
                'kill', 'kills', 'killed', 'killing', 'raise', 'raises', 'raised', 'raising', 'pass', 'passes', 'passed', 'passing',
                'sell', 'sells', 'sold', 'selling', 'decide', 'decides', 'decided', 'deciding', 'return', 'returns', 'returned', 'returning',
                'explain', 'explains', 'explained', 'explaining', 'develop', 'develops', 'developed', 'developing', 'carry', 'carries', 'carried', 'carrying',
                'break', 'breaks', 'broke', 'broken', 'breaking', 'receive', 'receives', 'received', 'receiving', 'agree', 'agrees', 'agreed', 'agreeing',
                'support', 'supports', 'supported', 'supporting', 'hit', 'hits', 'hitting', 'produce', 'produces', 'produced', 'producing',
                'eat', 'eats', 'ate', 'eaten', 'eating', 'cover', 'covers', 'covered', 'covering', 'catch', 'catches', 'caught', 'catching',
                'draw', 'draws', 'drew', 'drawn', 'drawing', 'choose', 'chooses', 'chose', 'chosen', 'choosing'
            ]);
            
            // Most common Spanish verbs
            const commonSpanishVerbs = new Set([
                'ser', 'estar', 'haber', 'tener', 'hacer', 'poder', 'decir', 'ir', 'ver', 'dar', 'saber', 'querer',
                'llegar', 'pasar', 'deber', 'poner', 'parecer', 'quedar', 'hablar', 'llevar', 'dejar', 'seguir',
                'encontrar', 'llamar', 'venir', 'pensar', 'salir', 'volver', 'tomar', 'conocer', 'vivir', 'sentir',
                'tratar', 'mirar', 'contar', 'empezar', 'esperar', 'buscar', 'existir', 'entrar', 'trabajar',
                'escribir', 'perder', 'producir', 'ocurrir', 'entender', 'pedir', 'recibir', 'recordar', 'terminar',
                'permitir', 'aparecer', 'conseguir', 'comenzar', 'servir', 'sacar', 'necesitar', 'mantener',
                'resultar', 'leer', 'caer', 'cambiar', 'presentar', 'crear', 'abrir', 'considerar', 'oír', 'acabar',
                'convertir', 'ganar', 'formar', 'traer', 'partir', 'morir', 'aceptar', 'realizar', 'suponer',
                'comprender', 'lograr', 'explicar', 'preguntar', 'tocar', 'reconocer', 'estudiar', 'alcanzar',
                'nacer', 'dirigir', 'correr', 'utilizar', 'pagar', 'ayudar', 'gustar', 'jugar', 'escuchar',
                'cumplir', 'ofrecer', 'descubrir', 'levantar', 'intentar', 'usar', 'decidir', 'reducir', 'establecer',
                'es', 'son', 'está', 'están', 'fue', 'fueron', 'estuvo', 'estuvieron', 'tiene', 'tienen', 'tenía', 'tenían',
                'hace', 'hacen', 'hizo', 'hicieron', 'puede', 'pueden', 'pudo', 'pudieron', 'dice', 'dicen', 'dijo', 'dijeron',
                'va', 'van', 'fue', 'fueron', 've', 'ven', 'vio', 'vieron', 'da', 'dan', 'dio', 'dieron', 'sabe', 'saben',
                'sabía', 'sabían', 'quiere', 'quieren', 'quiso', 'quisieron', 'llega', 'llegan', 'llegó', 'llegaron',
                'pasa', 'pasan', 'pasó', 'pasaron', 'debe', 'deben', 'debió', 'debieron', 'pone', 'ponen', 'puso', 'pusieron',
                'parece', 'parecen', 'pareció', 'parecieron', 'queda', 'quedan', 'quedó', 'quedaron', 'habla', 'hablan',
                'habló', 'hablaron', 'lleva', 'llevan', 'llevó', 'llevaron', 'deja', 'dejan', 'dejó', 'dejaron',
                'sigue', 'siguen', 'siguió', 'siguieron', 'encuentra', 'encuentran', 'encontró', 'encontraron',
                'llama', 'llaman', 'llamó', 'llamaron', 'viene', 'vienen', 'vino', 'vinieron', 'piensa', 'piensan',
                'pensó', 'pensaron', 'sale', 'salen', 'salió', 'salieron', 'vuelve', 'vuelven', 'volvió', 'volvieron',
                'toma', 'toman', 'tomó', 'tomaron', 'conoce', 'conocen', 'conoció', 'conocieron', 'vive', 'viven',
                'vivió', 'vivieron', 'siente', 'sienten', 'sintió', 'sintieron', 'trata', 'tratan', 'trató', 'trataron',
                'mira', 'miran', 'miró', 'miraron', 'cuenta', 'cuentan', 'contó', 'contaron', 'empieza', 'empiezan',
                'empezó', 'empezaron', 'espera', 'esperan', 'esperó', 'esperaron', 'busca', 'buscan', 'buscó', 'buscaron',
                'existe', 'existen', 'existió', 'existieron', 'entra', 'entran', 'entró', 'entraron', 'trabaja', 'trabajan',
                'trabajó', 'trabajaron', 'escribe', 'escriben', 'escribió', 'escribieron', 'pierde', 'pierden', 'perdió', 'perdieron',
                'produce', 'producen', 'produjo', 'produjeron', 'ocurre', 'ocurren', 'ocurrió', 'ocurrieron',
                'entiende', 'entienden', 'entendió', 'entendieron', 'pide', 'piden', 'pidió', 'pidieron',
                'recibe', 'reciben', 'recibió', 'recibieron', 'recuerda', 'recuerdan', 'recordó', 'recordaron',
                'termina', 'terminan', 'terminó', 'terminaron', 'permite', 'permiten', 'permitió', 'permitieron',
                'aparece', 'aparecen', 'apareció', 'aparecieron', 'consigue', 'consiguen', 'consiguió', 'consiguieron',
                'comienza', 'comienzan', 'comenzó', 'comenzaron', 'sirve', 'sirven', 'sirvió', 'sirvieron',
                'saca', 'sacan', 'sacó', 'sacaron', 'necesita', 'necesitan', 'necesitó', 'necesitaron',
                'mantiene', 'mantienen', 'mantuvo', 'mantuvieron', 'resulta', 'resultan', 'resultó', 'resultaron',
                'lee', 'leen', 'leyó', 'leyeron', 'cae', 'caen', 'cayó', 'cayeron', 'cambia', 'cambian', 'cambió', 'cambiaron',
                'presenta', 'presentan', 'presentó', 'presentaron', 'crea', 'crean', 'creó', 'crearon',
                'abre', 'abren', 'abrió', 'abrieron', 'considera', 'consideran', 'consideró', 'consideraron',
                'oye', 'oyen', 'oyó', 'oyeron', 'acaba', 'acaban', 'acabó', 'acabaron', 'convierte', 'convierten',
                'convirtió', 'convirtieron', 'gana', 'ganan', 'ganó', 'ganaron', 'forma', 'forman', 'formó', 'formaron',
                'trae', 'traen', 'trajo', 'trajeron', 'parte', 'parten', 'partió', 'partieron', 'muere', 'mueren',
                'murió', 'murieron', 'acepta', 'aceptan', 'aceptó', 'aceptaron', 'realiza', 'realizan', 'realizó', 'realizaron',
                'supone', 'suponen', 'supuso', 'supusieron', 'comprende', 'comprenden', 'comprendió', 'comprendieron',
                'logra', 'logran', 'logró', 'lograron', 'explica', 'explican', 'explicó', 'explicaron',
                'pregunta', 'preguntan', 'preguntó', 'preguntaron', 'toca', 'tocan', 'tocó', 'tocaron',
                'reconoce', 'reconocen', 'reconoció', 'reconocieron', 'estudia', 'estudian', 'estudió', 'estudiaron',
                'alcanza', 'alcanzan', 'alcanzó', 'alcanzaron', 'nace', 'nacen', 'nació', 'nacieron',
                'dirige', 'dirigen', 'dirigió', 'dirigieron', 'corre', 'corren', 'corrió', 'corrieron',
                'utiliza', 'utilizan', 'utilizó', 'utilizaron', 'paga', 'pagan', 'pagó', 'pagaron',
                'ayuda', 'ayudan', 'ayudó', 'ayudaron', 'gusta', 'gustan', 'gustó', 'gustaron',
                'juega', 'juegan', 'jugó', 'jugaron', 'escucha', 'escuchan', 'escuchó', 'escucharon',
                'cumple', 'cumplen', 'cumplió', 'cumplieron', 'ofrece', 'ofrecen', 'ofreció', 'ofrecieron',
                'descubre', 'descubren', 'descubrió', 'descubrieron', 'levanta', 'levantan', 'levantó', 'levantaron',
                'intenta', 'intentan', 'intentó', 'intentaron', 'usa', 'usan', 'usó', 'usaron',
                'decide', 'deciden', 'decidió', 'decidieron', 'reduce', 'reducen', 'redujo', 'redujeron',
                'establece', 'establecen', 'estableció', 'establecieron', 'siendo', 'estando', 'habiendo',
                'teniendo', 'haciendo', 'pudiendo', 'diciendo', 'yendo', 'viendo', 'dando', 'sabiendo',
                'queriendo', 'llegando', 'pasando', 'debiendo', 'poniendo', 'pareciendo', 'quedando',
                'hablando', 'llevando', 'dejando', 'siguiendo', 'encontrando', 'llamando', 'viniendo',
                'pensando', 'saliendo', 'volviendo', 'tomando', 'conociendo', 'viviendo', 'sintiendo',
                'tratando', 'mirando', 'contando', 'empezando', 'esperando', 'buscando', 'existiendo',
                'entrando', 'trabajando', 'escribiendo', 'perdiendo', 'produciendo', 'ocurriendo',
                'entendiendo', 'pidiendo', 'recibiendo', 'recordando', 'terminando', 'permitiendo',
                'apareciendo', 'consiguiendo', 'comenzando', 'sirviendo', 'sacando', 'necesitando',
                'manteniendo', 'resultando', 'leyendo', 'cayendo', 'cambiando', 'presentando',
                'creando', 'abriendo', 'considerando', 'oyendo', 'acabando', 'convirtiendo',
                'ganando', 'formando', 'trayendo', 'partiendo', 'muriendo', 'aceptando',
                'realizando', 'suponiendo', 'comprendiendo', 'logrando', 'explicando', 'preguntando',
                'tocando', 'reconociendo', 'estudiando', 'alcanzando', 'naciendo', 'dirigiendo',
                'corriendo', 'utilizando', 'pagando', 'ayudando', 'gustando', 'jugando', 'escuchando',
                'cumpliendo', 'ofreciendo', 'descubriendo', 'levantando', 'intentando', 'usando',
                'decidiendo', 'reduciendo', 'estableciendo'
            ]);
            
            // Check if it's a common verb first (most reliable for verbs)
            if (commonVerbs.has(word) || commonSpanishVerbs.has(word)) {
                return 'verb';
            }
            
            // Expanded common words dictionary (most reliable classification)
            const commonWords = {
                // Determiners
                'the': 'determiner', 'a': 'determiner', 'an': 'determiner', 'this': 'determiner',
                'that': 'determiner', 'these': 'determiner', 'those': 'determiner', 'some': 'determiner',
                'any': 'determiner', 'each': 'determiner', 'every': 'determiner', 'all': 'determiner',
                'both': 'determiner', 'few': 'determiner', 'many': 'determiner', 'most': 'determiner',
                'other': 'determiner', 'another': 'determiner', 'such': 'determiner', 'what': 'determiner',
                'which': 'determiner', 'whose': 'determiner', 'el': 'determiner', 'la': 'determiner',
                'los': 'determiner', 'las': 'determiner', 'un': 'determiner', 'una': 'determiner',
                'unos': 'determiner', 'unas': 'determiner', 'este': 'determiner', 'esta': 'determiner',
                'estos': 'determiner', 'estas': 'determiner', 'ese': 'determiner', 'esa': 'determiner',
                'esos': 'determiner', 'esas': 'determiner', 'aquel': 'determiner', 'aquella': 'determiner',
                'aquellos': 'determiner', 'aquellas': 'determiner', 'mucho': 'determiner', 'mucha': 'determiner',
                'muchos': 'determiner', 'muchas': 'determiner', 'poco': 'determiner', 'poca': 'determiner',
                'pocos': 'determiner', 'pocas': 'determiner', 'todo': 'determiner', 'toda': 'determiner',
                'todos': 'determiner', 'todas': 'determiner', 'algún': 'determiner', 'alguna': 'determiner',
                'algunos': 'determiner', 'algunas': 'determiner', 'ningún': 'determiner', 'ninguna': 'determiner',
                'ningunos': 'determiner', 'ningunas': 'determiner',
                // Conjunctions
                'and': 'conjunction', 'or': 'conjunction', 'but': 'conjunction', 'nor': 'conjunction',
                'for': 'conjunction', 'so': 'conjunction', 'yet': 'conjunction', 'because': 'conjunction',
                'if': 'conjunction', 'although': 'conjunction', 'though': 'conjunction', 'while': 'conjunction',
                'since': 'conjunction', 'until': 'conjunction', 'unless': 'conjunction', 'when': 'conjunction',
                'where': 'conjunction', 'as': 'conjunction', 'than': 'conjunction', 'y': 'conjunction',
                'o': 'conjunction', 'u': 'conjunction', 'pero': 'conjunction', 'mas': 'conjunction',
                'sino': 'conjunction', 'aunque': 'conjunction', 'a pesar de': 'conjunction',
                'sin embargo': 'conjunction', 'no obstante': 'conjunction', 'porque': 'conjunction',
                'pues': 'conjunction', 'puesto que': 'conjunction', 'ya que': 'conjunction',
                'si': 'conjunction', 'como': 'conjunction', 'cuando': 'conjunction', 'donde': 'conjunction',
                'mientras': 'conjunction', 'mientras que': 'conjunction', 'antes de que': 'conjunction',
                'después de que': 'conjunction', 'hasta que': 'conjunction', 'desde que': 'conjunction',
                // Prepositions
                'in': 'preposition', 'on': 'preposition', 'at': 'preposition', 'to': 'preposition',
                'of': 'preposition', 'for': 'preposition', 'with': 'preposition', 'from': 'preposition',
                'by': 'preposition', 'about': 'preposition', 'into': 'preposition', 'onto': 'preposition',
                'upon': 'preposition', 'over': 'preposition', 'under': 'preposition', 'above': 'preposition',
                'below': 'preposition', 'between': 'preposition', 'among': 'preposition', 'through': 'preposition',
                'during': 'preposition', 'before': 'preposition', 'after': 'preposition', 'since': 'preposition',
                'until': 'preposition', 'within': 'preposition', 'without': 'preposition', 'against': 'preposition',
                'across': 'preposition', 'around': 'preposition', 'behind': 'preposition', 'beside': 'preposition',
                'beyond': 'preposition', 'near': 'preposition', 'off': 'preposition', 'out': 'preposition',
                'en': 'preposition', 'de': 'preposition', 'a': 'preposition', 'por': 'preposition',
                'para': 'preposition', 'con': 'preposition', 'sin': 'preposition', 'sobre': 'preposition',
                'bajo': 'preposition', 'entre': 'preposition', 'hasta': 'preposition', 'desde': 'preposition',
                'durante': 'preposition', 'mediante': 'preposition', 'según': 'preposition', 'contra': 'preposition',
                'hacia': 'preposition', 'tras': 'preposition', 'ante': 'preposition', 'bajo': 'preposition',
                // Pronouns (subject, object, possessive, reflexive)
                'i': 'pronoun', 'you': 'pronoun', 'he': 'pronoun', 'she': 'pronoun', 'it': 'pronoun',
                'we': 'pronoun', 'they': 'pronoun', 'me': 'pronoun', 'him': 'pronoun', 'her': 'pronoun',
                'us': 'pronoun', 'them': 'pronoun', 'my': 'pronoun', 'your': 'pronoun', 'his': 'pronoun',
                'her': 'pronoun', 'its': 'pronoun', 'our': 'pronoun', 'their': 'pronoun', 'mine': 'pronoun',
                'yours': 'pronoun', 'hers': 'pronoun', 'ours': 'pronoun', 'theirs': 'pronoun',
                'myself': 'pronoun', 'yourself': 'pronoun', 'himself': 'pronoun', 'herself': 'pronoun',
                'itself': 'pronoun', 'ourselves': 'pronoun', 'yourselves': 'pronoun', 'themselves': 'pronoun',
                'who': 'pronoun', 'whom': 'pronoun', 'whose': 'pronoun', 'which': 'pronoun', 'that': 'pronoun',
                'yo': 'pronoun', 'tú': 'pronoun', 'él': 'pronoun', 'ella': 'pronoun', 'ello': 'pronoun',
                'nosotros': 'pronoun', 'nosotras': 'pronoun', 'vosotros': 'pronoun', 'vosotras': 'pronoun',
                'ellos': 'pronoun', 'ellas': 'pronoun', 'usted': 'pronoun', 'ustedes': 'pronoun',
                'me': 'pronoun', 'te': 'pronoun', 'le': 'pronoun', 'nos': 'pronoun', 'os': 'pronoun', 'les': 'pronoun',
                'mí': 'pronoun', 'ti': 'pronoun', 'sí': 'pronoun', 'conmigo': 'pronoun', 'contigo': 'pronoun',
                'consigo': 'pronoun', 'mi': 'pronoun', 'tu': 'pronoun', 'su': 'pronoun', 'nuestro': 'pronoun',
                'nuestra': 'pronoun', 'nuestros': 'pronoun', 'nuestras': 'pronoun', 'vuestro': 'pronoun',
                'vuestra': 'pronoun', 'vuestros': 'pronoun', 'vuestras': 'pronoun', 'mío': 'pronoun',
                'mía': 'pronoun', 'míos': 'pronoun', 'mías': 'pronoun', 'tuyo': 'pronoun', 'tuya': 'pronoun',
                'tuyos': 'pronoun', 'tuyas': 'pronoun', 'suyo': 'pronoun', 'suya': 'pronoun', 'suyos': 'pronoun',
                'suyas': 'pronoun', 'mismo': 'pronoun', 'misma': 'pronoun', 'mismos': 'pronoun', 'mismas': 'pronoun',
                'quien': 'pronoun', 'quienes': 'pronoun', 'que': 'pronoun', 'cual': 'pronoun', 'cuales': 'pronoun',
                'cuanto': 'pronoun', 'cuanta': 'pronoun', 'cuantos': 'pronoun', 'cuantas': 'pronoun',
                // Interjections
                'oh': 'interjection', 'ah': 'interjection', 'wow': 'interjection', 'oops': 'interjection',
                'hey': 'interjection', 'hi': 'interjection', 'hello': 'interjection', 'yes': 'interjection',
                'no': 'interjection', 'well': 'interjection', 'hmm': 'interjection', 'uh': 'interjection',
                'ay': 'interjection', 'eh': 'interjection', 'oh': 'interjection', 'uf': 'interjection',
                'huy': 'interjection', 'oye': 'interjection', 'vaya': 'interjection',
                // Adverbs (common ones)
                'not': 'adverb', 'very': 'adverb', 'too': 'adverb', 'so': 'adverb', 'quite': 'adverb',
                'rather': 'adverb', 'just': 'adverb', 'only': 'adverb', 'also': 'adverb', 'even': 'adverb',
                'still': 'adverb', 'already': 'adverb', 'yet': 'adverb', 'again': 'adverb', 'here': 'adverb',
                'there': 'adverb', 'where': 'adverb', 'when': 'adverb', 'how': 'adverb', 'why': 'adverb',
                'now': 'adverb', 'then': 'adverb', 'today': 'adverb', 'yesterday': 'adverb', 'tomorrow': 'adverb',
                'always': 'adverb', 'never': 'adverb', 'often': 'adverb', 'sometimes': 'adverb', 'usually': 'adverb',
                'no': 'adverb', 'sí': 'adverb', 'también': 'adverb', 'tampoco': 'adverb', 'muy': 'adverb',
                'mucho': 'adverb', 'poco': 'adverb', 'más': 'adverb', 'menos': 'adverb', 'bastante': 'adverb',
                'demasiado': 'adverb', 'suficiente': 'adverb', 'casi': 'adverb', 'solo': 'adverb', 'sólo': 'adverb',
                'aún': 'adverb', 'todavía': 'adverb', 'ya': 'adverb', 'ahora': 'adverb', 'entonces': 'adverb',
                'después': 'adverb', 'antes': 'adverb', 'luego': 'adverb', 'pronto': 'adverb', 'tarde': 'adverb',
                'temprano': 'adverb', 'siempre': 'adverb', 'nunca': 'adverb', 'jamás': 'adverb', 'aquí': 'adverb',
                'ahí': 'adverb', 'allí': 'adverb', 'allá': 'adverb', 'cerca': 'adverb', 'lejos': 'adverb',
                'dentro': 'adverb', 'fuera': 'adverb', 'arriba': 'adverb', 'abajo': 'adverb', 'adelante': 'adverb',
                'atrás': 'adverb', 'bien': 'adverb', 'mal': 'adverb', 'mejor': 'adverb', 'peor': 'adverb',
                'así': 'adverb', 'como': 'adverb', 'cuando': 'adverb', 'donde': 'adverb', 'adonde': 'adverb',
                'cuanto': 'adverb', 'como': 'adverb',
                // Verbs "to be" - must check before pattern matching
                'am': 'verb', 'is': 'verb', 'are': 'verb', 'was': 'verb', 'were': 'verb',
                'be': 'verb', 'been': 'verb', 'being': 'verb'
            };
            
            // Check common words first (most reliable)
            if (commonWords[word]) {
                return commonWords[word];
            }
            
            // Context-based classification for ambiguous words
            // "be" can be verb (infinitive), but also check context
            if (word === 'be') {
                // After "to" -> infinitive verb
                if (prevWord === 'to') return 'verb';
                // After modal verbs -> infinitive verb
                const modalVerbs = ['can', 'could', 'may', 'might', 'must', 'shall', 'should', 'will', 'would'];
                if (modalVerbs.includes(prevWord)) return 'verb';
                // Before adjective/noun -> linking verb
                if (nextWord && (nextWord.endsWith('ing') || nextWord.endsWith('ed') || nextWord.length > 3)) {
                    return 'verb';
                }
                // Default: verb (most common use)
                return 'verb';
            }
            
            // "what" - can be pronoun, determiner, interjection, or adverb depending on context
            if (word === 'what') {
                // At start of sentence/question -> interjection or pronoun
                if (context?.index === 0 || prevWord === '' || prevWord === '?') {
                    return 'pronoun'; // "What is that?" or "What!"
                }
                // Before noun -> determiner
                if (nextWord && nextWord.length > 2 && !commonWords[nextWord]) {
                    return 'determiner'; // "What time is it?"
                }
                // Default: pronoun
                return 'pronoun';
            }
            
            // "that" - can be pronoun, determiner, or conjunction
            if (word === 'that') {
                // After verb/preposition -> pronoun
                const verbPreps = ['say', 'think', 'know', 'see', 'believe', 'tell', 'show', 'of', 'in', 'on', 'at'];
                if (verbPreps.includes(prevWord)) return 'pronoun';
                // Before noun -> determiner
                if (nextWord && nextWord.length > 2 && !commonWords[nextWord]) {
                    return 'determiner'; // "that book"
                }
                // Introducing clause -> conjunction
                if (nextWord && (nextWord === 'is' || nextWord === 'was' || nextWord === 'are' || nextWord === 'were')) {
                    return 'conjunction'; // "that is"
                }
                // Default: pronoun
                return 'pronoun';
            }
            
            // "as" - can be preposition, conjunction, or adverb
            if (word === 'as') {
                // Before noun/pronoun -> preposition
                if (nextWord && (nextWord.length > 2 || commonWords[nextWord] === 'pronoun')) {
                    return 'preposition'; // "as a child"
                }
                // After "such" or "same" -> conjunction
                if (prevWord === 'such' || prevWord === 'same') return 'conjunction';
                // Default: conjunction
                return 'conjunction';
            }
            
            // "for" - can be preposition or conjunction
            if (word === 'for') {
                // Before noun/pronoun -> preposition
                if (nextWord && (nextWord.length > 2 || commonWords[nextWord] === 'pronoun')) {
                    return 'preposition'; // "for you"
                }
                // Introducing reason -> conjunction
                if (nextWord && (nextWord === 'it' || nextWord === 'this' || nextWord === 'that')) {
                    return 'conjunction'; // "for it is"
                }
                // Default: preposition
                return 'preposition';
            }
            
            // "since" - can be preposition or conjunction
            if (word === 'since') {
                // Before noun -> preposition
                if (nextWord && nextWord.length > 2 && !commonWords[nextWord]) {
                    return 'preposition'; // "since Monday"
                }
                // Default: conjunction
                return 'conjunction';
            }
            
            // "until" - can be preposition or conjunction
            if (word === 'until') {
                // Before noun -> preposition
                if (nextWord && nextWord.length > 2 && !commonWords[nextWord]) {
                    return 'preposition'; // "until tomorrow"
                }
                // Default: conjunction
                return 'conjunction';
            }
            
            // "well" - can be adverb, interjection, or noun
            if (word === 'well') {
                // At start or after comma -> interjection
                if (context?.index === 0 || prevWord === '' || prevWord === ',') {
                    return 'interjection'; // "Well, I think..."
                }
                // Before adjective/verb -> adverb
                if (nextWord && (nextWord.endsWith('ing') || nextWord.endsWith('ed') || nextWord.length > 3)) {
                    return 'adverb'; // "well done"
                }
                // Default: adverb
                return 'adverb';
            }
            
            // Check if it's a "to be" verb (ser/estar)
            if (isSerEstar(word)) {
                return 'verb';
            }
            
            // Morphological patterns (more specific first)
            // Noun patterns
            if (word.endsWith('tion') || word.endsWith('sion') || word.endsWith('ness') || word.endsWith('ment') ||
                word.endsWith('ity') || word.endsWith('ism') || word.endsWith('ship') || word.endsWith('hood')) {
                return 'noun';
            }
            
            // Adjective patterns (but check context - "al" can be noun ending too)
            if (word.endsWith('ful') || word.endsWith('less') || word.endsWith('ous') || word.endsWith('ive')) {
                return 'adjective';
            }
            // "al" ending - can be adjective or noun, check context
            if (word.endsWith('al') && word.length > 3) {
                // If it's a known proper noun, it's a noun
                if (KNOWN_PROPER_NOUNS.has(word)) return 'noun';
                // If capitalized and not in common words, likely noun (proper noun)
                const originalWord = context?.allWords?.[context.index] || word;
                if (/^[A-Z]/.test(originalWord)) return 'noun';
                // Default: adjective
                return 'adjective';
            }
            
            // Adverb patterns
            if (word.endsWith('ly') && word.length > 4) { // "fly" is not an adverb
                return 'adverb';
            }
            
            // Verb patterns (more specific)
            if (word.endsWith('ing') && word.length > 4) { // "king", "ring", "thing" are not verbs
                // Check if it's a known noun
                const ingNouns = ['king', 'ring', 'thing', 'sing', 'wing', 'spring', 'string', 'bring', 'cling'];
                if (!ingNouns.includes(word)) {
                    return 'verb';
                }
            }
            if (word.endsWith('ed') && word.length > 3) { // "red", "bed", "led" are not verbs
                const edNouns = ['red', 'bed', 'led', 'wed', 'fed', 'shed', 'sled'];
                if (!edNouns.includes(word)) {
                    return 'verb';
                }
            }
            
            // Words ending in 's' - could be plural nouns, possessive nouns, or 3rd person verbs
            // Context helps: after determiner -> noun, after subject pronoun -> verb
            if (word.endsWith('s') && word.length > 2) {
                // Check if it's a known verb base form + 's'
                const baseForm = word.slice(0, -1); // Remove 's'
                const determiners = ['the', 'a', 'an', 'this', 'that', 'these', 'those', 'some', 'any', 'each', 'every',
                                     'el', 'la', 'los', 'las', 'un', 'una', 'unos', 'unas'];
                if (determiners.includes(prevWord)) {
                    return 'noun'; // "the cats", "los gatos"
                }
                const subjectPronouns = ['i', 'you', 'he', 'she', 'it', 'we', 'they', 'él', 'ella', 'ello', 'yo', 'tú'];
                if (subjectPronouns.includes(prevWord)) {
                    // After subject pronoun, more likely to be verb
                    if (commonVerbs.has(baseForm) || commonSpanishVerbs.has(baseForm)) {
                        return 'verb'; // "he runs", "él corre"
                    }
                    return 'verb'; // "he runs"
                }
                // If it's a known verb base, likely verb
                if (commonVerbs.has(baseForm) || commonSpanishVerbs.has(baseForm)) {
                    return 'verb';
                }
                // Default: noun (more common for plurals)
                return 'noun';
            }
            
            // Default: be more conservative, try context-based inference before defaulting
            // After determiner -> likely noun
            const determiners = ['the', 'a', 'an', 'this', 'that', 'these', 'those', 'some', 'any', 'each', 'every',
                                 'el', 'la', 'los', 'las', 'un', 'una', 'unos', 'unas'];
            if (determiners.includes(prevWord)) {
                return 'noun';
            }
            // After subject pronoun -> likely verb
            const subjectPronouns = ['i', 'you', 'he', 'she', 'it', 'we', 'they', 'él', 'ella', 'ello', 'yo', 'tú'];
            if (subjectPronouns.includes(prevWord)) {
                return 'verb';
            }
            // Before noun indicators -> likely adjective
            if (nextWord && (determiners.includes(nextWord) || commonWords[nextWord] === 'noun')) {
                return 'adjective';
            }
            
            // Last resort: if we truly can't determine, return 'other' instead of guessing 'noun'
            // This prevents false classifications and is more honest
            return 'other';
        }

        function isSerEstar(word) {
            const cleanWord = word.replace(/[^\w]/g, '').toLowerCase();
            const serEstarWords = [
                // Spanish
                'ser', 'estar', 'es', 'son', 'está', 'están', 'fue', 'fueron',
                'estaba', 'estaban', 'sido', 'estado', 'siendo', 'estando',
                'sea', 'sean', 'esté', 'estén', 'fuera', 'fueran',
                // English
                'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being'
            ];
            return serEstarWords.includes(cleanWord);
        }

        function splitTextIntoWords(text) {
            const words = [];
            let currentWord = '';
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                
                if (/[\u4e00-\u9fff]/.test(char)) {
                    if (currentWord.trim()) {
                        words.push(currentWord.trim());
                        currentWord = '';
                    }
                    words.push(char);
                } else if (/\s/.test(char)) {
                    if (currentWord.trim()) {
                        words.push(currentWord.trim());
                        currentWord = '';
                    }
                } else {
                    currentWord += char;
                }
            }
            
            if (currentWord.trim()) {
                words.push(currentWord.trim());
            }
            
            return words.filter(word => word.length > 0);
        }
        
        // Limit text input to 700 words
        function limitWordCount(event) {
            const textInput = event.target;
            const text = textInput.value;
            const words = splitTextIntoWords(text);
            const MAX_WORDS = 700;
            
            if (words.length > MAX_WORDS) {
                // Truncate to 700 words
                const truncatedWords = words.slice(0, MAX_WORDS);
                
                // Reconstruct text from truncated words - simpler approach
                let truncatedText = '';
                let wordIndex = 0;
                let currentWord = '';
                let inWord = false;
                
                // Reconstruct by going through original text and counting words
                for (let i = 0; i < text.length && wordIndex < MAX_WORDS; i++) {
                    const char = text[i];
                    
                    if (/[\u4e00-\u9fff]/.test(char)) {
                        // Chinese character - each is a word
                        if (currentWord.trim()) {
                            truncatedText += currentWord;
                            currentWord = '';
                            wordIndex++;
                        }
                        truncatedText += char;
                        wordIndex++;
                        inWord = false;
                    } else if (/\s/.test(char)) {
                        // Whitespace
                        if (currentWord.trim()) {
                            truncatedText += currentWord;
                            currentWord = '';
                            wordIndex++;
                            inWord = false;
                        }
                        truncatedText += char;
                    } else {
                        // Regular character
                        currentWord += char;
                        inWord = true;
                    }
                }
                
                // If we're in the middle of a word and haven't reached the limit, add it
                if (wordIndex < MAX_WORDS && currentWord.trim()) {
                    truncatedText += currentWord;
                }
                
                // Update value
                const cursorPos = textInput.selectionStart;
                textInput.value = truncatedText;
                
                // Try to maintain cursor position if possible
                const newCursorPos = Math.min(cursorPos, truncatedText.length);
                textInput.setSelectionRange(newCursorPos, newCursorPos);
                
                // Show warning
                const existingWarning = document.getElementById('wordLimitWarning');
                if (existingWarning) {
                    existingWarning.remove();
                }
                const warning = document.createElement('div');
                warning.id = 'wordLimitWarning';
                warning.style.cssText = 'color: #ff6600; font-size: 11px; margin-top: 5px;';
                warning.textContent = `Maximum 700 words allowed. Text truncated.`;
                textInput.parentNode.appendChild(warning);
                setTimeout(() => {
                    if (warning.parentNode) {
                        warning.parentNode.removeChild(warning);
                    }
                }, 3000);
            }
        }
        
        // Handle paste events to limit word count
        function handlePaste(event) {
            event.preventDefault();
            
            const pastedText = (event.clipboardData || window.clipboardData).getData('text');
            const textInput = event.target;
            const currentText = textInput.value;
            const selectionStart = textInput.selectionStart;
            const selectionEnd = textInput.selectionEnd;
            
            // Get current word count
            const currentWords = splitTextIntoWords(currentText);
            const MAX_WORDS = 700;
            
            // Calculate how many words we can add
            const wordsAvailable = MAX_WORDS - currentWords.length;
            
            if (wordsAvailable <= 0) {
                // Already at limit, don't allow paste
                const existingWarning = document.getElementById('wordLimitWarning');
                if (existingWarning) {
                    existingWarning.remove();
                }
                const warning = document.createElement('div');
                warning.id = 'wordLimitWarning';
                warning.style.cssText = 'color: #ff6600; font-size: 11px; margin-top: 5px;';
                warning.textContent = 'Maximum 700 words reached. Cannot paste more text.';
                textInput.parentNode.appendChild(warning);
                setTimeout(() => {
                    if (warning.parentNode) {
                        warning.parentNode.removeChild(warning);
                    }
                }, 3000);
                return;
            }
            
            // Split pasted text into words and take only what fits
            const pastedWords = splitTextIntoWords(pastedText);
            const wordsToPaste = pastedWords.slice(0, wordsAvailable);
            
            // Reconstruct text from words (simplified - preserve original spacing when possible)
            let textToPaste = '';
            if (pastedWords.length > 0) {
                // Try to preserve original text structure
                const originalText = pastedText;
                let wordCount = 0;
                let currentWord = '';
                
                for (let i = 0; i < originalText.length && wordCount < wordsAvailable; i++) {
                    const char = originalText[i];
                    
                    if (/[\u4e00-\u9fff]/.test(char)) {
                        if (currentWord.trim()) {
                            textToPaste += currentWord;
                            currentWord = '';
                            wordCount++;
                        }
                        textToPaste += char;
                        wordCount++;
                    } else if (/\s/.test(char)) {
                        if (currentWord.trim()) {
                            textToPaste += currentWord;
                            currentWord = '';
                            wordCount++;
                        }
                        textToPaste += char;
                    } else {
                        currentWord += char;
                    }
                }
            }
            
            // Insert the text
            const newText = currentText.substring(0, selectionStart) + 
                          textToPaste + 
                          currentText.substring(selectionEnd);
            
            textInput.value = newText;
            textInput.setSelectionRange(selectionStart + textToPaste.length, selectionStart + textToPaste.length);
            
            // Trigger input event to validate word count
            textInput.dispatchEvent(new Event('input'));
            
            // Show warning if text was truncated
            if (pastedWords.length > wordsAvailable) {
                const existingWarning = document.getElementById('wordLimitWarning');
                if (existingWarning) {
                    existingWarning.remove();
                }
                const warning = document.createElement('div');
                warning.id = 'wordLimitWarning';
                warning.style.cssText = 'color: #ff6600; font-size: 11px; margin-top: 5px;';
                warning.textContent = `Pasted text truncated to fit 700 word limit.`;
                textInput.parentNode.appendChild(warning);
                setTimeout(() => {
                    if (warning.parentNode) {
                        warning.parentNode.removeChild(warning);
                    }
                }, 3000);
            }
        }

        function analyzeText(text) {
            console.log('analyzeText called with text:', text.substring(0, 100) + (text.length > 100 ? '...' : ''));
            
            // Detect text structure type
            textStructureType = detectTextStructure(text);
            console.log('Detected text structure type:', textStructureType);
            
            const words = splitTextIntoWords(text);
            console.log(`splitTextIntoWords returned ${words.length} words:`, words.slice(0, 10));
            
            // Limit to 700 words maximum
            const MAX_WORDS = 700;
            const limitedWords = words.slice(0, MAX_WORDS);
            
            if (words.length > MAX_WORDS) {
                console.log(`Text exceeded ${MAX_WORDS} words. Processing first ${MAX_WORDS} words only.`);
            }
            
            if (limitedWords.length === 0) {
                console.error('No words found after splitting!');
                analyzedWords = [];
                return analyzedWords;
            }
            
            // Calcular frecuencias
            const wordFreq = {};
            limitedWords.forEach(word => {
                const cleanWord = word.toLowerCase();
                wordFreq[cleanWord] = (wordFreq[cleanWord] || 0) + 1;
            });
            
            // Handle case where all words are unique (maxFreq would be 1, but we need to handle empty case)
            const freqValues = Object.values(wordFreq);
            const maxFreq = freqValues.length > 0 ? Math.max(...freqValues) : 1;
            console.log(`Word frequencies calculated. Max frequency: ${maxFreq}, Unique words: ${freqValues.length}`);
            
            analyzedWords = limitedWords.map((word, idx) => {
                const cleanWord = word.toLowerCase();
                // Provide context for better POS classification
                const prevWord = idx > 0 ? limitedWords[idx - 1] : '';
                const nextWord = idx < limitedWords.length - 1 ? limitedWords[idx + 1] : '';
                const context = {
                    prevWord: prevWord,
                    nextWord: nextWord,
                    index: idx,
                    allWords: limitedWords
                };
                const pos = getPOS(word, context);
                const frequency = wordFreq[cleanWord] || 1;
                const isSerEstarWord = isSerEstar(word);
                
                if (idx < 5) { // Log first 5 words for debugging
                    console.log(`Word ${idx}: "${word}" -> POS: ${pos}, isSerEstar: ${isSerEstarWord}, frequency: ${frequency}, context: prev="${prevWord}", next="${nextWord}"`);
                }
                
                return {
                    text: word,
                    pos: pos,
                    frequency: frequency,
                    normalizedFrequency: frequency / maxFreq,
                    isSerEstar: isSerEstarWord,
                    isName: isName(word, idx) && pos === 'noun' // Mark names
                };
            });
            
            // Second pass: detect surnames after names (like "Carbajal" after "Juan")
            analyzedWords.forEach((wordData, idx) => {
                if (!wordData.isName && wordData.pos === 'noun' && idx > 0) {
                    const previousWord = analyzedWords[idx - 1];
                    // If previous word is a name, check if current word could be a surname
                    if (previousWord && previousWord.isName && previousWord.pos === 'noun') {
                        const cleanWord = wordData.text.replace(/[^\w\u4e00-\u9fff]/g, '');
                        const isCapitalized = /^[A-Z\u00C0-\u017F]/.test(cleanWord) && cleanWord.length > 1;
                        // Check if it's in the known proper nouns (like "Carbajal")
                        if (KNOWN_PROPER_NOUNS.has(cleanWord) || isCapitalized) {
                            wordData.isName = true; // Mark as name (surname)
                        }
                    }
                }
            });
            
            console.log(`analyzeText completed. Total analyzed words: ${analyzedWords.length}`);
            return analyzedWords;
        }

        // ==================== SISTEMA DE PUNTUACIÓN LINGÜÍSTICA ====================
        // LINGUISTIC VALUE SCORING SYSTEM (Ontological–Contextual Accumulation Model)
        // LEDGER-BASED SYSTEM: No averages, no normalization, no cap. Value is cumulative and additive.
        // Each word generates value independently, modified by context. Total = sum of all adjusted word values.
        
        // 1. BASE VALUE BY WORD TYPE
        function getBaseValue(word, pos) {
            const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
            
            // Pronouns
            if (pos === 'pronoun') {
                if (cleanWord === 'i' || cleanWord === 'we' || cleanWord === 'yo' || cleanWord === 'nosotros' || cleanWord === 'nosotras') {
                    return 7.5;
                }
                if (cleanWord === 'you' || cleanWord === 'tú' || cleanWord === 'vosotros' || cleanWord === 'vosotras') {
                    return 6.0;
                }
                if (cleanWord === 'he' || cleanWord === 'she' || cleanWord === 'they' || cleanWord === 'it' ||
                    cleanWord === 'él' || cleanWord === 'ella' || cleanWord === 'ellos' || cleanWord === 'ellas') {
                    return 5.0;
                }
                return 5.0; // Default for pronouns
            }
            
            // Verbs
            if (pos === 'verb') {
                // Ontological/Existential verbs
                const ontologicalVerbs = ['is', 'am', 'are', 'was', 'were', 'be', 'been', 'being',
                                         'exist', 'exists', 'existed', 'remaining', 'remain', 'remains',
                                         'become', 'becomes', 'became',
                                         'ser', 'estar', 'es', 'son', 'está', 'están', 'fue', 'fueron',
                                         'existir', 'existe', 'existen', 'permanecer', 'permanece', 'permanecen',
                                         'convertirse', 'convertir'];
                if (ontologicalVerbs.includes(cleanWord)) {
                    // "To be" verbs have high value (aligned with ledger system: 8.0)
                    if (cleanWord === 'is' || cleanWord === 'am' || cleanWord === 'are' || cleanWord === 'was' || cleanWord === 'were' ||
                        cleanWord === 'be' || cleanWord === 'been' || cleanWord === 'being' ||
                        cleanWord === 'ser' || cleanWord === 'estar' || cleanWord === 'es' || cleanWord === 'son' || 
                        cleanWord === 'está' || cleanWord === 'están') {
                        return 8.0; // Base value for "to be" (ledger system alignment)
                    }
                    return 7.0;
                }
                
                // Modal/Capacity verbs
                const modalVerbs = ['can', 'could', 'must', 'should', 'may', 'might', 'will', 'would',
                                   'poder', 'debe', 'deber', 'debería', 'podría'];
                if (modalVerbs.includes(cleanWord)) {
                    return 6.0;
                }
                
                // Narrative/reporting verbs
                const narrativeVerbs = ['say', 'says', 'said', 'tell', 'tells', 'told', 'describe', 'describes', 'described',
                                       'decir', 'dice', 'dijo', 'contar', 'cuenta', 'contó', 'describir', 'describe', 'describió'];
                if (narrativeVerbs.includes(cleanWord)) {
                    return 4.0;
                }
                
                return 5.0; // Default for concrete action verbs
            }
            
            // Nouns
            if (pos === 'noun') {
                // Check if it's a proper noun (name) - these have very high value
                const isCapitalized = /^[A-Z\u00C0-\u017F]/.test(word) && word.length > 1;
                const commonCapitalized = ['I', 'The', 'A', 'An', 'This', 'That', 'These', 'Those', 
                                          'He', 'She', 'We', 'They', 'You', 'It'];
                if (isCapitalized && !commonCapitalized.includes(word)) {
                    return 25.0; // Names have very high ontological value (increased to prioritize names)
                }
                
                // Ontological nouns
                const ontologicalNouns = ['human', 'humans', 'body', 'bodies', 'life', 'lives', 'world', 'worlds', 'self', 'selves',
                                         'humano', 'humanos', 'cuerpo', 'cuerpos', 'vida', 'vidas', 'mundo', 'mundos', 'yo', 'ser'];
                if (ontologicalNouns.includes(cleanWord)) {
                    return 6.5;
                }
                
                // Abstract but overused
                const abstractOverused = ['identity', 'identities', 'freedom', 'freedoms', 'value', 'values',
                                         'identidad', 'identidades', 'libertad', 'libertades', 'valor', 'valores'];
                if (abstractOverused.includes(cleanWord)) {
                    return 4.5;
                }
                
                // Technical nouns
                const technicalNouns = ['algorithm', 'algorithms', 'protocol', 'protocols', 'system', 'systems',
                                       'algoritmo', 'algoritmos', 'protocolo', 'protocolos', 'sistema', 'sistemas'];
                if (technicalNouns.includes(cleanWord)) {
                    return 3.5;
                }
                
                return 4.0; // Default for concrete specific nouns
            }
            
            // Adjectives
            if (pos === 'adjective') {
                // Essential/ontological adjectives
                const essentialAdj = ['good', 'human', 'alive', 'real', 'true', 'existent',
                                     'bueno', 'buena', 'humano', 'humana', 'vivo', 'viva', 'real', 'verdadero', 'verdadera'];
                if (essentialAdj.includes(cleanWord)) {
                    return 6.0;
                }
                
                // Evaluative soft
                const evaluativeSoft = ['nice', 'interesting', 'beautiful', 'pretty',
                                       'bonito', 'bonita', 'interesante', 'hermoso', 'hermosa', 'lindo', 'linda'];
                if (evaluativeSoft.includes(cleanWord)) {
                    return 3.5;
                }
                
                return 3.0; // Default for purely descriptive adjectives
            }
            
            // Function Words
            if (pos === 'conjunction' || pos === 'preposition' || pos === 'determiner') {
                // Negation
                if (cleanWord === 'not' || cleanWord === 'no' || cleanWord === 'sin' || cleanWord === 'nada') {
                    return 6.0;
                }
                
                // Conditional
                if (cleanWord === 'if' || cleanWord === 'si') {
                    return 5.5;
                }
                
                // Causal
                if (cleanWord === 'because' || cleanWord === 'porque' || cleanWord === 'por') {
                    return 5.0;
                }
                
                // Articles, prepositions, conjunctions
                const functionWords = ['the', 'a', 'an', 'of', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                                      'el', 'la', 'los', 'las', 'un', 'una', 'de', 'y', 'o', 'pero', 'en', 'con', 'por', 'para'];
                if (functionWords.includes(cleanWord)) {
                    // Deterministic value based on word hash (0.5-1.0 range)
                    let hash = 0;
                    for (let i = 0; i < cleanWord.length; i++) {
                        hash = ((hash << 5) - hash) + cleanWord.charCodeAt(i);
                        hash = hash & hash; // Convert to 32-bit integer
                    }
                    return 0.5 + (Math.abs(hash) % 51) / 100; // Value between 0.5-1.0
                }
                
                return 1.0; // Default for function words
            }
            
            // Default minimum value
            return 0.1;
        }
        
        // 2. CONTEXTUAL MULTIPLIERS
        
        // A. Text Length Density Multiplier (ledger-based: short texts concentrate ontological force)
        function getLengthMultiplier(wordCount) {
            // Synthesized: maintains premium for extreme brevity while aligning with ledger system ranges
            if (wordCount === 1) return 3.0; // Single word = maximum ontological concentration
            if (wordCount === 2) return 2.5; // Two words = very high concentration
            if (wordCount === 3) return 2.2; // "I am X" = perfect ontological density
            if (wordCount >= 4 && wordCount <= 5) return 2.0; // Still very concentrated
            if (wordCount >= 6 && wordCount <= 10) return 1.6; // Ledger: 1-10 words = ×1.6
            if (wordCount >= 11 && wordCount <= 50) return 1.3; // Ledger: 11-50 words = ×1.3
            if (wordCount >= 51 && wordCount <= 200) return 1.0; // Ledger: 51-200 words = ×1.0
            if (wordCount >= 201 && wordCount <= 700) return 0.7; // Ledger: 201-700 words = ×0.7
            return 0.7; // Default for texts beyond 700 words
        }
        
        // B. Name with "to be" Multiplier (names near "to be" verbs get bonus)
        function getNameWithToBeMultiplier(wordIndex, words) {
            const word = words[wordIndex];
            
            // Skip extra names - they don't exist for context
            if (word && word.isExtraName) return 1.0;
            
            // Check if this word is a name
            if (!isName(word.text, wordIndex) || word.pos !== 'noun') {
                return 1.0; // Not a name, no bonus
            }
            
            // Check if there's a "to be" verb nearby (within 3 words)
            // Filter out extra names from context
            const windowSize = 3;
            const start = Math.max(0, wordIndex - windowSize);
            const end = Math.min(words.length, wordIndex + windowSize + 1);
            const window = [];
            for (let i = start; i < end; i++) {
                if (words[i] && !words[i].isExtraName) {
                    window.push(words[i]);
                }
            }
            
            // Look for "to be" verbs in the window
            let hasToBe = false;
            window.forEach(w => {
                if (w.isSerEstar) {
                    hasToBe = true;
                }
            });
            
            if (hasToBe) {
                // Check if it forms a pattern: "I am Name" or "Name is X" or "X is Name"
                for (let i = 0; i < window.length - 2; i++) {
                    const w1 = window[i];
                    const w2 = window[i + 1];
                    const w3 = window[i + 2];
                    
                    // Pattern 1: I/pronoun + "to be" + Name
                    const isFirstPerson = (w1.text.toLowerCase() === 'i' || w1.text.toLowerCase() === 'yo' || 
                                          w1.text.toLowerCase() === 'we' || w1.text.toLowerCase() === 'nosotros') && 
                                         w1.pos === 'pronoun';
                    const isToBe = w2.isSerEstar;
                    const isNameWord = isName(w3.text, start + i + 2) && w3.pos === 'noun';
                    
                    if (isFirstPerson && isToBe && isNameWord && (wordIndex === start + i + 2)) {
                        return 2.0; // High bonus for "I am Name" pattern
                    }
                    
                    // Pattern 2: Name + "to be" + complement
                    const w1IsName = isName(w1.text, start + i) && w1.pos === 'noun';
                    const w3IsName = isName(w3.text, start + i + 2) && w3.pos === 'noun';
                    
                    if (w1IsName && isToBe && (wordIndex === start + i)) {
                        return 1.8; // Good bonus for "Name is X"
                    }
                    
                    if (w3IsName && isToBe && (wordIndex === start + i + 2)) {
                        return 1.8; // Good bonus for "X is Name"
                    }
                }
                
                // If "to be" is nearby but not in a clear pattern, still give a bonus
                return 1.5; // Moderate bonus for proximity to "to be"
            }
            
            return 1.0; // No "to be" nearby, no bonus
        }
        
        // C. Ontological Assertion Multiplier
        function isOntologicalAssertion(wordIndex, words) {
            if (wordIndex < 0 || wordIndex >= words.length) return false;
            // Skip extra names - they don't exist for context
            if (words[wordIndex] && words[wordIndex].isExtraName) return false;
            
            const windowSize = 5;
            const start = Math.max(0, wordIndex - windowSize);
            const end = Math.min(words.length, wordIndex + windowSize + 1);
            // Filter out extra names from context window
            const window = [];
            for (let i = start; i < end; i++) {
                if (words[i] && !words[i].isExtraName) {
                    window.push(words[i]);
                }
            }
            
            // Check for: I + am/is/are + essential adjective/noun/name
            for (let i = 0; i < window.length - 2; i++) {
                const w1 = window[i];
                const w2 = window[i + 1];
                const w3 = window[i + 2];
                
                // Pattern: I/pronoun + am/is/are + adjective/noun/name
                const isFirstPerson = (w1.text.toLowerCase() === 'i' || w1.text.toLowerCase() === 'yo') && w1.pos === 'pronoun';
                const isToBe = (w2.text.toLowerCase() === 'am' || w2.text.toLowerCase() === 'is' || w2.text.toLowerCase() === 'are' ||
                               w2.text.toLowerCase() === 'es' || w2.text.toLowerCase() === 'son' || w2.text.toLowerCase() === 'estoy' ||
                               w2.text.toLowerCase() === 'está' || w2.text.toLowerCase() === 'están') && w2.pos === 'verb';
                
                // Check if w3 is essential word OR a proper noun (name)
                const isEssentialWord = (w3.pos === 'adjective' || w3.pos === 'noun') && 
                                   (w3.text.toLowerCase() === 'human' || w3.text.toLowerCase() === 'good' || w3.text.toLowerCase() === 'alive' ||
                                    w3.text.toLowerCase() === 'real' || w3.text.toLowerCase() === 'humano' || w3.text.toLowerCase() === 'bueno' ||
                                    w3.text.toLowerCase() === 'vivo' || w3.text.toLowerCase() === 'real');
                
                // Check if w3 is a name using the existing isName function
                const actualIndex = start + i + 2;
                const isNameProperNoun = isName(w3.text, actualIndex) && w3.pos === 'noun';
                
                const isEssential = isEssentialWord || isNameProperNoun;
                
                if (isFirstPerson && isToBe && isEssential && 
                    (wordIndex === start + i || wordIndex === start + i + 1 || wordIndex === start + i + 2)) {
                    return true;
                }
            }
            
            // Check for: Noun + is/are + noun/adjective
            for (let i = 0; i < window.length - 2; i++) {
                const w1 = window[i];
                const w2 = window[i + 1];
                const w3 = window[i + 2];
                
                const isNoun = w1.pos === 'noun';
                const isToBe = (w2.text.toLowerCase() === 'is' || w2.text.toLowerCase() === 'are' ||
                               w2.text.toLowerCase() === 'es' || w2.text.toLowerCase() === 'son') && w2.pos === 'verb';
                const isComplement = (w3.pos === 'noun' || w3.pos === 'adjective');
                
                if (isNoun && isToBe && isComplement && 
                    (wordIndex === start + i || wordIndex === start + i + 1 || wordIndex === start + i + 2)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // C. Semantic Closure Multiplier (ledger-based system: self-contained assertions > dependent statements)
        function getSemanticClosureMultiplier(wordIndex, words, totalWords) {
            // Synthesized with existing logic: maintains high values for short texts while aligning with ledger system
            // Self-contained assertion (short text = maximum ontological density)
            if (totalWords === 1) return 2.0; // Single word = maximum concentration (beyond ledger ×1.4 for extreme cases)
            if (totalWords === 2) return 1.8; // Two words = very high concentration
            if (totalWords === 3) return 1.7; // "I am X" = perfect (beyond ledger ×1.4)
            if (totalWords >= 4 && totalWords <= 5) return 1.5; // Still very self-contained
            if (totalWords >= 6 && totalWords <= 10) {
                return 1.4; // Ledger system: self-contained assertion = ×1.4
            }
            
            // Productive ambiguity (medium text, some context)
            if (totalWords >= 11 && totalWords <= 50) {
                return 1.2; // Ledger system: productive ambiguity = ×1.2
            }
            
            // Heavy dependence on external context (long text = explanations = less value)
            if (totalWords >= 51 && totalWords <= 200) {
                return 0.8; // Ledger system: heavy dependence = ×0.8
            }
            
            return 0.8; // Very long texts have heavy dependence on context
        }
        
        // D. Scarcity/Density Multiplier (penaliza repetición excesiva)
        // A más repeticiones, menos valor por instancia (ley de escasez)
        function getRepetitionMultiplier(wordIndex, words, wordText, totalWords) {
            const cleanWord = wordText.toLowerCase().replace(/[^\w]/g, '');
            
            // Check if this is a "to be" verb (special handling)
            const toBeVerbs = ['is', 'am', 'are', 'was', 'were', 'be', 'been', 'being',
                               'ser', 'estar', 'es', 'son', 'está', 'están'];
            const isToBe = toBeVerbs.includes(cleanWord);
            
            // Check if this word is an ontological nucleus (pronouns, "to be", essential words)
            const ontologicalNuclei = ['i', 'we', 'you', 'am', 'is', 'are', 'be', 'human', 'good', 'real', 'alive',
                                      'yo', 'nosotros', 'tú', 'ser', 'estar', 'es', 'humano', 'bueno', 'real', 'vivo'];
            
            // Count occurrences of this word (excluding extra names)
            let count = 0;
            words.forEach(w => {
                // Skip extra names - they don't count
                if (w && w.isExtraName) return;
                if (w.text.toLowerCase().replace(/[^\w]/g, '') === cleanWord) {
                    count++;
                }
            });
            
            // Special handling for "to be" verbs - escasez = más valor
            if (isToBe) {
                // Calcular densidad relativa (cuántas veces aparece "to be" en relación al texto total)
                const toBeDensity = count / totalWords;
                
                // Si aparece solo una vez: valor máximo (máxima escasez)
                if (count === 1) {
                    return 3.5; // Muy alto para "to be" único - máxima escasez
                }
                
                // Si hay muy pocas apariciones (alta escasez): valor muy alto
                if (count === 2) {
                    return 2.8; // Muy alto - alta escasez
                }
                if (count === 3) {
                    return 2.2; // Alto - buena escasez
                }
                
                // Si hay pocas apariciones: buen valor
                if (count === 4) {
                    return 1.8;
                }
                if (count === 5) {
                    return 1.5;
                }
                
                // Si hay moderadas apariciones: valor moderado
                if (count === 6) {
                    return 1.2;
                }
                if (count === 7) {
                    return 1.0;
                }
                if (count === 8) {
                    return 0.9;
                }
                
                // Si hay muchas apariciones: penalización progresiva
                if (count === 9) {
                    return 0.7;
                }
                if (count === 10) {
                    return 0.5;
                }
                
                // Más de 10 apariciones: degradación muy agresiva (baja escasez = bajo valor)
                return Math.max(0.3, 0.5 - (count - 10) * 0.03);
            }
            
            // Special handling for names - scarcity increases value (fewer names = more value per name)
            const isNameWord = isName(wordText, wordIndex) && words[wordIndex].pos === 'noun';
            
            if (isNameWord) {
                // Count name groups (compound names count as one)
                const nameGroups = window.nameGroups || [];
                
                // Find if this name is part of a compound name group
                let nameGroup = null;
                for (let i = 0; i < nameGroups.length; i++) {
                    if (nameGroups[i].indices.includes(wordIndex)) {
                        nameGroup = nameGroups[i];
                        break;
                    }
                }
                
                // Count distinct name groups (compound names = 1 group, single names = 1 group each)
                // This ensures "John Smith" counts as 1 name group, not 2
                const distinctNameGroups = new Set();
                
                nameGroups.forEach(group => {
                    distinctNameGroups.add(group.startIndex); // Each group identified by start index
                });
                
                // Also count single names (not part of any compound)
                words.forEach((w, idx) => {
                    if (isName(w.text, idx) && w.pos === 'noun') {
                        // Check if it's not part of any compound name group
                        let isPartOfGroup = false;
                        nameGroups.forEach(group => {
                            if (group.indices.includes(idx)) {
                                isPartOfGroup = true;
                            }
                        });
                        if (!isPartOfGroup) {
                            distinctNameGroups.add(idx); // Single name = its own index
                        }
                    }
                });
                
                // Use distinctNameGroups count for scarcity calculation (compound names count as one)
                const effectiveNameCount = distinctNameGroups.size;
                
                // Count how many words are NOT names (to check if text only has names)
                // Count verbs and other significant words (not just common words)
                let nonNameWordCount = 0;
                let hasVerbs = false;
                words.forEach((w, idx) => {
                    const isNameWord = isName(w.text, idx) && w.pos === 'noun';
                    if (!isNameWord) {
                        // Check if it's a verb (significant word that reduces name value)
                        if (w.pos === 'verb') {
                            hasVerbs = true;
                            nonNameWordCount++;
                        } else {
                            // Exclude very common short words (articles, prepositions, etc.)
                            const commonWords = ['the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'to', 'of', 'in', 'on', 'at', 'for', 'with', 'and', 'or', 'but'];
                            const cleanW = w.text.toLowerCase().replace(/[^\w]/g, '');
                            if (!commonWords.includes(cleanW) && cleanW.length > 1) {
                                nonNameWordCount++;
                            }
                        }
                    }
                });
                
                // Calculate multiplier based on effective name count
                // All names in a compound will get the same multiplier
                let scarcityMultiplier;
                
                // Special case: if text ONLY has names (no verbs, no other significant words), maximum value
                if (nonNameWordCount === 0 && !hasVerbs) {
                    // Text only contains names (individual or compound) - highest possible value
                    if (effectiveNameCount === 1) {
                        scarcityMultiplier = 25.0; // Maximum value for names alone
                    } else if (effectiveNameCount === 2) {
                        scarcityMultiplier = 20.0; // Very high value for 2 name groups alone
                    } else {
                        scarcityMultiplier = 15.0; // High value for multiple name groups alone
                    }
                } else if ((effectiveNameCount === 1 || effectiveNameCount === 2) && nonNameWordCount <= 2 && !hasVerbs) {
                    scarcityMultiplier = 15.0; // Enormous value - text only has names (with minimal other words)
                } else if (effectiveNameCount === 1) {
                    scarcityMultiplier = 10.0; // Maximum value for single name/compound (maximum scarcity)
                } else if (effectiveNameCount === 2) {
                    scarcityMultiplier = 8.0; // Very high value for 2 name groups
                } else if (effectiveNameCount === 3) {
                    scarcityMultiplier = 3.0; // High value for 3 name groups
                } else if (effectiveNameCount === 4) {
                    scarcityMultiplier = 2.0; // Good value for 4 name groups
                } else if (effectiveNameCount === 5) {
                    scarcityMultiplier = 1.5; // Moderate value for 5 name groups
                } else if (effectiveNameCount <= 7) {
                    scarcityMultiplier = 1.2; // Slightly above normal for 6-7 name groups
                } else if (effectiveNameCount <= 10) {
                    scarcityMultiplier = 1.0; // Normal value for 8-10 name groups
                } else {
                    // Many name groups: progressive penalty (more names = less value per name)
                    scarcityMultiplier = Math.max(0.3, 1.0 - (effectiveNameCount - 10) * 0.07);
                }
                
                // Calculate repetition multiplier: if this specific name appears many times, it has more value
                // Count how many times this specific name (or name group) appears
                let nameRepetitionCount = 0;
                
                if (nameGroup) {
                    // For compound names: create a unique identifier from the concatenated texts
                    const groupText = nameGroup.indices.map(idx => words[idx].text.toLowerCase().replace(/[^\w]/g, '')).join(' ');
                    // Count how many times this same compound name group appears
                    nameGroups.forEach(g => {
                        const gText = g.indices.map(idx => words[idx].text.toLowerCase().replace(/[^\w]/g, '')).join(' ');
                        if (gText === groupText) {
                            nameRepetitionCount++;
                        }
                    });
                } else {
                    // For single names: count exact matches (case-insensitive)
                    const currentNameText = wordText.toLowerCase().replace(/[^\w]/g, '');
                    words.forEach((w, idx) => {
                        const wIsName = isName(w.text, idx) && w.pos === 'noun';
                        // Only count if it's not part of a compound name group
                        if (wIsName) {
                            let isPartOfAnyGroup = false;
                            nameGroups.forEach(g => {
                                if (g.indices.includes(idx)) {
                                    isPartOfAnyGroup = true;
                                }
                            });
                            if (!isPartOfAnyGroup) {
                                const wClean = w.text.toLowerCase().replace(/[^\w]/g, '');
                                if (wClean === currentNameText) {
                                    nameRepetitionCount++;
                                }
                            }
                        }
                    });
                }
                
                // Repetition multiplier: more repetitions = more value (up to a limit)
                let repetitionMultiplier = 1.0;
                if (nameRepetitionCount >= 10) {
                    repetitionMultiplier = 2.5; // Very high value for names repeated 10+ times
                } else if (nameRepetitionCount >= 7) {
                    repetitionMultiplier = 2.0; // High value for 7-9 repetitions
                } else if (nameRepetitionCount >= 5) {
                    repetitionMultiplier = 1.7; // Good value for 5-6 repetitions
                } else if (nameRepetitionCount >= 3) {
                    repetitionMultiplier = 1.4; // Moderate value for 3-4 repetitions
                } else if (nameRepetitionCount >= 2) {
                    repetitionMultiplier = 1.2; // Slight bonus for 2 repetitions
                }
                
                // Compound name multiplier: 2 names > 1 name, 3+ names = same as 2 names
                let compoundMultiplier = 1.0;
                if (nameGroup) {
                    const nameCount = nameGroup.indices.length;
                    if (nameCount >= 2) {
                        // 2 or more names: apply bonus (2 names get bonus, 3+ get same bonus as 2)
                        compoundMultiplier = 1.8; // 2+ names are more valuable than single names
                    }
                    // Single names (nameCount === 1) keep compoundMultiplier = 1.0
                }
                
                // Combine scarcity, repetition, and compound multipliers
                let multiplier = scarcityMultiplier * repetitionMultiplier * compoundMultiplier;
                
                // Store multiplier in name group so all names in compound get same value
                if (nameGroup) {
                    if (!nameGroup.scarcityMultiplier) {
                        nameGroup.scarcityMultiplier = multiplier;
                    }
                    // Use the stored multiplier for consistency
                    return nameGroup.scarcityMultiplier;
                }
                
                return multiplier;
            }
            
            // Si aparece solo una vez: valor máximo (rareza = valor)
            if (count === 1) {
                return 1.5; // Premiar la singularidad
            }
            
            // Si es núcleo ontológico y aparece pocas veces en texto corto: repetición estratégica
            if (ontologicalNuclei.includes(cleanWord)) {
                if (totalWords <= 10 && count <= 3) {
                    return 1.3; // Repetición estratégica en textos muy cortos
                }
                if (totalWords <= 20 && count <= 5) {
                    return 1.1; // Repetición moderada
                }
                // Penalizar repetición excesiva: más repeticiones = menos valor cada una
                if (count > 5) {
                    return Math.max(0.5, 1.0 - (count - 5) * 0.1); // Degradación progresiva
                }
                return 1.0;
            }
            
            // Para palabras no ontológicas: penalizar más la repetición
            if (count > 1) {
                return Math.max(0.3, 1.0 - (count - 1) * 0.15); // Degradación más agresiva
            }
            
            return 1.0;
        }
        
        // E. Tense-Based Multiplier (Temporal Value System)
        // Aplica multiplicadores según el tiempo verbal del texto y su complejidad
        function getTenseMultiplier(wordIndex, words, totalWords) {
            // 1. Detectar tiempo verbal de cada verbo
            function detectVerbTense(word, pos) {
                if (pos !== 'verb') return null;
                
                const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
                
                // Presente
                const presentVerbs = ['is', 'am', 'are', 'be', 'being', 'exist', 'exists', 'remain', 'remains',
                                     'es', 'son', 'estar', 'ser', 'existe', 'existen', 'permanece', 'permanecen',
                                     'have', 'has', 'do', 'does', 'go', 'goes', 'come', 'comes', 'see', 'sees',
                                     'tengo', 'tiene', 'hago', 'hace', 'voy', 'va', 'vengo', 'viene', 'veo', 've'];
                
                // Pasado
                const pastVerbs = ['was', 'were', 'been', 'existed', 'remained', 'became', 'had', 'did', 'went',
                                  'came', 'saw', 'fue', 'fueron', 'estuvo', 'estuvieron', 'existió', 'existieron',
                                  'tuvo', 'hizo', 'fue', 'vino', 'vio', 'said', 'told', 'thought', 'knew',
                                  'dijo', 'contó', 'pensó', 'supo'];
                
                // Futuro (will, going to, modales de futuro)
                const futureVerbs = ['will', 'shall', 'would', 'going', 'gonna',
                                    'será', 'serán', 'estará', 'estarán', 'tendrá', 'tendrán', 'hará', 'harán',
                                    'irá', 'irán', 'vendrá', 'vendrán', 'verá', 'verán'];
                
                // Futuro implícito (verbos modales que indican futuro)
                const futureModal = ['will', 'shall', 'would', 'can', 'could', 'may', 'might',
                                    'podrá', 'podrán', 'deberá', 'deberán', 'puede', 'pueden'];
                
                if (presentVerbs.includes(cleanWord)) return 'present';
                if (pastVerbs.includes(cleanWord)) return 'past';
                if (futureVerbs.includes(cleanWord) || futureModal.includes(cleanWord)) return 'future';
                
                // Detección por sufijos (ing = presente continuo, ed = pasado)
                if (cleanWord.endsWith('ing')) return 'present';
                if (cleanWord.endsWith('ed')) return 'past';
                
                return null;
            }
            
            // 2. Analizar todos los verbos del texto para determinar tiempo predominante
            // Skip extra names - they don't exist for context
            let presentCount = 0;
            let pastCount = 0;
            let futureCount = 0;
            const wordTenses = [];
            
            words.forEach((w, idx) => {
                // Skip extra names - they don't count for context
                if (w && w.isExtraName) {
                    wordTenses[idx] = null;
                    return;
                }
                const tense = detectVerbTense(w.text, w.pos);
                wordTenses[idx] = tense;
                if (tense === 'present') presentCount++;
                else if (tense === 'past') pastCount++;
                else if (tense === 'future') futureCount++;
            });
            
            const totalVerbs = presentCount + pastCount + futureCount;
            const currentWordTense = wordTenses[wordIndex];
            
            // Si no hay verbos o la palabra actual no es verbo, retornar 1.0
            if (totalVerbs === 0 || !currentWordTense) {
                return 1.0;
            }
            
            // 3. Determinar tiempo predominante
            let predominantTense = null;
            if (presentCount > pastCount && presentCount > futureCount) predominantTense = 'present';
            else if (pastCount > presentCount && pastCount > futureCount) predominantTense = 'past';
            else if (futureCount > presentCount && futureCount > pastCount) predominantTense = 'future';
            else if (presentCount > 0 && (pastCount > 0 || futureCount > 0)) {
                // Mezcla: presente con otro tiempo
                if (futureCount > 0) predominantTense = 'present_future';
                if (pastCount > 0) predominantTense = 'present_past';
            }
            
            // 4. Aplicar multiplicadores según las reglas
            
            // REGLA 1: TEXTO EN PASADO - más largo = más valor (aumentada influencia)
            if (predominantTense === 'past' && currentWordTense === 'past') {
                // Multiplicador positivo con longitud (incrementado significativamente)
                if (totalWords <= 10) return 1.5; // Textos muy cortos en pasado se benefician más
                if (totalWords <= 50) return 1.5 + (totalWords / 50) * 0.9; // 1.5 a 2.4
                if (totalWords <= 200) return 2.4 + ((totalWords - 50) / 150) * 1.2; // 2.4 a 3.6
                return 3.6 + Math.min(0.9, (totalWords - 200) / 500); // Hasta 4.5 para textos muy largos
            }
            
            // REGLA 2: TEXTO EN PRESENTE - más simple/corto = más valor (aumentada influencia)
            if (predominantTense === 'present' && currentWordTense === 'present') {
                // Multiplicador negativo con longitud (más corto = más valor, incrementado significativamente)
                if (totalWords === 1) return 5.0; // Máximo valor para palabra única (duplicado)
                if (totalWords === 2) return 4.4;
                if (totalWords === 3) return 4.0; // "I am X" = ideal (duplicado)
                if (totalWords <= 5) return 3.6;
                if (totalWords <= 10) return 3.0;
                if (totalWords <= 20) return 2.4;
                if (totalWords <= 50) return 2.0;
                if (totalWords <= 200) return 1.6; // Penalización para textos largos en presente
                return 1.2; // Penalización fuerte para textos muy largos
            }
            
            // REGLA 3: TEXTO EN FUTURO - más largo = menos valor (aumentada influencia)
            if (predominantTense === 'future' && currentWordTense === 'future') {
                // Multiplicador negativo con longitud (más largo = menos valor, incrementado significativamente)
                if (totalWords <= 5) return 3.0; // Textos cortos en futuro valen más (duplicado)
                if (totalWords <= 10) return 2.4;
                if (totalWords <= 20) return 2.0;
                if (totalWords <= 50) return 1.6;
                if (totalWords <= 200) return 1.2;
                return 0.8; // Penalización fuerte para textos largos en futuro
            }
            
            // REGLA 4: PRESENTE + FUTURO - las partes en futuro acumulan mucho más valor (aumentada influencia)
            if (predominantTense === 'present_future') {
                if (currentWordTense === 'future') {
                    // Las partes en futuro valen mucho más (incrementado significativamente)
                    if (totalWords <= 10) return 6.0; // Máximo valor para futuro en textos cortos (duplicado)
                    if (totalWords <= 20) return 5.0;
                    if (totalWords <= 50) return 4.0;
                    if (totalWords <= 200) return 3.0;
                    return 2.4; // Aún alto para textos largos
                } else if (currentWordTense === 'present') {
                    // Las partes en presente mantienen valor normal o ligeramente reducido (incrementado)
                    if (totalWords <= 10) return 3.0;
                    if (totalWords <= 20) return 2.4;
                    return 2.0;
                }
            }
            
            // REGLA 5: PRESENTE + PASADO - más corto y simple = más valor; más extenso y conexiones = menos valor (aumentada influencia)
            if (predominantTense === 'present_past') {
                // Calcular complejidad (número de conexiones aproximado por densidad de palabras)
                const complexity = totalWords; // Más palabras = más complejidad
                
                if (currentWordTense === 'present' || currentWordTense === 'past') {
                    // Textos cortos y simples valen más (incrementado significativamente)
                    if (totalWords <= 3) return 4.0; // Máximo valor (duplicado)
                    if (totalWords <= 5) return 3.6;
                    if (totalWords <= 10) return 3.0;
                    if (totalWords <= 20) return 2.4;
                    if (totalWords <= 50) return 2.0;
                    // Penalización por extensión y conexiones
                    if (totalWords <= 200) return 1.4; // Menos valor para textos extensos
                    return 1.0; // Penalización fuerte para textos muy extensos con muchas conexiones
                }
            }
            
            // Default: sin multiplicador especial
            return 1.0;
        }
        
        // F. Narrative/Explanatory Penalty Multiplier
        // Penaliza textos que explican/describen en lugar de afirmar ser
        function getNarrativePenalty(wordIndex, words, totalWords) {
            // Detectar verbos narrativos/explicativos
            const narrativeVerbs = ['say', 'says', 'said', 'tell', 'tells', 'told', 'describe', 'describes', 'described',
                                   'explain', 'explains', 'explained', 'mean', 'means', 'meant', 'think', 'thinks', 'thought',
                                   'decir', 'dice', 'dijo', 'contar', 'cuenta', 'contó', 'describir', 'describe', 'describió',
                                   'explicar', 'explica', 'explicó', 'significar', 'significa', 'pensar', 'piensa', 'pensó'];
            
            let narrativeWordCount = 0;
            words.forEach(w => {
                // Skip extra names - they don't count for context
                if (w && w.isExtraName) return;
                const cleanWord = w.text.toLowerCase().replace(/[^\w]/g, '');
                if (narrativeVerbs.includes(cleanWord) || 
                    (w.pos === 'verb' && !w.isSerEstar && 
                     !['am', 'is', 'are', 'be', 'was', 'were', 'es', 'son', 'estar', 'ser'].includes(cleanWord))) {
                    narrativeWordCount++;
                }
            });
            
            // Si hay muchos verbos narrativos, el texto está explicando (penalizar)
            if (narrativeWordCount > totalWords * 0.2) {
                // Más del 20% son verbos narrativos = texto explicativo
                return 0.6; // Penalización significativa
            }
            if (narrativeWordCount > totalWords * 0.1) {
                // Más del 10% son verbos narrativos
                return 0.8;
            }
            
            return 1.0; // Sin penalización para textos afirmativos
        }
        
        // Identify compound names (consecutive names treated as one)
        function identifyCompoundNames() {
            const nameGroups = [];
            let currentGroup = null;
            
            analyzedWords.forEach((wordData, index) => {
                const isNameWord = wordData.isName && wordData.pos === 'noun';
                
                if (isNameWord) {
                    if (currentGroup === null) {
                        // Start new group
                        currentGroup = {
                            indices: [index],
                            startIndex: index
                        };
                    } else {
                        // Check if this name is consecutive to the previous one
                        const lastIndex = currentGroup.indices[currentGroup.indices.length - 1];
                        if (index === lastIndex + 1) {
                            // Consecutive name - add to current group
                            currentGroup.indices.push(index);
                        } else {
                            // Not consecutive - save current group and start new one
                            if (currentGroup.indices.length > 0) {
                                nameGroups.push(currentGroup);
                            }
                            currentGroup = {
                                indices: [index],
                                startIndex: index
                            };
                        }
                    }
                } else {
                    // Not a name - close current group if exists
                    if (currentGroup !== null && currentGroup.indices.length > 0) {
                        nameGroups.push(currentGroup);
                        currentGroup = null;
                    }
                }
            });
            
            // Don't forget the last group
            if (currentGroup !== null && currentGroup.indices.length > 0) {
                nameGroups.push(currentGroup);
            }
            
            // Store in global for use in repetition multiplier
            window.nameGroups = nameGroups;
            
            // Mark words that are part of compound names
            nameGroups.forEach(group => {
                if (group.indices.length > 1) {
                    // This is a compound name - mark all words in the group
                    group.indices.forEach((idx, position) => {
                        analyzedWords[idx].isPartOfCompoundName = true;
                        analyzedWords[idx].compoundNameGroup = group;
                        // Mark 3rd+ names as "extra" - they don't count for context
                        if (position >= 2) {
                            analyzedWords[idx].isExtraName = true; // 3rd name or later
                        }
                    });
                }
            });
            
            console.log(`Identified ${nameGroups.length} name groups (${nameGroups.filter(g => g.indices.length > 1).length} compound names)`);
            return nameGroups;
        }
        
        // MAIN CALCULATION FUNCTION
        function calculateScores() {
            console.log('calculateScores called with', analyzedWords.length, 'words');
            
            if (!analyzedWords || analyzedWords.length === 0) {
                console.error('calculateScores: No analyzed words to process!');
                return;
            }
            
            // Identify compound names first
            identifyCompoundNames();
            
            // Count only non-extra words for context calculations
            // Extra names (3rd+ in compounds) don't count for any contextual calculations
            const effectiveWords = analyzedWords.filter(w => !w.isExtraName);
            const totalWords = effectiveWords.length; // Use effective word count, not total
            const lengthMultiplier = getLengthMultiplier(totalWords);
            console.log(`Length multiplier for ${totalWords} effective words (${analyzedWords.length} total, ${analyzedWords.length - totalWords} extra names ignored)`);
            
            // Calculate final value for each word
            analyzedWords.forEach((wordData, index) => {
                try {
                    // Check if this name is part of a compound with 3+ names
                    // If so, and it's the 3rd name or later, set value to 0
                    let isExtraName = false;
                    if (wordData.isName && wordData.isPartOfCompoundName && wordData.compoundNameGroup) {
                        const nameGroup = wordData.compoundNameGroup;
                        if (nameGroup.indices.length > 2) {
                            // This is a compound with 3+ names
                            const positionInGroup = nameGroup.indices.indexOf(index);
                            if (positionInGroup >= 2) {
                                // This is the 3rd name or later - set value to 0
                                isExtraName = true;
                            }
                        }
                    }
                    
                    // If this is an extra name (3rd+ in a compound), set all values to 0
                    if (isExtraName) {
                        wordData.baseValue = 0;
                        wordData.finalValue = 0;
                        wordData.totalScore = 0;
                        wordData.lengthMultiplier = 1.0;
                        wordData.ontologicalMultiplier = 1.0;
                        wordData.nameWithToBeMultiplier = 1.0;
                        wordData.semanticMultiplier = 1.0;
                        wordData.repetitionMultiplier = 1.0;
                        wordData.tenseMultiplier = 1.0;
                        wordData.narrativePenalty = 1.0;
                        return; // Skip rest of calculation for this word
                    }
                    
                    // Get base value
                    let baseValue = getBaseValue(wordData.text, wordData.pos);
                    
                    // Apply minimum value constraint
                    baseValue = Math.max(baseValue, 0.1);
                    
                    // Apply multipliers
                    let ontologicalMultiplier = isOntologicalAssertion(index, analyzedWords) ? 1.8 : 1.0;
                    let nameWithToBeMultiplier = getNameWithToBeMultiplier(index, analyzedWords); // Bonus for names with "to be"
                    let semanticMultiplier = getSemanticClosureMultiplier(index, analyzedWords, totalWords);
                    let repetitionMultiplier = getRepetitionMultiplier(index, analyzedWords, wordData.text, totalWords);
                    let tenseMultiplier = getTenseMultiplier(index, analyzedWords, totalWords); // Temporal value multiplier
                    let narrativePenalty = getNarrativePenalty(index, analyzedWords, totalWords);
                    
                    // Calculate final word value (LEDGER-BASED: no normalization, no averaging, accumulation only)
                    wordData.baseValue = baseValue;
                    // Apply all contextual multipliers (ledger system: each word's value modified by context)
                    // Final Word Value = Base Value × Length × Ontological × Name+ToBe × Semantic × Repetition × Tense × Narrative × Global Reduction
                    wordData.finalValue = (baseValue * lengthMultiplier * ontologicalMultiplier * nameWithToBeMultiplier * semanticMultiplier * repetitionMultiplier * tenseMultiplier * narrativePenalty) * 0.4335;
                    // Global reduction of 60% applied (ledger entry adjustment)
                    
                    // Ensure minimum value
                    wordData.finalValue = Math.max(wordData.finalValue, 0.1);
                    
                    // Store for compatibility (using finalValue as totalScore)
                    wordData.totalScore = wordData.finalValue;
                    
                    // Store multipliers for debugging/info
                    wordData.lengthMultiplier = lengthMultiplier;
                    wordData.ontologicalMultiplier = ontologicalMultiplier;
                    wordData.nameWithToBeMultiplier = nameWithToBeMultiplier;
                    wordData.semanticMultiplier = semanticMultiplier;
                    wordData.repetitionMultiplier = repetitionMultiplier;
                    wordData.tenseMultiplier = tenseMultiplier;
                    wordData.narrativePenalty = narrativePenalty;
                    
                    // Log first few words for debugging
                    if (index < 5) {
                        console.log(`Word ${index} "${wordData.text}": base=${baseValue.toFixed(2)}, final=${wordData.finalValue.toFixed(2)}, pos=${wordData.pos}`);
                    }
                } catch (error) {
                    console.error(`Error calculating score for word ${index} (${wordData.text}):`, error);
                    // Set default values to prevent crash
                    wordData.baseValue = 0.1;
                    wordData.finalValue = 0.1;
                    wordData.totalScore = 0.1;
                }
            });
            
            // Note: Compound names with 3+ names now have the 3rd+ names set to value 0
            // This ensures that all compounds (2, 3, 4, 5... names) have the same total value
            // (only the first 2 names contribute to the value)
            
            // No normalization needed anymore since extra names are set to 0
            if (false && window.nameGroups && window.nameGroups.length > 0) {
                // Calculate reference value: what a 2-name compound should be worth
                // We need to recalculate values as if they were a 2-name compound, not using current values
                let referenceTotalValue = null;
                
                // Find first compound with 2+ names to calculate reference
                for (let i = 0; i < window.nameGroups.length; i++) {
                    const nameGroup = window.nameGroups[i];
                    if (nameGroup.indices.length >= 2) {
                        // Calculate what the first 2 names would be worth as a 2-name compound
                        // We need to recalculate removing the compound multiplier effect and reapplying for 2 names
                        const firstTwoIndices = nameGroup.indices.slice(0, 2);
                        let twoNameTotal = 0;
                        
                        firstTwoIndices.forEach(idx => {
                            const wordData = analyzedWords[idx];
                            if (wordData) {
                                // Current finalValue includes compound multiplier (1.8) for the actual compound size
                                // We need to calculate what it would be for a 2-name compound
                                // Since all names in compound get same multipliers, we can calculate:
                                // value_without_compound = finalValue / 1.8
                                // value_for_2name = value_without_compound * 1.8 = finalValue
                                // But wait, that's the same... 
                                // Actually, the issue is that the repetition multiplier includes compound info
                                // Let's recalculate properly: get base value and all multipliers except compound
                                const baseVal = wordData.baseValue || 0.1;
                                const lengthMult = wordData.lengthMultiplier || 1.0;
                                const ontologicalMult = wordData.ontologicalMultiplier || 1.0;
                                const nameToBeMult = wordData.nameWithToBeMultiplier || 1.0;
                                const semanticMult = wordData.semanticMultiplier || 1.0;
                                const tenseMult = wordData.tenseMultiplier || 1.0;
                                const narrativePen = wordData.narrativePenalty || 1.0;
                                
                                // Get repetition multiplier: we need to extract the compound multiplier part
                                // The repetition multiplier returned from getRepetitionMultiplier includes:
                                // scarcity * repetition * compound (1.8 for compounds)
                                // For a 2-name compound, we want the same scarcity and repetition, but compound is still 1.8
                                // So actually the repetition multiplier should be the same!
                                // The issue is that we're already using the right multiplier, so let's just use current value
                                // But wait - if this is a 3-name compound, the current value has compound 1.8 applied
                                // which is correct, but we want to know what 2 names would be worth
                                // Since each name gets the same multiplier, 2 names = 2 * (value_per_name)
                                // So we can just take the average value per name and multiply by 2
                                
                                // Actually simpler: use current finalValue directly since it already has all multipliers
                                if (wordData.finalValue) {
                                    twoNameTotal += wordData.finalValue;
                                }
                            }
                        });
                        
                        if (twoNameTotal > 0) {
                            referenceTotalValue = twoNameTotal;
                            console.log(`Reference value calculated from first 2 names: ${referenceTotalValue.toFixed(6)}`);
                            break;
                        }
                    }
                }
                
                // Now normalize ALL compounds to have this exact reference value
                if (referenceTotalValue !== null && referenceTotalValue > 0) {
                    console.log(`=== NORMALIZING ALL COMPOUNDS TO: ${referenceTotalValue.toFixed(6)} ===`);
                    window.nameGroups.forEach((nameGroup, groupIdx) => {
                        const nameCount = nameGroup.indices.length;
                        if (nameCount >= 2) {
                            // Calculate current total
                            let currentTotal = 0;
                            nameGroup.indices.forEach(idx => {
                                if (analyzedWords[idx] && analyzedWords[idx].finalValue) {
                                    currentTotal += analyzedWords[idx].finalValue;
                                }
                            });
                            
                            if (currentTotal > 0) {
                                const normalizationFactor = referenceTotalValue / currentTotal;
                                
                                // Apply normalization to ALL names in compound
                                nameGroup.indices.forEach(idx => {
                                    if (analyzedWords[idx] && analyzedWords[idx].finalValue) {
                                        const oldValue = analyzedWords[idx].finalValue;
                                        analyzedWords[idx].finalValue = oldValue * normalizationFactor;
                                        analyzedWords[idx].totalScore = analyzedWords[idx].finalValue;
                                    }
                                });
                                
                                // Verify
                                let newTotal = 0;
                                nameGroup.indices.forEach(idx => {
                                    if (analyzedWords[idx] && analyzedWords[idx].finalValue) {
                                        newTotal += analyzedWords[idx].finalValue;
                                    }
                                });
                                
                                console.log(`Compound ${groupIdx} (${nameCount} names): ${currentTotal.toFixed(6)} → ${newTotal.toFixed(6)} (factor: ${normalizationFactor.toFixed(6)})`);
                                
                                // Double-check: ensure the total is exactly the reference value
                                if (Math.abs(newTotal - referenceTotalValue) > 0.000001) {
                                    console.warn(`WARNING: Normalization mismatch! Expected ${referenceTotalValue.toFixed(6)}, got ${newTotal.toFixed(6)}`);
                                    // Force exact match by adjusting the last name
                                    if (nameGroup.indices.length > 0) {
                                        const lastIdx = nameGroup.indices[nameGroup.indices.length - 1];
                                        if (analyzedWords[lastIdx]) {
                                            const adjustment = referenceTotalValue - newTotal;
                                            analyzedWords[lastIdx].finalValue += adjustment;
                                            analyzedWords[lastIdx].totalScore = analyzedWords[lastIdx].finalValue;
                                            console.log(`Adjusted last name by ${adjustment.toFixed(6)} to fix total`);
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    // Final verification: check all compound totals
                    console.log(`=== FINAL VERIFICATION ===`);
                    const verificationResults = [];
                    window.nameGroups.forEach((nameGroup, groupIdx) => {
                        if (nameGroup.indices.length >= 2) {
                            let total = 0;
                            const names = [];
                            nameGroup.indices.forEach(idx => {
                                if (analyzedWords[idx] && analyzedWords[idx].finalValue) {
                                    total += analyzedWords[idx].finalValue;
                                    names.push(analyzedWords[idx].text);
                                }
                            });
                            const namesText = names.join(' + ');
                            const totalETH = ethPriceUSD ? (total / ethPriceUSD).toFixed(6) : total.toFixed(6);
                            console.log(`Compound ${groupIdx} (${nameGroup.indices.length} names) "${namesText}": ${total.toFixed(6)} USD = ${totalETH} ETH`);
                            verificationResults.push({ count: nameGroup.indices.length, total: total, names: namesText });
                        }
                    });
                    
                    // Verify all compounds have the same total
                    if (verificationResults.length > 1) {
                        const firstTotal = verificationResults[0].total;
                        const allMatch = verificationResults.every(r => Math.abs(r.total - firstTotal) < 0.0001);
                        if (allMatch) {
                            console.log(`✓ SUCCESS: All ${verificationResults.length} compounds have the same total: ${firstTotal.toFixed(6)}`);
                        } else {
                            console.error(`✗ ERROR: Compounds have different totals!`);
                            verificationResults.forEach(r => {
                                console.error(`  ${r.count} names "${r.names}": ${r.total.toFixed(6)}`);
                            });
                        }
                    }
                    console.log(`=== NORMALIZATION COMPLETE ===`);
                }
            }
            
            // Calculate total text value (LEDGER-BASED: sum of all word values - no averages, no normalization)
            // Total Text Value = Sum of all Final Word Values (ledger entry, not a symbolic number)
            const totalTextValue = analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
            
            // Store total text value
            window.totalTextScore = totalTextValue;
            
            // For visualization, we still need normalized scores (0 to 1) but keep original values
            const maxValue = Math.max(...analyzedWords.map(w => w.finalValue || 0), 1);
            analyzedWords.forEach(wordData => {
                wordData.normalizedScore = maxValue > 0 ? (wordData.finalValue || 0) / maxValue : 0.5;
                // Ensure normalizedScore is a valid number
                if (isNaN(wordData.normalizedScore) || !isFinite(wordData.normalizedScore)) {
                    wordData.normalizedScore = 0.5;
                }
            });
            
            console.log(`Calculated scores for ${analyzedWords.length} words. Max value: ${maxValue}, Total: ${totalTextValue}`);
        }
        
        function isToDoVerb(word) {
            const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
            const toDoVerbs = ['hacer', 'hace', 'hacen', 'hizo', 'hicieron', 'haciendo', 'hecho',
                              'do', 'does', 'did', 'doing', 'done', 'make', 'makes', 'made', 'making'];
            return toDoVerbs.includes(cleanWord);
        }
        
        function isToHaveVerb(word) {
            const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
            const toHaveVerbs = ['tener', 'tiene', 'tienen', 'tuvo', 'tuvieron', 'teniendo', 'tenido',
                                'haber', 'ha', 'han', 'había', 'habían', 'habiendo', 'habido',
                                'have', 'has', 'had', 'having'];
            return toHaveVerbs.includes(cleanWord);
        }
        
        function isSubject(wordData, index) {
            // Check if word is likely a subject (pronoun or noun at start of sentence/clause)
            if (wordData.pos === 'pronoun') return true;
            if (wordData.pos === 'noun' && index < 5) return true; // Early nouns often subjects
            return false;
        }
        
        function isIdentityWord(word) {
            const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
            const identityWords = ['yo', 'i', 'me', 'mi', 'mío', 'mía', 'myself',
                                  'tú', 'you', 'tu', 'tuyo', 'tuya', 'yourself',
                                  'él', 'ella', 'he', 'she', 'him', 'her', 'his', 'hers', 'himself', 'herself',
                                  'nosotros', 'nosotras', 'we', 'us', 'our', 'ourselves',
                                  'vosotros', 'vosotras', 'you', 'yourselves',
                                  'ellos', 'ellas', 'they', 'them', 'their', 'themselves',
                                  'persona', 'person', 'gente', 'people', 'ser', 'being', 'identidad', 'identity'];
            return identityWords.includes(cleanWord);
        }
        
        // Database of known proper nouns (names, cities, countries, etc.)
        const KNOWN_PROPER_NOUNS = new Set([
            // Common first names (English)
            'John', 'Mary', 'James', 'Robert', 'Michael', 'William', 'David', 'Richard', 'Joseph', 'Thomas',
            'Charles', 'Christopher', 'Daniel', 'Matthew', 'Anthony', 'Mark', 'Donald', 'Steven', 'Paul', 'Andrew',
            'Joshua', 'Kenneth', 'Kevin', 'Brian', 'George', 'Edward', 'Ronald', 'Timothy', 'Jason', 'Jeffrey',
            'Ryan', 'Jacob', 'Gary', 'Nicholas', 'Eric', 'Jonathan', 'Stephen', 'Larry', 'Justin', 'Scott',
            'Sarah', 'Jennifer', 'Emily', 'Jessica', 'Amanda', 'Melissa', 'Deborah', 'Michelle', 'Carol', 'Lisa',
            'Nancy', 'Karen', 'Betty', 'Helen', 'Sandra', 'Donna', 'Carolyn', 'Ruth', 'Sharon', 'Laura',
            'Anna', 'Emma', 'Olivia', 'Sophia', 'Isabella', 'Charlotte', 'Mia', 'Amelia', 'Harper', 'Evelyn',
            // Common first names (Spanish)
            'José', 'María', 'Juan', 'Francisco', 'Antonio', 'Manuel', 'Pedro', 'Carlos', 'Luis', 'Miguel',
            'Jesús', 'Javier', 'Fernando', 'Pablo', 'Ángel', 'Alejandro', 'Rafael', 'Mario', 'Enrique', 'Ricardo',
            'Carmen', 'Ana', 'Laura', 'Patricia', 'Guadalupe', 'Rosa', 'Martha', 'Gloria', 'Andrea', 'Monica',
            'Lucía', 'Sofía', 'Martina', 'Isabella', 'Valentina', 'Emma', 'Olivia', 'Sara', 'Julia', 'Paula',
            // Major cities (English)
            'Paris', 'London', 'New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix', 'Philadelphia', 'San Antonio', 'San Diego',
            'Dallas', 'San Jose', 'Austin', 'Jacksonville', 'San Francisco', 'Indianapolis', 'Columbus', 'Fort Worth', 'Charlotte', 'Seattle',
            'Denver', 'Washington', 'Boston', 'El Paso', 'Detroit', 'Nashville', 'Portland', 'Memphis', 'Oklahoma City', 'Las Vegas',
            'Louisville', 'Baltimore', 'Milwaukee', 'Albuquerque', 'Tucson', 'Fresno', 'Sacramento', 'Kansas City', 'Mesa', 'Atlanta',
            'Miami', 'Omaha', 'Raleigh', 'Minneapolis', 'New Orleans', 'Cleveland', 'Tulsa', 'Wichita', 'Arlington', 'Tampa',
            'Tokyo', 'Delhi', 'Shanghai', 'São Paulo', 'Mumbai', 'Beijing', 'Osaka', 'Cairo', 'Dhaka', 'Mexico City',
            'Buenos Aires', 'Kolkata', 'Bangkok', 'Istanbul', 'Lagos', 'Manila', 'Rio de Janeiro', 'Kinshasa', 'Lima', 'Bogotá',
            // Major cities (Spanish)
            'Madrid', 'Barcelona', 'Valencia', 'Sevilla', 'Zaragoza', 'Málaga', 'Murcia', 'Palma', 'Las Palmas', 'Bilbao',
            'Alicante', 'Córdoba', 'Valladolid', 'Vigo', 'Gijón', 'Hospitalet', 'Granada', 'Vitoria', 'A Coruña', 'Elche',
            'Buenos Aires', 'Córdoba', 'Rosario', 'Mendoza', 'La Plata', 'Tucumán', 'Mar del Plata', 'Salta', 'Santa Fe', 'San Juan',
            'Ciudad de México', 'Guadalajara', 'Monterrey', 'Puebla', 'Tijuana', 'León', 'Juárez', 'Torreón', 'Querétaro', 'San Luis Potosí',
            // Countries
            'Spain', 'France', 'Italy', 'Germany', 'United Kingdom', 'Portugal', 'Greece', 'Netherlands', 'Belgium', 'Switzerland',
            'Austria', 'Sweden', 'Norway', 'Denmark', 'Finland', 'Poland', 'Czech Republic', 'Hungary', 'Romania', 'Bulgaria',
            'Russia', 'China', 'Japan', 'India', 'Brazil', 'Argentina', 'Chile', 'Colombia', 'Peru', 'Venezuela',
            'Mexico', 'Canada', 'Australia', 'New Zealand', 'South Africa', 'Egypt', 'Turkey', 'Saudi Arabia', 'Iran', 'Iraq',
            'España', 'Francia', 'Italia', 'Alemania', 'Reino Unido', 'Portugal', 'Grecia', 'Países Bajos', 'Bélgica', 'Suiza',
            'México', 'Argentina', 'Chile', 'Colombia', 'Perú', 'Venezuela', 'Ecuador', 'Bolivia', 'Paraguay', 'Uruguay',
            // Other proper nouns
            'Amazon', 'Google', 'Microsoft', 'Apple', 'Facebook', 'Tesla', 'Nike', 'Coca-Cola', 'McDonald\'s', 'Starbucks',
            'Nintendo', 'Sony', 'Samsung', 'Volkswagen', 'Toyota', 'Honda', 'Ford', 'BMW', 'Mercedes', 'Audi',
            'Einstein', 'Shakespeare', 'Picasso', 'Mozart', 'Beethoven', 'Da Vinci', 'Galileo', 'Newton', 'Darwin', 'Freud',
            'Jesus', 'Buddha', 'Muhammad', 'Moses', 'Abraham', 'Noah', 'Adam', 'Eve', 'Mary', 'Joseph',
            'Carbajal'
        ]);
        
        function isName(word, index) {
            const cleanWord = word.replace(/[^\w\u4e00-\u9fff]/g, '');
            
            // First check against known proper nouns database (includes "Carbajal" and other surnames)
            if (KNOWN_PROPER_NOUNS.has(cleanWord)) {
                return true;
            }
            
            // Also check capitalized words that are nouns
            const isCapitalized = /^[A-Z\u00C0-\u017F]/.test(cleanWord) && cleanWord.length > 1;
            
            // Common words that are capitalized but not names
            const commonCapitalized = ['I', 'The', 'A', 'An', 'This', 'That', 'These', 'Those', 
                                      'He', 'She', 'We', 'They', 'You', 'It'];
            
            // Exclude common capitalized words
            if (commonCapitalized.includes(cleanWord)) {
                return false;
            }
            
            // Check if this word appears after a name (likely a surname like "Carbajal")
            if (index > 0 && analyzedWords && analyzedWords.length > 0) {
                const previousWord = analyzedWords[index - 1];
                if (previousWord && previousWord.isName && previousWord.pos === 'noun') {
                    // Previous word is a name, so this capitalized word is likely a surname
                    if (isCapitalized && cleanWord.length >= 2) {
                        const context = { prevWord: previousWord.text, nextWord: '', index: index, allWords: analyzedWords || [] };
                        const pos = getPOS(word, context);
                        if (pos === 'noun') {
                            return true;
                        }
                    }
                }
            }
            
            // If it's a noun and capitalized, likely a name
            if (isCapitalized && index < 3) {
                return true; // Early capitalized nouns are likely names
            }
            
            // Capitalized word that's not a common word
            if (isCapitalized && cleanWord.length >= 2) {
                const prevWord = index > 0 && analyzedWords ? analyzedWords[index - 1]?.text || '' : '';
                const nextWord = analyzedWords && index < analyzedWords.length - 1 ? analyzedWords[index + 1]?.text || '' : '';
                const context = { prevWord: prevWord, nextWord: nextWord, index: index, allWords: analyzedWords || [] };
                const pos = getPOS(word, context);
                if (pos === 'noun') {
                    return true;
                }
            }
            
            return false;
        }
        
        function findMoralStructures() {
            const structures = [];
            const windowSize = 5; // Look at 5-word windows
            
            for (let i = 0; i < analyzedWords.length - 2; i++) {
                const window = analyzedWords.slice(i, Math.min(i + windowSize, analyzedWords.length));
                const windowIndices = window.map((_, idx) => i + idx);
                
                // Structure 1: Subject + "to be" + Complement (identity/existence)
                const subjectIndex = window.findIndex((w, idx) => isSubject(w, i + idx));
                const toBeIndex = window.findIndex(w => w.isSerEstar);
                const complementIndex = window.findIndex((w, idx) => 
                    idx > Math.max(subjectIndex, toBeIndex) && 
                    (w.pos === 'noun' || w.pos === 'adjective' || isIdentityWord(w.text))
                );
                
                if (subjectIndex >= 0 && toBeIndex >= 0 && complementIndex >= 0 && 
                    subjectIndex < toBeIndex && toBeIndex < complementIndex) {
                    // Check if complement is adjective or personal name (more valuable)
                    const complementWord = window[complementIndex];
                    const isPersonalComplement = complementWord.pos === 'adjective' || 
                                                 (complementWord.pos === 'noun' && isName(complementWord.text, windowIndices[complementIndex])) ||
                                                 isIdentityWord(complementWord.text);
                    const isSituation = complementWord.pos === 'noun' && !isName(complementWord.text, windowIndices[complementIndex]) && 
                                       !isIdentityWord(complementWord.text);
                    
                    const structureType = isPersonalComplement ? 'subject_to_be_personal' : 
                                         isSituation ? 'subject_to_be_situation' : 
                                         'subject_to_be_complement';
                    
                    const score = calculateStructureScore(structureType, window, windowIndices);
                    structures.push({
                        type: structureType,
                        indices: [windowIndices[subjectIndex], windowIndices[toBeIndex], windowIndices[complementIndex]],
                        score: score
                    });
                }
                
                // Structure 2: Subject + "to do" + Object (action)
                const toDoIndex = window.findIndex(w => isToDoVerb(w.text));
                const objectIndex = window.findIndex((w, idx) => 
                    idx > Math.max(subjectIndex, toDoIndex) && w.pos === 'noun'
                );
                
                if (subjectIndex >= 0 && toDoIndex >= 0 && objectIndex >= 0 &&
                    subjectIndex < toDoIndex && toDoIndex < objectIndex) {
                    const score = calculateStructureScore('subject_to_do_object', window, windowIndices);
                    structures.push({
                        type: 'subject_to_do_object',
                        indices: [windowIndices[subjectIndex], windowIndices[toDoIndex], windowIndices[objectIndex]],
                        score: score
                    });
                }
                
                // Structure 3: Subject + "to have" + Object (possession/existence)
                const toHaveIndex = window.findIndex(w => isToHaveVerb(w.text));
                const haveObjectIndex = window.findIndex((w, idx) => 
                    idx > Math.max(subjectIndex, toHaveIndex) && w.pos === 'noun'
                );
                
                if (subjectIndex >= 0 && toHaveIndex >= 0 && haveObjectIndex >= 0 &&
                    subjectIndex < toHaveIndex && toHaveIndex < haveObjectIndex) {
                    const score = calculateStructureScore('subject_to_have_object', window, windowIndices);
                    structures.push({
                        type: 'subject_to_have_object',
                        indices: [windowIndices[subjectIndex], windowIndices[toHaveIndex], windowIndices[haveObjectIndex]],
                        score: score
                    });
                }
                
                // Structure 4: Identity structure (pronoun + "to be" + identity)
                const pronounIndex = window.findIndex(w => w.pos === 'pronoun' || isIdentityWord(w.text));
                const identityToBeIndex = window.findIndex((w, idx) => idx > pronounIndex && w.isSerEstar);
                const identityComplementIndex = window.findIndex((w, idx) => 
                    idx > identityToBeIndex && (isIdentityWord(w.text) || w.pos === 'noun' || w.pos === 'adjective')
                );
                
                if (pronounIndex >= 0 && identityToBeIndex >= 0 && identityComplementIndex >= 0) {
                    const score = calculateStructureScore('identity_structure', window, windowIndices);
                    structures.push({
                        type: 'identity_structure',
                        indices: [windowIndices[pronounIndex], windowIndices[identityToBeIndex], windowIndices[identityComplementIndex]],
                        score: score
                    });
                }
            }
            
            return structures;
        }
        
        function calculateStructureScore(structureType, window, indices) {
            let baseScore = 0;
            
            switch(structureType) {
                case 'subject_to_be_personal':
                    baseScore = 10; // Very high value - to be + adjective/personal name
                    break;
                case 'subject_to_be_situation':
                    baseScore = 6; // Lower value - to be + situation/noun
                    break;
                case 'subject_to_be_complement':
                    baseScore = 8; // High moral value - existence/identity (fallback)
                    break;
                case 'subject_to_do_object':
                    baseScore = 7; // High value - action/purpose
                    break;
                case 'subject_to_have_object':
                    baseScore = 6; // Medium-high value - possession/existence
                    break;
                case 'identity_structure':
                    baseScore = 9; // Very high moral value - identity
                    break;
                default:
                    baseScore = 5;
            }
            
            // Add complexity bonus based on modifiers/adjectives
            const modifiers = window.filter(w => w.pos === 'adjective' || w.pos === 'adverb').length;
            baseScore += modifiers * 0.5;
            
            // Ensure score is between 1-10 for structure complexity/morality
            return Math.min(10, Math.max(1, Math.round(baseScore * 10) / 10));
        }

        // ==================== VISUALIZACIÓN 3D ====================
        // Detect text structure type
        let textStructureType = 'unknown';
        
        function detectTextStructure(text) {
            const lines = text.split(/\n+/).filter(line => line.trim().length > 0);
            
            if (lines.length === 0) return 'unknown';
            
            // Check if it's a list (bullet points or numbered)
            const listPatterns = {
                bullet: /^[\s]*[-•*\+]\s+/,
                numbered: /^[\s]*\d+[\.\)]\s+/,
                lettered: /^[\s]*[a-zA-Z][\.\)]\s+/
            };
            
            let listItemCount = 0;
            lines.forEach(line => {
                if (listPatterns.bullet.test(line) || listPatterns.numbered.test(line) || listPatterns.lettered.test(line)) {
                    listItemCount++;
                }
            });
            
            // If more than 50% of lines are list items, it's a list
            if (listItemCount / lines.length > 0.5) {
                return 'list';
            }
            
            // Check average sentence length (rough estimate)
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(/\s+/).length, 0) / sentences.length;
            
            // Check if it's very short (single sentence or phrase)
            const wordCount = text.split(/\s+/).filter(w => w.length > 0).length;
            if (wordCount <= 10) {
                return 'short_phrase';
            }
            
            // Check if sentences are very short (aphorisms, definitions)
            if (avgSentenceLength <= 8 && sentences.length > 3) {
                return 'short_sentences';
            }
            
            // Check if it's paragraph-based (multiple paragraphs)
            if (lines.length > 3 && lines.some(line => line.length > 100)) {
                return 'paragraphs';
            }
            
            // Default to narrative flow
            return 'narrative';
        }
        
        function getClusterPosition(wordData, index) {
            // Original positioning based on POS clusters
            return getNarrativePosition(wordData, index);
        }
        
        function getSemanticCorePosition(wordData, index) {
            // Initialize if not available
            if (!window.semanticCores) {
                window.semanticCores = [];
            }
            if (!window.coreWords) {
                window.coreWords = new Map();
            }
            
            // Check if semantic cores are available
            if (!window.semanticCores || window.semanticCores.length === 0) {
                // Fallback to narrative positioning if no cores detected
                return getNarrativePosition(wordData, index);
            }
            
            const cores = window.semanticCores;
            const coreWords = window.coreWords || new Map();
            
            // Use structure-specific cluster distribution
            const distributionType = getClusterDistributionType();
            
            // Check if this word is a semantic core
            const coreIndex = coreWords.get(index);
            
            if (coreIndex !== undefined) {
                // This word IS a semantic core - position at center of its cluster
                const core = cores[coreIndex];
                const coreIndexInCores = core.index;
                
                // Get core position based on distribution type
                const corePos = getCorePosition(coreIndexInCores, cores.length, distributionType, wordData);
                
                return corePos;
            } else {
                // This word belongs to a core - position around its core
                const assignedCoreIndex = coreWords.get(index);
                
                if (assignedCoreIndex !== undefined) {
                    const core = cores[assignedCoreIndex];
                    const coreIndexInCores = core.index;
                    const distributionType = getClusterDistributionType();
                    
                    // Calculate core position using distribution type
                    const corePos = getCorePosition(coreIndexInCores, cores.length, distributionType, core.wordData);
                    
                    // Position around the core - different arrangements for different text types
                    const clusterArrangement = getClusterArrangement(distributionType);
                    
                    const relatedIndex = core.relatedWords.indexOf(index);
                    const totalRelated = core.relatedWords.length;
                    
                    let offsetX, offsetY, offsetZ;
                    
                    if (clusterArrangement === 'sphere') {
                        // 3D sphere around core - closer
                        const angle = (relatedIndex / Math.max(1, totalRelated)) * Math.PI * 2;
                        const verticalAngle = (relatedIndex / Math.max(1, totalRelated)) * Math.PI;
                        const radius = 0.5 + (wordData.normalizedScore * 0.8); // Reduced
                        offsetX = Math.cos(angle) * Math.sin(verticalAngle) * radius;
                        offsetY = Math.cos(verticalAngle) * radius * 0.6; // Reduced
                        offsetZ = Math.sin(angle) * Math.sin(verticalAngle) * radius;
                    } else if (clusterArrangement === 'flat_circle') {
                        // Flat circle around core - closer
                        const angle = (relatedIndex / Math.max(1, totalRelated)) * Math.PI * 2;
                        const radius = 0.6 + (wordData.normalizedScore * 0.7); // Reduced
                        offsetX = Math.cos(angle) * radius;
                        offsetY = (wordData.normalizedScore - 0.5) * 0.5; // Reduced
                        offsetZ = Math.sin(angle) * radius;
                    } else if (clusterArrangement === 'vertical_stack') {
                        // Vertical stack - closer
                        const verticalPos = (relatedIndex / Math.max(1, totalRelated) - 0.5) * 1.5; // Reduced
                        const angle = (relatedIndex / Math.max(1, totalRelated)) * Math.PI * 2;
                        const radius = 0.4 + (wordData.normalizedScore * 0.4); // Reduced
                        offsetX = Math.cos(angle) * radius;
                        offsetY = verticalPos;
                        offsetZ = Math.sin(angle) * radius;
                    } else {
                        // Default: loose sphere - closer
                        const angle = (relatedIndex / Math.max(1, totalRelated)) * Math.PI * 2;
                        const radius = 0.7 + (wordData.normalizedScore * 1.0); // Reduced
                        offsetX = Math.cos(angle) * radius;
                        offsetY = (wordData.normalizedScore - 0.5) * 1.0; // Reduced
                        offsetZ = Math.sin(angle) * radius;
                    }
                    
                    return {
                        x: corePos.x + offsetX,
                        y: corePos.y + offsetY,
                        z: corePos.z + offsetZ
                    };
                } else {
                    // Word not assigned to any core - use fallback
                    return getFallbackPosition(wordData, index);
                }
            }
        }
        
        // Determine cluster distribution type based on text structure
        function getClusterDistributionType() {
            // Use the detected text structure to determine how to distribute clusters
            if (textStructureType === 'list') {
                return 'vertical_columns'; // Lists: vertical columns
            } else if (textStructureType === 'short_phrase') {
                return 'centered_tight'; // Short phrases: tight, centered clusters
            } else if (textStructureType === 'short_sentences') {
                return 'scattered_medium'; // Short sentences: medium-sized scattered clusters
            } else if (textStructureType === 'paragraphs') {
                return 'horizontal_bands'; // Paragraphs: horizontal bands
            } else {
                return 'sphere_distributed'; // Narrative: distributed in sphere
            }
        }
        
        // Get core position based on distribution type
        function getCorePosition(coreIndex, totalCores, distributionType, wordData) {
            const normalizedIndex = coreIndex / Math.max(1, totalCores);
            
            switch(distributionType) {
                case 'vertical_columns':
                    // Vertical columns (for lists) - closer together
                    const columns = Math.ceil(Math.sqrt(totalCores));
                    const column = coreIndex % columns;
                    const row = Math.floor(coreIndex / columns);
                    return {
                        x: (column - (columns - 1) / 2) * 2.0, // Reduced from 3
                        y: -row * 1.8, // Reduced from 2.5
                        z: (wordData.normalizedScore - 0.5) * 1.5 // Reduced from 2
                    };
                    
                case 'centered_tight':
                    // Tight, centered clusters (for short phrases) - very close
                    const angle = normalizedIndex * Math.PI * 2;
                    const radius = 0.8 + normalizedIndex * 0.3; // Reduced from 1.5
                    return {
                        x: Math.cos(angle) * radius,
                        y: (wordData.normalizedScore - 0.5) * 0.8, // Reduced
                        z: Math.sin(angle) * radius
                    };
                    
                case 'scattered_medium':
                    // Medium-sized scattered clusters (for short sentences) - closer
                    const scatterAngle = normalizedIndex * Math.PI * 2.5;
                    const scatterRadius = 1.5 + coreIndex * 0.5; // Reduced from 2
                    return {
                        x: Math.cos(scatterAngle) * scatterRadius,
                        y: (normalizedIndex - 0.5) * 2 + (wordData.normalizedScore - 0.5) * 0.8, // Reduced
                        z: Math.sin(scatterAngle) * scatterRadius
                    };
                    
                case 'horizontal_bands':
                    // Horizontal bands (for paragraphs) - closer
                    const bandWidth = Math.ceil(Math.sqrt(totalCores));
                    const band = Math.floor(coreIndex / bandWidth);
                    const posInBand = coreIndex % bandWidth;
                    return {
                        x: (posInBand - (bandWidth - 1) / 2) * 2.0, // Reduced from 2.5
                        y: -band * 1.5, // Reduced from 2
                        z: (wordData.normalizedScore - 0.5) * 2.0 // Reduced from 3
                    };
                    
                case 'sphere_distributed':
                default:
                    // Distributed in sphere (for narrative) - closer
                    const sphereAngle = normalizedIndex * Math.PI * 2;
                    const sphereVerticalAngle = normalizedIndex * Math.PI;
                    const sphereRadius = 2.0 + coreIndex * 0.5; // Reduced from 3
                    return {
                        x: Math.cos(sphereAngle) * Math.sin(sphereVerticalAngle) * sphereRadius,
                        y: Math.cos(sphereVerticalAngle) * sphereRadius * 0.8 + (wordData.normalizedScore - 0.5) * 0.8, // Reduced
                        z: Math.sin(sphereAngle) * Math.sin(sphereVerticalAngle) * sphereRadius
                    };
            }
        }
        
        // Get cluster arrangement (how words are arranged around cores)
        function getClusterArrangement(distributionType) {
            switch(distributionType) {
                case 'centered_tight':
                    return 'flat_circle'; // Tight clusters: flat circles
                case 'vertical_columns':
                    return 'vertical_stack'; // Lists: vertical stacks
                case 'scattered_medium':
                    return 'sphere'; // Scattered: 3D spheres
                case 'horizontal_bands':
                    return 'flat_circle'; // Bands: flat circles
                default:
                    return 'sphere'; // Default: 3D spheres
            }
        }
        
        function createFallbackConnections() {
            // Simple fallback: connect adjacent high-value words
            for (let i = 0; i < nodes.length; i++) {
                const currentNode = nodes[i];
                const currentWord = currentNode.userData.wordData;
                
                if (currentWord.normalizedScore > 0.5) {
                    // Connect to other high-value words of same POS
                    for (let j = i + 1; j < nodes.length; j++) {
                        const otherNode = nodes[j];
                        const otherWord = otherNode.userData.wordData;
                        
                        if (otherWord.normalizedScore > 0.5 && 
                            otherWord.pos === currentWord.pos) {
                            createConnection(currentNode, otherNode);
                            break; // Connect to first match only
                        }
                    }
                }
            }
        }
        
        function getFallbackPosition(wordData, index) {
            // Position unassigned words based on POS and value
            const posGroups = {
                'noun': { x: 0, y: 2, z: 0 },
                'verb': { x: 0, y: -2, z: 0 },
                'adjective': { x: 2, y: 0, z: 0 },
                'pronoun': { x: -2, y: 0, z: 0 },
                'other': { x: 0, y: 0, z: 0 }
            };
            
            const basePos = posGroups[wordData.pos] || posGroups['other'];
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords;
            
            // Spread based on value
            const valueSpread = wordData.normalizedScore * 3;
            const angle = normalizedIndex * Math.PI * 2;
            
            return {
                x: basePos.x + Math.cos(angle) * valueSpread,
                y: basePos.y + (wordData.normalizedScore - 0.5) * 2,
                z: basePos.z + Math.sin(angle) * valueSpread
            };
        }
        
        // Position for lists: vertical or circular groups by list item
        function getListPosition(wordData, index) {
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords;
            
            // Find which "list item" this word belongs to by looking for list markers
            // This is a simplified approach - in practice you'd want to track list boundaries better
            const wordsPerItem = Math.max(3, Math.ceil(totalWords / 10)); // Assume ~10 list items
            const itemIndex = Math.floor(index / wordsPerItem);
            const itemPosition = (index % wordsPerItem) / wordsPerItem; // Position within item
            
            // Create vertical stack of items, with words spreading horizontally within each
            const itemY = -itemIndex * 1.5; // Stack items vertically
            const itemAngle = itemIndex * (Math.PI * 2 / 10); // Circular arrangement per item
            
            // Within each item, words spread in a line/arc
            const withinItemSpread = (itemPosition - 0.5) * 2; // -1 to 1
            const radius = 2 + itemIndex * 0.3; // Growing radius for outer items
            
            // Value-based depth
            const depthZ = wordData.normalizedScore * 3 - 1.5;
            
            return {
                x: Math.cos(itemAngle) * radius + withinItemSpread * 0.8,
                y: itemY + (wordData.normalizedScore - 0.5) * 0.5,
                z: Math.sin(itemAngle) * radius + depthZ
            };
        }
        
        // Position for short phrases: compact, centered, high value words prominent
        function getShortPhrasePosition(wordData, index) {
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords;
            
            // Compact circular arrangement centered on origin
            const angle = (normalizedIndex * Math.PI * 2) + (wordData.normalizedScore * Math.PI);
            const radius = 0.5 + wordData.normalizedScore * 2; // Value determines distance from center
            
            // Vertical stacking based on value (high value higher)
            const heightY = wordData.normalizedScore * 2 - 1;
            
            return {
                x: Math.cos(angle) * radius,
                y: heightY,
                z: Math.sin(angle) * radius + (normalizedIndex - 0.5) * 0.5
            };
        }
        
        // Position for short sentences: each sentence forms a small cluster
        function getShortSentencesPosition(wordData, index) {
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords;
            
            // Group words into sentences (approximate: assume 5-8 words per sentence)
            const wordsPerSentence = 6;
            const sentenceIndex = Math.floor(index / wordsPerSentence);
            const wordInSentence = index % wordsPerSentence;
            
            // Each sentence is a small cluster
            const sentenceAngle = sentenceIndex * (Math.PI * 2 / 15); // Arrange sentences in a large circle
            const sentenceRadius = 3 + sentenceIndex * 0.2;
            
            // Words within sentence form a small arc
            const wordAngle = (wordInSentence / wordsPerSentence) * Math.PI * 0.6; // Small arc
            const wordRadius = 0.3 + wordData.normalizedScore * 0.5;
            
            return {
                x: Math.cos(sentenceAngle) * sentenceRadius + Math.cos(sentenceAngle + wordAngle) * wordRadius,
                y: (wordData.normalizedScore - 0.5) * 1.5 + (sentenceIndex % 3 - 1) * 0.3,
                z: Math.sin(sentenceAngle) * sentenceRadius + Math.sin(sentenceAngle + wordAngle) * wordRadius
            };
        }
        
        // Position for paragraphs: linear flow with paragraph breaks
        function getParagraphsPosition(wordData, index) {
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords;
            
            // Estimate paragraph breaks (assume ~50-100 words per paragraph)
            const wordsPerParagraph = 75;
            const paragraphIndex = Math.floor(index / wordsPerParagraph);
            const wordInParagraph = index % wordsPerParagraph;
            
            // Paragraphs form vertical columns with horizontal flow within
            const columnX = (paragraphIndex % 3 - 1) * 3; // 3 columns
            const paragraphY = -paragraphIndex * 2; // Stack paragraphs vertically
            
            // Words flow horizontally within paragraph
            const wordX = (wordInParagraph / wordsPerParagraph - 0.5) * 4;
            const wordY = (wordData.normalizedScore - 0.5) * 1;
            const wordZ = (normalizedIndex - 0.5) * 3;
            
            return {
                x: columnX + wordX * 0.5,
                y: paragraphY + wordY,
                z: wordZ
            };
        }
        
        // Position for narrative: traditional flow with POS clusters
        function getNarrativePosition(wordData, index) {
            // Base cluster centers based on syntax (POS) - more spread out
            const posGroups = {
                'noun': { x: -4, y: 0, z: -2 },
                'verb': { x: 4, y: 0, z: 2 },
                'adjective': { x: 0, y: 4, z: -1 },
                'adverb': { x: 0, y: -4, z: 1 },
                'pronoun': { x: -2, y: 2, z: 4 },
                'preposition': { x: 2, y: -2, z: -4 },
                'conjunction': { x: -3, y: -3, z: -3 },
                'determiner': { x: 3, y: -3, z: 3 },
                'other': { x: 0, y: 0, z: 0 }
            };
            
            const basePos = posGroups[wordData.pos] || posGroups['other'];
            
            // Use text order/index to create organic flow following syntax
            const totalWords = analyzedWords.length;
            const normalizedIndex = index / totalWords; // 0 to 1
            
            // Create organic distribution based on syntax order
            // Each POS cluster spreads organically following text sequence
            const sequenceAngle = normalizedIndex * Math.PI * 4; // Multiple rotations
            const sequenceRadius = 0.5 + (normalizedIndex * 2.5); // Growing radius
            
            // INVERTED: More valuable nodes closer to exterior, less valuable closer to interior
            const minDistance = 0.8;
            const maxDistance = 5.0;
            const distanceFromClusterCenter = minDistance + (wordData.normalizedScore * (maxDistance - minDistance));
            
            // Add significant vertical variation (less flat)
            const verticalSpread = 3.5;
            const verticalOffset = (normalizedIndex - 0.5) * verticalSpread * 2; // Spread based on order
            const verticalRandom = (Math.random() - 0.5) * verticalSpread;
            
            // Organic positioning following syntax order
            const angle1 = sequenceAngle;
            const angle2 = normalizedIndex * Math.PI * 2;
            
            // Less organized, more chaotic distribution
            const chaosFactor = 1.2;
            const randomX = (Math.random() - 0.5) * chaosFactor;
            const randomY = (Math.random() - 0.5) * chaosFactor;
            const randomZ = (Math.random() - 0.5) * chaosFactor;
            
            return {
                x: basePos.x + Math.cos(angle1) * distanceFromClusterCenter * Math.cos(angle2) + randomX,
                y: basePos.y + verticalOffset + Math.sin(angle1) * distanceFromClusterCenter + verticalRandom + randomY,
                z: basePos.z + Math.sin(angle2) * distanceFromClusterCenter + (normalizedIndex - 0.5) * 2 + randomZ
            };
        }

        function create3DNode(wordData, index) {
            let geometry;
            const baseSize = 0.06; // Reduced from 0.12 to make nodes smaller
            
            // Store connection count (will be updated after connections are created)
            wordData.connectionCount = 0;
            
            // Color for spheres based on value (yellow for highest value, greyish blues for others, white for low value)
            let color;
            const score = wordData.normalizedScore;
            
            if (score > 0.85) {
                color = 0xffff00; // Yellow for most valuable nodes
            } else if (score > 0.7) {
                color = 0x4a6fa5; // Dark greyish blue for very high value
            } else if (score > 0.5) {
                color = 0x5a7fb5; // Medium-dark greyish blue for high value
            } else if (score > 0.3) {
                color = 0x6a8fc5; // Medium greyish blue for medium-high value
            } else if (score > 0.1) {
                color = 0x7a9fd5; // Light greyish blue for medium value
            } else {
                color = 0xffffff; // White for low value
            }
            
            const material = new THREE.MeshLambertMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.9
            });
            
            // Verbs "to be" are cubes with flat rectangular base
            if (wordData.isSerEstar) {
                // Create a cube for "to be" verbs
                const cubeSize = baseSize;
                geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize, 1, 1, 1);
                const cube = new THREE.Mesh(geometry, material);
                
                // Add a flat rectangular base below the cube
                // Make it similar to names: same size as cube, with good separation
                const flatRectWidth = baseSize * 1.0; // Same width as cube (like names have same size as sphere)
                const flatRectDepth = baseSize * 1.0; // Same depth as cube
                const flatRectHeight = baseSize * 0.1; // Thin base (same as names)
                const flatRectGeometry = new THREE.BoxGeometry(flatRectWidth, flatRectHeight, flatRectDepth, 1, 1, 1);
                const flatRectMaterial = new THREE.MeshLambertMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
                const flatRect = new THREE.Mesh(flatRectGeometry, flatRectMaterial);
                
                // Position the flat rectangle below the cube with more separation
                // Cube bottom is at -baseSize/2, so position base at -baseSize * 2.0 for good separation (same as names)
                flatRect.position.y = -baseSize * 2.0; // Same separation as names (sphere to flat square)
                flatRect.rotation.x = 0;
                
                // Create a group to hold both the cube and the flat rectangle
                const nodeGroup = new THREE.Group();
                nodeGroup.add(cube);
                nodeGroup.add(flatRect);
                
                const pos = getClusterPosition(wordData, index);
                nodeGroup.position.set(pos.x, pos.y, pos.z);
                
                nodeGroup.userData = {
                    wordData: wordData,
                    index: index,
                    connectionCount: 0,
                    isSphere: false,
                    isSerEstar: true,
                    mainNode: cube,
                    flatRect: flatRect
                };
                
                scene.add(nodeGroup);
                nodes.push(nodeGroup);
                
                return nodeGroup;
            }
            // Nouns (including names) are spheres with flat square base
            else if (wordData.pos === 'noun') {
                // Create a sphere with a flat square base
                // Use a sphere geometry and we'll add a flat square at the bottom
                geometry = new THREE.SphereGeometry(baseSize, 8, 8);
                const node = new THREE.Mesh(geometry, material);
                
                const flatSquareSize = baseSize * 1.0; // Increased to 1.0 (much wider - same size as sphere)
                const flatSquareGeometry = new THREE.BoxGeometry(flatSquareSize, flatSquareSize * 0.1, flatSquareSize, 1, 1, 1);
                const flatSquareMaterial = new THREE.MeshLambertMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
                const flatSquare = new THREE.Mesh(flatSquareGeometry, flatSquareMaterial);
                
                // Position the flat square further from the bottom of the sphere
                flatSquare.position.y = -baseSize * 2.0; // Increased to 2.0 (more separation from sphere)
                flatSquare.rotation.x = 0;
                
                // Create a group to hold both the sphere and the flat square
                const nodeGroup = new THREE.Group();
                nodeGroup.add(node);
                nodeGroup.add(flatSquare);
                
                const pos = getClusterPosition(wordData, index);
                nodeGroup.position.set(pos.x, pos.y, pos.z);
                
                nodeGroup.userData = {
                    wordData: wordData,
                    index: index,
                    connectionCount: 0,
                    isSphere: true,
                    isNoun: true,
                    mainNode: node,
                    flatSquare: flatSquare
                };
                
                scene.add(nodeGroup);
                nodes.push(nodeGroup);
                
                return nodeGroup;
            } else {
                // All other nodes start as spheres (high value nodes remain spheres)
                // Nodes with connections will be converted to cubes later
                // Reduced quality: 8 segments instead of 16 for better performance
                geometry = new THREE.SphereGeometry(baseSize, 8, 8);
                const node = new THREE.Mesh(geometry, material);
                
                const pos = getClusterPosition(wordData, index);
                node.position.set(pos.x, pos.y, pos.z);
                
                node.userData = {
                    wordData: wordData,
                    index: index,
                    connectionCount: 0,
                    isSphere: true // Track if it's a sphere or cube
                };
                
                scene.add(node);
                nodes.push(node);
                
                return node;
            }
        }
        
        // Update node shapes after connections are created
        function updateNodeShapes() {
            nodes.forEach(node => {
                // Skip if it's a noun (nouns always stay as spheres with flat base)
                if (node.userData.isNoun) {
                    return;
                }
                // Skip if it's a "to be" verb (they always stay as cubes with flat rectangular base)
                if (node.userData.isSerEstar) {
                    return;
                }
                
                const connectionCount = node.userData.connectionCount;
                
                if (connectionCount > 0) {
                    // Nodes with connections become cubes
                    const baseSize = 0.06; // Reduced from 0.12 to make nodes smaller
                    let geometry;
                    
                    if (connectionCount >= 5) {
                        // Many connections = rectangular cube (low quality for performance)
                        geometry = new THREE.BoxGeometry(baseSize * 1.2, baseSize * 0.8, baseSize * 1.5, 1, 1, 1);
                    } else {
                        // Few connections = regular cube (low quality for performance)
                        geometry = new THREE.BoxGeometry(baseSize, baseSize, baseSize, 1, 1, 1);
                    }
                    
                    // Replace geometry
                    const oldMaterial = node.material;
                    const newMesh = new THREE.Mesh(geometry, oldMaterial);
                    newMesh.position.copy(node.position);
                    newMesh.userData = node.userData;
                    newMesh.userData.isSphere = false;
                    
                    // Remove old node and add new one
                    scene.remove(node);
                    const nodeIndex = nodes.indexOf(node);
                    nodes[nodeIndex] = newMesh;
                    scene.add(newMesh);
                }
                // Nodes without connections remain as spheres (already created)
            });
        }

        // Identify semantic, morphological, and syntactic cores (key concepts) in the text
        function identifySemanticCores() {
            const cores = [];
            const coreWords = new Map(); // word -> core index
            
            // Calculate word importance scores (semantic + morphological + syntactic)
            const wordImportance = analyzedWords.map((wordData, index) => {
                let importance = 0;
                
                // Semantic importance
                importance += wordData.normalizedScore * 3;
                
                // Morphological importance (word structure, length, complexity)
                const wordLength = wordData.text.length;
                importance += Math.min(wordLength / 10, 1) * 0.5;
                
                // Syntactic importance (POS-based)
                const posWeights = {
                    'pronoun': 2.0,
                    'verb': 1.8,
                    'noun': 1.5,
                    'adjective': 1.2,
                    'adverb': 1.0,
                    'other': 0.5
                };
                importance += (posWeights[wordData.pos] || 0.5) * 0.5;
                
                // Frequency importance (repeated words are more important)
                importance += wordData.normalizedFrequency * 1.0;
                
                // Ontological assertion bonus
                if (isOntologicalAssertion(index, analyzedWords)) {
                    importance += 2.0;
                }
                
                return { index, importance, wordData };
            });
            
            // Sort by importance and select top words as cores
            wordImportance.sort((a, b) => b.importance - a.importance);
            
            // Determine number of cores based on text length and structure
            const totalWords = analyzedWords.length;
            let numCores;
            if (totalWords <= 10) {
                numCores = Math.min(3, totalWords);
            } else if (totalWords <= 50) {
                numCores = Math.min(5, Math.ceil(totalWords / 10));
            } else if (totalWords <= 200) {
                numCores = Math.min(8, Math.ceil(totalWords / 25));
            } else {
                numCores = Math.min(12, Math.ceil(totalWords / 50));
            }
            
            // Create cores from top important words
            const selectedCores = wordImportance.slice(0, numCores);
            
            selectedCores.forEach((item, coreIndex) => {
                const wordData = item.wordData;
                const index = item.index;
                const cleanWord = wordData.text.toLowerCase().replace(/[^\w]/g, '');
                
                // Determine core type
                let coreType = 'semantic';
                if (wordData.pos === 'pronoun' && (cleanWord === 'i' || cleanWord === 'we' || cleanWord === 'you' || 
                    cleanWord === 'yo' || cleanWord === 'nosotros' || cleanWord === 'tú')) {
                    coreType = 'ontological_subject';
                } else if (wordData.isSerEstar) {
                    coreType = 'existence';
                } else if (isName(wordData.text, index) && wordData.pos === 'noun') {
                    coreType = 'identity';
                } else if (wordData.pos === 'noun') {
                    coreType = 'morphological_noun';
                } else if (wordData.pos === 'verb') {
                    coreType = 'syntactic_verb';
                } else if (wordData.pos === 'adjective') {
                    coreType = 'descriptive';
                }
                
                cores.push({
                    index: coreIndex,
                    wordIndex: index,
                    wordData: wordData,
                    type: coreType,
                    relatedWords: [],
                    importance: item.importance
                });
                coreWords.set(index, coreIndex);
            });
            
            // 2. Group ALL words around cores based on multiple criteria
            analyzedWords.forEach((wordData, index) => {
                if (coreWords.has(index)) return; // Skip cores themselves
                
                let bestCore = null;
                let bestScore = 0;
                
                cores.forEach(core => {
                    let score = 0;
                    
                    // 1. Morphological similarity (same POS)
                    if (wordData.pos === core.wordData.pos) {
                        score += 2.5;
                    }
                    
                    // 2. Semantic proximity (text position)
                    const textDistance = Math.abs(index - core.wordIndex);
                    const maxDistance = Math.min(20, Math.ceil(totalWords / 5));
                    if (textDistance <= maxDistance) {
                        score += (maxDistance - textDistance) / maxDistance * 2.0;
                    }
                    
                    // 3. Syntactic relationships (check for grammatical patterns)
                    const window = 8;
                    if (textDistance <= window) {
                        const start = Math.max(0, Math.min(index, core.wordIndex) - 3);
                        const end = Math.min(analyzedWords.length, Math.max(index, core.wordIndex) + 3);
                        const windowWords = analyzedWords.slice(start, end);
                        
                        // Pattern: subject + verb + object
                        for (let i = 0; i < windowWords.length - 2; i++) {
                            const w1 = windowWords[i];
                            const w2 = windowWords[i + 1];
                            const w3 = windowWords[i + 2];
                            
                            // Core + "to be" + word OR word + "to be" + core
                            if ((w1 === core.wordData || w1 === wordData) && 
                                (w2.isSerEstar) &&
                                (w3 === core.wordData || w3 === wordData)) {
                                score += 6.0; // Very strong syntactic relationship
                            }
                            
                            // Noun + verb + noun pattern
                            if (w1.pos === 'noun' && w2.pos === 'verb' && w3.pos === 'noun' &&
                                (w1 === core.wordData || w3 === core.wordData) &&
                                (w1 === wordData || w3 === wordData)) {
                                score += 3.0;
                            }
                        }
                    }
                    
                    // 4. Semantic similarity (same word = same concept)
                    const coreWord = core.wordData.text.toLowerCase().replace(/[^\w]/g, '');
                    const word = wordData.text.toLowerCase().replace(/[^\w]/g, '');
                    if (coreWord === word) {
                        score += 5.0; // Same word = same concept
                    }
                    
                    // 5. Value similarity (high-value words cluster together)
                    const valueDiff = Math.abs(wordData.normalizedScore - core.wordData.normalizedScore);
                    if (valueDiff < 0.3) {
                        score += 1.5;
                    }
                    if (wordData.normalizedScore > 0.6 && core.wordData.normalizedScore > 0.6) {
                        score += 1.0;
                    }
                    
                    // 6. Frequency similarity (repeated words cluster together)
                    const freqDiff = Math.abs(wordData.normalizedFrequency - core.wordData.normalizedFrequency);
                    if (freqDiff < 0.2) {
                        score += 1.0;
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestCore = core;
                    }
                });
                
                // Assign to best core (lower threshold to ensure all words are assigned)
                if (bestCore && bestScore >= 0.5) {
                    bestCore.relatedWords.push(index);
                    coreWords.set(index, bestCore.index);
                } else if (cores.length > 0) {
                    // Fallback: assign to nearest core by text position
                    const nearestCore = cores.reduce((nearest, core) => {
                        const dist1 = Math.abs(index - nearest.wordIndex);
                        const dist2 = Math.abs(index - core.wordIndex);
                        return dist2 < dist1 ? core : nearest;
                    });
                    nearestCore.relatedWords.push(index);
                    coreWords.set(index, nearestCore.index);
                }
            });
            
            return { cores, coreWords };
        }
        
        function createConnections() {
            // Clear existing connections
            connections.forEach(conn => scene.remove(conn));
            connections = [];
            
            // Reset connection counts
            nodes.forEach(node => {
                node.userData.connectionCount = 0;
                node.userData.wordData.connectionCount = 0;
            });
            
            if (nodes.length < 2) return;
            
            // Connect nodes semantically based on text order
            // Words that appear close together in the text are semantically related
            for (let i = 0; i < nodes.length; i++) {
                const currentNode = nodes[i];
                const currentIndex = currentNode.userData.index;
                
                // Connect to adjacent words in the text (semantic proximity)
                const adjacentRange = 3; // Connect to words within 3 positions
                
                for (let j = Math.max(0, i - adjacentRange); j < Math.min(nodes.length, i + adjacentRange + 1); j++) {
                    if (i !== j) {
                        const otherNode = nodes[j];
                        // Handle both regular nodes and noun groups
                        const otherIndex = otherNode.userData.index !== undefined ? 
                            otherNode.userData.index : 
                            (otherNode.userData.wordData ? analyzedWords.findIndex(w => w === otherNode.userData.wordData) : j);
                        
                        // Calculate semantic distance based on text position
                        const textDistance = Math.abs(currentIndex - otherIndex);
                        
                        // Connect adjacent words (distance 1-2) with higher probability
                        if (textDistance <= 2) {
                            // Always connect adjacent words
                            createConnection(currentNode, otherNode);
                        } else if (textDistance === 3 && Math.random() > 0.5) {
                            // 50% chance for distance 3
                            createConnection(currentNode, otherNode);
                        }
                    }
                }
                
                // Connect words of the same POS that are close in text order
                const samePOSNodes = nodes.filter(n => 
                    n.userData.wordData.pos === currentNode.userData.wordData.pos &&
                    n !== currentNode &&
                    Math.abs(n.userData.index - currentIndex) <= 5
                );
                
                // Connect to 1-2 same POS nodes that are nearby in text
                const numSamePOS = Math.min(2, samePOSNodes.length);
                for (let k = 0; k < numSamePOS; k++) {
                    const targetNode = samePOSNodes[Math.floor(Math.random() * samePOSNodes.length)];
                    if (!connections.some(conn => 
                        (conn.userData.fromNode === currentNode && conn.userData.toNode === targetNode) ||
                        (conn.userData.fromNode === targetNode && conn.userData.toNode === currentNode)
                    )) {
                        createConnection(currentNode, targetNode);
                    }
                }
            }
            
            // Update node shapes based on connection count
            updateNodeShapes();
        }
        
        function createSemanticConnections(cores, coreWords) {
            // Track which nodes have connections
            const connectedNodes = new Set();
            
            // 1. Connect all words to their semantic core (hub-spoke pattern)
            coreWords.forEach((coreIndex, wordIndex) => {
                const core = cores[coreIndex];
                const coreNode = nodes.find(n => n.userData.index === core.wordIndex);
                const wordNode = nodes.find(n => n.userData.index === wordIndex);
                
                if (coreNode && wordNode && coreNode !== wordNode) {
                    createConnection(coreNode, wordNode);
                    connectedNodes.add(coreNode);
                    connectedNodes.add(wordNode);
                }
            });
            
            // 2. Connect words within the same semantic core (cluster connections)
            cores.forEach(core => {
                const coreNode = nodes.find(n => n.userData.index === core.wordIndex);
                if (!coreNode) return;
                
                // Connect related words to each other (within same core)
                for (let i = 0; i < core.relatedWords.length; i++) {
                    const wordIndex1 = core.relatedWords[i];
                    const wordNode1 = nodes.find(n => n.userData.index === wordIndex1);
                    
                    if (!wordNode1) continue;
                    
                    // Connect to core
                    if (coreNode !== wordNode1) {
                        // Already connected above, but ensure it exists
                        if (!connections.some(c => 
                            (c.userData.fromNode === coreNode && c.userData.toNode === wordNode1) ||
                            (c.userData.fromNode === wordNode1 && c.userData.toNode === coreNode)
                        )) {
                            createConnection(coreNode, wordNode1);
                        }
                    }
                    
                    // Connect to other words in same core (if they share semantic similarity)
                    for (let j = i + 1; j < core.relatedWords.length; j++) {
                        const wordIndex2 = core.relatedWords[j];
                        const wordNode2 = nodes.find(n => n.userData.index === wordIndex2);
                        
                        if (!wordNode2) continue;
                        
                        const word1 = analyzedWords[wordIndex1];
                        const word2 = analyzedWords[wordIndex2];
                        
                        // Connect if same POS or both high value
                        if (word1.pos === word2.pos || 
                            (word1.normalizedScore > 0.6 && word2.normalizedScore > 0.6)) {
                            createConnection(wordNode1, wordNode2);
                        }
                    }
                }
            });
            
            // 3. Connect cores to each other (inter-core connections)
            for (let i = 0; i < cores.length; i++) {
                for (let j = i + 1; j < cores.length; j++) {
                    const core1 = cores[i];
                    const core2 = cores[j];
                    
                    const coreNode1 = nodes.find(n => n.userData.index === core1.wordIndex);
                    const coreNode2 = nodes.find(n => n.userData.index === core2.wordIndex);
                    
                    if (!coreNode1 || !coreNode2) continue;
                    
                    // Connect cores if they share related words or have semantic relationship
                    const sharedRelated = core1.relatedWords.filter(idx => 
                        core2.relatedWords.includes(idx)
                    ).length;
                    
                    // Connect if cores are of complementary types or share concepts
                    const shouldConnect = 
                        sharedRelated > 0 || // Share related words
                        (core1.type === 'ontological_subject' && core2.type === 'existence') ||
                        (core1.type === 'existence' && core2.type === 'essential_concept') ||
                        (core1.type === 'identity' && core2.type === 'ontological_subject') ||
                        Math.abs(core1.wordIndex - core2.wordIndex) <= 5; // Close in text
                    
                    if (shouldConnect) {
                        createConnection(coreNode1, coreNode2);
                    }
                }
            }
            
            // 4. Ensure ALL nodes have at least one connection
            nodes.forEach(node => {
                if (!connectedNodes.has(node)) {
                    // Find nearest connected node
                    let nearestNode = null;
                    let minDistance = Infinity;
                    
                    connectedNodes.forEach(connectedNode => {
                        const dist = node.position.distanceTo(connectedNode.position);
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearestNode = connectedNode;
                        }
                    });
                    
                    if (nearestNode) {
                        createConnection(node, nearestNode);
                        connectedNodes.add(node);
                    } else {
                        // If no connected nodes, connect to nearest node by text position
                        const nodeIndex = node.userData.index;
                        let nearestByText = null;
                        let minTextDist = Infinity;
                        
                        nodes.forEach(otherNode => {
                            if (otherNode === node) return;
                            const textDist = Math.abs(nodeIndex - otherNode.userData.index);
                            if (textDist < minTextDist) {
                                minTextDist = textDist;
                                nearestByText = otherNode;
                            }
                        });
                        
                        if (nearestByText) {
                            createConnection(node, nearestByText);
                            connectedNodes.add(node);
                            connectedNodes.add(nearestByText);
                        }
                    }
                }
            });
            
            // 5. Add additional connections within clusters for better connectivity
            cores.forEach(core => {
                const coreNode = nodes.find(n => n.userData.index === core.wordIndex);
                if (!coreNode) return;
                
                // Connect words within same cluster if they're semantically similar
                for (let i = 0; i < core.relatedWords.length; i++) {
                    const wordIndex1 = core.relatedWords[i];
                    const wordNode1 = nodes.find(n => n.userData.index === wordIndex1);
                    if (!wordNode1) continue;
                    
                    const word1 = analyzedWords[wordIndex1];
                    
                    for (let j = i + 1; j < core.relatedWords.length; j++) {
                        const wordIndex2 = core.relatedWords[j];
                        const wordNode2 = nodes.find(n => n.userData.index === wordIndex2);
                        if (!wordNode2) continue;
                        
                        const word2 = analyzedWords[wordIndex2];
                        
                        // Connect if they share characteristics
                        if (word1.pos === word2.pos || 
                            Math.abs(word1.normalizedScore - word2.normalizedScore) < 0.3 ||
                            Math.abs(wordIndex1 - wordIndex2) <= 5) {
                            
                            // Check if already connected
                            if (!connections.some(c => 
                                (c.userData.fromNode === wordNode1 && c.userData.toNode === wordNode2) ||
                                (c.userData.fromNode === wordNode2 && c.userData.toNode === wordNode1)
                            )) {
                                createConnection(wordNode1, wordNode2);
                            }
                        }
                    }
                }
            });
        }
        
        function createListConnections() {
            // In lists, connect words within the same list item more strongly
            const wordsPerItem = Math.max(3, Math.ceil(analyzedWords.length / 10));
            
            for (let i = 0; i < nodes.length; i++) {
                const currentNode = nodes[i];
                const currentIndex = currentNode.userData.index;
                const itemIndex = Math.floor(currentIndex / wordsPerItem);
                
                // Connect to words in same list item (stronger connections)
                for (let j = 0; j < nodes.length; j++) {
                    if (i === j) continue;
                    const otherNode = nodes[j];
                    const otherIndex = otherNode.userData.index;
                    const otherItemIndex = Math.floor(otherIndex / wordsPerItem);
                    
                    const textDistance = Math.abs(currentIndex - otherIndex);
                    
                    if (itemIndex === otherItemIndex && textDistance <= 5) {
                        // Same item: connect closely spaced words
                        if (textDistance <= 3) {
                            createConnection(currentNode, otherNode);
                        }
                    } else if (Math.abs(itemIndex - otherItemIndex) === 1 && textDistance <= 2) {
                        // Adjacent items: connect only very close words (bridges)
                        if (textDistance <= 2) {
                            createConnection(currentNode, otherNode);
                        }
                    }
                }
            }
        }
        
        function createShortPhraseConnections() {
            // Short phrases: all words are closely connected (tight network)
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const distance = Math.abs(i - j);
                    if (distance <= 3) {
                        createConnection(nodes[i], nodes[j]);
                    }
                }
            }
        }
        
        function createShortSentencesConnections() {
            // Connect words within sentences, less between sentences
            const wordsPerSentence = 6;
            
            for (let i = 0; i < nodes.length; i++) {
                const currentNode = nodes[i];
                const currentIndex = currentNode.userData.index;
                const sentenceIndex = Math.floor(currentIndex / wordsPerSentence);
                
                for (let j = 0; j < nodes.length; j++) {
                    if (i === j) continue;
                    const otherNode = nodes[j];
                    const otherIndex = otherNode.userData.index;
                    const otherSentenceIndex = Math.floor(otherIndex / wordsPerSentence);
                    
                    const textDistance = Math.abs(currentIndex - otherIndex);
                    
                    if (sentenceIndex === otherSentenceIndex) {
                        // Same sentence: connect closely
                        if (textDistance <= 4) {
                            createConnection(currentNode, otherNode);
                        }
                    } else if (Math.abs(sentenceIndex - otherSentenceIndex) === 1 && textDistance <= 2) {
                        // Adjacent sentences: minimal connections
                        if (textDistance <= 2 && Math.random() > 0.7) {
                            createConnection(currentNode, otherNode);
                        }
                    }
                }
            }
        }
        
        function createParagraphsConnections() {
            // Connect words within paragraphs, less between paragraphs
            const wordsPerParagraph = 75;
            
            for (let i = 0; i < nodes.length; i++) {
                const currentNode = nodes[i];
                const currentIndex = currentNode.userData.index;
                const paragraphIndex = Math.floor(currentIndex / wordsPerParagraph);
                
                // Connect to adjacent words in the text (semantic proximity)
                const adjacentRange = 4; // Connect to words within 4 positions
                
                for (let j = Math.max(0, i - adjacentRange); j < Math.min(nodes.length, i + adjacentRange + 1); j++) {
                    if (i !== j) {
                        const otherNode = nodes[j];
                        // Handle both regular nodes and noun groups
                        const otherIndex = otherNode.userData.index !== undefined ? 
                            otherNode.userData.index : 
                            (otherNode.userData.wordData ? analyzedWords.findIndex(w => w === otherNode.userData.wordData) : j);
                        
                        // Calculate semantic distance based on text position
                        const textDistance = Math.abs(currentIndex - otherIndex);
                        
                        // Connect adjacent words (distance 1-2) with higher probability
                        if (textDistance <= 2) {
                            // Always connect adjacent words
                            createConnection(currentNode, otherNode);
                        } else if (textDistance === 3 && Math.random() > 0.5) {
                            // 50% chance for distance 3
                            createConnection(currentNode, otherNode);
                        }
                    }
                }
                
                // Connect words of the same POS that are close in text order and same paragraph
                const samePOSNodes = nodes.filter(n => {
                    const nIndex = n.userData.index;
                    const nParagraph = Math.floor(nIndex / wordsPerParagraph);
                    return n.userData.wordData.pos === currentNode.userData.wordData.pos &&
                           n !== currentNode &&
                           Math.abs(nIndex - currentIndex) <= 5 &&
                           nParagraph === paragraphIndex; // Only same paragraph
                });
                
                // Connect to 1-2 same POS nodes that are nearby in text
                const numSamePOS = Math.min(2, samePOSNodes.length);
                for (let k = 0; k < numSamePOS; k++) {
                    const targetNode = samePOSNodes[Math.floor(Math.random() * samePOSNodes.length)];
                    if (!connections.some(conn => 
                        (conn.userData.fromNode === currentNode && conn.userData.toNode === targetNode) ||
                        (conn.userData.fromNode === targetNode && conn.userData.toNode === currentNode)
                    )) {
                        createConnection(currentNode, targetNode);
                    }
                }
            }
        }
        
        function createNarrativeConnections() {
            // Original connection pattern for narrative text
            for (let i = 0; i < nodes.length; i++) {
                const currentNode = nodes[i];
                const currentIndex = currentNode.userData.index;
                
                // Connect to adjacent words in the text (semantic proximity)
                const adjacentRange = 3; // Connect to words within 3 positions
                
                for (let j = Math.max(0, i - adjacentRange); j < Math.min(nodes.length, i + adjacentRange + 1); j++) {
                    if (i !== j) {
                        const otherNode = nodes[j];
                        // Handle both regular nodes and noun groups
                        const otherIndex = otherNode.userData.index !== undefined ? 
                            otherNode.userData.index : 
                            (otherNode.userData.wordData ? analyzedWords.findIndex(w => w === otherNode.userData.wordData) : j);
                        
                        // Calculate semantic distance based on text position
                        const textDistance = Math.abs(currentIndex - otherIndex);
                        
                        // Connect adjacent words (distance 1-2) with higher probability
                        if (textDistance <= 2) {
                            // Always connect adjacent words
                            createConnection(currentNode, otherNode);
                        } else if (textDistance === 3 && Math.random() > 0.5) {
                            // 50% chance for distance 3
                            createConnection(currentNode, otherNode);
                        }
                    }
                }
                
                // Connect words of the same POS that are close in text order
                const samePOSNodes = nodes.filter(n => 
                    n.userData.wordData.pos === currentNode.userData.wordData.pos &&
                    n !== currentNode &&
                    Math.abs(n.userData.index - currentIndex) <= 5
                );
                
                // Connect to 1-2 same POS nodes that are nearby in text
                const numSamePOS = Math.min(2, samePOSNodes.length);
                for (let k = 0; k < numSamePOS; k++) {
                    const targetNode = samePOSNodes[Math.floor(Math.random() * samePOSNodes.length)];
                    if (!connections.some(conn => 
                        (conn.userData.fromNode === currentNode && conn.userData.toNode === targetNode) ||
                        (conn.userData.fromNode === targetNode && conn.userData.toNode === currentNode)
                    )) {
                        createConnection(currentNode, targetNode);
                    }
                }
            }
        }

        function createConnection(fromNode, toNode) {
            // Get actual position (handle groups for nouns)
            const fromPos = fromNode.userData.isNoun ? fromNode.position : fromNode.position;
            const toPos = toNode.userData.isNoun ? toNode.position : toNode.position;
            
            const geometry = new THREE.BufferGeometry().setFromPoints([
                fromPos,
                toPos
            ]);
            
            // Color based on the value of connected nodes (white for highest value, greyish blues for others)
            const fromValue = fromNode.userData.wordData.normalizedScore;
            const toValue = toNode.userData.wordData.normalizedScore;
            const avgValue = (fromValue + toValue) / 2;
            
            let connectionColor;
            if (avgValue > 0.85) {
                connectionColor = 0xffffff; // White for most valuable connections
            } else if (avgValue > 0.7) {
                connectionColor = 0x4a6fa5; // Dark greyish blue for high value connections
            } else if (avgValue > 0.5) {
                connectionColor = 0x5a7fb5; // Medium-dark greyish blue
            } else if (avgValue > 0.3) {
                connectionColor = 0x6a8fc5; // Medium greyish blue
            } else if (avgValue > 0.1) {
                connectionColor = 0x7a9fd5; // Light greyish blue
            } else {
                connectionColor = 0xffffff; // White for low value connections
            }
            
            const material = new THREE.LineBasicMaterial({
                color: connectionColor,
                transparent: true,
                opacity: 0.2 + (avgValue * 0.15) // More transparent: 0.2-0.35 range
            });
            
            const line = new THREE.Line(geometry, material);
            line.userData = {
                fromNode: fromNode,
                toNode: toNode
            };
            
            // Update connection counts (handle both regular nodes and noun groups)
            fromNode.userData.connectionCount++;
            toNode.userData.connectionCount++;
            if (fromNode.userData.wordData) {
                fromNode.userData.wordData.connectionCount++;
            }
            if (toNode.userData.wordData) {
                toNode.userData.wordData.connectionCount++;
            }
            
            scene.add(line);
            connections.push(line);
            
            return line;
        }

        function updateConnections() {
            connections.forEach(connection => {
                const fromNode = connection.userData.fromNode;
                const toNode = connection.userData.toNode;
                
                // Get actual position (handle groups for nouns)
                const fromPos = fromNode.userData.isNoun ? fromNode.position : fromNode.position;
                const toPos = toNode.userData.isNoun ? toNode.position : toNode.position;
                
                const points = [fromPos, toPos];
                connection.geometry.setFromPoints(points);
            });
        }

        function clearScene() {
            nodes.forEach(node => scene.remove(node));
            connections.forEach(conn => scene.remove(conn));
            nodes = [];
            connections = [];
            removeNametags();
            nametagsVisible = false;
            
            // Clear max-value-panel
            maxValueNode = null;
            if (maxValuePanelMesh) {
                if (maxValuePanelScene) {
                    maxValuePanelScene.remove(maxValuePanelMesh);
                }
                if (maxValuePanelMesh.geometry) maxValuePanelMesh.geometry.dispose();
                if (maxValuePanelMesh.material) maxValuePanelMesh.material.dispose();
                if (maxValuePanelMesh.children) {
                    maxValuePanelMesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
                maxValuePanelMesh = null;
            }
            if (maxValuePanelAnimationId) {
                cancelAnimationFrame(maxValuePanelAnimationId);
                maxValuePanelAnimationId = null;
            }
            
            // Clear max-value-panel fields (check if elements exist)
            const maxValuePanelWordEl = document.getElementById('max-value-panel-word');
            const maxValueWordEl = document.getElementById('max-value-word');
            const maxValueIndividualValueEl = document.getElementById('max-value-individual-value');
            const maxValuePositionEl = document.getElementById('max-value-position');
            const maxValueRelativeValueEl = document.getElementById('max-value-relative-value');
            const maxValuePosEl = document.getElementById('max-value-pos');
            const maxValueConnectionsEl = document.getElementById('max-value-connections');
            const maxValueSizeEl = document.getElementById('max-value-size');
            const maxValuePerformanceEl = document.getElementById('max-value-performance');
            const maxValueIsNameEl = document.getElementById('max-value-is-name');
            const maxValueIsSerEstarEl = document.getElementById('max-value-is-ser-estar');
            
            if (maxValuePanelWordEl) maxValuePanelWordEl.textContent = '-';
            if (maxValueWordEl) maxValueWordEl.textContent = '-';
            if (maxValueIndividualValueEl) maxValueIndividualValueEl.textContent = '-';
            if (maxValuePositionEl) maxValuePositionEl.textContent = '-';
            if (maxValueRelativeValueEl) maxValueRelativeValueEl.textContent = '-';
            if (maxValuePosEl) maxValuePosEl.textContent = '-';
            if (maxValueConnectionsEl) maxValueConnectionsEl.textContent = '-';
            if (maxValueSizeEl) maxValueSizeEl.textContent = '-';
            if (maxValuePerformanceEl) maxValuePerformanceEl.textContent = '-';
            if (maxValueIsNameEl) maxValueIsNameEl.textContent = '-';
            if (maxValueIsSerEstarEl) maxValueIsSerEstarEl.textContent = '-';
            
            // Clear node list
            if (nodeListVisible) {
                const container = document.getElementById('node-list-container');
                container.classList.remove('visible');
                clearNodeList();
                nodeListVisible = false;
            }
        }

        // ==================== GENERACIÓN DE VISUALIZACIÓN ====================
        function generateVisualization() {
            // Hide right panel if visible (since we're generating a new visualization)
            // Hide all right panels
            hideNodeDetails();
            
            const text = document.getElementById('textInput').value.trim();
            
            if (!text) {
                alert('Please enter some text');
                return;
            }
            
            // Limpiar escena anterior
            clearScene();
            
            // Store generation date/time
            visualizationGenerationDate = new Date();
            
            // Analizar texto
            analyzeText(text);
            
            // Calcular puntuaciones
            calculateScores();
            
            // Crear nodos 3D
            analyzedWords.forEach((wordData, index) => {
                create3DNode(wordData, index);
            });
            
            // Crear conexiones
            createConnections();
            
            // Actualizar estadísticas
            updateStats();
            
            // Update max value panel
            updateMaxValuePanel();
            
            // Enable export button
            document.getElementById('exportBtn').disabled = false;
        }

        // ==================== NAVEGACIÓN A CLAIM ====================
        // Variables para claim modal
        let claimScene = null;
        let claimCamera = null;
        let claimAnimationId = null;
        let sharedNodeListRenderer = null;
        let sharedNodeListScene = null;
        let sharedNodeListCamera = null;

        function navigateToClaim() {
            if (nodes.length === 0) {
                alert('No hay visualización para reclamar. Genera una visualización primero.');
                return;
            }
            
            const modal = document.getElementById('claim-modal');
            if (!modal) return;
            
            // Mostrar modal
            modal.style.display = 'block';
            modal.style.visibility = 'visible';
            modal.style.opacity = '1';
            
            // Inicializar contenido del modal
            initClaimModal();
        }

        function initClaimModal() {
            // Crear visualización 3D
            initClaim3DScene();
            
            // Mostrar Total Value (idéntico al modal original)
            showClaimTotalValue();
        }

        function initClaim3DScene() {
            const container = document.getElementById('claim-3d-container');
            if (!container) return;
            
            // Limpiar contenido previo
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // Limpiar escena anterior si existe
            if (claimScene) {
                claimScene.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
            if (claimAnimationId) {
                cancelAnimationFrame(claimAnimationId);
                claimAnimationId = null;
            }
            
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Usar el renderer principal en lugar de crear uno nuevo
            // Renderizar a una textura y luego mostrar en un canvas 2D
            claimScene = new THREE.Scene();
            claimScene.background = new THREE.Color(0x000000); // Fondo negro

            claimCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            
            // Calcular bounding box para ver todo el cuerpo
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            nodes.forEach(node => {
                const pos = node.position;
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y);
                minZ = Math.min(minZ, pos.z);
                maxZ = Math.max(maxZ, pos.z);
            });
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxSize = Math.max(sizeX, sizeY, sizeZ, 1);
            
            // Posicionar cámara para ver todo el cuerpo (más cerca para que se vea más grande)
            const distance = maxSize * 1.8; // Reducido de 2.5 a 1.8 para hacer el cuerpo más grande
            claimCamera.position.set(centerX, centerY, centerZ + distance);
            claimCamera.lookAt(centerX, centerY, centerZ);

            // Luces
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            claimScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 5);
            claimScene.add(directionalLight);

            // Clonar nodos y conexiones
            nodes.forEach(node => {
                const clonedNode = node.isGroup ? node.clone(true) : node.clone();
                claimScene.add(clonedNode);
            });
            
            connections.forEach(connection => {
                const clonedConnection = connection.clone();
                claimScene.add(clonedConnection);
            });

            // Crear canvas 2D para mostrar la imagen renderizada
            const canvas2D = document.createElement('canvas');
            canvas2D.width = width;
            canvas2D.height = height;
            canvas2D.style.cssText = 'width: 100%; height: 100%; display: block;';
            container.appendChild(canvas2D);
            
            const ctx2D = canvas2D.getContext('2d');
            
            // Renderizar usando el renderer principal a una textura temporal
            const renderTarget = new THREE.WebGLRenderTarget(width, height);
            
            // Guardar estado del renderer principal
            const originalSize = renderer.getSize(new THREE.Vector2());
            const originalClearColor = renderer.getClearColor(new THREE.Color());
            
            // Renderizar una vez
            renderer.setRenderTarget(renderTarget);
            renderer.setClearColor(0x000000, 1); // Fondo negro
            renderer.render(claimScene, claimCamera);
            
            // Leer la textura y dibujarla en el canvas 2D
            const gl = renderer.getContext();
            const pixels = new Uint8Array(width * height * 4);
            renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, pixels);
            
            const imageData = ctx2D.createImageData(width, height);
            for (let i = 0; i < pixels.length; i += 4) {
                imageData.data[i] = pixels[i];     // R
                imageData.data[i + 1] = pixels[i + 1]; // G
                imageData.data[i + 2] = pixels[i + 2]; // B
                imageData.data[i + 3] = pixels[i + 3]; // A
            }
            ctx2D.putImageData(imageData, 0, 0);
            
            // Restaurar estado del renderer principal
            renderer.setRenderTarget(null);
            renderer.setSize(originalSize.x, originalSize.y);
            renderer.setClearColor(originalClearColor, 1);
            
            // Limpiar render target
            renderTarget.dispose();
            
            // Limpiar escena temporal
            claimScene.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
            claimScene = null;
        }

        function showClaimTotalValue() {
            const container = document.getElementById('claim-total-value-container');
            if (!container) return;
            
            // Limpiar contenido previo
            container.innerHTML = '';
            
            // Crear estructura idéntica al modal de Total Value
            const wrapper = document.createElement('div');
            wrapper.id = 'claim-total-value-wrapper';
            wrapper.style.cssText = 'position: relative; max-width: 100%; margin: 0;';
            
            const content = document.createElement('div');
            content.id = 'claim-value-logic-content';
            content.style.cssText = 'font-size: 11px; line-height: 1.1; color: #000000; margin-top: 5px;';
            
            const overviewContainer = document.createElement('div');
            overviewContainer.id = 'claim-value-logic-overview-container';
            overviewContainer.style.cssText = 'width: 100%; max-width: 100%; height: 150px; background: #000000; border: 1px solid #ffffff; margin-top: 5px; margin-bottom: 5px; border-radius: 0; position: relative; display: block; overflow: hidden; box-sizing: border-box;';
            const overviewCanvas = document.createElement('canvas');
            overviewCanvas.id = 'claim-value-logic-overview-canvas';
            overviewCanvas.style.cssText = 'width: 100%; height: 100%; display: block;';
            overviewContainer.appendChild(overviewCanvas);
            
            const top5Grid = document.createElement('div');
            top5Grid.id = 'claim-value-logic-top5-grid';
            top5Grid.style.cssText = 'display: block; margin-top: 5px; margin-bottom: 5px;';
            
            const totalBox = document.createElement('div');
            totalBox.id = 'claim-value-logic-total-box';
            totalBox.style.cssText = 'background: #000000; border: 1px solid #ffffff; padding: 6px; margin-top: 5px; border-radius: 0; display: none;';
            const totalDisplay = document.createElement('div');
            totalDisplay.style.cssText = 'color: #ffffff; font-size: 11px;';
            totalDisplay.innerHTML = '<strong>Total Value:</strong> <span id="claim-value-logic-total-display">-</span>';
            totalBox.appendChild(totalDisplay);
            
            wrapper.appendChild(content);
            wrapper.appendChild(overviewContainer);
            wrapper.appendChild(top5Grid);
            wrapper.appendChild(totalBox);
            container.appendChild(wrapper);
            
            // Generar el contenido usando la misma lógica que showValueLogicSummary
            if (!analyzedWords || analyzedWords.length === 0) return;
            
            const totalWords = analyzedWords.length;
            const totalValueUSD = window.totalTextScore || analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
            const avgBaseValue = analyzedWords.reduce((sum, w) => sum + (w.baseValue || 0), 0) / totalWords;
            const avgFinalValueUSD = totalValueUSD / totalWords;
            
            let totalValueETH = 0;
            let avgFinalValueETH = 0;
            if (ethPriceUSD) {
                totalValueETH = totalValueUSD / ethPriceUSD;
                avgFinalValueETH = avgFinalValueUSD / ethPriceUSD;
            }
            
            const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                `${totalValueETH.toFixed(6)} ETH` : 
                `${totalValueETH.toFixed(10)} ETH`;
            const avgFinalValueETHDisplay = avgFinalValueETH >= 0.01 ? 
                `${avgFinalValueETH.toFixed(6)} ETH` : 
                `${avgFinalValueETH.toFixed(10)} ETH`;
            
            // Calcular multiplicadores promedio (reutilizar lógica existente)
            const avgLengthMultiplier = analyzedWords.reduce((sum, w) => sum + (w.lengthMultiplier || 1), 0) / totalWords;
            const avgOntologicalMultiplier = analyzedWords.reduce((sum, w) => sum + (w.ontologicalMultiplier || 1), 0) / totalWords;
            const avgNameWithToBeMultiplier = analyzedWords.reduce((sum, w) => sum + (w.nameWithToBeMultiplier || 1), 0) / totalWords;
            const avgSemanticMultiplier = analyzedWords.reduce((sum, w) => sum + (w.semanticMultiplier || 1), 0) / totalWords;
            const avgRepetitionMultiplier = analyzedWords.reduce((sum, w) => sum + (w.repetitionMultiplier || 1), 0) / totalWords;
            const avgTenseMultiplier = analyzedWords.reduce((sum, w) => sum + (w.tenseMultiplier || 1), 0) / totalWords;
            const avgNarrativePenalty = analyzedWords.reduce((sum, w) => sum + (w.narrativePenalty || 1), 0) / totalWords;
            
            // Contar tiempos verbales (reutilizar lógica existente)
            let presentCount = 0, pastCount = 0, futureCount = 0;
            analyzedWords.forEach((w) => {
                if (w.pos === 'verb') {
                    const cleanWord = w.text.toLowerCase().replace(/[^\w]/g, '');
                    const presentVerbs = ['is', 'am', 'are', 'be', 'being', 'exist', 'exists', 'remain', 'remains',
                                         'es', 'son', 'estar', 'ser', 'existe', 'existen', 'permanece', 'permanecen',
                                         'have', 'has', 'do', 'does', 'go', 'goes', 'come', 'comes', 'see', 'sees',
                                         'tengo', 'tiene', 'hago', 'hace', 'voy', 'va', 'vengo', 'viene', 'veo', 've'];
                    const pastVerbs = ['was', 'were', 'been', 'existed', 'remained', 'became', 'had', 'did', 'went',
                                      'came', 'saw', 'fue', 'fueron', 'estuvo', 'estuvieron', 'existió', 'existieron',
                                      'tuvo', 'hizo', 'fue', 'vino', 'vio', 'said', 'told', 'thought', 'knew',
                                      'dijo', 'contó', 'pensó', 'supo'];
                    const futureVerbs = ['will', 'shall', 'would', 'going', 'gonna',
                                        'será', 'serán', 'estará', 'estarán', 'tendrá', 'tendrán', 'hará', 'harán',
                                        'irá', 'irán', 'vendrá', 'vendrán', 'verá', 'verán'];
                    const futureModal = ['will', 'shall', 'would', 'can', 'could', 'may', 'might',
                                        'podrá', 'podrán', 'deberá', 'deberán', 'puede', 'pueden'];
                    if (presentVerbs.includes(cleanWord) || cleanWord.endsWith('ing')) presentCount++;
                    else if (pastVerbs.includes(cleanWord) || cleanWord.endsWith('ed')) pastCount++;
                    else if (futureVerbs.includes(cleanWord) || futureModal.includes(cleanWord)) futureCount++;
                }
            });
            
            let predominantTense = 'none';
            const totalVerbs = presentCount + pastCount + futureCount;
            if (totalVerbs > 0) {
                if (presentCount > pastCount && presentCount > futureCount) predominantTense = 'present';
                else if (pastCount > presentCount && pastCount > futureCount) predominantTense = 'past';
                else if (futureCount > presentCount && futureCount > pastCount) predominantTense = 'future';
                else if (presentCount > 0 && (pastCount > 0 || futureCount > 0)) {
                    if (futureCount > 0) predominantTense = 'present_future';
                    else if (pastCount > 0) predominantTense = 'present_past';
                }
            }
            
            const tenseLabels = {
                'present': 'Present', 'past': 'Past', 'future': 'Future',
                'present_future': 'Present + Future', 'present_past': 'Present + Past',
                'none': 'No verbs detected'
            };
            
            // Contar por POS
            const posCounts = {}, posValues = {}, posValuesETH = {};
            analyzedWords.forEach(w => {
                const pos = w.pos || 'other';
                posCounts[pos] = (posCounts[pos] || 0) + 1;
                const valueUSD = w.finalValue || 0;
                posValues[pos] = (posValues[pos] || 0) + valueUSD;
                if (ethPriceUSD) {
                    posValuesETH[pos] = (posValuesETH[pos] || 0) + (valueUSD / ethPriceUSD);
                }
            });
            
            const toBeCount = analyzedWords.filter(w => w.isSerEstar).length;
            const nameGroups = window.nameGroups || [];
            const nameCount = nameGroups.length;
            const ontologicalValues = toBeCount + nameCount;
            const ontologicalAssertions = analyzedWords.filter(w => w.ontologicalMultiplier > 1).length;
            
            const top4Words = [...analyzedWords]
                .sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0))
                .slice(0, 4);
            
            const topWords = [...analyzedWords]
                .sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0))
                .slice(0, 20);
            
            function highlightNumber(num) {
                return `<span style="background: #ffffff; color: #000000 !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;">${num}</span>`;
            }
            
            const boxBg = "#000000";
            const boxBorder = "#ffffff";
            const textColor = "#ffffff";
            const borderColor = boxBorder;
            const dividerColor = "#333333";
            const boxStyle = `background: ${boxBg}; border: 1px solid ${boxBorder}; padding: 4px; margin-bottom: 3px; border-radius: 0;`;
            const itemStyle = "margin: 0.5px 0;";
            
            let generationDateStr = 'N/A';
            if (visualizationGenerationDate) {
                const date = visualizationGenerationDate;
                generationDateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}`;
            }
            
            let html = `
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">General Summary</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Total Words:</strong> ${highlightNumber(totalWords)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Average Value per Word:</strong> ${highlightNumber(avgFinalValueETHDisplay)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Average Base Value:</strong> ${highlightNumber(avgBaseValue.toFixed(2))}</div>
                </div>
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Date</h3>
                    <div style="${itemStyle} color: ${textColor};">${generationDateStr}</div>
                </div>
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Applied Multipliers (Average)</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Length Multiplier:</strong> ×${highlightNumber(avgLengthMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Multiplier:</strong> ×${highlightNumber(avgOntologicalMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Name + "to be" Multiplier:</strong> ×${highlightNumber(avgNameWithToBeMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Semantic Closure Multiplier:</strong> ×${highlightNumber(avgSemanticMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Repetition Multiplier:</strong> ×${highlightNumber(avgRepetitionMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Temporal Multiplier:</strong> ×${highlightNumber(avgTenseMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Predominant Tense:</strong> ${highlightNumber(tenseLabels[predominantTense])} (Present: ${presentCount}, Past: ${pastCount}, Future: ${futureCount})</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Narrative Penalty:</strong> ×${highlightNumber(avgNarrativePenalty.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Global Reduction (60%):</strong> ×${highlightNumber('0.4335')}</div>
                </div>
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Distribution by Word Type</h3>
            `;
            
            Object.keys(posCounts).forEach(pos => {
                const count = posCounts[pos];
                const valueETH = posValuesETH[pos] || 0;
                const percentage = (count / totalWords * 100).toFixed(1);
                const valuePercentage = totalValueETH > 0 ? ((valueETH / totalValueETH) * 100).toFixed(1) : '0.0';
                const valueETHDisplay = valueETH >= 0.01 ? `${valueETH.toFixed(6)} ETH` : `${valueETH.toFixed(10)} ETH`;
                html += `<div style="${itemStyle} color: ${textColor};"><strong>${pos}:</strong> ${highlightNumber(count)} words (${highlightNumber(percentage + '%')}) - Value: ${highlightNumber(valueETHDisplay)} (${highlightNumber(valuePercentage + '%')})</div>`;
            });
            
            html += `
                </div>
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Special Elements</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Values:</strong> ${highlightNumber(ontologicalValues)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Names:</strong> ${highlightNumber(nameCount)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Assertions:</strong> ${highlightNumber(ontologicalAssertions)}</div>
                </div>
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Top 20 Words by Value</h3>
            `;
            
            topWords.forEach((w, idx) => {
                const wordValueUSD = w.finalValue || 0;
                const wordValueETH = ethPriceUSD ? wordValueUSD / ethPriceUSD : 0;
                const wordValueETHDisplay = wordValueETH >= 0.01 ? `${wordValueETH.toFixed(6)} ETH` : `${wordValueETH.toFixed(10)} ETH`;
                html += `
                    <div style="${itemStyle} color: ${textColor}; padding: 2px 0; border-top: 1px solid ${dividerColor};">
                        <strong>${idx + 1}. "${w.text}"</strong><br>
                        Value: ${highlightNumber(wordValueETHDisplay)}<br>
                        Base: ${highlightNumber((w.baseValue || 0).toFixed(2))} | 
                        Length: ×${highlightNumber((w.lengthMultiplier || 1).toFixed(2))} | 
                        Ontological: ×${highlightNumber((w.ontologicalMultiplier || 1).toFixed(2))} | 
                        Repetition: ×${highlightNumber((w.repetitionMultiplier || 1).toFixed(2))}
                    </div>
                `;
            });
            
            html += `</div>`;
            
            content.innerHTML = html;
            
            // Crear overview 3D (reutilizar función existente pero adaptada)
            createClaimValueLogicOverview(overviewContainer, overviewCanvas);
            
            // Generar top 4 grid con fractales
            generateClaimTop5Grid(top5Grid, top4Words);
            
            // Actualizar total value box
            const claimTotalDisplay = document.getElementById('claim-value-logic-total-display');
            if (claimTotalDisplay) {
                claimTotalDisplay.textContent = totalValueETHDisplay;
            }
            totalBox.style.display = 'block';
        }

        function createClaimValueLogicOverview(container, canvas) {
            if (!container || !canvas || !nodes || nodes.length === 0) return;
            
            // Asegurarse de que el contenedor esté visible
            container.style.display = 'block';
            container.style.visibility = 'visible';
            container.style.opacity = '1';
            
            // Esperar a que el DOM se actualice para obtener las dimensiones correctas
            setTimeout(() => {
                const containerRect = container.getBoundingClientRect();
                let containerWidth = Math.floor(containerRect.width);
                const containerHeight = 150;
                
                // Si el ancho es 0 o muy pequeño, usar un valor por defecto
                if (containerWidth <= 0) {
                    containerWidth = 340;
                }
                
                // Asegurarse de que el canvas tenga dimensiones explícitas
                canvas.width = containerWidth;
                canvas.height = containerHeight;
                
                // Limpiar renderer anterior si existe
                if (window.claimOverviewRenderer) {
                    try {
                        window.claimOverviewRenderer.dispose();
                    } catch (e) {
                        console.warn('Error disposing claim overview renderer:', e);
                    }
                    window.claimOverviewRenderer = null;
                }
                
                // Crear escena (similar al overview regular)
                const overviewScene = new THREE.Scene();
                overviewScene.background = new THREE.Color(0x000000);
                
                const overviewCamera = new THREE.PerspectiveCamera(50, containerWidth / containerHeight, 0.1, 1000);
                
                // Calcular bounding box
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                let minZ = Infinity, maxZ = -Infinity;
                
                nodes.forEach(node => {
                    const pos = node.position;
                    minX = Math.min(minX, pos.x);
                    maxX = Math.max(maxX, pos.x);
                    minY = Math.min(minY, pos.y);
                    maxY = Math.max(maxY, pos.y);
                    minZ = Math.min(minZ, pos.z);
                    maxZ = Math.max(maxZ, pos.z);
                });
                
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;
                
                const sizeX = maxX - minX;
                const sizeY = maxY - minY;
                const sizeZ = maxZ - minZ;
                const maxSize = Math.max(sizeX, sizeY, sizeZ, 1);
                
                const distance = maxSize * 2.5;
                overviewCamera.position.set(centerX, centerY, centerZ + distance);
                overviewCamera.lookAt(centerX, centerY, centerZ);
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
                overviewScene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(2, 2, 2);
                overviewScene.add(directionalLight);
                
                // Clone nodes at smaller scale
                const scaleFactor = 0.25;
                nodes.forEach(node => {
                    let clonedNode;
                    if (node.isGroup) {
                        clonedNode = node.clone(true);
                    } else {
                        clonedNode = node.clone();
                    }
                    clonedNode.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    overviewScene.add(clonedNode);
                });
                
                // Clone connections
                connections.forEach(conn => {
                    const clonedConn = conn.clone();
                    overviewScene.add(clonedConn);
                });
                
                // Create renderer directly with the canvas (igual que el overview regular)
                try {
                    window.claimOverviewRenderer = new THREE.WebGLRenderer({ 
                        canvas: canvas,
                        antialias: false,
                        powerPreference: "low-power"
                    });
                    window.claimOverviewRenderer.setSize(containerWidth, containerHeight);
                    window.claimOverviewRenderer.setPixelRatio(0.5);
                    
                    // Renderizar en el siguiente frame para asegurar que todo esté listo
                    requestAnimationFrame(() => {
                        if (window.claimOverviewRenderer && overviewScene && overviewCamera) {
                            window.claimOverviewRenderer.render(overviewScene, overviewCamera);
                        }
                    });
                } catch (error) {
                    console.error('Error creating claim overview renderer:', error);
                    // Fallback: intentar copiar del overview regular si está disponible
                    const existingOverview = document.getElementById('value-logic-overview-canvas');
                    if (existingOverview && existingOverview.width > 0 && existingOverview.height > 0) {
                        try {
                            const ctx2D = canvas.getContext('2d');
                            canvas.width = containerWidth;
                            canvas.height = containerHeight;
                            ctx2D.drawImage(existingOverview, 0, 0, containerWidth, containerHeight);
                        } catch (e) {
                            console.error('Error copying existing overview:', e);
                        }
                    }
                }
            }, 300);
        }

        function generateClaimTop5Grid(container, top4Words) {
            if (!container || !top4Words || top4Words.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            const boxBorder = "#ffffff";
            const boxBg = "#000000";
            const textColor = "#ffffff";
            
            let gridHTML = '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">';
            
            top4Words.forEach((w, idx) => {
                const wordIndex = analyzedWords.indexOf(w);
                if (wordIndex < 0) return;
                
                const fractalCanvasId = `claim-top5-grid-fractal-${idx}`;
                gridHTML += `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                        <div style="border: 1px solid ${boxBorder}; background: #000000; width: 100%; padding: 2px;">
                            <canvas id="${fractalCanvasId}" width="120" height="90" style="display: block; width: 100%; height: 90px;"></canvas>
                        </div>
                        <div style="border: 1px solid ${boxBorder}; background: ${boxBg}; padding: 4px; width: 100%;">
                            <div style="color: ${textColor}; font-size: 10px; text-align: center; font-family: Helvetica, Arial, sans-serif;">${w.text}</div>
                        </div>
                    </div>
                `;
            });
            
            gridHTML += '</div>';
            container.innerHTML = gridHTML;
            container.style.display = 'block';
            
            // Generar fractales
            setTimeout(() => {
                top4Words.forEach((w, idx) => {
                    const wordIndex = analyzedWords.indexOf(w);
                    if (wordIndex >= 0) {
                        const fractalCanvasId = `claim-top5-grid-fractal-${idx}`;
                        generateTop5Fractal(fractalCanvasId, wordIndex);
                    }
                });
            }, 150);
        }

        function createClaimTop12NodesList() {
            const grid = document.getElementById('claim-nodes-grid');
            if (!grid) return;
            
            // Limpiar contenido previo
            grid.innerHTML = '';
            
            const sortedNodes = [...nodes].sort((a, b) => {
                const scoreA = a.userData.wordData ? (a.userData.wordData.finalValue || 0) : 0;
                const scoreB = b.userData.wordData ? (b.userData.wordData.finalValue || 0) : 0;
                return scoreB - scoreA;
            });

            const top12 = sortedNodes.slice(0, 12);

            top12.forEach((node, index) => {
                const wordData = node.userData.wordData;
                if (!wordData) return;

                const item = document.createElement('div');
                item.className = 'node-list-item';
                item.style.cssText = 'width: 180px; height: auto; min-height: 250px; background: rgba(255, 255, 255, 0.95); border: none; padding: 5px; display: flex; flex-direction: column; overflow: visible; box-sizing: border-box; flex-shrink: 0;';

                const header = document.createElement('div');
                header.style.cssText = 'text-align: center; margin-bottom: 5px; padding: 2px;';
                const h3 = document.createElement('h3');
                h3.style.cssText = 'color: #000000; font-size: 11px; margin: 0; font-family: Helvetica, Arial, sans-serif;';
                h3.textContent = wordData.text;
                header.appendChild(h3);
                item.appendChild(header);

                const canvasContainer = document.createElement('div');
                canvasContainer.className = 'node-list-item-canvas-container';
                canvasContainer.style.cssText = 'width: 100%; height: 140px; background: #000000; margin-bottom: 5px; position: relative;';
                const canvas = document.createElement('canvas');
                canvas.className = 'node-list-item-canvas';
                canvas.width = 200;
                canvas.height = 140;
                canvasContainer.appendChild(canvas);
                item.appendChild(canvasContainer);

                // Añadir fractal debajo del canvas 3D
                const fractalContainer = document.createElement('div');
                fractalContainer.style.cssText = 'width: 100%; margin-bottom: 5px; border: 1px solid #ffffff; background: #000000; padding: 1px; box-sizing: border-box; overflow: visible;';
                const fractalCanvas = document.createElement('canvas');
                fractalCanvas.id = `claim-node-list-fractal-${index}`;
                fractalCanvas.width = 178;
                fractalCanvas.height = 94;
                fractalCanvas.style.cssText = 'display: block; width: 100%; height: 94px; background: #000000; box-sizing: border-box;';
                fractalContainer.appendChild(fractalCanvas);
                item.appendChild(fractalContainer);

                grid.appendChild(item);

                // Crear escena 3D para este nodo
                createClaimNodeListItem3D(canvas, node, index);
                
                // Generar fractal para este nodo
                const wordIndex = node.userData.index;
                if (wordIndex >= 0 && analyzedWords && wordIndex < analyzedWords.length) {
                    setTimeout(() => {
                        generateTop5Fractal(`claim-node-list-fractal-${index}`, wordIndex);
                    }, 150 + (index * 50)); // Stagger generation to avoid blocking
                }
            });
        }

        function createClaimNodeListItem3D(canvas, node, index) {
            // Usar renderer compartido si no existe
            if (!sharedNodeListRenderer) {
                // Crear un canvas temporal para el renderer compartido
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 200;
                tempCanvas.height = 140;
                sharedNodeListRenderer = new THREE.WebGLRenderer({ canvas: tempCanvas, antialias: false });
                sharedNodeListRenderer.setSize(200, 140);
                
                sharedNodeListScene = new THREE.Scene();
                sharedNodeListScene.background = new THREE.Color(0x000000);
                
                sharedNodeListCamera = new THREE.PerspectiveCamera(75, 200 / 140, 0.1, 1000);
                sharedNodeListCamera.position.set(0, 0, 0.3);
                sharedNodeListCamera.lookAt(0, 0, 0);
                
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                sharedNodeListScene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(5, 5, 5);
                sharedNodeListScene.add(directionalLight);
            }
            
            // Limpiar escena anterior
            while (sharedNodeListScene.children.length > 2) { // Mantener las luces
                const child = sharedNodeListScene.children[2];
                sharedNodeListScene.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            }
            
            // Clonar el nodo y centrarlo
            const clone = node.isGroup ? node.clone(true) : node.clone();
            clone.position.set(0, 0, 0);
            sharedNodeListScene.add(clone);
            
            // Renderizar a una textura temporal
            const renderTarget = new THREE.WebGLRenderTarget(200, 140);
            
            // Guardar estado del renderer
            const originalSize = sharedNodeListRenderer.getSize(new THREE.Vector2());
            const originalClearColor = sharedNodeListRenderer.getClearColor(new THREE.Color());
            
            // Renderizar
            sharedNodeListRenderer.setRenderTarget(renderTarget);
            sharedNodeListRenderer.setClearColor(0x000000, 1);
            sharedNodeListRenderer.render(sharedNodeListScene, sharedNodeListCamera);
            
            // Leer la textura y dibujarla en el canvas 2D
            const ctx2D = canvas.getContext('2d');
            const pixels = new Uint8Array(200 * 140 * 4);
            sharedNodeListRenderer.readRenderTargetPixels(renderTarget, 0, 0, 200, 140, pixels);
            
            const imageData = ctx2D.createImageData(200, 140);
            for (let i = 0; i < pixels.length; i += 4) {
                imageData.data[i] = pixels[i];
                imageData.data[i + 1] = pixels[i + 1];
                imageData.data[i + 2] = pixels[i + 2];
                imageData.data[i + 3] = pixels[i + 3];
            }
            ctx2D.putImageData(imageData, 0, 0);
            
            // Restaurar estado del renderer
            sharedNodeListRenderer.setRenderTarget(null);
            sharedNodeListRenderer.setSize(originalSize.x, originalSize.y);
            sharedNodeListRenderer.setClearColor(originalClearColor, 1);
            
            // Limpiar render target
            renderTarget.dispose();
            
            // Remover el nodo clonado de la escena
            sharedNodeListScene.remove(clone);
            if (clone.geometry) clone.geometry.dispose();
            if (clone.material) {
                if (Array.isArray(clone.material)) {
                    clone.material.forEach(m => m.dispose());
                } else {
                    clone.material.dispose();
                }
            }
        }

        function hideClaimModal() {
            const modal = document.getElementById('claim-modal');
            if (modal) {
                modal.style.display = 'none';
                modal.style.visibility = 'hidden';
                modal.style.opacity = '0';
            }
            
            // Limpiar recursos 3D
            if (claimAnimationId) {
                cancelAnimationFrame(claimAnimationId);
                claimAnimationId = null;
            }
            
            if (claimScene) {
                claimScene.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                claimScene = null;
            }
            
            // Limpiar renderer compartido de nodos
            if (sharedNodeListRenderer) {
                if (sharedNodeListScene) {
                    sharedNodeListScene.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    sharedNodeListScene = null;
                }
                sharedNodeListRenderer.dispose();
                sharedNodeListRenderer = null;
                sharedNodeListCamera = null;
            }
        }

        async function downloadClaimPurchasePack() {
            try {
                // Verificar JSZip
                if (typeof JSZip === 'undefined') {
                    // Cargar JSZip dinámicamente
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                    await new Promise((resolve, reject) => {
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                }
                
                const zip = new JSZip();
                let imageReady = false;
                let glbReady = false;

                function checkAndDownload() {
                    if (imageReady && glbReady) {
                        zip.generateAsync({ type: 'blob' }).then((content) => {
                            const link = document.createElement('a');
                            link.href = URL.createObjectURL(content);
                            link.download = `purchase-pack-${getTimestamp()}.zip`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            setTimeout(() => URL.revokeObjectURL(link.href), 100);
                        });
                    }
                }

                // 1. Capturar imagen del total value (capturar todo el contenido sin cortes)
                const totalValueContainer = document.getElementById('claim-total-value-container');
                if (totalValueContainer && typeof html2canvas !== 'undefined') {
                    // Clonar el contenedor fuera de la vista para evitar glitches visuales
                    const clonedContainer = totalValueContainer.cloneNode(true);
                    clonedContainer.id = 'claim-total-value-container-clone';
                    clonedContainer.style.position = 'fixed';
                    clonedContainer.style.left = '-9999px';
                    clonedContainer.style.top = '0';
                    clonedContainer.style.height = 'auto';
                    clonedContainer.style.maxHeight = 'none';
                    clonedContainer.style.overflow = 'visible';
                    clonedContainer.style.opacity = '1';
                    clonedContainer.style.visibility = 'visible';
                    clonedContainer.style.display = 'block';
                    clonedContainer.style.width = totalValueContainer.offsetWidth + 'px';
                    document.body.appendChild(clonedContainer);
                    
                    // Asegurarse de que los contenedores estén visibles en el clon
                    const clonedOverviewContainer = clonedContainer.querySelector('#claim-value-logic-overview-container');
                    const clonedTop5Grid = clonedContainer.querySelector('#claim-value-logic-top5-grid');
                    if (clonedOverviewContainer) {
                        clonedOverviewContainer.style.display = 'block';
                    }
                    if (clonedTop5Grid) {
                        clonedTop5Grid.style.display = 'block';
                    }
                    
                    // Copiar el contenido de los canvas al clon
                    const originalCanvases = totalValueContainer.querySelectorAll('canvas');
                    const clonedCanvases = clonedContainer.querySelectorAll('canvas');
                    
                    // Mapear canvas por ID para copiar correctamente
                    originalCanvases.forEach((originalCanvas) => {
                        const canvasId = originalCanvas.id;
                        if (!canvasId) return;
                        
                        const clonedCanvas = clonedContainer.querySelector('#' + canvasId);
                        if (clonedCanvas && originalCanvas.width > 0 && originalCanvas.height > 0) {
                            try {
                                const ctx = clonedCanvas.getContext('2d');
                                if (ctx) {
                                    clonedCanvas.width = originalCanvas.width;
                                    clonedCanvas.height = originalCanvas.height;
                                    // Copiar el contenido del canvas original
                                    ctx.drawImage(originalCanvas, 0, 0);
                                }
                            } catch (e) {
                                console.warn('Could not copy canvas ' + canvasId + ':', e);
                            }
                        }
                    });
                    
                    // Esperar a que el DOM se actualice y los canvas se rendericen
                    setTimeout(() => {
                        // Asegurarse de que todos los canvas estén listos
                        const allCanvasesReady = Array.from(clonedCanvases).every(canvas => {
                            return canvas.width > 0 && canvas.height > 0;
                        });
                        
                        if (!allCanvasesReady) {
                            // Reintentar copiar los canvas
                            originalCanvases.forEach((originalCanvas) => {
                                const canvasId = originalCanvas.id;
                                if (!canvasId) return;
                                
                                const clonedCanvas = clonedContainer.querySelector('#' + canvasId);
                                if (clonedCanvas && originalCanvas.width > 0 && originalCanvas.height > 0) {
                                    try {
                                        const ctx = clonedCanvas.getContext('2d');
                                        if (ctx) {
                                            clonedCanvas.width = originalCanvas.width;
                                            clonedCanvas.height = originalCanvas.height;
                                            ctx.drawImage(originalCanvas, 0, 0);
                                        }
                                    } catch (e) {
                                        console.warn('Could not copy canvas ' + canvasId + ':', e);
                                    }
                                }
                            });
                        }
                        
                        html2canvas(clonedContainer, {
                            backgroundColor: '#dcdcdc',
                            scale: 2,
                            height: clonedContainer.scrollHeight,
                            width: clonedContainer.scrollWidth,
                            useCORS: true,
                            allowTaint: true,
                            logging: false,
                            ignoreElements: (element) => {
                                // No ignorar nada, capturar todo
                                return false;
                            },
                            onclone: (clonedDoc) => {
                                // Asegurarse de que los contenedores estén visibles en el clon de html2canvas
                                const clonedOverview = clonedDoc.getElementById('claim-value-logic-overview-container');
                                const clonedTop5 = clonedDoc.getElementById('claim-value-logic-top5-grid');
                                if (clonedOverview) {
                                    clonedOverview.style.display = 'block';
                                }
                                if (clonedTop5) {
                                    clonedTop5.style.display = 'block';
                                }
                                
                                // Copiar canvas nuevamente en el clon de html2canvas
                                originalCanvases.forEach((originalCanvas) => {
                                    const canvasId = originalCanvas.id;
                                    if (!canvasId) return;
                                    
                                    const clonedCanvas = clonedDoc.getElementById(canvasId);
                                    if (clonedCanvas && originalCanvas.width > 0 && originalCanvas.height > 0) {
                                        try {
                                            const ctx = clonedCanvas.getContext('2d');
                                            if (ctx) {
                                                clonedCanvas.width = originalCanvas.width;
                                                clonedCanvas.height = originalCanvas.height;
                                                ctx.drawImage(originalCanvas, 0, 0);
                                            }
                                        } catch (e) {
                                            console.warn('Could not copy canvas in onclone ' + canvasId + ':', e);
                                        }
                                    }
                                });
                            }
                        }).then((canvas) => {
                            // Eliminar el clon
                            if (clonedContainer.parentNode) {
                                document.body.removeChild(clonedContainer);
                            }
                            
                            canvas.toBlob((blob) => {
                                zip.file('total-value-summary.jpg', blob);
                                imageReady = true;
                                checkAndDownload();
                            }, 'image/jpeg', 1.0);
                        }).catch((error) => {
                            console.error('Error capturing total value:', error);
                            // Eliminar el clon en caso de error
                            if (clonedContainer.parentNode) {
                                document.body.removeChild(clonedContainer);
                            }
                            imageReady = true;
                            checkAndDownload();
                        });
                    }, 300);
                } else {
                    imageReady = true;
                    checkAndDownload();
                }

                // 2. Exportar GLB
                if (typeof THREE.GLTFExporter === 'undefined') {
                    alert('Error: GLTFExporter no está disponible.');
                    glbReady = true;
                    checkAndDownload();
                    return;
                }

                const exportScene = new THREE.Scene();
                nodes.forEach(node => {
                    const clonedNode = node.isGroup ? node.clone(true) : node.clone();
                    exportScene.add(clonedNode);
                });
                connections.forEach(connection => {
                    const clonedConnection = connection.clone();
                    exportScene.add(clonedConnection);
                });

                try {
                    const exporter = new THREE.GLTFExporter();
                    exporter.parse(exportScene, (result) => {
                        let blob;
                        if (result instanceof ArrayBuffer) {
                            blob = new Blob([result], { type: 'model/gltf-binary' });
                        } else {
                            const output = JSON.stringify(result, null, 2);
                            blob = new Blob([output], { type: 'application/json' });
                        }
                        zip.file('text-body.glb', blob);
                        glbReady = true;
                        checkAndDownload();
                    }, {
                        binary: true,
                        trs: false,
                        onlyVisible: true,
                        truncateDrawRange: true,
                        embedImages: true,
                        animations: [],
                        includeCustomExtensions: false
                    });
                } catch (error) {
                    console.error('Error exporting GLB:', error);
                    glbReady = true;
                    checkAndDownload();
                }
            } catch (e) {
                console.error('Error creating purchase pack:', e);
                alert('Error al crear el pack. Por favor, intenta de nuevo.');
            }
        }

        // ==================== EXPORTACIÓN GLB ====================
        function exportToGLB() {
            if (nodes.length === 0) {
                alert('No nodes to export. Generate a visualization first.');
                return;
            }
            
            // Check if GLTFExporter is available
            if (typeof THREE.GLTFExporter === 'undefined') {
                // Try to load dynamically
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js';
                script.onload = () => {
                    setTimeout(() => performExport(), 100);
                };
                script.onerror = () => {
                    alert('Error loading GLTFExporter. Please check your internet connection.');
                };
                document.head.appendChild(script);
                return;
            }
            
            performExport();
        }
        
        function performExport() {
            // Crear una escena temporal para exportar
            const exportScene = new THREE.Scene();
            
            // Copiar todos los nodos y conexiones
            // Use deep clone (true) for groups (nouns with flat base, "to be" verbs with flat rectangular base)
            nodes.forEach(node => {
                const clonedNode = node.isGroup ? node.clone(true) : node.clone();
                exportScene.add(clonedNode);
            });
            
            connections.forEach(connection => {
                const clonedConnection = connection.clone();
                exportScene.add(clonedConnection);
            });
            
            try {
                // Exportar usando GLTFExporter
                const exporter = new THREE.GLTFExporter();
                
                exporter.parse(exportScene, (result) => {
                    let blob;
                    let filename;
                    
                    if (result instanceof ArrayBuffer) {
                        // GLB binario
                        blob = new Blob([result], { type: 'model/gltf-binary' });
                        filename = `text-body-${getTimestamp()}.glb`;
                    } else if (typeof result === 'object') {
                        // GLTF JSON (fallback)
                        const output = JSON.stringify(result, null, 2);
                        blob = new Blob([output], { type: 'application/json' });
                        filename = `text-body-${getTimestamp()}.gltf`;
                    } else {
                        throw new Error('Formato de resultado no reconocido');
                    }
                    
                    // Descargar
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Limpiar URL después de un tiempo
                    setTimeout(() => URL.revokeObjectURL(link.href), 100);
                }, {
                    binary: true,
                    trs: false,
                    onlyVisible: true,
                    truncateDrawRange: true,
                    embedImages: true,
                    animations: [],
                    includeCustomExtensions: false
                });
            } catch (error) {
                console.error('Error exporting:', error);
                alert('Error exporting the model. Please try again.');
            }
        }
        
        function getTimestamp() {
            const now = new Date();
            return now.getFullYear() + 
                String(now.getMonth() + 1).padStart(2, '0') + 
                String(now.getDate()).padStart(2, '0') + '-' +
                String(now.getHours()).padStart(2, '0') + 
                String(now.getMinutes()).padStart(2, '0') + 
                String(now.getSeconds()).padStart(2, '0');
        }

        // ==================== CONTROLES DE CÁMARA ====================
        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseMove(event) {
            if (!isDragging) return;
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            
            cameraAngleY += deltaX * 0.01;
            cameraAngleX += deltaY * 0.01;
            
            // Limitar ángulo vertical
            cameraAngleX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleX));
            
            updateCameraPosition();
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseUp(event) {
            isDragging = false;
        }
        
        function onMouseMoveCoordinates(event) {
            // Calculate mouse position in normalized device coordinates
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Create raycaster from camera
            const tempRaycaster = new THREE.Raycaster();
            tempRaycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
            
            // Update global mouse position for use in updateCoordinatesDisplay
            mouse.x = mouseX;
            mouse.y = mouseY;
            
            // Calculate point at a distance along the ray (distance from camera to target area)
            // Use the distance from camera to cameraTarget as reference
            const distance = camera.position.distanceTo(cameraTarget);
            const intersectionPoint = new THREE.Vector3();
            tempRaycaster.ray.at(distance, intersectionPoint);
            
            // Update coordinates display
            const xElement = document.getElementById('realtime-camera-x');
            const yElement = document.getElementById('realtime-camera-y');
            const zElement = document.getElementById('realtime-camera-z');
            
            if (xElement && yElement && zElement) {
                xElement.textContent = intersectionPoint.x.toFixed(2);
                yElement.textContent = intersectionPoint.y.toFixed(2);
                zElement.textContent = intersectionPoint.z.toFixed(2);
            }
        }
        
        function updateCoordinatesDisplay() {
            // Update coordinates based on current mouse position or center of screen
            // Use center of screen (0, 0) if mouse position not available
            const mouseX = mouse && mouse.x !== undefined ? mouse.x : 0;
            const mouseY = mouse && mouse.y !== undefined ? mouse.y : 0;
            
            const tempRaycaster = new THREE.Raycaster();
            tempRaycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
            
            // Calculate point at distance from camera to target
            const distance = camera.position.distanceTo(cameraTarget);
            const intersectionPoint = new THREE.Vector3();
            tempRaycaster.ray.at(distance, intersectionPoint);
            
            const xElement = document.getElementById('realtime-camera-x');
            const yElement = document.getElementById('realtime-camera-y');
            const zElement = document.getElementById('realtime-camera-z');
            
            if (xElement && yElement && zElement) {
                xElement.textContent = intersectionPoint.x.toFixed(2);
                yElement.textContent = intersectionPoint.y.toFixed(2);
                zElement.textContent = intersectionPoint.z.toFixed(2);
            }
        }
        
        function onMouseMoveHover(event) {
            if (isDragging) return; // Don't check hover while dragging
            
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Check intersection with nodes
            const intersects = raycaster.intersectObjects(nodes, true); // true = check children (for noun groups)
            
            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                
                // Get the actual node (might be a group for nouns)
                let actualNode = intersected;
                if (intersected.parent && intersected.parent.userData && intersected.parent.userData.isNoun) {
                    actualNode = intersected.parent;
                } else if (intersected.userData && intersected.userData.isNoun && intersected.userData.mainNode) {
                    actualNode = intersected;
                }
                
                if (actualNode.userData && actualNode.userData.wordData) {
                    hoveredNode = actualNode;
                    showNodeInfo(actualNode, event.clientX, event.clientY);
                } else {
                    hideNodeInfo();
                }
            } else {
                hideNodeInfo();
            }
        }
        
        function onNodeClick(event) {
            if (isDragging) return; // Don't check click if we were dragging
            
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Check intersection with nodes
            const intersects = raycaster.intersectObjects(nodes, true); // true = check children (for noun groups)
            
            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                
                // Get the actual node (might be a group for nouns or "to be" verbs)
                let actualNode = intersected;
                if (intersected.parent && intersected.parent.userData && (intersected.parent.userData.isNoun || intersected.parent.userData.isSerEstar)) {
                    actualNode = intersected.parent;
                } else if (intersected.userData && ((intersected.userData.isNoun || intersected.userData.isSerEstar) && intersected.userData.mainNode)) {
                    actualNode = intersected;
                }
                
                if (actualNode.userData && actualNode.userData.wordData) {
                    hoveredNode = actualNode;
                    showNodeDetails(actualNode);
                }
            }
        }
        
        // Helper function to get next available offset
        function getNextRightPanelOffset() {
            // If there's an available offset from a closed panel, use it
            if (availableOffsets.length > 0) {
                return availableOffsets.pop();
            }
            // Otherwise, calculate new offset based on number of active panels
            return rightPanels.length * 20; // 20px offset per panel
        }
        
        // Helper function to create a cloned right panel
        function createRightPanelClone(panelId, offset) {
            const originalPanel = document.getElementById('right-panel');
            if (!originalPanel) return null;
            
            // Clone the panel
            const clonedPanel = originalPanel.cloneNode(true);
            clonedPanel.id = `right-panel-${panelId}`;
            clonedPanel.className = 'right-panel-clone';
            
            // Set position with offset
            clonedPanel.style.bottom = (15 + offset) + 'px';
            clonedPanel.style.right = (5 + offset) + 'px';
            
            // Update all IDs in cloned panel to be unique (must do this BEFORE querying elements)
            // But keep track of key container IDs for later reference
            const allElements = clonedPanel.querySelectorAll('[id]');
            const idMap = {};
            let headerId = null;
            let detailsId = null;
            allElements.forEach(el => {
                if (el.id) {
                    const oldId = el.id;
                    const newId = oldId + '-' + panelId;
                    el.id = newId;
                    idMap[oldId] = newId;
                    
                    // Track important container IDs
                    if (oldId === 'right-panel-header') headerId = newId;
                    if (oldId === 'node-details-content') detailsId = newId;
                }
            });
            
            // Store IDs for later use
            clonedPanel.dataset.headerId = headerId;
            clonedPanel.dataset.detailsId = detailsId;
            
            // Update close button to use specific panel ID (after IDs are updated)
            const closeBtn = clonedPanel.querySelector(`#right-panel-close-${panelId}`);
            if (closeBtn) {
                closeBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    hideRightPanel(panelId);
                };
            } else {
                console.error('Close button not found for panel:', panelId);
            }
            
            // Add to body
            document.body.appendChild(clonedPanel);
            
            return clonedPanel;
        }
        
        // Helper function to create 3D scene for a cloned panel
        function createRightPanelScene(panelId) {
            const panel = document.getElementById(`right-panel-${panelId}`);
            if (!panel) {
                console.error('Panel not found:', `right-panel-${panelId}`);
                return null;
            }
            
            // Canvas ID is updated to right-panel-canvas-{panelId}
            const canvas = panel.querySelector(`#right-panel-canvas-${panelId}`) || panel.querySelector('canvas');
            if (!canvas) {
                console.error('Canvas not found in panel:', panelId);
                return null;
            }
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            const camera = new THREE.PerspectiveCamera(50, 200 / 150, 0.1, 100);
            camera.position.set(0, 0, 2);
            camera.lookAt(0, 0, 0);
            
            const renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: false,
                alpha: false
            });
            // Get actual canvas dimensions (accounting for padding: 200px - 10px = 190px)
            const canvasWidth = 190;
            const canvasHeight = 140; // Increased from 90px
            renderer.setSize(canvasWidth, canvasHeight);
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(2, 2, 2);
            scene.add(directionalLight);
            
            return { scene, camera, renderer };
        }
        
        // Helper function to show enlarged node in a specific panel
        function showRightPanelEnlargedNodeForPanel(panelId, node) {
            const panelData = rightPanels.find(p => p.id === panelId);
            if (!panelData || !panelData.scene) return;
            
            // Remove previous mesh
            if (panelData.mesh) {
                panelData.scene.remove(panelData.mesh);
                if (panelData.mesh.geometry) panelData.mesh.geometry.dispose();
                if (panelData.mesh.material) panelData.mesh.material.dispose();
                if (panelData.mesh.children) {
                    panelData.mesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            }
            
            // Clone the node for display (enlarged)
            const wordData = node.userData.wordData;
            const enlargedSize = 0.35;
            
            let color;
            const score = wordData.normalizedScore;
            if (score > 0.85) {
                color = 0xffff00;
            } else if (score > 0.7) {
                color = 0x4a6fa5;
            } else if (score > 0.5) {
                color = 0x5a7fb5;
            } else if (score > 0.3) {
                color = 0x6a8fc5;
            } else if (score > 0.1) {
                color = 0x7a9fd5;
            } else {
                color = 0xffffff;
            }
            
            let mesh;
            if (wordData.isSerEstar) {
                const cubeGeometry = new THREE.BoxGeometry(enlargedSize, enlargedSize, enlargedSize, 1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const cube = new THREE.Mesh(cubeGeometry, material);
                
                const flatRectWidth = enlargedSize * 1.0;
                const flatRectDepth = enlargedSize * 1.0;
                const flatRectHeight = enlargedSize * 0.1;
                const flatRectGeometry = new THREE.BoxGeometry(flatRectWidth, flatRectHeight, flatRectDepth, 1, 1, 1);
                const flatRectMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const flatRect = new THREE.Mesh(flatRectGeometry, flatRectMaterial);
                flatRect.position.y = -enlargedSize * 2.0;
                
                const group = new THREE.Group();
                group.add(cube);
                group.add(flatRect);
                mesh = group;
            } else if (wordData.pos === 'noun') {
                const sphereGeometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const sphere = new THREE.Mesh(sphereGeometry, material);
                
                const flatSquareSize = enlargedSize * 1.0;
                const flatSquareGeometry = new THREE.BoxGeometry(flatSquareSize, flatSquareSize * 0.1, flatSquareSize, 1, 1, 1);
                const flatSquareMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const flatSquare = new THREE.Mesh(flatSquareGeometry, flatSquareMaterial);
                flatSquare.position.y = -enlargedSize * 2.0;
                
                const group = new THREE.Group();
                group.add(sphere);
                group.add(flatSquare);
                mesh = group;
            } else if (node.userData.connectionCount > 0) {
                let geometry;
                if (node.userData.connectionCount >= 5) {
                    geometry = new THREE.BoxGeometry(enlargedSize * 1.2, enlargedSize * 0.8, enlargedSize * 1.5, 1, 1, 1);
                } else {
                    geometry = new THREE.BoxGeometry(enlargedSize, enlargedSize, enlargedSize, 1, 1, 1);
                }
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                mesh = new THREE.Mesh(geometry, material);
            } else {
                const geometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                mesh = new THREE.Mesh(geometry, material);
            }
            
            panelData.mesh = mesh;
            panelData.scene.add(mesh);
            
            // Render immediately to show the node
            if (panelData.renderer && panelData.camera) {
                panelData.renderer.render(panelData.scene, panelData.camera);
            }
        }
        
        // Helper function to animate a specific panel
        function animateRightPanelNodeForPanel(panelId) {
            const panelData = rightPanels.find(p => p.id === panelId);
            if (!panelData || !panelData.mesh || !panelData.renderer || !panelData.scene || !panelData.camera) {
                if (panelData && panelData.animationId) {
                    cancelAnimationFrame(panelData.animationId);
                    panelData.animationId = null;
                }
                return;
            }
            
            // Rotate the node
            panelData.mesh.rotation.y += 0.01;
            panelData.mesh.rotation.x += 0.005;
            
            panelData.renderer.render(panelData.scene, panelData.camera);
            panelData.animationId = requestAnimationFrame(() => animateRightPanelNodeForPanel(panelId));
        }
        
        function showNodeDetails(node) {
            if (!node.userData || !node.userData.wordData) return;
            
            // Check if we need to remove the oldest panel
            if (rightPanels.length >= MAX_RIGHT_PANELS) {
                const oldestPanel = rightPanels.shift(); // Remove first (oldest)
                hideRightPanel(oldestPanel.id);
            }
            
            // Get next available offset
            const offset = getNextRightPanelOffset();
            
            // Create new panel
            const panelId = rightPanelCounter++;
            const panelElement = createRightPanelClone(panelId, offset);
            if (!panelElement) return;
            
            // Create 3D scene for this panel
            const sceneData = createRightPanelScene(panelId);
            if (!sceneData) {
                panelElement.remove();
                return;
            }
            
            const wordData = node.userData.wordData;
            const index = node.userData.index;
            const totalValue = window.totalTextScore || 0;
            const individualValue = wordData.finalValue || wordData.totalScore || 0;
            const relativeValue = totalValue > 0 ? ((individualValue / totalValue) * 100).toFixed(2) + '%' : '0%';
            
            // Calculate node size in KB (approximate)
            let nodeSizeKB = 0;
            if (node.userData.isSerEstar) {
                nodeSizeKB = (1 * 1 * 1 * 4 * 3) + (1.5 * 0.1 * 1.2 * 4 * 3);
            } else if (node.userData.isNoun) {
                nodeSizeKB = (8 * 8 * 8 * 4 * 3) + (1 * 1 * 1 * 4 * 3);
            } else if (node.userData.connectionCount > 0) {
                nodeSizeKB = (8 * 4 * 3);
            } else {
                nodeSizeKB = (8 * 8 * 8 * 4 * 3);
            }
            nodeSizeKB = (nodeSizeKB / 1024).toFixed(4);
            
            // Calculate performance impact
            const performanceImpact = node.userData.connectionCount > 0 ? 
                'Medium (' + node.userData.connectionCount + ' connections)' : 
                'Low';
            
            // Convert individual value to ETH for display
            let individualValueETH = 0;
            if (ethPriceUSD) {
                individualValueETH = individualValue / ethPriceUSD;
            }
            const individualValueETHDisplay = individualValueETH >= 0.01 ? 
                `${individualValueETH.toFixed(6)} ETH` : 
                `${individualValueETH.toFixed(10)} ETH`;
            
            // Convert total value to ETH
            let totalValueETH = 0;
            if (ethPriceUSD) {
                totalValueETH = totalValue / ethPriceUSD;
            }
            const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                `${totalValueETH.toFixed(6)} ETH` : 
                `${totalValueETH.toFixed(10)} ETH`;
            
            // Update panel content - find elements using stored IDs or structure
            const headerId = panelElement.dataset.headerId || `right-panel-header-${panelId}`;
            const detailsId = panelElement.dataset.detailsId || `node-details-content-${panelId}`;
            
            const detailsContent = panelElement.querySelector(`#${detailsId}`);
            
            // Update header word - position it in top right corner
            let panelWordEl = panelElement.querySelector(`#right-panel-word-${panelId}`);
            
            // If word element doesn't exist, create it
            if (!panelWordEl) {
                panelWordEl = document.createElement('h3');
                panelWordEl.id = `right-panel-word-${panelId}`;
                panelWordEl.style.cssText = 'position: absolute; top: 2px; right: 5px; color: #000000; font-size: 11px; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; z-index: 10; line-height: 1;';
                panelElement.appendChild(panelWordEl);
            }
            
            if (panelWordEl) {
                panelWordEl.textContent = wordData.text;
            }
            
            // Update details content using innerHTML (like TOP NODES)
            if (detailsContent) {
                // Force visibility BEFORE updating content - match max-value-panel-info exactly
                detailsContent.style.display = 'block';
                detailsContent.style.visibility = 'visible';
                detailsContent.style.opacity = '1';
                detailsContent.style.background = '#000000';
                detailsContent.style.color = '#ffffff';
                detailsContent.style.fontSize = '9px';
                detailsContent.style.fontFamily = 'Helvetica, Arial, sans-serif';
                detailsContent.style.lineHeight = '1.3';
                detailsContent.style.margin = '0';
                detailsContent.style.padding = '8px';
                detailsContent.style.flex = '1';
                detailsContent.style.minHeight = '0';
                detailsContent.style.boxSizing = 'border-box';
                detailsContent.style.overflowY = 'visible';
                
                detailsContent.innerHTML = `
                    <div><strong>Word:</strong> ${wordData.text}</div>
                    <div><strong>Individual Value:</strong> $${individualValue.toFixed(2)} USD (${individualValueETHDisplay})</div>
                    <div><strong>Position in Text:</strong> ${index + 1} / ${analyzedWords.length}</div>
                    <div><strong>Value / Total:</strong> ${relativeValue} ($${totalValue.toFixed(2)} total / ${totalValueETHDisplay})</div>
                    <div><strong>Part of Speech:</strong> ${wordData.pos}</div>
                    <div><strong>Connections:</strong> ${node.userData.connectionCount || 0}</div>
                    <div><strong>Size (KB):</strong> ${nodeSizeKB} KB</div>
                    <div><strong>Performance:</strong> ${performanceImpact}</div>
                    <div><strong>Is Name:</strong> ${wordData.isName ? 'Yes' : 'No'}</div>
                    <div><strong>Is identity:</strong> ${wordData.isSerEstar ? 'Yes' : 'No'}</div>
                `;
                
                // Verify it's visible after update
                const computedStyle = window.getComputedStyle(detailsContent);
                console.log('Details content updated. Display:', computedStyle.display, 'Visibility:', computedStyle.visibility, 'Opacity:', computedStyle.opacity, 'Background:', computedStyle.backgroundColor, 'Height:', computedStyle.height);
            } else {
                console.error('Details content element not found!');
            }
            
            // Store panel data first
            const panelData = {
                id: panelId,
                element: panelElement,
                node: node,
                scene: sceneData.scene,
                renderer: sceneData.renderer,
                camera: sceneData.camera,
                mesh: null,
                animationId: null,
                offset: offset
            };
            
            rightPanels.push(panelData);
            
            // Show enlarged node in panel (must be after panelData is in rightPanels array)
            showRightPanelEnlargedNodeForPanel(panelId, node);
            
            // Show panel - ensure it's visible
            panelElement.classList.add('visible');
            panelElement.style.display = 'flex';
            panelElement.style.visibility = 'visible';
            panelElement.style.opacity = '1';
            
            // Debug: log if elements were found
            console.log('Panel created:', panelId, 'Header found:', !!header, 'Details found:', !!detailsContent, 'HeaderId:', headerId, 'DetailsId:', detailsId);
            
            // Start animation
            animateRightPanelNodeForPanel(panelId);
        }
        
        function showRightPanelEnlargedNode(node) {
            if (!rightPanelScene || !rightPanelRenderer) return;
            
            // Remove previous mesh
            if (rightPanelMesh) {
                rightPanelScene.remove(rightPanelMesh);
                if (rightPanelMesh.geometry) rightPanelMesh.geometry.dispose();
                if (rightPanelMesh.material) rightPanelMesh.material.dispose();
                if (rightPanelMesh.children) {
                    rightPanelMesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            }
            
            // Clone the node for display (enlarged)
            const wordData = node.userData.wordData;
            const baseSize = 0.06;
            const enlargedSize = 0.35; // Larger for right panel
            
            let color;
            const score = wordData.normalizedScore;
            
            if (score > 0.85) {
                color = 0xffff00;
            } else if (score > 0.7) {
                color = 0x4a6fa5;
            } else if (score > 0.5) {
                color = 0x5a7fb5;
            } else if (score > 0.3) {
                color = 0x6a8fc5;
            } else if (score > 0.1) {
                color = 0x7a9fd5;
            } else {
                color = 0xffffff;
            }
            
            if (wordData.isSerEstar) {
                // Create cube with flat rectangular base for "to be" verbs
                const cubeGeometry = new THREE.BoxGeometry(enlargedSize, enlargedSize, enlargedSize, 1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const cube = new THREE.Mesh(cubeGeometry, material);
                
                // Make base same size as cube (like names have same size as sphere)
                const flatRectWidth = enlargedSize * 1.0; // Same width as cube
                const flatRectDepth = enlargedSize * 1.0; // Same depth as cube
                const flatRectHeight = enlargedSize * 0.1; // Thin base
                const flatRectGeometry = new THREE.BoxGeometry(flatRectWidth, flatRectHeight, flatRectDepth, 1, 1, 1);
                const flatRectMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const flatRect = new THREE.Mesh(flatRectGeometry, flatRectMaterial);
                flatRect.position.y = -enlargedSize * 2.0; // Same separation as names
                
                const group = new THREE.Group();
                group.add(cube);
                group.add(flatRect);
                rightPanelMesh = group;
            } else if (wordData.pos === 'noun') {
                // Create sphere with flat square for nouns
                const sphereGeometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const sphere = new THREE.Mesh(sphereGeometry, material);
                
                const flatSquareSize = enlargedSize * 1.0;
                const flatSquareGeometry = new THREE.BoxGeometry(flatSquareSize, flatSquareSize * 0.1, flatSquareSize, 1, 1, 1);
                const flatSquareMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const flatSquare = new THREE.Mesh(flatSquareGeometry, flatSquareMaterial);
                flatSquare.position.y = -enlargedSize * 2.0;
                
                const group = new THREE.Group();
                group.add(sphere);
                group.add(flatSquare);
                rightPanelMesh = group;
            } else if (node.userData.connectionCount > 0) {
                // Cube for connected nodes
                let geometry;
                if (node.userData.connectionCount >= 5) {
                    geometry = new THREE.BoxGeometry(enlargedSize * 1.2, enlargedSize * 0.8, enlargedSize * 1.5, 1, 1, 1);
                } else {
                    geometry = new THREE.BoxGeometry(enlargedSize, enlargedSize, enlargedSize, 1, 1, 1);
                }
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                rightPanelMesh = new THREE.Mesh(geometry, material);
            } else {
                // Sphere for unconnected nodes
                const geometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                rightPanelMesh = new THREE.Mesh(geometry, material);
            }
            
            rightPanelScene.add(rightPanelMesh);
        }
        
        function animateRightPanelNode() {
            if (!rightPanelMesh || !rightPanelRenderer || !rightPanelScene || !rightPanelCamera) {
                if (rightPanelAnimationId) {
                    cancelAnimationFrame(rightPanelAnimationId);
                    rightPanelAnimationId = null;
                }
                return;
            }
            
            // Rotate the node
            rightPanelMesh.rotation.y += 0.01;
            rightPanelMesh.rotation.x += 0.005;
            
            rightPanelRenderer.render(rightPanelScene, rightPanelCamera);
            rightPanelAnimationId = requestAnimationFrame(animateRightPanelNode);
        }
        
        // ==================== VALUE LOGIC SUMMARY ====================
        
        function generateTop5Node3D(canvasId, wordData, wordIndex) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            try {
                // Create a small 3D scene for the node
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                
                const canvasWidth = canvas.width || 120;
                const canvasHeight = canvas.height || 90;
                const camera = new THREE.PerspectiveCamera(50, canvasWidth / canvasHeight, 0.1, 100);
                // Camera position for centered, appropriately sized node, slightly to the right
                camera.position.set(0.1, 0, 1.2); // Slight right offset (0.1) to center in recuadro
                camera.lookAt(0.1, 0, 0); // Look at slightly right position
                
                const renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: false,
                    alpha: false
                });
                renderer.setSize(canvasWidth, canvasHeight);
                renderer.setPixelRatio(1);
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(2, 2, 2);
                scene.add(directionalLight);
                
                // Create node geometry based on word data
                const baseSize = 0.06;
                const smallSize = 0.2; // Smaller, appropriately sized for preview
                
                let color;
                const score = wordData.normalizedScore || 0;
                if (score > 0.85) {
                    color = 0xffff00;
                } else if (score > 0.7) {
                    color = 0x4a6fa5;
                } else if (score > 0.5) {
                    color = 0x5a7fb5;
                } else if (score > 0.3) {
                    color = 0x6a8fc5;
                } else if (score > 0.1) {
                    color = 0x7a9fd5;
                } else {
                    color = 0xffffff;
                }
                
                let mesh;
                if (wordData.isSerEstar) {
                    // Cube with flat rectangular base
                    const cubeGeometry = new THREE.BoxGeometry(smallSize, smallSize, smallSize, 1, 1, 1);
                    const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                    const cube = new THREE.Mesh(cubeGeometry, material);
                    
                    const flatRectWidth = smallSize * 1.0;
                    const flatRectDepth = smallSize * 1.0;
                    const flatRectHeight = smallSize * 0.1;
                    const flatRectGeometry = new THREE.BoxGeometry(flatRectWidth, flatRectHeight, flatRectDepth, 1, 1, 1);
                    const flatRectMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                    const flatRect = new THREE.Mesh(flatRectGeometry, flatRectMaterial);
                    flatRect.position.y = -smallSize * 2.0;
                    
                    const group = new THREE.Group();
                    group.add(cube);
                    group.add(flatRect);
                    mesh = group;
                } else if (wordData.pos === 'noun') {
                    // Sphere with flat square
                    const sphereGeometry = new THREE.SphereGeometry(smallSize, 8, 8);
                    const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                    const sphere = new THREE.Mesh(sphereGeometry, material);
                    
                    const flatSquareSize = smallSize * 1.0;
                    const flatSquareGeometry = new THREE.BoxGeometry(flatSquareSize, flatSquareSize * 0.1, flatSquareSize, 1, 1, 1);
                    const flatSquareMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                    const flatSquare = new THREE.Mesh(flatSquareGeometry, flatSquareMaterial);
                    flatSquare.position.y = -smallSize * 2.0;
                    
                    const group = new THREE.Group();
                    group.add(sphere);
                    group.add(flatSquare);
                    mesh = group;
                } else {
                    // Regular sphere
                    const sphereGeometry = new THREE.SphereGeometry(smallSize, 8, 8);
                    const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                    mesh = new THREE.Mesh(sphereGeometry, material);
                }
                
                scene.add(mesh);
                
                // Position mesh slightly to the right for better centering in recuadro
                mesh.position.x = 0.05; // Slight right offset
                
                // Render with slight rotation
                mesh.rotation.y = Math.PI / 4;
                mesh.rotation.x = Math.PI / 6;
                renderer.render(scene, camera);
                
                // Clean up
                setTimeout(() => {
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                    if (mesh.children) {
                        mesh.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    }
                    renderer.dispose();
                }, 100);
            } catch (e) {
                console.warn('Error generating top5 node 3D:', e);
            }
        }
        
        function generateTop5Grid(top4Words) {
            const gridContainer = document.getElementById('value-logic-top5-grid');
            if (!gridContainer) return;
            
            if (!top4Words || top4Words.length === 0) {
                gridContainer.style.display = 'none';
                return;
            }
            
            // Get color mode
            const boxBorder = valueLogicColorMode ? "#000000" : "#ffffff";
            const boxBg = valueLogicColorMode ? "#ffffff" : "#000000";
            const textColor = valueLogicColorMode ? "#000000" : "#ffffff";
            
            // Create grid HTML - 2 columns
            let gridHTML = '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">';
            
            top4Words.forEach((w, idx) => {
                const wordIndex = analyzedWords.indexOf(w);
                if (wordIndex < 0) return;
                
                const fractalCanvasId = `top5-grid-fractal-${idx}`;
                
                // Each cell: fractal in box, word in box at bottom
                gridHTML += `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                        <div style="border: 1px solid ${boxBorder}; background: #000000; width: 100%; padding: 2px;">
                            <canvas id="${fractalCanvasId}" width="120" height="90" style="display: block; width: 100%; height: 90px;"></canvas>
                        </div>
                        <div style="border: 1px solid ${boxBorder}; background: ${boxBg}; padding: 4px; width: 100%;">
                            <div style="color: ${textColor}; font-size: 10px; text-align: center; font-family: Helvetica, Arial, sans-serif;">${w.text}</div>
                        </div>
                    </div>
                `;
            });
            
            gridHTML += '</div>';
            gridContainer.innerHTML = gridHTML;
            gridContainer.style.display = 'block';
            
            // Generate fractals
            setTimeout(() => {
                top4Words.forEach((w, idx) => {
                    const wordIndex = analyzedWords.indexOf(w);
                    if (wordIndex >= 0) {
                        const fractalCanvasId = `top5-grid-fractal-${idx}`;
                        
                        // Generate fractal visualization
                        generateTop5Fractal(fractalCanvasId, wordIndex);
                    }
                });
            }, 150);
        }
        
        function generateTop5Fractal(canvasId, wordIndex) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !analyzedWords || wordIndex < 0 || wordIndex >= analyzedWords.length) {
                return;
            }
            
            try {
                const ctx = canvas.getContext('2d');
                if (!ctx) return;
                
                const wordData = analyzedWords[wordIndex];
                const params = calculateFractalParameters(wordIndex);
                
                // Clear canvas
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Generate fractal at smaller resolution
                const width = canvas.width;
                const height = canvas.height;
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;
                
                // Use lower resolution for performance
                const scale = 0.5;
                const renderWidth = Math.floor(width * scale);
                const renderHeight = Math.floor(height * scale);
                
                // Calculate scaleFactor to fit complete fractal in canvas
                // For Mandelbrot/Julia sets, typical range is -2 to 2 (4 units total)
                // We want the fractal to fit exactly in the canvas boundaries
                // For width=120, to show 4 units: scaleFactor = width / 4 = 30
                // For height=90, to show 4 units: scaleFactor = height / 4 = 22.5
                // Use the smaller value to ensure it fits in both dimensions
                const fractalRange = 4.0; // -2 to 2 range
                const scaleFactorX = width / fractalRange; // ~30 for 120px width
                const scaleFactorY = height / fractalRange; // ~22.5 for 90px height
                const scaleFactor = Math.min(scaleFactorX, scaleFactorY); // Use smaller to fit both dimensions
                
                // Center the fractal (no offset) to show complete fractal
                const offsetX = 0; // Centered
                const offsetY = 0; // Centered
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Generate fractal
                for (let y = 0; y < renderHeight; y++) {
                    for (let x = 0; x < renderWidth; x++) {
                        const px = (x - renderWidth / 2) / scaleFactor + offsetX;
                        const py = (y - renderHeight / 2) / scaleFactor + offsetY;
                        
                        let color = [0, 0, 0, 255];
                        
                        switch (params.family) {
                            case 'Mandelbrot':
                                color = mandelbrotColor(px, py, params);
                                break;
                            case 'Multibrot':
                                color = multibrotColor(px, py, params);
                                break;
                            case 'Julia':
                                color = juliaColor(px, py, params);
                                break;
                            case 'Newton':
                                color = newtonColor(px, py, params);
                                break;
                            case 'OrbitTrap':
                                color = orbitTrapColor(px, py, params);
                                break;
                            default:
                                color = mandelbrotColor(px, py, params);
                        }
                        
                        // Write to image data (scaled up)
                        for (let sy = 0; sy < 1 / scale; sy++) {
                            for (let sx = 0; sx < 1 / scale; sx++) {
                                const idx = ((Math.floor(y / scale) + sy) * width + Math.floor(x / scale) + sx) * 4;
                                if (idx >= 0 && idx < data.length - 3) {
                                    data[idx] = color[0];
                                    data[idx + 1] = color[1];
                                    data[idx + 2] = color[2];
                                    data[idx + 3] = color[3];
                                }
                            }
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            } catch (e) {
                console.warn('Error generating top5 fractal:', e);
            }
        }
        
        function showValueLogicSummary() {
            if (!analyzedWords || analyzedWords.length === 0) {
                alert('No text analyzed. Please generate a visualization first.');
                return;
            }
            
            const modal = document.getElementById('value-logic-modal');
            const modalContainer = document.getElementById('value-logic-modal-container');
            const content = document.getElementById('value-logic-content');
            const totalValueBtn = document.getElementById('total-value-display');
            
            // Show modal explicitly
            if (modal) {
                modal.style.display = 'block';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
                modal.style.pointerEvents = 'auto';
            }
            
            // Position modal below the button
            if (totalValueBtn && modalContainer) {
                const btnRect = totalValueBtn.getBoundingClientRect();
                modalContainer.style.top = (btnRect.bottom + 5) + 'px'; // 5px gap below button
                modalContainer.style.left = btnRect.left + 'px';
                modalContainer.style.margin = '0'; // Remove auto margin
            }
            
            // Calculate statistics
            const totalWords = analyzedWords.length;
            const totalValueUSD = window.totalTextScore || analyzedWords.reduce((sum, w) => sum + (w.finalValue || 0), 0);
            const avgBaseValue = analyzedWords.reduce((sum, w) => sum + (w.baseValue || 0), 0) / totalWords;
            const avgFinalValueUSD = totalValueUSD / totalWords;
            
            // Convert to ETH
            let totalValueETH = 0;
            let avgFinalValueETH = 0;
            if (ethPriceUSD) {
                totalValueETH = totalValueUSD / ethPriceUSD;
                avgFinalValueETH = avgFinalValueUSD / ethPriceUSD;
            }
            
            const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                `${totalValueETH.toFixed(6)} ETH` : 
                `${totalValueETH.toFixed(10)} ETH`;
            const avgFinalValueETHDisplay = avgFinalValueETH >= 0.01 ? 
                `${avgFinalValueETH.toFixed(6)} ETH` : 
                `${avgFinalValueETH.toFixed(10)} ETH`;
            
            // Calculate average multipliers
            const avgLengthMultiplier = analyzedWords.reduce((sum, w) => sum + (w.lengthMultiplier || 1), 0) / totalWords;
            const avgOntologicalMultiplier = analyzedWords.reduce((sum, w) => sum + (w.ontologicalMultiplier || 1), 0) / totalWords;
            const avgNameWithToBeMultiplier = analyzedWords.reduce((sum, w) => sum + (w.nameWithToBeMultiplier || 1), 0) / totalWords;
            const avgSemanticMultiplier = analyzedWords.reduce((sum, w) => sum + (w.semanticMultiplier || 1), 0) / totalWords;
            const avgRepetitionMultiplier = analyzedWords.reduce((sum, w) => sum + (w.repetitionMultiplier || 1), 0) / totalWords;
            const avgTenseMultiplier = analyzedWords.reduce((sum, w) => sum + (w.tenseMultiplier || 1), 0) / totalWords;
            const avgNarrativePenalty = analyzedWords.reduce((sum, w) => sum + (w.narrativePenalty || 1), 0) / totalWords;
            
            // Calculate predominant tense
            let presentCount = 0;
            let pastCount = 0;
            let futureCount = 0;
            analyzedWords.forEach((w, idx) => {
                // Use the same tense detection logic as getTenseMultiplier
                if (w.pos === 'verb') {
                    const cleanWord = w.text.toLowerCase().replace(/[^\w]/g, '');
                    const presentVerbs = ['is', 'am', 'are', 'be', 'being', 'exist', 'exists', 'remain', 'remains',
                                         'es', 'son', 'estar', 'ser', 'existe', 'existen', 'permanece', 'permanecen',
                                         'have', 'has', 'do', 'does', 'go', 'goes', 'come', 'comes', 'see', 'sees',
                                         'tengo', 'tiene', 'hago', 'hace', 'voy', 'va', 'vengo', 'viene', 'veo', 've'];
                    const pastVerbs = ['was', 'were', 'been', 'existed', 'remained', 'became', 'had', 'did', 'went',
                                      'came', 'saw', 'fue', 'fueron', 'estuvo', 'estuvieron', 'existió', 'existieron',
                                      'tuvo', 'hizo', 'fue', 'vino', 'vio', 'said', 'told', 'thought', 'knew',
                                      'dijo', 'contó', 'pensó', 'supo'];
                    const futureVerbs = ['will', 'shall', 'would', 'going', 'gonna',
                                        'será', 'serán', 'estará', 'estarán', 'tendrá', 'tendrán', 'hará', 'harán',
                                        'irá', 'irán', 'vendrá', 'vendrán', 'verá', 'verán'];
                    const futureModal = ['will', 'shall', 'would', 'can', 'could', 'may', 'might',
                                        'podrá', 'podrán', 'deberá', 'deberán', 'puede', 'pueden'];
                    
                    if (presentVerbs.includes(cleanWord) || cleanWord.endsWith('ing')) {
                        presentCount++;
                    } else if (pastVerbs.includes(cleanWord) || cleanWord.endsWith('ed')) {
                        pastCount++;
                    } else if (futureVerbs.includes(cleanWord) || futureModal.includes(cleanWord)) {
                        futureCount++;
                    }
                }
            });
            
            let predominantTense = 'none';
            const totalVerbs = presentCount + pastCount + futureCount;
            if (totalVerbs > 0) {
                if (presentCount > pastCount && presentCount > futureCount) {
                    predominantTense = 'present';
                } else if (pastCount > presentCount && pastCount > futureCount) {
                    predominantTense = 'past';
                } else if (futureCount > presentCount && futureCount > pastCount) {
                    predominantTense = 'future';
                } else if (presentCount > 0 && (pastCount > 0 || futureCount > 0)) {
                    if (futureCount > 0) {
                        predominantTense = 'present_future';
                    } else if (pastCount > 0) {
                        predominantTense = 'present_past';
                    }
                }
            }
            
            const tenseLabels = {
                'present': 'Present',
                'past': 'Past',
                'future': 'Future',
                'present_future': 'Present + Future',
                'present_past': 'Present + Past',
                'none': 'No verbs detected'
            };
            
            // Count by POS
            const posCounts = {};
            const posValues = {};
            const posValuesETH = {};
            analyzedWords.forEach(w => {
                const pos = w.pos || 'other';
                posCounts[pos] = (posCounts[pos] || 0) + 1;
                const valueUSD = w.finalValue || 0;
                posValues[pos] = (posValues[pos] || 0) + valueUSD;
                if (ethPriceUSD) {
                    posValuesETH[pos] = (posValuesETH[pos] || 0) + (valueUSD / ethPriceUSD);
                }
            });
            
            // Count special words
            const toBeCount = analyzedWords.filter(w => w.isSerEstar).length;
            
            // Count names: use nameGroups so compound names count as 1, not multiple
            // Each name group (single name or compound name) counts as 1 name
            const nameGroups = window.nameGroups || [];
            const nameCount = nameGroups.length; // Each name or compound name = 1
            
            // Ontological Values: toBeCount + nameCount (each name or compound name counts as 1 ontological value)
            const ontologicalValues = toBeCount + nameCount;
            
            const ontologicalAssertions = analyzedWords.filter(w => w.ontologicalMultiplier > 1).length;
            
            // Top 4 words by value (for visualizations)
            const top4Words = [...analyzedWords]
                .sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0))
                .slice(0, 4);
            
            // Top 20 words by value
            const topWords = [...analyzedWords]
                .sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0))
                .slice(0, 20);
            
            // Helper function to highlight numbers
            function highlightNumber(num) {
                if (valueLogicColorMode) {
                    // White mode: black background, white text
                    return `<span style="background: #000000; color: #ffffff !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;">${num}</span>`;
                } else {
                    // Black mode: white background, black text
                    return `<span style="background: #ffffff; color: #000000 !important; padding: 0; display: inline-block; line-height: 1.0; vertical-align: baseline;">${num}</span>`;
                }
            }
            
            // Build HTML content with color mode support
            const boxBg = valueLogicColorMode ? "#ffffff" : "#000000";
            const boxBorder = valueLogicColorMode ? "#000000" : "#ffffff";
            const textColor = valueLogicColorMode ? "#000000" : "#ffffff";
            const borderColor = boxBorder;
            const dividerColor = valueLogicColorMode ? "#cccccc" : "#333333";
            const boxStyle = `background: ${boxBg}; border: 1px solid ${boxBorder}; padding: 4px; margin-bottom: 3px; border-radius: 0;`;
            const itemStyle = "margin: 0.5px 0;";
            
            // Format generation date/time
            let generationDateStr = 'N/A';
            if (visualizationGenerationDate) {
                const date = visualizationGenerationDate;
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');
                generationDateStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
            }
            
            let html = `
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">General Summary</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Total Words:</strong> ${highlightNumber(totalWords)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Average Value per Word:</strong> ${highlightNumber(avgFinalValueETHDisplay)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Average Base Value:</strong> ${highlightNumber(avgBaseValue.toFixed(2))}</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Date</h3>
                    <div style="${itemStyle} color: ${textColor};">${generationDateStr}</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Applied Multipliers (Average)</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Length Multiplier:</strong> ×${highlightNumber(avgLengthMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Multiplier:</strong> ×${highlightNumber(avgOntologicalMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Name + "to be" Multiplier:</strong> ×${highlightNumber(avgNameWithToBeMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Semantic Closure Multiplier:</strong> ×${highlightNumber(avgSemanticMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Repetition Multiplier:</strong> ×${highlightNumber(avgRepetitionMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Temporal Multiplier:</strong> ×${highlightNumber(avgTenseMultiplier.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Predominant Tense:</strong> ${highlightNumber(tenseLabels[predominantTense])} (Present: ${presentCount}, Past: ${pastCount}, Future: ${futureCount})</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Narrative Penalty:</strong> ×${highlightNumber(avgNarrativePenalty.toFixed(2))}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Global Reduction (60%):</strong> ×${highlightNumber('0.4335')}</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Distribution by Word Type</h3>
            `;
            
            Object.keys(posCounts).forEach(pos => {
                const count = posCounts[pos];
                const valueETH = posValuesETH[pos] || 0;
                const percentage = (count / totalWords * 100).toFixed(1);
                const valuePercentage = totalValueETH > 0 ? ((valueETH / totalValueETH) * 100).toFixed(1) : '0.0';
                const valueETHDisplay = valueETH >= 0.01 ? 
                    `${valueETH.toFixed(6)} ETH` : 
                    `${valueETH.toFixed(10)} ETH`;
                html += `<div style="${itemStyle} color: ${textColor};"><strong>${pos}:</strong> ${highlightNumber(count)} words (${highlightNumber(percentage + '%')}) - Value: ${highlightNumber(valueETHDisplay)} (${highlightNumber(valuePercentage + '%')})</div>`;
            });
            
            html += `
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Special Elements</h3>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Values:</strong> ${highlightNumber(ontologicalValues)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Names:</strong> ${highlightNumber(nameCount)}</div>
                    <div style="${itemStyle} color: ${textColor};"><strong>Ontological Assertions:</strong> ${highlightNumber(ontologicalAssertions)}</div>
                </div>
                
                <div style="${boxStyle}">
                    <h3 style="font-size: 12px; margin: 0 0 2px 0; color: ${textColor}; border-bottom: 1px solid ${borderColor}; padding-bottom: 1px;">Top 20 Words by Value</h3>
            `;
            
            topWords.forEach((w, idx) => {
                const wordValueUSD = w.finalValue || 0;
                const wordValueETH = ethPriceUSD ? wordValueUSD / ethPriceUSD : 0;
                const wordValueETHDisplay = wordValueETH >= 0.01 ? 
                    `${wordValueETH.toFixed(6)} ETH` : 
                    `${wordValueETH.toFixed(10)} ETH`;
                html += `
                    <div style="${itemStyle} color: ${textColor}; padding: 2px 0; border-top: 1px solid ${dividerColor};">
                        <strong>${idx + 1}. "${w.text}"</strong><br>
                        Value: ${highlightNumber(wordValueETHDisplay)}<br>
                        Base: ${highlightNumber((w.baseValue || 0).toFixed(2))} | 
                        Length: ×${highlightNumber((w.lengthMultiplier || 1).toFixed(2))} | 
                        Ontological: ×${highlightNumber((w.ontologicalMultiplier || 1).toFixed(2))} | 
                        Repetition: ×${highlightNumber((w.repetitionMultiplier || 1).toFixed(2))}
                    </div>
                `;
            });
            
            html += `
                </div>
            `;
            
            content.innerHTML = html;
            
            // Create overview visualization
            createValueLogicOverview();
            
            // Generate top 4 grid with nodes and fractals
            generateTop5Grid(top4Words);
            
            // Update total value box
            const totalBox = document.getElementById('value-logic-total-box');
            const totalDisplay = document.getElementById('value-logic-total-display');
            if (totalBox && totalDisplay) {
                totalDisplay.textContent = totalValueETHDisplay;
                totalBox.style.display = 'block';
                
                // Apply color mode to total box
                if (valueLogicColorMode) {
                    totalBox.style.background = '#ffffff';
                    totalBox.style.border = '1px solid #000000';
                    const totalBoxDiv = totalBox.querySelector('div');
                    if (totalBoxDiv) totalBoxDiv.style.color = '#000000';
                } else {
                    totalBox.style.background = '#000000';
                    totalBox.style.border = '1px solid #ffffff';
                    const totalBoxDiv = totalBox.querySelector('div');
                    if (totalBoxDiv) totalBoxDiv.style.color = '#ffffff';
                }
            }
            
            modal.style.display = 'block';
            modal.style.visibility = 'visible';
            modal.style.opacity = '1';
            modal.style.pointerEvents = 'auto';
        }
        
        function toggleValueLogicColorMode() {
            valueLogicColorMode = !valueLogicColorMode;
            
            // Update color indicator
            const indicator = document.getElementById('value-logic-color-indicator');
            if (indicator) {
                indicator.style.background = valueLogicColorMode ? '#ffffff' : '#000000';
            }
            
            // Re-generate the content with new colors
            if (analyzedWords && analyzedWords.length > 0) {
                showValueLogicSummary();
            }
        }
        
        function saveValueLogicSummaryAsImage() {
            const modal = document.getElementById('value-logic-modal');
            if (!modal || modal.style.display === 'none') return;
            
            // Get the modal content container (the inner div, not the overlay)
            const modalContainer = document.getElementById('value-logic-modal-container');
            if (!modalContainer) return;
            
            // Check if html2canvas is available
            if (typeof html2canvas === 'undefined') {
                alert('Error: html2canvas library not loaded. Please check your internet connection.');
                return;
            }
            
            // Capture the 3D canvas overview if it exists and is visible
            const overviewCanvas = document.getElementById('value-logic-overview-canvas');
            const overviewContainer = document.getElementById('value-logic-overview-container');
            let canvasImageData = null;
            let tempImg = null;
            let originalCanvasStyle = null;
            
            if (overviewCanvas && overviewContainer && overviewContainer.style.display !== 'none') {
                try {
                    // Render one more frame to ensure canvas is up to date
                    if (valueLogicOverviewRenderer && valueLogicOverviewScene && valueLogicOverviewCamera) {
                        valueLogicOverviewRenderer.render(valueLogicOverviewScene, valueLogicOverviewCamera);
                    }
                    
                    // Convert canvas to data URL
                    canvasImageData = overviewCanvas.toDataURL('image/png');
                    
                    // Create a temporary image element to replace the canvas
                    tempImg = document.createElement('img');
                    tempImg.src = canvasImageData;
                    tempImg.style.width = '100%';
                    tempImg.style.height = '100%';
                    tempImg.style.display = 'block';
                    
                    // Hide the canvas temporarily
                    originalCanvasStyle = overviewCanvas.style.cssText;
                    overviewCanvas.style.display = 'none';
                    
                    // Insert the image in the container
                    overviewContainer.appendChild(tempImg);
                } catch (e) {
                    console.warn('Could not capture 3D canvas:', e);
                    canvasImageData = null;
                }
            }
            
            // Capture top 4 fractal canvases
            const top5CanvasImages = [];
            for (let i = 0; i < 4; i++) {
                const fractalCanvas = document.getElementById(`top5-grid-fractal-${i}`);
                
                if (fractalCanvas) {
                    try {
                        const fractalDataURL = fractalCanvas.toDataURL('image/png');
                        const fractalImg = document.createElement('img');
                        fractalImg.src = fractalDataURL;
                        fractalImg.style.width = fractalCanvas.style.width || '60px';
                        fractalImg.style.height = fractalCanvas.style.height || '45px';
                        fractalImg.style.display = 'block';
                        top5CanvasImages.push({ canvas: fractalCanvas, img: fractalImg });
                    } catch (e) {
                        console.warn(`Could not capture top5 fractal canvas ${i}:`, e);
                    }
                }
            }
            
            // Replace canvas elements with images temporarily
            top5CanvasImages.forEach(({ canvas, img }) => {
                if (canvas && canvas.parentNode) {
                    const originalStyle = canvas.style.cssText;
                    canvas.style.display = 'none';
                    canvas.parentNode.insertBefore(img, canvas);
                    img.style.cssText = originalStyle;
                }
            });
            
            // Force a small delay to ensure rendering is complete
            setTimeout(() => {
                // Use html2canvas to capture the modal content - let it capture naturally
                // html2canvas will automatically capture the full element including all content
                html2canvas(modalContainer, {
                    backgroundColor: '#dcdcdcc2', // Match the modal background color (rgba(220, 220, 220, 0.76))
                    scale: 2, // Higher quality
                    logging: false,
                    useCORS: true,
                    allowTaint: true, // Allow taint to include canvas images
                    removeContainer: false,
                    imageTimeout: 0,
                    onclone: function(clonedDoc) {
                        // Ensure the cloned element maintains its dimensions
                        const clonedContainer = clonedDoc.getElementById('value-logic-modal-container');
                        if (clonedContainer) {
                            clonedContainer.style.position = 'absolute';
                            clonedContainer.style.left = '0';
                            clonedContainer.style.top = '0';
                        }
                    }
                }).then(canvas => {
                    // Restore original canvas if we replaced it
                    if (tempImg && overviewCanvas && overviewContainer) {
                        try {
                            overviewContainer.removeChild(tempImg);
                            overviewCanvas.style.cssText = originalCanvasStyle || '';
                        } catch (e) {
                            console.warn('Error restoring canvas:', e);
                        }
                    }
                    
                    // Restore top 5 canvases
                    top5CanvasImages.forEach(({ canvas, img }) => {
                        if (canvas && img && img.parentNode) {
                            try {
                                img.parentNode.removeChild(img);
                                canvas.style.display = 'block';
                            } catch (e) {
                                console.warn('Error restoring top5 canvas:', e);
                            }
                        }
                    });
                    
                    // Ensure canvas dimensions are correct - scale is already applied by html2canvas
                    // The canvas width/height should be actualWidth * scale and actualHeight * scale
                    // But html2canvas handles this automatically, so we just need to ensure proper aspect ratio
                    
                    // Convert canvas to blob
                    canvas.toBlob(function(blob) {
                        if (!blob) {
                            alert('Error generating image. Please try again.');
                            return;
                        }
                        
                        // Create download link
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `total-value-summary-${getTimestamp()}.jpg`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        // Clean up URL
                        setTimeout(() => URL.revokeObjectURL(url), 100);
                    }, 'image/jpeg', 1.0); // Maximum quality JPEG
                }).catch(error => {
                    console.error('Error capturing image:', error);
                    
                    // Restore original canvas on error
                    if (tempImg && overviewCanvas && overviewContainer) {
                        try {
                            overviewContainer.removeChild(tempImg);
                            overviewCanvas.style.cssText = originalCanvasStyle || '';
                        } catch (e) {
                            console.warn('Error restoring canvas:', e);
                        }
                    }
                    
                    // Restore top 5 canvases on error
                    canvasReplacements.forEach(({ canvas, img, parent }) => {
                        if (canvas && img && parent && img.parentNode === parent) {
                            try {
                                // Replace image back with canvas
                                parent.replaceChild(canvas, img);
                            } catch (e) {
                                console.warn('Error restoring top5 canvas:', e);
                            }
                        }
                    });
                    
                    alert('Error capturing the window. Please try again.');
                });
            }, 100); // Small delay to ensure rendering is complete
        }
        
        // ==================== FRACTAL GENERATION ====================
        function setupFractalClickListeners() {
            // Right panel canvas click - setup on initialization
            setTimeout(() => {
                if (rightPanelCanvas) {
                    rightPanelCanvas.style.cursor = 'pointer';
                    rightPanelCanvas.addEventListener('click', function(e) {
                        if (selectedNode && selectedNode.userData && selectedNode.userData.wordData) {
                            const wordIndex = selectedNode.userData.index;
                            showFractalModal(wordIndex, e.clientX, e.clientY);
                        }
                    });
                }
                
                // Max value panel canvas click
                if (maxValuePanelCanvas) {
                    maxValuePanelCanvas.style.cursor = 'pointer';
                    maxValuePanelCanvas.addEventListener('click', function(e) {
                        if (maxValueNode && maxValueNode.userData && maxValueNode.userData.wordData) {
                            const wordIndex = maxValueNode.userData.index;
                            showFractalModal(wordIndex, e.clientX, e.clientY);
                        }
                    });
                }
                
                // Node info panel canvas click
                if (nodeInfoCanvas) {
                    nodeInfoCanvas.style.cursor = 'pointer';
                    nodeInfoCanvas.addEventListener('click', function(e) {
                        if (hoveredNode && hoveredNode.userData && hoveredNode.userData.wordData) {
                            const wordIndex = hoveredNode.userData.index;
                            showFractalModal(wordIndex, e.clientX, e.clientY);
                        }
                    });
                }
            }, 100);
        }
        
        function addNodeListCanvasClickListener(canvas, nodeIndex) {
            if (canvas && !canvas.dataset.fractalListenerAdded) {
                canvas.style.cursor = 'pointer';
                canvas.dataset.fractalListenerAdded = 'true';
                canvas.addEventListener('click', function(e) {
                    if (analyzedWords && nodeIndex >= 0 && nodeIndex < analyzedWords.length) {
                        showFractalModal(nodeIndex, e.clientX, e.clientY);
                    }
                });
            }
        }
        
        function showFractalModal(wordIndex, mouseX, mouseY) {
            if (fractalGenerationInProgress || !analyzedWords || wordIndex < 0 || wordIndex >= analyzedWords.length) {
                return;
            }
            
            const wordData = analyzedWords[wordIndex];
            currentFractalWordIndex = wordIndex;
            
            // Update modal title
            document.getElementById('fractal-word-name').textContent = wordData.text;
            
            // Show modal
            const fractalModal = document.getElementById('fractal-modal');
            fractalModal.style.display = 'block';
            fractalModal.style.visibility = 'visible';
            fractalModal.style.opacity = '1';
            fractalModal.style.pointerEvents = 'auto';
            
            // Position container at mouse position if provided, otherwise use default position
            const fractalModalContainer = document.getElementById('fractal-modal-container');
            if (fractalModalContainer) {
                if (mouseX !== undefined && mouseY !== undefined) {
                    // Position at mouse coordinates
                    fractalModalContainer.style.top = mouseY + 'px';
                    fractalModalContainer.style.left = mouseX + 'px';
                    fractalModalContainer.style.right = 'auto';
                    fractalModalContainer.style.bottom = 'auto';
                    fractalModalContainer.style.transform = 'none';
                    
                    // Ensure modal doesn't go off screen
                    const modalWidth = 300; // max-width of modal
                    const modalHeight = 250; // approximate height
                    if (mouseX + modalWidth > window.innerWidth) {
                        fractalModalContainer.style.left = (window.innerWidth - modalWidth - 10) + 'px';
                    }
                    if (mouseY + modalHeight > window.innerHeight) {
                        fractalModalContainer.style.top = (window.innerHeight - modalHeight - 10) + 'px';
                    }
                } else {
                    // Default position: just below fps bar, fully to the right
                    fractalModalContainer.style.top = '25px';
                    fractalModalContainer.style.right = '0px';
                    fractalModalContainer.style.left = 'auto';
                    fractalModalContainer.style.bottom = 'auto';
                    fractalModalContainer.style.transform = 'none';
                }
            }
            
            // Generate fractal
            generateWordFractal(wordIndex);
        }
        
        function generateWordFractal(wordIndex) {
            if (!fractalCtx || !analyzedWords || wordIndex < 0 || wordIndex >= analyzedWords.length) {
                return;
            }
            
            fractalGenerationInProgress = true;
            
            const wordData = analyzedWords[wordIndex];
            const params = calculateFractalParameters(wordIndex);
            
            // Clear canvas
            fractalCtx.fillStyle = '#000000';
            fractalCtx.fillRect(0, 0, fractalCanvas.width, fractalCanvas.height);
            
            // Generate fractal based on family type
            setTimeout(() => {
                try {
                    renderFractal(params);
                    fractalGenerationInProgress = false;
                } catch (e) {
                    console.error('Error generating fractal:', e);
                    fractalGenerationInProgress = false;
                }
            }, 10); // Small delay to prevent blocking
        }
        
        function calculateFractalParameters(wordIndex) {
            if (!analyzedWords || wordIndex < 0 || wordIndex >= analyzedWords.length) {
                return getDefaultFractalParams();
            }
            
            const wordData = analyzedWords[wordIndex];
            const leftWord = wordIndex > 0 ? analyzedWords[wordIndex - 1] : null;
            const rightWord = wordIndex < analyzedWords.length - 1 ? analyzedWords[wordIndex + 1] : null;
            
            // Detect ontological cluster (I/we + am/is/are pattern)
            const isFirstPerson = wordData.pos === 'pronoun' && 
                (wordData.text.toLowerCase() === 'i' || wordData.text.toLowerCase() === 'we');
            const isToBe = wordData.isSerEstar;
            const isAfterToBe = leftWord && leftWord.isSerEstar && 
                (leftWord.text.toLowerCase() === 'am' || leftWord.text.toLowerCase() === 'is' || 
                 leftWord.text.toLowerCase() === 'are' || leftWord.text.toLowerCase() === 'was' || 
                 leftWord.text.toLowerCase() === 'were');
            
            // Determine fractal family based on POS and context
            let family = 'Mandelbrot';
            if (wordData.pos === 'pronoun') {
                family = 'OrbitTrap';
            } else if (isToBe) {
                family = 'Multibrot';
            } else if (wordData.pos === 'verb' && !isToBe) {
                family = 'Newton';
            } else if (wordData.pos === 'noun') {
                // Check if abstract (hard to determine, use as concrete for now)
                family = 'Mandelbrot';
            } else if (wordData.pos === 'adjective') {
                family = 'Julia';
            } else if (wordData.pos === 'conjunction' || wordData.text.toLowerCase().match(/^(if|because|although|though|while)$/)) {
                family = 'LSystem';
            } else if (wordData.pos === 'preposition' || wordData.pos === 'determiner') {
                family = 'IFS';
            } else if (wordData.text.toLowerCase().match(/^(must|can|should|may|might|could|would)$/)) {
                family = 'DomainColoring';
            }
            
            // Calculate depth based on value (calculate first, before using in seed)
            const wordValue = wordData.finalValue || wordData.totalScore || 0;
            
            // Calculate seed from context - more variation (now wordValue is available)
            const seedStr = `${wordData.text}|${leftWord ? leftWord.text : ''}|${rightWord ? rightWord.text : ''}|${wordIndex}|${wordData.pos}|${wordValue}`;
            const seed = simpleHash(seedStr);
            
            // Additional seed-based variations for uniqueness
            const seedNorm1 = (seed % 997) / 997;
            const seedNorm2 = ((seed * 7919) % 997) / 997; // Different prime for variation
            const seedNorm3 = ((seed * 3571) % 997) / 997;
            let depth = 200; // Default
            if (wordValue < 0.1) depth = 80;
            else if (wordValue < 2) depth = 80 + (wordValue - 0.1) * (120 / 1.9);
            else if (wordValue < 5) depth = 200 + (wordValue - 2) * (400 / 3);
            else if (wordValue < 10) depth = 600 + (wordValue - 5) * (1400 / 5);
            else depth = 2000;
            depth = Math.round(Math.min(2000, Math.max(80, depth)));
            
            // Calculate zoom - reduced to show more colored area
            let zoom = 0.3 + seedNorm1 * 0.4; // Base zoom varies by seed (0.3-0.7)
            if (isFirstPerson || isToBe || isAfterToBe) {
                zoom = 0.4 + seedNorm1 * 0.3; // Lower zoom = more area visible for ontological clusters
                if (isToBe) zoom *= 0.8; // Even lower for "to be"
            } else {
                zoom = 0.2 + seedNorm1 * 0.3 + (wordValue * 0.05); // Varied by seed and value
            }
            zoom = Math.min(1.0, Math.max(0.15, zoom)); // Range: 0.15-1.0 for more visible area
            
            // Calculate symmetry (high for semantic closure, low for dependencies)
            let symmetry = 0.5;
            if (wordData.semanticMultiplier && wordData.semanticMultiplier > 1.2) {
                symmetry = 0.7 + (wordData.semanticMultiplier - 1.2) * 0.3;
            }
            if (isToBe) symmetry = 0.9; // Very high symmetry for "to be"
            symmetry = Math.min(1.0, Math.max(0.1, symmetry));
            
            // Calculate perturbation (high for negation/conditionals)
            let perturbation = 0.1;
            const wordLower = wordData.text.toLowerCase();
            if (wordLower === 'not' || wordLower === 'no') {
                perturbation = 0.8;
            } else if (wordLower.match(/^(if|unless|unless|when|while)$/)) {
                perturbation = 0.6;
            }
            
            // Determine palette based on tense
            let palette = 'high_contrast'; // Default (present)
            // This would require tense detection, using default for now
            
            return {
                family: family,
                seed: seed,
                seedNorm1: seedNorm1,
                seedNorm2: seedNorm2,
                seedNorm3: seedNorm3,
                depth: depth,
                zoom: zoom,
                symmetry: symmetry,
                perturbation: perturbation,
                palette: palette,
                wordValue: wordValue,
                wordText: wordData.text.toLowerCase(),
                pos: wordData.pos
            };
        }
        
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return Math.abs(hash);
        }
        
        function getDefaultFractalParams() {
            return {
                family: 'Mandelbrot',
                seed: 12345,
                depth: 200,
                zoom: 1.0,
                symmetry: 0.5,
                perturbation: 0.1,
                palette: 'high_contrast',
                wordValue: 0
            };
        }
        
        function renderFractal(params) {
            const width = fractalCanvas.width;
            const height = fractalCanvas.height;
            const imageData = fractalCtx.createImageData(width, height);
            const data = imageData.data;
            
            // Use lower resolution for performance, then scale up
            const scale = 0.5; // Render at half resolution for speed
            const renderWidth = Math.floor(width * scale);
            const renderHeight = Math.floor(height * scale);
            
            // Use seed-based offset to vary each fractal's view
            const offsetX = ((params.seedNorm1 || 0.5) - 0.5) * 2.0; // -1 to 1
            const offsetY = ((params.seedNorm2 || 0.5) - 0.5) * 2.0; // -1 to 1
            const centerX = width / 2;
            const centerY = height / 2;
            const scaleFactor = params.zoom * 150; // Reduced for more area
            
            // Generate fractal based on family
            for (let y = 0; y < renderHeight; y++) {
                for (let x = 0; x < renderWidth; x++) {
                    const px = (x - renderWidth / 2) / scaleFactor + offsetX;
                    const py = (y - renderHeight / 2) / scaleFactor + offsetY;
                    
                    let color = [0, 0, 0, 255]; // Default black
                    
                    switch (params.family) {
                        case 'Mandelbrot':
                            color = mandelbrotColor(px, py, params);
                            break;
                        case 'Multibrot':
                            color = multibrotColor(px, py, params);
                            break;
                        case 'Julia':
                            color = juliaColor(px, py, params);
                            break;
                        case 'Newton':
                            color = newtonColor(px, py, params);
                            break;
                        case 'OrbitTrap':
                            color = orbitTrapColor(px, py, params);
                            break;
                        default:
                            color = mandelbrotColor(px, py, params);
                    }
                    
                    // Write to image data (scaled up)
                    for (let sy = 0; sy < 1 / scale; sy++) {
                        for (let sx = 0; sx < 1 / scale; sx++) {
                            const idx = ((Math.floor(y / scale) + sy) * width + Math.floor(x / scale) + sx) * 4;
                            if (idx >= 0 && idx < data.length - 3) {
                                data[idx] = color[0];
                                data[idx + 1] = color[1];
                                data[idx + 2] = color[2];
                                data[idx + 3] = color[3];
                            }
                        }
                    }
                }
            }
            
            fractalCtx.putImageData(imageData, 0, 0);
        }
        
        function mandelbrotColor(x, y, params) {
            // Vary starting point based on seed for uniqueness
            const seedOffsetX = (params.seedNorm1 - 0.5) * 0.5;
            const seedOffsetY = (params.seedNorm2 - 0.5) * 0.5;
            let zx = seedOffsetX, zy = seedOffsetY;
            const cx = x + seedOffsetX * 0.3;
            const cy = y + seedOffsetY * 0.3;
            let iterations = 0;
            const maxIter = Math.floor(params.depth * 0.15); // Increased iterations for more detail
            const escapeRadius = 2.5 + params.seedNorm1 * 0.5; // Vary escape radius
            
            while (zx * zx + zy * zy < escapeRadius * escapeRadius && iterations < maxIter) {
                const tmp = zx * zx - zy * zy + cx;
                zy = 2 * zx * zy + cy;
                zx = tmp;
                iterations++;
            }
            
            return iterationsToColor(iterations, maxIter, params);
        }
        
        function multibrotColor(x, y, params) {
            // Vary power based on seed for different shapes
            const power = 2.5 + params.seedNorm1 * 1.5; // 2.5 to 4.0
            let zx = 0, zy = 0;
            const seedOffsetX = (params.seedNorm2 - 0.5) * 0.3;
            const seedOffsetY = (params.seedNorm3 - 0.5) * 0.3;
            const cx = x + seedOffsetX;
            const cy = y + seedOffsetY;
            let iterations = 0;
            const maxIter = Math.floor(params.depth * 0.2); // More iterations for "to be"
            const escapeRadius = 2.0 + params.seedNorm1 * 1.0;
            
            while (zx * zx + zy * zy < escapeRadius * escapeRadius && iterations < maxIter) {
                const r = Math.sqrt(zx * zx + zy * zy);
                const theta = Math.atan2(zy, zx);
                const newR = Math.pow(r, power);
                const newTheta = theta * power;
                zx = newR * Math.cos(newTheta) + cx;
                zy = newR * Math.sin(newTheta) + cy;
                iterations++;
            }
            
            return iterationsToColor(iterations, maxIter, params);
        }
        
        function juliaColor(x, y, params) {
            // Much more variation in Julia set parameters
            const cx = -0.8 + params.seedNorm1 * 1.6; // -0.8 to 0.8
            const cy = -0.8 + params.seedNorm2 * 1.6; // -0.8 to 0.8
            let zx = x + (params.seedNorm3 - 0.5) * 0.5;
            let zy = y + (params.seedNorm1 - 0.5) * 0.5;
            let iterations = 0;
            const maxIter = Math.floor(params.depth * 0.15);
            const escapeRadius = 2.0 + params.seedNorm2 * 1.0;
            
            while (zx * zx + zy * zy < escapeRadius * escapeRadius && iterations < maxIter) {
                const tmp = zx * zx - zy * zy + cx;
                zy = 2 * zx * zy + cy;
                zx = tmp;
                iterations++;
            }
            
            return iterationsToColor(iterations, maxIter, params);
        }
        
        function newtonColor(x, y, params) {
            // Varied Newton fractal with seed-based parameters
            const polynomialOrder = 3 + Math.floor(params.seedNorm1 * 3); // 3 to 6
            let zx = x + (params.seedNorm2 - 0.5) * 0.5;
            let zy = y + (params.seedNorm3 - 0.5) * 0.5;
            let iterations = 0;
            const maxIter = Math.floor(params.depth * 0.08);
            const tolerance = 0.001 + params.seedNorm1 * 0.01;
            
            for (let i = 0; i < maxIter; i++) {
                const zx2 = zx * zx;
                const zy2 = zy * zy;
                const r2 = zx2 + zy2;
                const r2n = Math.pow(r2, polynomialOrder / 2);
                const denom = polynomialOrder * r2n;
                if (Math.abs(denom) < tolerance) break;
                
                // Simplified Newton iteration
                const angle = Math.atan2(zy, zx);
                const r = Math.sqrt(r2);
                const newAngle = angle * (polynomialOrder - 1) / polynomialOrder;
                const newR = Math.pow(r, (polynomialOrder - 1) / polynomialOrder);
                zx = newR * Math.cos(newAngle) - x / polynomialOrder;
                zy = newR * Math.sin(newAngle) - y / polynomialOrder;
                iterations++;
                if (zx * zx + zy * zy < tolerance) break;
            }
            
            return iterationsToColor(iterations, maxIter, params);
        }
        
        function orbitTrapColor(x, y, params) {
            // Varied orbit trap based on seed
            const trapType = Math.floor(params.seedNorm1 * 3); // 0, 1, or 2
            let zx = x + (params.seedNorm2 - 0.5) * 0.3;
            let zy = y + (params.seedNorm3 - 0.5) * 0.3;
            let iterations = 0;
            const maxIter = Math.floor(params.depth * 0.12);
            let minDist = Infinity;
            const cx = -0.4 + params.seedNorm1 * 0.8;
            const cy = -0.4 + params.seedNorm2 * 0.8;
            
            while (zx * zx + zy * zy < 4 && iterations < maxIter) {
                let dist;
                if (trapType === 0) {
                    dist = Math.abs(zx) + Math.abs(zy); // Manhattan
                } else if (trapType === 1) {
                    dist = Math.sqrt(zx * zx + zy * zy); // Euclidean
                } else {
                    dist = Math.max(Math.abs(zx), Math.abs(zy)); // Chebyshev
                }
                minDist = Math.min(minDist, dist);
                const tmp = zx * zx - zy * zy + cx;
                zy = 2 * zx * zy + cy;
                zx = tmp;
                iterations++;
            }
            
            // More colorful based on iterations and distance
            const distFactor = Math.min(1, minDist / 2);
            const iterFactor = iterations / maxIter;
            const r = Math.floor(255 * distFactor * iterFactor);
            const g = Math.floor(200 * distFactor * (1 - iterFactor * 0.5));
            const b = Math.floor(150 * (1 - distFactor) * iterFactor);
            return [r, g, b, 255];
        }
        
        function iterationsToColor(iterations, maxIter, params) {
            // Don't make inside completely black - add some color based on proximity
            const normalized = iterations / maxIter;
            let r, g, b;
            
            if (iterations >= maxIter) {
                // Inside set - use dark color but not pure black, varies by seed
                const darkFactor = 0.1 + params.seedNorm1 * 0.2;
                r = Math.floor(30 * darkFactor);
                g = Math.floor(20 * darkFactor);
                b = Math.floor(40 * darkFactor);
                return [r, g, b, 255];
            }
            
            // Much more variation in color schemes based on word and seed
            const colorScheme = Math.floor((params.seed + params.wordText.charCodeAt(0)) % 5);
            
            if (colorScheme === 0) {
                // High contrast blue-purple
                r = Math.floor(50 + 205 * normalized);
                g = Math.floor(30 + 100 * normalized);
                b = Math.floor(100 + 155 * (1 - normalized * 0.5));
            } else if (colorScheme === 1) {
                // Warm red-orange
                r = Math.floor(80 + 175 * normalized);
                g = Math.floor(40 + 100 * normalized * normalized);
                b = Math.floor(20 + 50 * normalized);
            } else if (colorScheme === 2) {
                // Cool green-cyan
                r = Math.floor(20 + 60 * normalized);
                g = Math.floor(100 + 155 * normalized);
                b = Math.floor(120 + 135 * normalized);
            } else if (colorScheme === 3) {
                // Vibrant rainbow
                const hue = (normalized * 360 + (params.seed % 360)) % 360;
                r = Math.floor(128 + 127 * Math.sin((hue / 360) * Math.PI * 2));
                g = Math.floor(128 + 127 * Math.sin((hue / 360) * Math.PI * 2 + 2.09));
                b = Math.floor(128 + 127 * Math.sin((hue / 360) * Math.PI * 2 + 4.19));
            } else {
                // Cool purple-pink
                r = Math.floor(100 + 155 * normalized);
                g = Math.floor(50 + 80 * normalized);
                b = Math.floor(150 + 105 * normalized);
            }
            
            // Apply seed-based variation
            r = Math.floor(r * (0.85 + params.seedNorm1 * 0.3));
            g = Math.floor(g * (0.85 + params.seedNorm2 * 0.3));
            b = Math.floor(b * (0.85 + params.seedNorm3 * 0.3));
            
            // Apply symmetry effect (brighter)
            if (params.symmetry > 0.7) {
                const symFactor = (params.symmetry - 0.7) / 0.3;
                r = Math.min(255, Math.floor(r * (1 + symFactor * 0.5)));
                g = Math.min(255, Math.floor(g * (1 + symFactor * 0.5)));
                b = Math.min(255, Math.floor(b * (1 + symFactor * 0.5)));
            }
            
            // Ensure minimum brightness to avoid pure black
            r = Math.max(20, r);
            g = Math.max(15, g);
            b = Math.max(25, b);
            
            return [Math.min(255, r), Math.min(255, g), Math.min(255, b), 255];
        }
        
        function hideValueLogicSummary() {
            document.getElementById('value-logic-modal').style.display = 'none';
            
            // Clean up overview scene
            if (valueLogicOverviewAnimationId) {
                cancelAnimationFrame(valueLogicOverviewAnimationId);
                valueLogicOverviewAnimationId = null;
            }
            if (valueLogicOverviewNodes.length > 0) {
                valueLogicOverviewNodes.forEach(node => {
                    if (valueLogicOverviewScene) {
                        valueLogicOverviewScene.remove(node);
                    }
                    if (node.geometry) node.geometry.dispose();
                    if (node.material) node.material.dispose();
                    if (node.children) {
                        node.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    }
                });
                valueLogicOverviewNodes = [];
            }
            if (valueLogicOverviewRenderer) {
                valueLogicOverviewRenderer.dispose();
                valueLogicOverviewRenderer = null;
            }
            valueLogicOverviewScene = null;
            valueLogicOverviewCamera = null;
        }
        
        function createValueLogicOverview() {
            if (!nodes || nodes.length === 0) return;
            
            const container = document.getElementById('value-logic-overview-container');
            const canvas = document.getElementById('value-logic-overview-canvas');
            if (!container || !canvas) return;
            
            container.style.display = 'block';
            
            // Clean up previous scene if exists
            if (valueLogicOverviewAnimationId) {
                cancelAnimationFrame(valueLogicOverviewAnimationId);
                valueLogicOverviewAnimationId = null;
            }
            if (valueLogicOverviewNodes.length > 0) {
                valueLogicOverviewNodes.forEach(node => {
                    if (valueLogicOverviewScene) {
                        valueLogicOverviewScene.remove(node);
                    }
                    if (node.geometry) node.geometry.dispose();
                    if (node.material) node.material.dispose();
                    if (node.children) {
                        node.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    }
                });
                valueLogicOverviewNodes = [];
            }
            if (valueLogicOverviewRenderer) {
                valueLogicOverviewRenderer.dispose();
            }
            
            // Create scene
            valueLogicOverviewScene = new THREE.Scene();
            valueLogicOverviewScene.background = new THREE.Color(0x000000);
            
            // Get actual container dimensions
            const containerRect = container.getBoundingClientRect();
            const containerWidth = Math.floor(containerRect.width) || 376; // Account for padding
            const containerHeight = 150;
            valueLogicOverviewCamera = new THREE.PerspectiveCamera(50, containerWidth / containerHeight, 0.1, 1000);
            
            // Calculate bounding box of all nodes
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            nodes.forEach(node => {
                const pos = node.position;
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y);
                minZ = Math.min(minZ, pos.z);
                maxZ = Math.max(maxZ, pos.z);
            });
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxSize = Math.max(sizeX, sizeY, sizeZ, 1);
            
            // Position camera far away to see all nodes (static, no rotation)
            const distance = maxSize * 2.5;
            valueLogicOverviewCamera.position.set(centerX, centerY, centerZ + distance);
            valueLogicOverviewCamera.lookAt(centerX, centerY, centerZ);
            
            // Add lights (simple lighting for performance)
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            valueLogicOverviewScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(2, 2, 2);
            valueLogicOverviewScene.add(directionalLight);
            
            // Clone all nodes at smaller scale for overview (reduced quality)
            const scaleFactor = 0.25; // Smaller scale for better performance
            nodes.forEach(node => {
                let clonedNode;
                
                if (node.isGroup) {
                    // Clone group (nouns with flat base, "to be" verbs with flat rectangular base)
                    clonedNode = node.clone(true);
                    clonedNode.scale.set(scaleFactor, scaleFactor, scaleFactor);
                } else {
                    // Clone regular node
                    clonedNode = node.clone();
                    clonedNode.scale.set(scaleFactor, scaleFactor, scaleFactor);
                }
                
                valueLogicOverviewScene.add(clonedNode);
                valueLogicOverviewNodes.push(clonedNode);
            });
            
            // Clone connections (simplified)
            connections.forEach(conn => {
                const clonedConn = conn.clone();
                valueLogicOverviewScene.add(clonedConn);
            });
            
            // Create renderer with reduced quality for performance
            valueLogicOverviewRenderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: false,
                powerPreference: "low-power"
            });
            valueLogicOverviewRenderer.setSize(containerWidth, containerHeight);
            valueLogicOverviewRenderer.setPixelRatio(0.5); // Very low pixel ratio for performance
            
            // Static render (no animation)
            valueLogicOverviewRenderer.render(valueLogicOverviewScene, valueLogicOverviewCamera);
        }
        
        function hideRightPanel(panelId) {
            const panelIndex = rightPanels.findIndex(p => p.id === panelId);
            if (panelIndex === -1) {
                console.warn('Panel not found for removal:', panelId);
                return;
            }
            
            const panelData = rightPanels[panelIndex];
            
            // Stop animation
            if (panelData.animationId) {
                cancelAnimationFrame(panelData.animationId);
                panelData.animationId = null;
            }
            
            // Clean up 3D mesh
            if (panelData.mesh && panelData.scene) {
                try {
                    panelData.scene.remove(panelData.mesh);
                    if (panelData.mesh.geometry) panelData.mesh.geometry.dispose();
                    if (panelData.mesh.material) {
                        if (Array.isArray(panelData.mesh.material)) {
                            panelData.mesh.material.forEach(mat => mat.dispose());
                        } else {
                            panelData.mesh.material.dispose();
                        }
                    }
                    if (panelData.mesh.children && panelData.mesh.children.length > 0) {
                        panelData.mesh.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => mat.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                    }
                } catch (e) {
                    console.error('Error cleaning up mesh:', e);
                }
                panelData.mesh = null;
            }
            
            // Clean up renderer
            if (panelData.renderer) {
                try {
                    panelData.renderer.dispose();
                } catch (e) {
                    console.error('Error disposing renderer:', e);
                }
            }
            
            // Remove from DOM
            if (panelData.element && panelData.element.parentNode) {
                try {
                    panelData.element.remove();
                } catch (e) {
                    console.error('Error removing element:', e);
                }
            }
            
            // Add offset to available stack for reuse
            if (panelData.offset !== undefined) {
                availableOffsets.push(panelData.offset);
            }
            
            // Remove from array
            rightPanels.splice(panelIndex, 1);
            
            // Clear selectedNode if this was the last panel
            if (rightPanels.length === 0) {
                selectedNode = null;
            }
        }
        
        function hideNodeDetails() {
            // Hide all panels (for backward compatibility)
            rightPanels.forEach(panel => {
                hideRightPanel(panel.id);
            });
            hoveredNode = null;
            selectedNode = null;
        }

        // ==================== MAX VALUE PANEL ====================
        function findMaxValueNode() {
            if (nodes.length === 0) return null;
            
            let maxNode = null;
            let maxScore = -1;
            
            nodes.forEach(node => {
                if (node.userData.wordData) {
                    const score = node.userData.wordData.totalScore || 0;
                    if (score > maxScore) {
                        maxScore = score;
                        maxNode = node;
                    }
                }
            });
            
            return maxNode;
        }

        function updateMaxValuePanel() {
            if (!maxValuePanelScene || !maxValuePanelRenderer) return;
            
            // Find the node with maximum value
            maxValueNode = findMaxValueNode();
            
            if (!maxValueNode) {
                // Clear panel if no nodes
                if (maxValuePanelMesh) {
                    maxValuePanelScene.remove(maxValuePanelMesh);
                    if (maxValuePanelMesh.geometry) maxValuePanelMesh.geometry.dispose();
                    if (maxValuePanelMesh.material) maxValuePanelMesh.material.dispose();
                    if (maxValuePanelMesh.children) {
                        maxValuePanelMesh.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    }
                    maxValuePanelMesh = null;
                }
                document.getElementById('max-value-panel-word').textContent = '-';
                document.getElementById('max-value-word').textContent = '-';
                document.getElementById('max-value-individual-value').textContent = '-';
                document.getElementById('max-value-position').textContent = '-';
                document.getElementById('max-value-relative-value').textContent = '-';
                document.getElementById('max-value-pos').textContent = '-';
                document.getElementById('max-value-connections').textContent = '-';
                document.getElementById('max-value-size').textContent = '-';
                document.getElementById('max-value-performance').textContent = '-';
                document.getElementById('max-value-is-name').textContent = '-';
                document.getElementById('max-value-is-ser-estar').textContent = '-';
                return;
            }
            
            // Update info - same as showNodeDetails
            const wordData = maxValueNode.userData.wordData;
            const index = maxValueNode.userData.index;
            const totalValue = window.totalTextScore || analyzedWords.reduce((sum, w) => sum + (w.finalValue || w.totalScore || 0), 0);
            const individualValue = wordData.finalValue || wordData.totalScore || 0;
            const relativeValue = totalValue > 0 ? ((individualValue / totalValue) * 100).toFixed(2) + '%' : '0%';
            
            // Calculate node size in KB (approximate) - same as showNodeDetails
            let nodeSizeKB = 0;
            if (maxValueNode.userData.isNoun) {
                // Sphere + flat square
                nodeSizeKB = (8 * 8 * 8 * 4 * 3) + (1 * 1 * 1 * 4 * 3);
            } else if (maxValueNode.userData.connectionCount > 0) {
                // Cube
                nodeSizeKB = (8 * 4 * 3);
            } else {
                // Sphere
                nodeSizeKB = (8 * 8 * 8 * 4 * 3);
            }
            nodeSizeKB = (nodeSizeKB / 1024).toFixed(4);
            
            // Calculate performance impact
            const performanceImpact = maxValueNode.userData.connectionCount > 0 ? 
                'Medium (' + maxValueNode.userData.connectionCount + ' connections)' : 
                'Low';
            
            // Convert individual value to ETH for display - same format as showNodeDetails
            let individualValueETH = 0;
            if (ethPriceUSD) {
                individualValueETH = individualValue / ethPriceUSD;
            }
            const individualValueETHDisplay = individualValueETH >= 0.01 ? 
                `${individualValueETH.toFixed(6)} ETH` : 
                `${individualValueETH.toFixed(10)} ETH`;
            
            // Convert total value to ETH
            let totalValueETH = 0;
            if (ethPriceUSD) {
                totalValueETH = totalValue / ethPriceUSD;
            }
            const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                `${totalValueETH.toFixed(6)} ETH` : 
                `${totalValueETH.toFixed(10)} ETH`;
            
            // Update header with word
            document.getElementById('max-value-panel-word').textContent = wordData.text;
            
            // Update all fields
            document.getElementById('max-value-word').textContent = wordData.text;
            document.getElementById('max-value-individual-value').textContent = '$' + individualValue.toFixed(2) + ' USD (' + individualValueETHDisplay + ')';
            document.getElementById('max-value-position').textContent = (index + 1) + ' / ' + analyzedWords.length;
            document.getElementById('max-value-relative-value').textContent = relativeValue + ' ($' + totalValue.toFixed(2) + ' total / ' + totalValueETHDisplay + ')';
            document.getElementById('max-value-pos').textContent = wordData.pos;
            document.getElementById('max-value-connections').textContent = maxValueNode.userData.connectionCount || 0;
            document.getElementById('max-value-size').textContent = nodeSizeKB + ' KB';
            document.getElementById('max-value-performance').textContent = performanceImpact;
            document.getElementById('max-value-is-name').textContent = wordData.isName ? 'Yes' : 'No';
            document.getElementById('max-value-is-ser-estar').textContent = wordData.isSerEstar ? 'Yes' : 'No';
            
            // Remove previous mesh
            if (maxValuePanelMesh) {
                maxValuePanelScene.remove(maxValuePanelMesh);
                if (maxValuePanelMesh.geometry) maxValuePanelMesh.geometry.dispose();
                if (maxValuePanelMesh.material) maxValuePanelMesh.material.dispose();
                if (maxValuePanelMesh.children) {
                    maxValuePanelMesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            }
            
            // Clone the node for display (enlarged)
            const baseSize = 0.06;
            const enlargedSize = 0.3; // Size for max-value-panel
            
            let color;
            const score = wordData.normalizedScore || 0;
            
            if (score > 0.85) {
                color = 0xffff00; // Yellow for highest value
            } else if (score > 0.7) {
                color = 0x4a6fa5; // Dark greyish blue
            } else if (score > 0.5) {
                color = 0x5a7fb5; // Medium-dark greyish blue
            } else if (score > 0.3) {
                color = 0x6a8fc5; // Medium greyish blue
            } else if (score > 0.1) {
                color = 0x7a9fd5; // Light greyish blue
            } else {
                color = 0xffffff; // White
            }
            
            if (wordData.isSerEstar) {
                // Create cube with flat rectangular base for "to be" verbs
                const cubeGeometry = new THREE.BoxGeometry(enlargedSize, enlargedSize, enlargedSize, 1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const cube = new THREE.Mesh(cubeGeometry, material);
                
                // Make base same size as cube (like names have same size as sphere)
                const flatRectWidth = enlargedSize * 1.0; // Same width as cube
                const flatRectDepth = enlargedSize * 1.0; // Same depth as cube
                const flatRectHeight = enlargedSize * 0.1; // Thin base
                const flatRectGeometry = new THREE.BoxGeometry(flatRectWidth, flatRectHeight, flatRectDepth, 1, 1, 1);
                const flatRectMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const flatRect = new THREE.Mesh(flatRectGeometry, flatRectMaterial);
                flatRect.position.y = -enlargedSize * 2.0; // Same separation as names
                
                const group = new THREE.Group();
                group.add(cube);
                group.add(flatRect);
                maxValuePanelMesh = group;
            } else if (wordData.pos === 'noun') {
                // Create sphere with flat square for nouns
                const sphereGeometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const sphere = new THREE.Mesh(sphereGeometry, material);
                
                const flatSquareSize = enlargedSize * 1.0;
                const flatSquareGeometry = new THREE.BoxGeometry(flatSquareSize, flatSquareSize * 0.1, flatSquareSize, 1, 1, 1);
                const flatSquareMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const flatSquare = new THREE.Mesh(flatSquareGeometry, flatSquareMaterial);
                flatSquare.position.y = -enlargedSize * 2.0;
                
                const group = new THREE.Group();
                group.add(sphere);
                group.add(flatSquare);
                maxValuePanelMesh = group;
            } else if (maxValueNode.userData.connectionCount > 0) {
                // Cube for connected nodes
                let geometry;
                if (maxValueNode.userData.connectionCount >= 5) {
                    geometry = new THREE.BoxGeometry(enlargedSize * 1.2, enlargedSize * 0.8, enlargedSize * 1.5, 1, 1, 1);
                } else {
                    geometry = new THREE.BoxGeometry(enlargedSize, enlargedSize, enlargedSize, 1, 1, 1);
                }
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                maxValuePanelMesh = new THREE.Mesh(geometry, material);
            } else {
                // Sphere for unconnected nodes
                const geometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                maxValuePanelMesh = new THREE.Mesh(geometry, material);
            }
            
            maxValuePanelScene.add(maxValuePanelMesh);
            
            // Start animation
            if (maxValuePanelAnimationId) {
                cancelAnimationFrame(maxValuePanelAnimationId);
            }
            animateMaxValuePanelNode();
        }

        function animateMaxValuePanelNode() {
            if (!maxValuePanelMesh || !maxValuePanelRenderer || !maxValuePanelScene || !maxValuePanelCamera) {
                if (maxValuePanelAnimationId) {
                    cancelAnimationFrame(maxValuePanelAnimationId);
                    maxValuePanelAnimationId = null;
                }
                return;
            }
            
            maxValuePanelMesh.rotation.y += 0.01;
            maxValuePanelMesh.rotation.x += 0.005;
            
            maxValuePanelRenderer.render(maxValuePanelScene, maxValuePanelCamera);
            maxValuePanelAnimationId = requestAnimationFrame(animateMaxValuePanelNode);
        }
        
        function clearTextBox() {
            // Check if right-panel is visible and if the selected node is part of the text being cleared
            const rightPanel = document.getElementById('right-panel');
            if (rightPanel && rightPanel.classList.contains('visible') && selectedNode) {
                // Check if the selected node is in the nodes array (part of the current visualization)
                if (nodes.includes(selectedNode)) {
                    hideNodeDetails(); // Close the right-panel
                }
            }
            
            document.getElementById('textInput').value = '';
            // Reset stats
            document.getElementById('valueScore').textContent = '0.00';
            document.getElementById('valueETH').textContent = '';
            
            // Reset mapped text view
            const mappedContainer = document.getElementById('mapped-text-container');
            const textInput = document.getElementById('textInput');
            mappedContainer.style.display = 'none';
            textInput.style.display = 'block';
            mappedTextVisible = false;
            // Clear scene - properly handle both regular nodes and noun groups
            nodes.forEach(node => {
                scene.remove(node);
                
                // Handle noun groups (THREE.Group objects)
                if (node.isGroup) {
                    node.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                } else {
                    // Regular nodes
                    if (node.geometry) node.geometry.dispose();
                    if (node.material) node.material.dispose();
                }
            });
            
            connections.forEach(conn => {
                scene.remove(conn);
                if (conn.geometry) conn.geometry.dispose();
                if (conn.material) conn.material.dispose();
            });
            
            nodes = [];
            connections = [];
            analyzedWords = [];
            selectedNode = null;

            // Si TOP NODES está activo, ocultarlo porque el cuerpo desaparece
            if (nodeListVisible) {
                const container = document.getElementById('node-list-container');
                if (container) {
                    container.classList.remove('visible');
                }
                if (typeof clearNodeList === 'function') {
                    clearNodeList();
                }
                nodeListVisible = false;
            }

            // Disable export button
            document.getElementById('exportBtn').disabled = true;
        }
        
        function showNodeInfo(node, mouseX, mouseY) {
            if (!nodeInfoPanel || !node.userData || !node.userData.wordData) return;
            
            const wordData = node.userData.wordData;
            const index = node.userData.index;
            const totalValue = window.totalTextScore || 0;
            const individualValue = wordData.finalValue || wordData.totalScore || 0;
            const relativeValue = totalValue > 0 ? ((individualValue / totalValue) * 100).toFixed(2) + '%' : '0%';
            
            // Calculate node size in KB (approximate)
            let nodeSizeKB = 0;
            if (node.userData.isNoun) {
                nodeSizeKB = (8 * 8 * 8 * 4 * 3) + (1 * 1 * 1 * 4 * 3);
            } else if (node.userData.connectionCount > 0) {
                nodeSizeKB = (8 * 4 * 3);
            } else {
                nodeSizeKB = (8 * 8 * 8 * 4 * 3);
            }
            nodeSizeKB = (nodeSizeKB / 1024).toFixed(4);
            
            // Convert individual value to ETH for display
            let individualValueETH = 0;
            if (ethPriceUSD) {
                individualValueETH = individualValue / ethPriceUSD;
            }
            const individualValueETHDisplay = individualValueETH >= 0.01 ? 
                `${individualValueETH.toFixed(4)} ETH` : 
                `${individualValueETH.toFixed(6)} ETH`;
            
            // Update condensed info panel content
            document.getElementById('info-word').textContent = wordData.text.length > 8 ? wordData.text.substring(0, 8) + '...' : wordData.text;
            document.getElementById('info-individual-value').textContent = individualValueETH >= 0.01 ? 
                individualValueETH.toFixed(4) + ' ETH' : individualValueETH.toFixed(6) + ' ETH';
            document.getElementById('info-position').textContent = (index + 1) + '/' + analyzedWords.length;
            document.getElementById('info-relative-value').textContent = relativeValue;
            document.getElementById('info-pos').textContent = wordData.pos.substring(0, 3).toUpperCase();
            document.getElementById('info-connections').textContent = node.userData.connectionCount || 0;
            document.getElementById('info-size').textContent = parseFloat(nodeSizeKB).toFixed(2);
            document.getElementById('info-performance').textContent = node.userData.connectionCount > 0 ? 'M' : 'L';
            document.getElementById('info-is-name').textContent = wordData.isName ? 'Y' : 'N';
            document.getElementById('info-is-ser-estar').textContent = wordData.isSerEstar ? 'Y' : 'N';
            
            // Show enlarged node in canvas
            showEnlargedNode(node);
            
            // Start animation
            if (nodeInfoAnimationId) {
                cancelAnimationFrame(nodeInfoAnimationId);
            }
            animateNodeInfo();
            
            // Calculate node position on screen
            const vector = new THREE.Vector3();
            if (node.userData.isNoun && node.userData.mainNode) {
                node.userData.mainNode.getWorldPosition(vector);
            } else {
                node.getWorldPosition(vector);
            }
            vector.project(camera);
            
            // Convert to screen coordinates
            const nodeScreenX = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const nodeScreenY = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            // Position panel next to node on screen
            const panelWidth = 220;
            const panelHeight = 220;
            let panelX = nodeScreenX + 20;
            let panelY = nodeScreenY - 20;
            
            // Keep panel within viewport
            if (panelX + panelWidth > window.innerWidth) {
                panelX = nodeScreenX - panelWidth - 20;
            }
            if (panelY + panelHeight > window.innerHeight) {
                panelY = window.innerHeight - panelHeight - 10;
            }
            if (panelX < 0) panelX = 10;
            if (panelY < 0) panelY = 10;
            
            nodeInfoPanel.style.left = panelX + 'px';
            nodeInfoPanel.style.top = panelY + 'px';
            nodeInfoPanel.classList.add('visible');
        }
        
        function showEnlargedNode(node) {
            if (!nodeInfoScene || !nodeInfoRenderer) return;
            
            // Remove previous mesh
            if (nodeInfoMesh) {
                nodeInfoScene.remove(nodeInfoMesh);
                if (nodeInfoMesh.geometry) nodeInfoMesh.geometry.dispose();
                if (nodeInfoMesh.material) nodeInfoMesh.material.dispose();
                if (nodeInfoMesh.children) {
                    nodeInfoMesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            }
            
            // Clone the node for display (enlarged)
            const wordData = node.userData.wordData;
            const baseSize = 0.06;
            const enlargedSize = 0.3; // 5x larger
            
            let color;
            const score = wordData.normalizedScore;
            
            if (score > 0.85) {
                color = 0xffff00;
            } else if (score > 0.7) {
                color = 0x4a6fa5;
            } else if (score > 0.5) {
                color = 0x5a7fb5;
            } else if (score > 0.3) {
                color = 0x6a8fc5;
            } else if (score > 0.1) {
                color = 0x7a9fd5;
            } else {
                color = 0xffffff;
            }
            
            if (wordData.pos === 'noun') {
                // Create sphere with flat square for nouns
                const sphereGeometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const sphere = new THREE.Mesh(sphereGeometry, material);
                
                const flatSquareSize = enlargedSize * 1.0;
                const flatSquareGeometry = new THREE.BoxGeometry(flatSquareSize, flatSquareSize * 0.1, flatSquareSize, 1, 1, 1);
                const flatSquareMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const flatSquare = new THREE.Mesh(flatSquareGeometry, flatSquareMaterial);
                flatSquare.position.y = -enlargedSize * 2.0;
                
                const group = new THREE.Group();
                group.add(sphere);
                group.add(flatSquare);
                nodeInfoMesh = group;
            } else if (node.userData.connectionCount > 0) {
                // Cube for connected nodes
                let geometry;
                if (node.userData.connectionCount >= 5) {
                    geometry = new THREE.BoxGeometry(enlargedSize * 1.2, enlargedSize * 0.8, enlargedSize * 1.5, 1, 1, 1);
                } else {
                    geometry = new THREE.BoxGeometry(enlargedSize, enlargedSize, enlargedSize, 1, 1, 1);
                }
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                nodeInfoMesh = new THREE.Mesh(geometry, material);
            } else {
                // Sphere for unconnected nodes
                const geometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                nodeInfoMesh = new THREE.Mesh(geometry, material);
            }
            
            nodeInfoScene.add(nodeInfoMesh);
        }
        
        function animateNodeInfo() {
            if (!nodeInfoMesh || !nodeInfoRenderer || !nodeInfoScene || !nodeInfoCamera) {
                if (nodeInfoAnimationId) {
                    cancelAnimationFrame(nodeInfoAnimationId);
                    nodeInfoAnimationId = null;
                }
                return;
            }
            
            // Rotate the node
            nodeInfoMesh.rotation.y += 0.01;
            nodeInfoMesh.rotation.x += 0.005;
            
            nodeInfoRenderer.render(nodeInfoScene, nodeInfoCamera);
            nodeInfoAnimationId = requestAnimationFrame(animateNodeInfo);
        }
        
        function hideNodeInfo() {
            if (nodeInfoPanel) {
                nodeInfoPanel.classList.remove('visible');
            }
            hoveredNode = null;
            if (nodeInfoAnimationId) {
                cancelAnimationFrame(nodeInfoAnimationId);
                nodeInfoAnimationId = null;
            }
            if (nodeInfoMesh) {
                nodeInfoScene.remove(nodeInfoMesh);
                if (nodeInfoMesh.geometry) nodeInfoMesh.geometry.dispose();
                if (nodeInfoMesh.material) nodeInfoMesh.material.dispose();
                if (nodeInfoMesh.children) {
                    nodeInfoMesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
                nodeInfoMesh = null;
            }
        }

        function onWheel(event) {
            event.preventDefault();
            // More effective zoom: increased sensitivity from 0.01 to 0.02
            cameraRadius += event.deltaY * 0.02;
            cameraRadius = Math.max(3, Math.min(50, cameraRadius));
            updateCameraPosition();
        }
        
        function onKeyDown(event) {
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || 
                event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                event.preventDefault();
                keysPressed[event.key] = true;
            }
        }
        
        function onKeyUp(event) {
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || 
                event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                event.preventDefault();
                keysPressed[event.key] = false;
            }
        }
        
        // Update camera position based on keyboard input
        function updateKeyboardNavigation() {
            const moveSpeed = 0.1; // Speed of movement
            
            if (keysPressed.ArrowUp) {
                // Move camera target up (vertical navigation)
                cameraTarget.y += moveSpeed;
            }
            if (keysPressed.ArrowDown) {
                // Move camera target down (vertical navigation)
                cameraTarget.y -= moveSpeed;
            }
            if (keysPressed.ArrowLeft) {
                // Move camera target left (horizontal navigation)
                cameraTarget.x -= moveSpeed;
            }
            if (keysPressed.ArrowRight) {
                // Move camera target right (horizontal navigation)
                cameraTarget.x += moveSpeed;
            }
            
            updateCameraPosition();
            // Coordinates will be updated by updateCoordinatesDisplay in animate loop
        }
        
        function resetCamera() {
            // Reset camera to initial position
            cameraRadius = initialCameraRadius;
            cameraAngleX = initialCameraAngleX;
            cameraAngleY = initialCameraAngleY;
            cameraTarget.copy(initialCameraTarget);
            updateCameraPosition();
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && !document.msFullscreenElement) {
                // Enter fullscreen
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) {
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen (ESC key also works by default)
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }
        
        function changeBackgroundColor() {
            // Cycle through colors: AZUL -> NEGRO -> GRIS -> AZUL
            backgroundColorIndex = (backgroundColorIndex + 1) % backgroundColors.length;
            currentBackgroundColor = backgroundColors[backgroundColorIndex];
            
            // Update scene background
            scene.background = new THREE.Color(currentBackgroundColor);
            
            // Update renderer clear color
            renderer.setClearColor(currentBackgroundColor, 1);
            
            // Update the color square in the button
            const colorSquare = document.getElementById('bgColorSquare');
            if (colorSquare) {
                // Convert hex to CSS color
                const hexColor = '#' + currentBackgroundColor.toString(16).padStart(6, '0');
                colorSquare.style.background = hexColor;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== ACTUALIZACIÓN DE ESTADÍSTICAS ====================
        function updateStats() {
            // Calculate and display total value (accumulated, not normalized)
            // Using finalValue from the new linguistic scoring system
            const totalValue = window.totalTextScore || analyzedWords.reduce((sum, wordData) => {
                return sum + (wordData.finalValue || wordData.totalScore || 0);
            }, 0);
            
            // Convert to Ethereum and display (only ETH, no USD)
            // Note: The totalValue is now in the linguistic scoring units, not USD
            convertToEthereum(totalValue);
            
            // Update real-time info panel
            updateRealtimeInfo();
        }
        
        function updateRealtimeInfo() {
            // FPS (already calculated in animate)
            document.getElementById('realtime-fps').textContent = fps;
            
            // Mouse coordinates in 3D space (updated on mouse move)
            // These are updated by onMouseMoveCoordinates function
            
            // Nodes
            document.getElementById('realtime-nodes').textContent = nodes.length;
            
            // Connections
            document.getElementById('realtime-connections').textContent = connections.length;
            
            // Names (count nodes with isName)
            const nameCount = analyzedWords.filter(wordData => wordData.isName).length;
            document.getElementById('realtime-names').textContent = nameCount;
            
            // Total Value (using new linguistic scoring system)
            const totalValueUSD = window.totalTextScore || analyzedWords.reduce((sum, wordData) => {
                return sum + (wordData.finalValue || wordData.totalScore || 0);
            }, 0);
            
            let totalValueETH = 0;
            if (ethPriceUSD) {
                totalValueETH = totalValueUSD / ethPriceUSD;
            }
            const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                `${totalValueETH.toFixed(6)} ETH` : 
                `${totalValueETH.toFixed(10)} ETH`;
            document.getElementById('realtime-total-value').textContent = totalValueETHDisplay;
            
            // Average Value per Node
            const avgValueETH = nodes.length > 0 ? totalValueETH / nodes.length : 0;
            const avgValueETHDisplay = avgValueETH >= 0.01 ? 
                `${avgValueETH.toFixed(6)} ETH` : 
                `${avgValueETH.toFixed(10)} ETH`;
            document.getElementById('realtime-avg-value').textContent = avgValueETHDisplay;
            
            // Count by part of speech
            const posCounts = {
                noun: 0,
                verb: 0,
                adjective: 0,
                adverb: 0,
                other: 0
            };
            
            analyzedWords.forEach(wordData => {
                const pos = wordData.pos ? wordData.pos.toLowerCase() : 'other';
                if (pos === 'noun') {
                    posCounts.noun++;
                } else if (pos === 'verb') {
                    posCounts.verb++;
                } else if (pos === 'adjective' || pos === 'adj') {
                    posCounts.adjective++;
                } else if (pos === 'adverb' || pos === 'adv') {
                    posCounts.adverb++;
                } else {
                    posCounts.other++;
                }
            });
            
            document.getElementById('realtime-nouns').textContent = posCounts.noun;
            document.getElementById('realtime-verbs').textContent = posCounts.verb;
            document.getElementById('realtime-adjectives').textContent = posCounts.adjective;
            document.getElementById('realtime-adverbs').textContent = posCounts.adverb;
            document.getElementById('realtime-other').textContent = posCounts.other;
        }
        
        // Fetch Ethereum price and convert USD value to ETH
        async function convertToEthereum(usdValue) {
            try {
                // Fetch current Ethereum price from CoinGecko API
                if (!ethPriceUSD) {
                    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
                    const data = await response.json();
                    ethPriceUSD = data.ethereum.usd;
                }
                
                // Convert USD to ETH
                const ethValue = usdValue / ethPriceUSD;
                
                // Display ETH value only (no USD)
                const ethDisplay = ethValue >= 0.01 ? 
                    `${ethValue.toFixed(6)} ETH` : 
                    `${ethValue.toFixed(10)} ETH`;
                
                document.getElementById('valueScore').textContent = ethDisplay;
                document.getElementById('valueETH').textContent = ''; // Clear USD display
            } catch (error) {
                console.error('Error fetching Ethereum price:', error);
                document.getElementById('valueScore').textContent = 'ETH price unavailable';
                document.getElementById('valueETH').textContent = '';
                
                // Try alternative API (CoinCap) as fallback
                try {
                    const response = await fetch('https://api.coincap.io/v2/assets/ethereum');
                    const data = await response.json();
                    ethPriceUSD = parseFloat(data.data.priceUsd);
                    const ethValue = usdValue / ethPriceUSD;
                    const ethDisplay = ethValue >= 0.01 ? 
                        `${ethValue.toFixed(6)} ETH` : 
                        `${ethValue.toFixed(10)} ETH`;
                    document.getElementById('valueScore').textContent = ethDisplay;
                    document.getElementById('valueETH').textContent = ''; // Clear USD display
                } catch (fallbackError) {
                    console.error('Fallback API also failed:', fallbackError);
                }
            }
        }
        
        // Fetch Ethereum price on page load
        window.addEventListener('load', () => {
            fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd')
                .then(response => response.json())
                .then(data => {
                    ethPriceUSD = data.ethereum.usd;
                })
                .catch(error => {
                    console.error('Error fetching initial ETH price:', error);
                });
        });

        // ==================== NAMETAGS ====================
        function toggleNametags() {
            nametagsVisible = !nametagsVisible;
            
            if (nametagsVisible) {
                createNametags();
            } else {
                removeNametags();
            }
        }

        // ==================== TOP NODES ====================
        function toggleNodeList() {
            nodeListVisible = !nodeListVisible;
            const container = document.getElementById('node-list-container');
            
            if (nodeListVisible) {
                if (nodes.length === 0) {
                    alert('Please generate a visualization first');
                    nodeListVisible = false;
                    return;
                }
                container.classList.add('visible');
                createNodeListItems();
            } else {
                container.classList.remove('visible');
                clearNodeList();
            }
        }

        function findTop12Nodes() {
            if (nodes.length === 0) return [];
            
            // Sort nodes by their totalScore
            const sortedNodes = [...nodes].sort((a, b) => {
                const scoreA = a.userData.wordData ? (a.userData.wordData.totalScore || 0) : 0;
                const scoreB = b.userData.wordData ? (b.userData.wordData.totalScore || 0) : 0;
                return scoreB - scoreA; // Descending order
            });
            
            // Return top 12
            return sortedNodes.slice(0, 12);
        }

        function createNodeListItems() {
            clearNodeList();
            
            const top12Nodes = findTop12Nodes();
            const container = document.getElementById('node-list-container');
            
            top12Nodes.forEach((node, index) => {
                if (!node.userData || !node.userData.wordData) return;
                
                // Create item container
                const item = document.createElement('div');
                item.className = 'node-list-item';
                item.id = `node-list-item-${index}`;
                
                // Create header
                const header = document.createElement('div');
                header.className = 'node-list-item-header';
                const headerText = document.createElement('h3');
                headerText.style.cssText = 'color: #000000; font-size: 11px; margin: 0; font-family: Helvetica, Arial, sans-serif;';
                headerText.textContent = node.userData.wordData.text;
                header.appendChild(headerText);
                
                // Create canvas container
                const canvasContainer = document.createElement('div');
                canvasContainer.className = 'node-list-item-canvas-container';
                const canvas = document.createElement('canvas');
                canvas.className = 'node-list-item-canvas';
                canvas.id = `node-list-canvas-${index}`;
                canvasContainer.appendChild(canvas);
                
                // Create info container
                const infoContainer = document.createElement('div');
                infoContainer.className = 'node-list-item-info';
                
                // Populate info (same as showNodeDetails)
                const wordData = node.userData.wordData;
                const nodeIndex = node.userData.index;
                const totalValue = window.totalTextScore || analyzedWords.reduce((sum, w) => sum + (w.finalValue || w.totalScore || 0), 0);
                const individualValue = wordData.finalValue || wordData.totalScore || 0;
                const relativeValue = totalValue > 0 ? ((individualValue / totalValue) * 100).toFixed(2) + '%' : '0%';
                
                // Calculate node size in KB
                let nodeSizeKB = 0;
                if (node.userData.isSerEstar) {
                    // Cube + flat rectangular base
                    nodeSizeKB = (1 * 1 * 1 * 4 * 3) + (1.0 * 0.1 * 1.0 * 4 * 3);
                } else if (node.userData.isNoun) {
                    nodeSizeKB = (8 * 8 * 8 * 4 * 3) + (1 * 1 * 1 * 4 * 3);
                } else if (node.userData.connectionCount > 0) {
                    nodeSizeKB = (8 * 4 * 3);
                } else {
                    nodeSizeKB = (8 * 8 * 8 * 4 * 3);
                }
                nodeSizeKB = (nodeSizeKB / 1024).toFixed(4);
                
                const performanceImpact = node.userData.connectionCount > 0 ? 
                    'Medium (' + node.userData.connectionCount + ' connections)' : 
                    'Low';
                
                // Convert to ETH
                let individualValueETH = 0;
                if (ethPriceUSD) {
                    individualValueETH = individualValue / ethPriceUSD;
                }
                const individualValueETHDisplay = individualValueETH >= 0.01 ? 
                    `${individualValueETH.toFixed(6)} ETH` : 
                    `${individualValueETH.toFixed(10)} ETH`;
                
                let totalValueETH = 0;
                if (ethPriceUSD) {
                    totalValueETH = totalValue / ethPriceUSD;
                }
                const totalValueETHDisplay = totalValueETH >= 0.01 ? 
                    `${totalValueETH.toFixed(6)} ETH` : 
                    `${totalValueETH.toFixed(10)} ETH`;
                
                // Add info fields
                infoContainer.innerHTML = `
                    <div><strong>Word:</strong> ${wordData.text}</div>
                    <div><strong>Individual Value:</strong> $${individualValue.toFixed(2)} USD (${individualValueETHDisplay})</div>
                    <div><strong>Position in Text:</strong> ${nodeIndex + 1} / ${analyzedWords.length}</div>
                    <div><strong>Value / Total:</strong> ${relativeValue} ($${totalValue.toFixed(2)} total / ${totalValueETHDisplay})</div>
                    <div><strong>Part of Speech:</strong> ${wordData.pos}</div>
                    <div><strong>Connections:</strong> ${node.userData.connectionCount || 0}</div>
                    <div><strong>Size (KB):</strong> ${nodeSizeKB} KB</div>
                    <div><strong>Performance:</strong> ${performanceImpact}</div>
                    <div><strong>Is Name:</strong> ${wordData.isName ? 'Yes' : 'No'}</div>
                    <div><strong>Is identity:</strong> ${wordData.isSerEstar ? 'Yes' : 'No'}</div>
                `;
                
                // Assemble item
                item.appendChild(header);
                item.appendChild(canvasContainer);
                item.appendChild(infoContainer);
                container.appendChild(item);
                
                // Store node data for lazy loading
                item.dataset.nodeIndex = index;
                item.dataset.nodeData = JSON.stringify({
                    word: wordData.text,
                    pos: wordData.pos,
                    normalizedScore: wordData.normalizedScore || 0,
                    isNoun: node.userData.isNoun,
                    isSerEstar: wordData.isSerEstar || false,
                    connectionCount: node.userData.connectionCount || 0
                });
            });
            
            // Setup Intersection Observer for lazy loading
            setupNodeListIntersectionObserver();
        }
        
        function setupNodeListIntersectionObserver() {
            // Clean up existing observer
            if (nodeListIntersectionObserver) {
                nodeListIntersectionObserver.disconnect();
            }
            
            // Create new observer
            nodeListIntersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const item = entry.target;
                    const index = parseInt(item.dataset.nodeIndex);
                    
                    if (entry.isIntersecting) {
                        // Node is visible, create 3D scene if not already created
                        if (!nodeListRenderers[index]) {
                            const canvas = item.querySelector('.node-list-item-canvas');
                            const nodeData = JSON.parse(item.dataset.nodeData);
                            // Find the actual node from the nodes array
                            const top12Nodes = findTop12Nodes();
                            if (top12Nodes[index]) {
                                createNodeList3DScene(index, top12Nodes[index], canvas);
                                // Add fractal click listener
                                const nodeIndex = top12Nodes[index].userData.index;
                                addNodeListCanvasClickListener(canvas, nodeIndex);
                            }
                        }
                    } else {
                        // Node is not visible, cleanup if needed (optional - keep for performance)
                        // We'll keep them loaded but could cleanup here if needed
                    }
                });
            }, {
                root: document.getElementById('node-list-container'),
                rootMargin: '50px', // Start loading 50px before entering viewport
                threshold: 0.1
            });
            
            // Observe all node list items
            const items = document.querySelectorAll('.node-list-item');
            items.forEach(item => {
                nodeListIntersectionObserver.observe(item);
            });
        }

        function createNodeList3DScene(index, node, canvas) {
            // Usar renderer compartido si no existe
            if (!sharedTopNodesRenderer) {
                // Crear un canvas temporal para el renderer compartido
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 200;
                tempCanvas.height = 120;
                sharedTopNodesRenderer = new THREE.WebGLRenderer({ canvas: tempCanvas, antialias: false });
                sharedTopNodesRenderer.setSize(200, 120);
                sharedTopNodesRenderer.setPixelRatio(0.75);
                
                sharedTopNodesScene = new THREE.Scene();
                sharedTopNodesScene.background = new THREE.Color(0x000000);
                
                sharedTopNodesCamera = new THREE.PerspectiveCamera(50, 200 / 120, 0.1, 100);
                sharedTopNodesCamera.position.set(0, 0, 2);
                sharedTopNodesCamera.lookAt(0, 0, 0);
                
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                sharedTopNodesScene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(2, 2, 2);
                sharedTopNodesScene.add(directionalLight);
            }
            
            // Limpiar escena anterior (mantener solo las luces)
            while (sharedTopNodesScene.children.length > 2) {
                const child = sharedTopNodesScene.children[2];
                sharedTopNodesScene.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            }
            
            // Create mesh (same as showRightPanelEnlargedNode)
            const wordData = node.userData.wordData;
            const enlargedSize = 0.35;
            
            let color;
            const score = wordData.normalizedScore || 0;
            
            if (score > 0.85) {
                color = 0xffff00;
            } else if (score > 0.7) {
                color = 0x4a6fa5;
            } else if (score > 0.5) {
                color = 0x5a7fb5;
            } else if (score > 0.3) {
                color = 0x6a8fc5;
            } else if (score > 0.1) {
                color = 0x7a9fd5;
            } else {
                color = 0xffffff;
            }
            
            let mesh;
            if (wordData.isSerEstar) {
                // Create cube with flat rectangular base for "to be" verbs
                const cubeGeometry = new THREE.BoxGeometry(enlargedSize, enlargedSize, enlargedSize, 1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const cube = new THREE.Mesh(cubeGeometry, material);
                
                // Make base same size as cube (like names have same size as sphere)
                const flatRectWidth = enlargedSize * 1.0; // Same width as cube
                const flatRectDepth = enlargedSize * 1.0; // Same depth as cube
                const flatRectHeight = enlargedSize * 0.1; // Thin base
                const flatRectGeometry = new THREE.BoxGeometry(flatRectWidth, flatRectHeight, flatRectDepth, 1, 1, 1);
                const flatRectMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const flatRect = new THREE.Mesh(flatRectGeometry, flatRectMaterial);
                flatRect.position.y = -enlargedSize * 2.0; // Same separation as names
                
                const group = new THREE.Group();
                group.add(cube);
                group.add(flatRect);
                mesh = group;
            } else if (wordData.pos === 'noun') {
                const sphereGeometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const sphere = new THREE.Mesh(sphereGeometry, material);
                
                const flatSquareSize = enlargedSize * 1.0;
                const flatSquareGeometry = new THREE.BoxGeometry(flatSquareSize, flatSquareSize * 0.1, flatSquareSize, 1, 1, 1);
                const flatSquareMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                const flatSquare = new THREE.Mesh(flatSquareGeometry, flatSquareMaterial);
                flatSquare.position.y = -enlargedSize * 2.0;
                
                const group = new THREE.Group();
                group.add(sphere);
                group.add(flatSquare);
                mesh = group;
            } else if (node.userData.connectionCount > 0) {
                let geometry;
                if (node.userData.connectionCount >= 5) {
                    geometry = new THREE.BoxGeometry(enlargedSize * 1.2, enlargedSize * 0.8, enlargedSize * 1.5, 1, 1, 1);
                } else {
                    geometry = new THREE.BoxGeometry(enlargedSize, enlargedSize, enlargedSize, 1, 1, 1);
                }
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                mesh = new THREE.Mesh(geometry, material);
            } else {
                const geometry = new THREE.SphereGeometry(enlargedSize, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.9 });
                mesh = new THREE.Mesh(geometry, material);
            }
            
            sharedTopNodesScene.add(mesh);
            
            // Renderizar a una textura temporal
            const renderTarget = new THREE.WebGLRenderTarget(200, 120);
            
            // Guardar estado del renderer
            const originalSize = sharedTopNodesRenderer.getSize(new THREE.Vector2());
            const originalClearColor = sharedTopNodesRenderer.getClearColor(new THREE.Color());
            
            // Renderizar
            sharedTopNodesRenderer.setRenderTarget(renderTarget);
            sharedTopNodesRenderer.setClearColor(0x000000, 1);
            sharedTopNodesRenderer.render(sharedTopNodesScene, sharedTopNodesCamera);
            
            // Leer la textura y dibujarla en el canvas 2D
            const ctx2D = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 120;
            const pixels = new Uint8Array(200 * 120 * 4);
            sharedTopNodesRenderer.readRenderTargetPixels(renderTarget, 0, 0, 200, 120, pixels);
            
            const imageData = ctx2D.createImageData(200, 120);
            for (let i = 0; i < pixels.length; i += 4) {
                imageData.data[i] = pixels[i];
                imageData.data[i + 1] = pixels[i + 1];
                imageData.data[i + 2] = pixels[i + 2];
                imageData.data[i + 3] = pixels[i + 3];
            }
            ctx2D.putImageData(imageData, 0, 0);
            
            // Restaurar estado del renderer
            sharedTopNodesRenderer.setRenderTarget(null);
            sharedTopNodesRenderer.setSize(originalSize.x, originalSize.y);
            sharedTopNodesRenderer.setClearColor(originalClearColor, 1);
            
            // Limpiar render target
            renderTarget.dispose();
            
            // Remover el mesh de la escena
            sharedTopNodesScene.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => m.dispose());
                } else {
                    mesh.material.dispose();
                }
            }
            // Si es un grupo, limpiar también los hijos
            if (mesh.isGroup) {
                mesh.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
        }

        function clearNodeList() {
            const container = document.getElementById('node-list-container');
            container.innerHTML = '';
            
            // Stop all animations and clean up (ya no hay animaciones, pero mantenemos por compatibilidad)
            nodeListAnimationIds.forEach(id => {
                if (id) cancelAnimationFrame(id);
            });
            
            // Clean up renderers and scenes (ya se limpian en createNodeList3DScene, pero mantenemos por seguridad)
            nodeListRenderers.forEach(renderer => {
                if (renderer) {
                    renderer.dispose();
                }
            });
            
            // Limpiar renderer compartido
            if (sharedTopNodesRenderer) {
                if (sharedTopNodesScene) {
                    sharedTopNodesScene.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    sharedTopNodesScene = null;
                }
                sharedTopNodesRenderer.dispose();
                sharedTopNodesRenderer = null;
                sharedTopNodesCamera = null;
            }
            
            nodeListScenes = [];
            nodeListRenderers = [];
            nodeListMeshes = [];
            nodeListAnimationIds = [];
            nodeListItems = [];
        }

        // ==================== MAP TEXT ====================
        function mapText() {
            const mappedContainer = document.getElementById('mapped-text-container');
            const textInput = document.getElementById('textInput');
            
            // Toggle between mapped view and normal textarea
            if (mappedTextVisible) {
                // Switch back to textarea
                mappedContainer.style.display = 'none';
                textInput.style.display = 'block';
                mappedTextVisible = false;
                return;
            }
            
            const text = document.getElementById('textInput').value;
            
            if (!text || text.trim().length === 0) {
                alert('Please enter some text first');
                return;
            }
            
            // Analyze text and calculate scores if not already done
            if (analyzedWords.length === 0) {
                analyzeText(text);
                calculateScores();
            }
            
            // Hide textarea and show mapped container
            textInput.style.display = 'none';
            mappedContainer.style.display = 'block';
            mappedTextVisible = true;
            
            // Create a map of words to their scores
            const wordScoreMap = new Map();
            analyzedWords.forEach((wordData, index) => {
                const wordKey = wordData.text.toLowerCase();
                if (!wordScoreMap.has(wordKey)) {
                    wordScoreMap.set(wordKey, wordData.normalizedScore || 0);
                }
            });
            
            // Process text character by character to preserve spaces with colors
            const words = splitTextIntoWords(text);
            let mappedHTML = '';
            let currentTextIndex = 0;
            let lastBgColor = '#000000';
            let lastTextColor = '#ffffff';
            
            words.forEach((word, wordIndex) => {
                // Find the word in the original text
                const wordStart = text.indexOf(word, currentTextIndex);
                
                // Get the score for this word
                const wordKey = word.toLowerCase();
                const score = wordScoreMap.get(wordKey) || 0;
                
                let bgColor, textColor;
                
                if (score > 0.85) {
                    // Yellow background, black text (high value/yellow nodes)
                    bgColor = '#ffff00';
                    textColor = '#000000';
                } else if (score > 0.7 && score <= 0.85) {
                    // White background, black text (values that don't fit other categories)
                    bgColor = '#ffffff';
                    textColor = '#000000';
                } else if (score > 0.1 && score <= 0.7) {
                    // Blue background, white text (medium value/blue nodes)
                    bgColor = '#4a6fa5';
                    textColor = '#ffffff';
                } else {
                    // Grey background, white text (low value/white nodes)
                    bgColor = '#808080';
                    textColor = '#ffffff';
                }
                
                // Add any text before the word (spaces, punctuation, etc.) with the previous word's color
                if (wordStart > currentTextIndex) {
                    const beforeWord = text.substring(currentTextIndex, wordStart);
                    const escapedBefore = beforeWord.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    mappedHTML += `<span style="background-color: ${lastBgColor}; color: ${lastTextColor}; padding: 0; margin: 0; display: inline;">${escapedBefore}</span>`;
                }
                
                // Add the word with its color
                const escapedWord = word.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                mappedHTML += `<span style="background-color: ${bgColor}; color: ${textColor}; padding: 0; margin: 0; display: inline;">${escapedWord}</span>`;
                
                // Update last colors for next iteration
                lastBgColor = bgColor;
                lastTextColor = textColor;
                
                currentTextIndex = wordStart + word.length;
            });
            
            // Add any remaining text after the last word with the last word's color
            if (currentTextIndex < text.length) {
                const remaining = text.substring(currentTextIndex);
                const escapedRemaining = remaining.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                mappedHTML += `<span style="background-color: ${lastBgColor}; color: ${lastTextColor}; padding: 0; margin: 0; display: inline;">${escapedRemaining}</span>`;
            }
            
            mappedContainer.innerHTML = mappedHTML;
        }
        
        function createNametags() {
            removeNametags(); // Clear any existing nametags
            
            nodes.forEach(node => {
                const nametag = document.createElement('div');
                nametag.className = 'nametag';
                nametag.textContent = node.userData.wordData.text;
                nametag.id = `nametag-${node.userData.index}`;
                document.body.appendChild(nametag);
                nametags.push(nametag);
            });
            
            updateNametags();
        }
        
        function removeNametags() {
            nametags.forEach(tag => {
                if (tag.parentNode) {
                    tag.parentNode.removeChild(tag);
                }
            });
            nametags = [];
        }
        
        function updateNametags() {
            if (!nametagsVisible || nametags.length === 0) return;
            
            const vector = new THREE.Vector3();
            
            nodes.forEach((node, index) => {
                const nametag = nametags[index];
                if (!nametag) return;
                
                // Get 3D position and project to screen coordinates
                // Handle both regular nodes and noun groups
                if (node.userData.isNoun && node.userData.mainNode) {
                    node.userData.mainNode.getWorldPosition(vector);
                } else {
                    node.getWorldPosition(vector);
                }
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                
                // Only show nametag if node is in front of camera
                if (vector.z < 1) {
                    nametag.style.left = `${x}px`;
                    nametag.style.top = `${y}px`;
                    nametag.style.display = 'block';
                } else {
                    nametag.style.display = 'none';
                }
            });
        }

        // ==================== ANIMACIÓN ====================
        let lastFrameTime = 0;
        const targetFPS = 30; // Limit to 30 FPS for better performance
        const frameInterval = 1000 / targetFPS;
        let nodeInfoAnimationId = null;
        let fps = 0;
        let fpsLastTime = 0;
        let fpsFrameCount = 0;
        
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            
            // Calculate FPS
            if (fpsLastTime === 0) {
                fpsLastTime = currentTime;
            }
            fpsFrameCount++;
            if (currentTime - fpsLastTime >= 1000) {
                fps = fpsFrameCount;
                fpsFrameCount = 0;
                fpsLastTime = currentTime;
                const fpsRepeatedElement = document.getElementById('fpsRepeated');
                if (fpsRepeatedElement) {
                    // Repeat FPS text many times
                    const fpsText = `FPS: ${fps} `;
                    fpsRepeatedElement.textContent = fpsText.repeat(100);
                }
                // Update real-time info panel
                updateRealtimeInfo();
            }
            
            // Throttle frame rate for better performance
            const deltaTime = currentTime - lastFrameTime;
            if (deltaTime < frameInterval) {
                return;
            }
            lastFrameTime = currentTime - (deltaTime % frameInterval);
            
            // Update keyboard navigation
            if (keysPressed.ArrowUp || keysPressed.ArrowDown || 
                keysPressed.ArrowLeft || keysPressed.ArrowRight) {
                updateKeyboardNavigation();
            }
            
            // Update connections if nodes move (less frequently)
            if (connections.length > 0 && Math.floor(currentTime / frameInterval) % 2 === 0) {
                updateConnections();
            }
            
            // Update nametags position (less frequently)
            if (nametagsVisible && Math.floor(currentTime / frameInterval) % 2 === 0) {
                updateNametags();
            }
            
            // Update coordinates display continuously (every frame)
            updateCoordinatesDisplay();
            
            // Ensure renderer context is still valid and background is set
            if (renderer && renderer.domElement) {
                try {
                    // Ensure background color is maintained
                    renderer.setClearColor(currentBackgroundColor, 1);
                } catch (e) {
                    console.warn('Renderer context issue:', e);
                }
            }
            
            // Render main scene
            if (renderer && scene && camera) {
                try {
                    renderer.render(scene, camera);
                } catch (e) {
                    console.warn('Render error:', e);
                }
            }
        }

        // Start screen handler
        document.addEventListener('DOMContentLoaded', function() {
            const startScreen = document.getElementById('start-screen');
            const startButton = document.getElementById('start-button');
            
            // Initially hide all main content (exclude modals - they should stay hidden)
            const mainContent = document.querySelectorAll('#canvas-container, #left-panel, #top-bar, #fps-bar, #realtime-info-panel, #node-list-container, #max-value-panel');
            
            // Modals should always stay hidden until explicitly shown
            const valueLogicModal = document.getElementById('value-logic-modal');
            const fractalModal = document.getElementById('fractal-modal');
            const nodeInfoPanel = document.getElementById('node-info-panel');
            const rightPanel = document.getElementById('right-panel');
            
            mainContent.forEach(el => {
                if (el) el.style.display = 'none';
            });
            
            // Keep modals and panels hidden (they show on hover/click only)
            if (valueLogicModal) {
                valueLogicModal.style.display = 'none';
                valueLogicModal.style.visibility = 'hidden';
                valueLogicModal.style.opacity = '0';
            }
            if (fractalModal) {
                fractalModal.style.display = 'none';
                fractalModal.style.visibility = 'hidden';
                fractalModal.style.opacity = '0';
            }
            if (nodeInfoPanel) {
                nodeInfoPanel.style.display = 'none';
                nodeInfoPanel.style.visibility = 'hidden';
                nodeInfoPanel.style.opacity = '0';
            }
            if (rightPanel) {
                rightPanel.style.display = 'none';
                rightPanel.style.visibility = 'hidden';
                rightPanel.style.opacity = '0';
            }
            
            startButton.addEventListener('click', function() {
                // Mostrar modal de conexión de wallet
                const walletModal = document.getElementById('wallet-connect-modal');
                if (walletModal) {
                    walletModal.style.display = 'block';
                    walletModal.style.visibility = 'visible';
                    walletModal.style.opacity = '1';
                }
            });
            
            // Event listeners para el modal de wallet
            const walletModal = document.getElementById('wallet-connect-modal');
            const walletCloseBtn = document.getElementById('wallet-connect-close-btn');
            const walletConnectBtn = document.getElementById('wallet-connect-wallet-btn');
            
            function hideWalletModal() {
                if (walletModal) {
                    walletModal.style.display = 'none';
                    walletModal.style.visibility = 'hidden';
                    walletModal.style.opacity = '0';
                }
            }
            
            function proceedToMainApp() {
                // Ocultar modal de wallet
                hideWalletModal();
                
                // Hide start screen
                startScreen.classList.add('hidden');
                
                // Show all main content (but NOT modals - they show only when activated)
                mainContent.forEach(el => {
                    if (el) el.style.display = '';
                });
                
                // Ensure modals and panels stay hidden (they show on hover/click only)
                if (valueLogicModal) {
                    valueLogicModal.style.display = 'none';
                    valueLogicModal.style.visibility = 'hidden';
                    valueLogicModal.style.opacity = '0';
                }
                if (fractalModal) {
                    fractalModal.style.display = 'none';
                    fractalModal.style.visibility = 'hidden';
                    fractalModal.style.opacity = '0';
                }
                if (nodeInfoPanel) {
                    nodeInfoPanel.style.display = 'none';
                    nodeInfoPanel.style.visibility = 'hidden';
                    nodeInfoPanel.style.opacity = '0';
                    nodeInfoPanel.classList.remove('visible');
                }
                if (rightPanel) {
                    rightPanel.style.display = 'none';
                    rightPanel.style.visibility = 'hidden';
                    rightPanel.style.opacity = '0';
                    rightPanel.classList.remove('visible');
                }
                
                // Initialize the application
                init();
                
                // Double-check after init() that modals and panels remain hidden
                setTimeout(() => {
                    if (valueLogicModal && valueLogicModal.style.display !== 'block') {
                        valueLogicModal.style.display = 'none';
                        valueLogicModal.style.visibility = 'hidden';
                        valueLogicModal.style.opacity = '0';
                    }
                    if (fractalModal && fractalModal.style.display !== 'block') {
                        fractalModal.style.display = 'none';
                        fractalModal.style.visibility = 'hidden';
                        fractalModal.style.opacity = '0';
                    }
                    if (nodeInfoPanel && !nodeInfoPanel.classList.contains('visible')) {
                        nodeInfoPanel.style.display = 'none';
                        nodeInfoPanel.style.visibility = 'hidden';
                        nodeInfoPanel.style.opacity = '0';
                    }
                    if (rightPanel && !rightPanel.classList.contains('visible')) {
                        rightPanel.style.display = 'none';
                        rightPanel.style.visibility = 'hidden';
                        rightPanel.style.opacity = '0';
                    }
                }, 100);
            }
            
            if (walletCloseBtn) {
                walletCloseBtn.addEventListener('click', hideWalletModal);
            }
            
            if (walletConnectBtn) {
                walletConnectBtn.addEventListener('click', proceedToMainApp);
            }
            
            // Cerrar modal al hacer click fuera de él
            if (walletModal) {
                walletModal.addEventListener('click', function(e) {
                    if (e.target === walletModal) {
                        hideWalletModal();
                    }
                });
            }
        });
    </script>
</body>
</html>

